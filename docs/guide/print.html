<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dioxus Documentation</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Create book from markdown files. Like Gitbook but implemented in Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ROADMAP.html"><strong aria-hidden="true">2.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">3.</strong> Getting Set Up</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">4.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="elements/index.html"><strong aria-hidden="true">5.</strong> Describing the UI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="elements/vnodes.html"><strong aria-hidden="true">5.1.</strong> Intro to Elements</a></li><li class="chapter-item expanded "><a href="elements/conditional_rendering.html"><strong aria-hidden="true">5.2.</strong> Conditional Rendering</a></li><li class="chapter-item expanded "><a href="elements/lists.html"><strong aria-hidden="true">5.3.</strong> Lists</a></li><li class="chapter-item expanded "><a href="elements/special_attributes.html"><strong aria-hidden="true">5.4.</strong> Special Attributes</a></li></ol></li><li class="chapter-item expanded "><a href="components/index.html"><strong aria-hidden="true">6.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="components/propsmacro.html"><strong aria-hidden="true">6.1.</strong> Properties</a></li><li class="chapter-item expanded "><a href="components/exporting_components.html"><strong aria-hidden="true">6.2.</strong> Reusing, Importing, and Exporting</a></li><li class="chapter-item expanded "><a href="components/component_children.html"><strong aria-hidden="true">6.3.</strong> Children and Attributes</a></li><li class="chapter-item expanded "><a href="components/composing.html"><strong aria-hidden="true">6.4.</strong> How Data Flows</a></li></ol></li><li class="chapter-item expanded "><a href="interactivity/index.html"><strong aria-hidden="true">7.</strong> Adding Interactivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interactivity/event_handlers.html"><strong aria-hidden="true">7.1.</strong> Event Listeners</a></li><li class="chapter-item expanded "><a href="interactivity/hooks.html"><strong aria-hidden="true">7.2.</strong> Hooks</a></li><li class="chapter-item expanded "><a href="interactivity/usestate.html"><strong aria-hidden="true">7.3.</strong> UseState</a></li><li class="chapter-item expanded "><a href="interactivity/useref.html"><strong aria-hidden="true">7.4.</strong> UseRef</a></li><li class="chapter-item expanded "><a href="interactivity/user_input.html"><strong aria-hidden="true">7.5.</strong> User Input</a></li></ol></li><li class="chapter-item expanded "><a href="state/index.html"><strong aria-hidden="true">8.</strong> Managing State</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="state/localstate.html"><strong aria-hidden="true">8.1.</strong> Local State</a></li><li class="chapter-item expanded "><a href="state/sharedstate.html"><strong aria-hidden="true">8.2.</strong> Global State</a></li><li class="chapter-item expanded "><a href="state/liftingstate.html"><strong aria-hidden="true">8.3.</strong> Lifting State</a></li><li class="chapter-item expanded "><a href="state/errorhandling.html"><strong aria-hidden="true">8.4.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="helpers/index.html"><strong aria-hidden="true">9.</strong> Helper Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="state/fermi.html"><strong aria-hidden="true">9.1.</strong> Fermi</a></li><li class="chapter-item expanded "><a href="state/router.html"><strong aria-hidden="true">9.2.</strong> Router</a></li></ol></li><li class="chapter-item expanded "><a href="async/index.html"><strong aria-hidden="true">10.</strong> Working with Async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="async/use_future.html"><strong aria-hidden="true">10.1.</strong> UseFuture</a></li><li class="chapter-item expanded "><a href="async/coroutines.html"><strong aria-hidden="true">10.2.</strong> UseCoroutine</a></li></ol></li><li class="chapter-item expanded "><a href="final.html"><strong aria-hidden="true">11.</strong> Next Steps and Advanced Topics</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="misc/contributors.html">Contributors</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Dioxus Documentation</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/DioxusLabs/dioxus/edit/master/docs/guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><img src="./images/dioxuslogo_full.png" alt="dioxuslogo" /></p>
<p><strong>Dioxus</strong> is a library for building fast, scalable, and robust user interfaces with the Rust programming language. This guide will help you get started with Dioxus running on the Web, Desktop, Mobile, and more.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let mut count = use_state(&amp;cx, || 0);

    cx.render(rsx!(
        h1 { &quot;High-Five counter: {count}&quot; }
        button { onclick: move |_| count += 1, &quot;Up high!&quot; }
        button { onclick: move |_| count -= 1, &quot;Down low!&quot; }
    ))
};
<span class="boring">}
</span></code></pre></pre>
<p>In general, Dioxus and React share many functional similarities. If this guide is lacking in any general concept or an error message is confusing, React's documentation might be more helpful. We are dedicated to providing a <em>familiar</em> toolkit for UI in Rust, so we've chosen to follow in the footsteps of popular UI frameworks (React, Redux, etc). If you know React, then you already know Dioxus. If you don't know either, this guide will still help you!</p>
<blockquote>
<p>This is an introduction book! For advanced topics, check out the <a href="/reference">Reference</a> instead.</p>
</blockquote>
<h2 id="multiplatform"><a class="header" href="#multiplatform">Multiplatform</a></h2>
<p>Dioxus is a <em>portable</em> toolkit, meaning the Core implementation can run anywhere with no platform-dependent linking. Unlike many other Rust frontend toolkits, Dioxus is not intrinsically linked to WebSys. In fact, every element and event listener can be swapped out at compile time. By default, Dioxus ships with the <code>html</code> feature enabled, but this can be disabled depending on your target renderer.</p>
<p>Right now, we have several 1st-party renderers:</p>
<ul>
<li>WebSys (for WASM)</li>
<li>Tao/Tokio (for Desktop apps)</li>
<li>Tao/Tokio (for Mobile apps)</li>
<li>SSR (for generating static markup)</li>
<li>TUI/Rink (for terminal-based apps)</li>
</ul>
<h3 id="web-support"><a class="header" href="#web-support">Web Support</a></h3>
<hr />
<p>The Web is the best-supported target platform for Dioxus. To run on the Web, your app must be compiled to WebAssembly and depend on the <code>dioxus</code> crate with the <code>web</code> feature enabled. Because of the limitations of Wasm  not every crate will work with your web-apps, so you'll need to make sure that your crates work without native system calls (timers, IO, etc).</p>
<p>Because the web is a fairly mature platform, we expect there to be very little API churn for web-based features.</p>
<p><a href="/reference/platforms/web">Jump to the getting started guide for the web.</a></p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/DioxusLabs/example-projects/tree/master/todomvc">TodoMVC</a></li>
<li><a href="https://github.com/DioxusLabs/example-projects/tree/master/ecommerce-site">ECommerce</a></li>
</ul>
<p><a href="https://github.com/DioxusLabs/example-projects/blob/master/todomvc"><img src="https://github.com/DioxusLabs/example-projects/raw/master/todomvc/example.png" alt="TodoMVC example" /></a></p>
<h3 id="ssr-support"><a class="header" href="#ssr-support">SSR Support</a></h3>
<hr />
<p>Dioxus supports server-side rendering!</p>
<p>For rendering statically to an <code>.html</code> file or from a WebServer, then you'll want to make sure the <code>ssr</code> feature is enabled in the <code>dioxus</code> crate and use the <code>dioxus::ssr</code> API. We don't expect the SSR API to change drastically in the future.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let contents = dioxus::ssr::render_vdom(&amp;dom);
<span class="boring">}
</span></code></pre></pre>
<p><a href="/reference/platforms/ssr">Jump to the getting started guide for SSR.</a></p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/dioxusLabs/docsite">Example DocSite</a></li>
<li><a href="">Tide WebServer</a></li>
<li><a href="">Markdown to fancy HTML generator</a></li>
</ul>
<h3 id="desktop-support"><a class="header" href="#desktop-support">Desktop Support</a></h3>
<hr />
<p>The desktop is a powerful target for Dioxus, but is currently limited in capability when compared to the Web platform. Currently, desktop apps are rendered with the platform's WebView library, but your Rust code is running natively on a native thread. This means that browser APIs are <em>not</em> available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs <em>are</em> accessible, so streaming, WebSockets, filesystem, etc are all viable APIs. In the future, we plan to move to a custom webrenderer-based DOM renderer with WGPU integrations.</p>
<p>Desktop APIs will likely be in flux as we figure out better patterns than our ElectronJS counterpart.</p>
<p><a href="/reference/platforms/desktop">Jump to the getting started guide for Desktop.</a></p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/dioxusLabs/file-explorer/">File explorer</a></li>
<li><a href="https://github.com/DioxusLabs/example-projects/blob/master/wifi-scanner">WiFi scanner</a></li>
</ul>
<p><a href="https://github.com/DioxusLabs/example-projects/tree/master/file-explorer"><img src="https://raw.githubusercontent.com/DioxusLabs/example-projects/master/file-explorer/image.png" alt="File ExplorerExample" /></a></p>
<h3 id="mobile-support"><a class="header" href="#mobile-support">Mobile Support</a></h3>
<hr />
<p>Mobile is currently the least-supported renderer target for Dioxus. Mobile apps are rendered with the platform's WebView, meaning that animations, transparency, and native widgets are not currently achievable. In addition, iOS is the only supported Mobile Platform. It is possible to get Dioxus running on Android and rendered with WebView, but the Rust windowing library that Dioxus uses - tao - does not currently supported Android.</p>
<p>Mobile support is currently best suited for CRUD-style apps, ideally for internal teams who need to develop quickly but don't care much about animations or native widgets.</p>
<p><a href="/reference/platforms/mobile">Jump to the getting started guide for Mobile.</a></p>
<p>Examples:</p>
<ul>
<li><a href="https://github.com/DioxusLabs/example-projects/blob/master/ios_demo">Todo App</a></li>
</ul>
<h3 id="liveview--server-component-support"><a class="header" href="#liveview--server-component-support">LiveView / Server Component Support</a></h3>
<hr />
<p>The internal architecture of Dioxus was designed from day one to support the <code>LiveView</code> use-case, where a web server hosts a running app for each connected user. As of today, there is no first-class LiveView support - you'll need to wire this up yourself.</p>
<p>While not currently fully implemented, the expectation is that LiveView apps can be a hybrid between Wasm and server-rendered where only portions of a page are &quot;live&quot; and the rest of the page is either server-rendered, statically generated, or handled by the host SPA.</p>
<h3 id="multithreaded-support"><a class="header" href="#multithreaded-support">Multithreaded Support</a></h3>
<hr />
<p>The Dioxus VirtualDom, sadly, is not currently <code>Send</code>. Internally, we use quite a bit of interior mutability which is not thread-safe. This means you can't easily use Dioxus with most web frameworks like Tide, Rocket, Axum, etc.</p>
<p>To solve this, you'll want to spawn a VirtualDom on its own thread and communicate with it via channels.</p>
<p>When working with web frameworks that require <code>Send</code>, it is possible to render a VirtualDom immediately to a String - but you cannot hold the VirtualDom across an await point. For retained-state SSR (essentially LiveView), you'll need to create a pool of VirtualDoms.</p>
<p>Ultimately, you can always wrap the VirtualDom with a <code>Send</code> type and manually uphold the <code>Send</code> guarantees yourself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap--feature-set"><a class="header" href="#roadmap--feature-set">Roadmap &amp; Feature-set</a></h1>
<p>Before we dive into Dioxus, feel free to take a look at our feature set and roadmap to see if what Dioxus can do today works for you.</p>
<p>If a feature that you need doesn't exist or you want to contribute to projects on the roadmap, feel free to get involved by <a href="https://discord.gg/XgGxMSkvUM">joining the discord</a>.</p>
<p>Generally, here's the status of each platform:</p>
<ul>
<li>
<p><strong>Web</strong>: Dioxus is a great choice for pure web-apps - especially for CRUD/complex apps. However, it does lack the ecosystem of React, so you might be missing a component library or some useful hook.</p>
</li>
<li>
<p><strong>SSR</strong>: Dioxus is a great choice for pre-rendering, hydration, and rendering HTML on a web endpoint. Be warned - the VirtualDom is not (currently) <code>Send + Sync</code>.</p>
</li>
<li>
<p><strong>Desktop</strong>: You can build very competent single-window desktop apps right now. However, multi-window apps require support from Dioxus core and are not ready.</p>
</li>
<li>
<p><strong>Mobile</strong>: Mobile support is very young. You'll be figuring things out as you go and there are not many support crates for peripherals.</p>
</li>
<li>
<p><strong>LiveView</strong>: LiveView support is very young. You'll be figuring things out as you go. Thankfully, none of it is too hard and any work can be upstreamed into Dioxus.</p>
</li>
</ul>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<hr />
<table><thead><tr><th>Feature</th><th>Status</th><th>Description</th></tr></thead><tbody>
<tr><td>Conditional Rendering</td><td>‚úÖ</td><td>if/then to hide/show component</td></tr>
<tr><td>Map, Iterator</td><td>‚úÖ</td><td>map/filter/reduce to produce rsx!</td></tr>
<tr><td>Keyed Components</td><td>‚úÖ</td><td>advanced diffing with keys</td></tr>
<tr><td>Web</td><td>‚úÖ</td><td>renderer for web browser</td></tr>
<tr><td>Desktop (webview)</td><td>‚úÖ</td><td>renderer for desktop</td></tr>
<tr><td>Shared State (Context)</td><td>‚úÖ</td><td>share state through the tree</td></tr>
<tr><td>Hooks</td><td>‚úÖ</td><td>memory cells in components</td></tr>
<tr><td>SSR</td><td>‚úÖ</td><td>render directly to string</td></tr>
<tr><td>Component Children</td><td>‚úÖ</td><td>cx.children() as a list of nodes</td></tr>
<tr><td>Headless components</td><td>‚úÖ</td><td>components that don't return real elements</td></tr>
<tr><td>Fragments</td><td>‚úÖ</td><td>multiple elements without a real root</td></tr>
<tr><td>Manual Props</td><td>‚úÖ</td><td>Manually pass in props with spread syntax</td></tr>
<tr><td>Controlled Inputs</td><td>‚úÖ</td><td>stateful wrappers around inputs</td></tr>
<tr><td>CSS/Inline Styles</td><td>‚úÖ</td><td>syntax for inline styles/attribute groups</td></tr>
<tr><td>Custom elements</td><td>‚úÖ</td><td>Define new element primitives</td></tr>
<tr><td>Suspense</td><td>‚úÖ</td><td>schedule future render from future/promise</td></tr>
<tr><td>Integrated error handling</td><td>‚úÖ</td><td>Gracefully handle errors with ? syntax</td></tr>
<tr><td>NodeRef</td><td>‚úÖ</td><td>gain direct access to nodes</td></tr>
<tr><td>Re-hydration</td><td>‚úÖ</td><td>Pre-render to HTML to speed up first contentful paint</td></tr>
<tr><td>Jank-Free Rendering</td><td>‚úÖ</td><td>Large diffs are segmented across frames for silky-smooth transitions</td></tr>
<tr><td>Effects</td><td>‚úÖ</td><td>Run effects after a component has been committed to render</td></tr>
<tr><td>Portals</td><td>üõ†</td><td>Render nodes outside of the traditional tree structure</td></tr>
<tr><td>Cooperative Scheduling</td><td>üõ†</td><td>Prioritize important events over non-important events</td></tr>
<tr><td>Server Components</td><td>üõ†</td><td>Hybrid components for SPA and Server</td></tr>
<tr><td>Bundle Splitting</td><td>üëÄ</td><td>Efficiently and asynchronously load the app</td></tr>
<tr><td>Lazy Components</td><td>üëÄ</td><td>Dynamically load the new components as the page is loaded</td></tr>
<tr><td>1st class global state</td><td>‚úÖ</td><td>redux/recoil/mobx on top of context</td></tr>
<tr><td>Runs natively</td><td>‚úÖ</td><td>runs as a portable binary w/o a runtime (Node)</td></tr>
<tr><td>Subtree Memoization</td><td>‚úÖ</td><td>skip diffing static element subtrees</td></tr>
<tr><td>High-efficiency templates</td><td>üõ†</td><td>rsx! calls are translated to templates on the DOM's side</td></tr>
<tr><td>Compile-time correct</td><td>‚úÖ</td><td>Throw errors on invalid template layouts</td></tr>
<tr><td>Heuristic Engine</td><td>‚úÖ</td><td>track component memory usage to minimize future allocations</td></tr>
<tr><td>Fine-grained reactivity</td><td>üëÄ</td><td>Skip diffing for fine-grain updates</td></tr>
</tbody></table>
<ul>
<li>‚úÖ = implemented and working</li>
<li>üõ† = actively being worked on</li>
<li>üëÄ = not yet implemented or being worked on</li>
<li>‚ùì = not sure if will or can implement</li>
</ul>
<h2 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h2>
<p>These Features are planned for the future of Dioxus:</p>
<hr />
<h3 id="core"><a class="header" href="#core">Core</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Release of Dioxus Core</li>
<li><input disabled="" type="checkbox" checked=""/>
Upgrade documentation to include more theory and be more comprehensive</li>
<li><input disabled="" type="checkbox"/>
Support for HTML-side templates for lightning-fast dom manipulation</li>
<li><input disabled="" type="checkbox"/>
Support for multiple renderers for same virtualdom (subtrees)</li>
<li><input disabled="" type="checkbox"/>
Support for ThreadSafe (Send + Sync)</li>
<li><input disabled="" type="checkbox"/>
Support for Portals</li>
</ul>
<h3 id="ssr"><a class="header" href="#ssr">SSR</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
SSR Support + Hydration</li>
<li><input disabled="" type="checkbox"/>
Integrated suspense support for SSR</li>
</ul>
<h3 id="desktop"><a class="header" href="#desktop">Desktop</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Declarative window management</li>
<li><input disabled="" type="checkbox"/>
Templates for building/bundling</li>
<li><input disabled="" type="checkbox"/>
Fully native renderer</li>
<li><input disabled="" type="checkbox"/>
Access to Canvas/WebGL context natively</li>
</ul>
<h3 id="mobile"><a class="header" href="#mobile">Mobile</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Mobile standard library
<ul>
<li><input disabled="" type="checkbox"/>
GPS</li>
<li><input disabled="" type="checkbox"/>
Camera</li>
<li><input disabled="" type="checkbox"/>
filesystem</li>
<li><input disabled="" type="checkbox"/>
Biometrics</li>
<li><input disabled="" type="checkbox"/>
WiFi</li>
<li><input disabled="" type="checkbox"/>
Bluetooth</li>
<li><input disabled="" type="checkbox"/>
Notifications</li>
<li><input disabled="" type="checkbox"/>
Clipboard</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Animations</li>
<li><input disabled="" type="checkbox"/>
Native Renderer</li>
</ul>
<h3 id="bundling-cli"><a class="header" href="#bundling-cli">Bundling (CLI)</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Translation from HTML into RSX</li>
<li><input disabled="" type="checkbox" checked=""/>
Dev server</li>
<li><input disabled="" type="checkbox" checked=""/>
Live reload</li>
<li><input disabled="" type="checkbox" checked=""/>
Translation from JSX into RSX</li>
<li><input disabled="" type="checkbox"/>
Hot module replacement</li>
<li><input disabled="" type="checkbox"/>
Code splitting</li>
<li><input disabled="" type="checkbox"/>
Asset macros</li>
<li><input disabled="" type="checkbox"/>
Css pipeline</li>
<li><input disabled="" type="checkbox"/>
Image pipeline</li>
</ul>
<h3 id="essential-hooks"><a class="header" href="#essential-hooks">Essential hooks</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Router</li>
<li><input disabled="" type="checkbox" checked=""/>
Global state management</li>
<li><input disabled="" type="checkbox"/>
Resize observer</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>In this chapter, we're going to get set up with a small desktop application.</p>
<p>We'll learn about:</p>
<ul>
<li>Installing the Rust programming language</li>
<li>Installing the Dioxus CLI for bundling and developing</li>
<li>Suggested cargo extensions</li>
</ul>
<p>For platform-specific guides, check out the <a href="/reference/platforms/index.html">Platform Specific Guides</a>.</p>
<h1 id="setting-up-dioxus"><a class="header" href="#setting-up-dioxus">Setting up Dioxus</a></h1>
<p>Dioxus requires a few main things to get up and running:</p>
<ul>
<li>The <a href="https://www.rust-lang.org">Rust compiler</a> and associated build tooling</li>
<li>An editor of your choice, ideally configured with the <a href="https://rust-analyzer.github.io">Rust-Analyzer LSP plugin</a></li>
</ul>
<p>Dioxus integrates very well with the Rust-Analyzer IDE plugin which will provide appropriate syntax highlighting, code navigation, folding, and more.</p>
<h2 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h2>
<p>Head over to <a href="http://rust-lang.org">https://rust-lang.org</a> and install the Rust compiler.</p>
<p>Once installed, make sure to install wasm32-unknown-unknown as a target if you're planning on deploying your app to the web.</p>
<pre><code>rustup target add wasm32-unknown-unknown
</code></pre>
<h2 id="platform-specific-dependencies"><a class="header" href="#platform-specific-dependencies">Platform-Specific Dependencies</a></h2>
<p>If you are running a modern, mainstream operating system, you should need no additional setup to build WebView-based Desktop apps. However, if you are running an older version of Windows or a flavor of Linux with no default web rendering engine, you might need to install some additional dependencies.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Windows Desktop apps depend on WebView2 - a library which should be installed in all modern Windows distributions. If you have Edge installed, then Dioxus will work fine. If you <em>don't</em> have Webview2, <a href="https://developer.microsoft.com/en-us/microsoft-edge/webview2/">then you can install it through Microsoft</a>. MS provides 3 options:</p>
<ol>
<li>A tiny &quot;evergreen&quot; <em>bootstrapper</em> which will fetch an installer from Microsoft's CDN</li>
<li>A tiny <em>installer</em> which will fetch Webview2 from Microsoft's CDN</li>
<li>A statically linked version of Webview2 in your final binary for offline users</li>
</ol>
<p>For development purposes, use Option 1. </p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>Webview Linux apps require WebkitGtk. When distributing, this can be part of your dependency tree in your <code>.rpm</code> or <code>.deb</code>. However, it's very likely that your users will already have WebkitGtk.</p>
<pre><code>sudo apt install libwebkit2gtk-4.0-dev libgtk-3-dev libappindicator3-dev
</code></pre>
<p>When using Debian/bullseye <code>libappindicator3-dev</code> is no longer available but replaced by <code>libayatana-appindicator3-dev</code>.</p>
<pre><code># on Debian/bullseye use:
sudo apt install libwebkit2gtk-4.0-dev libgtk-3-dev libayatanta-appindicator3-dev
</code></pre>
<p>If you run into issues, make sure you have all the basics installed, as outlined in the <a href="https://tauri.studio/en/docs/get-started/setup-linux">Tauri docs</a>.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>Currently - everything for macOS is built right in! However, you might run into an issue if you're using nightly Rust due to some permissions issues in our Tao dependency (which have been resolved but not published).</p>
<h2 id="dioxus-cli-for-dev-server-bundling-etc"><a class="header" href="#dioxus-cli-for-dev-server-bundling-etc">Dioxus-CLI for dev server, bundling, etc.</a></h2>
<p>We also recommend installing the Dioxus CLI. The Dioxus CLI automates building and packaging for various targets and integrates with simulators, development servers, and app deployment. To install the CLI, you'll need cargo (which should be automatically installed with Rust):</p>
<pre><code>$ cargo install dioxus-cli
</code></pre>
<p>You can update dioxus-cli at any time with:</p>
<pre><code>$ cargo install --force dioxus-cli
</code></pre>
<p>We provide this 1st-party tool to save you from having to run potentially untrusted code every time you add a crate to your project - as is standard in the NPM ecosystem.</p>
<h2 id="suggested-extensions"><a class="header" href="#suggested-extensions">Suggested extensions</a></h2>
<p>If you want to keep your traditional <code>npm install XXX</code> workflow for adding packages, you might want to install <code>cargo-edit</code> and a few other fun <code>cargo</code> extensions:</p>
<ul>
<li><a href="https://github.com/killercup/cargo-edit">cargo edit</a> for adding dependencies from the CLI</li>
<li><a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a> for expanding macro calls</li>
<li><a href="https://doc.rust-lang.org/cargo/commands/cargo-tree.html">cargo tree</a> - an integrated cargo command that lets you inspect your dependency tree</li>
</ul>
<p>That's it! We won't need to touch NPM/WebPack/Babel/Parcel, etc. However, you <em>can</em> configure your app to use WebPack with <a href="https://rustwasm.github.io/wasm-pack/book/tutorials/hybrid-applications-with-webpack/using-your-library.html">traditional WASM-pack tooling</a>.</p>
<h2 id="rust-knowledge"><a class="header" href="#rust-knowledge">Rust Knowledge</a></h2>
<p>With Rust, things like benchmarking, testing, and documentation are included in the language. We strongly recommend going through the official Rust book <em>completely</em>. However, our hope is that a Dioxus app can serve as a great first Rust project. With Dioxus you'll learn about:</p>
<ul>
<li>Error handling</li>
<li>Structs, Functions, Enums</li>
<li>Closures</li>
<li>Macros</li>
</ul>
<p>We've put a lot of care into making Dioxus syntax familiar and easy to understand, so you won't need deep knowledge on async, lifetimes, or smart pointers until you really start building complex Dioxus apps.</p>
<p>We strongly encourage exploring the guides for more information on how to work with the integrated tooling:</p>
<ul>
<li><a href="Testing.html">Testing</a></li>
<li><a href="Documentation.html">Documentation</a></li>
<li><a href="Benchmarking.html">Benchmarking</a></li>
<li><a href="Building.html">Building</a></li>
<li><a href="Modules.html">Modules</a></li>
<li><a href="Crates.html">Crates</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world-desktop-app"><a class="header" href="#hello-world-desktop-app">&quot;Hello, World&quot; desktop app</a></h1>
<p>Let's put together a simple &quot;hello world&quot; desktop application to get acquainted with Dioxus.</p>
<p>In this chapter, we'll cover:</p>
<ul>
<li>Starting a new Dioxus project with Cargo</li>
<li>Adding Dioxus as a dependency</li>
<li>Launching our first component as the app root</li>
</ul>
<h3 id="a-new-project-with-cargo"><a class="header" href="#a-new-project-with-cargo">A new project with Cargo</a></h3>
<p>First, let's start a new project. Rust has the concept of executables and libraries. Executables have a <code>main.rs</code> and libraries have <code>lib.rs</code>. A project may have both. Our <code>hello world</code> will be an executable - we expect our app to launch when we run it! Cargo provides this for us:</p>
<pre><code class="language-shell">$ cargo new --bin hello-dioxus
</code></pre>
<p>Now, we can <code>cd</code> into our project and poke around:</p>
<pre><code class="language-shell">$ cd hello-dioxus
$ tree
.
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ .git
‚îú‚îÄ‚îÄ .gitignore
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
</code></pre>
<p>We are greeted with a pre-initialized git repository, our code folder (<code>src</code>) and our project file (<code>Cargo.toml</code>).</p>
<p>Our <code>src</code> folder holds our code. Our <code>main.rs</code> file holds our <code>fn main</code> which will be executed when our app is run.</p>
<pre><code class="language-shell">$ more src/main.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Right now, whenever our app is launched, &quot;Hello world&quot; will be echoed to the terminal.</p>
<pre><code class="language-shell">$ cargo run
   Compiling hello-dioxus v0.1.0
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/hello-dioxus`
Hello, world!
</code></pre>
<p>Our <code>Cargo.toml</code> file holds our dependencies and project flags.</p>
<pre><code class="language-shell">$ cat Cargo.toml
</code></pre>
<pre><code class="language-toml">[package]
name = &quot;hello-dioxus&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

</code></pre>
<h3 id="adding-dioxus-as-a-dependency"><a class="header" href="#adding-dioxus-as-a-dependency">Adding Dioxus as a dependency</a></h3>
<p>To use the Dioxus library, we'll want to add the most recent version of <code>Dioxus</code> to our crate. If you have <code>cargo edit</code> installed, simply call:</p>
<pre><code class="language-shell">$ cargo add dioxus --features desktop
</code></pre>
<p>It's very important to add <code>dioxus</code> with the <code>desktop</code> feature for this example. The <code>dioxus</code> crate is a batteries-include crate that combines a bunch of utility crates together, ensuring compatibility of the most important parts of the ecosystem. Under the hood, the <code>dioxus</code> crate configures various renderers, hooks, debug tooling, and more. The <code>desktop</code> feature ensures the we only depend on the smallest set of required crates to compile and render.</p>
<p>If you system does not provide the <code>libappindicator3</code> library, like Debian/bullseye, you can enable the replacement <code>ayatana</code> with an additional flag:</p>
<pre><code class="language-shell">$ # On Debian/bullseye use:
$ cargo add dioxus --features desktop --features ayatana
</code></pre>
<p>If you plan to develop extensions for the <code>Dioxus</code> ecosystem, please use the <code>dioxus</code> crate with the <code>core</code> feature to limit the amount of dependencies your project brings in.</p>
<h3 id="our-first-app"><a class="header" href="#our-first-app">Our first app</a></h3>
<p>Now, let's edit our <code>main.rs</code> file:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use dioxus::prelude::*;


fn main() {
    dioxus::desktop::launch(app);
}

fn app(cx: Scope) -&gt; Element {
    cx.render(rsx! (
        div { &quot;Hello, world!&quot; }
    ))
}
</code></pre></pre>
<p>At this point, you could call <code>cargo run</code> and be greeted with a simple <code>Hello, World!</code> screen:</p>
<p><img src="images/helloworld.png" alt="hello world" /></p>
<h3 id="dissecting-our-example"><a class="header" href="#dissecting-our-example">Dissecting our example</a></h3>
<p>The <code>use</code> statement at the top of our app imports everything from the the <code>prelude</code> module. <code>use</code>-ing the prelude imports the right traits, types, and macros needed for working with Dioxus.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dioxus::prelude::*;
<span class="boring">}
</span></code></pre></pre>
<p>This initialization code launches a Tokio runtime on a helper thread where your code will run. Then, the WebView renderer will be launched on the main-thread. Due to platform requirements, the main thread is blocked by your app's event loop.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    dioxus::desktop::launch(app);
}
</code></pre></pre>
<p>Finally, our app. Every component in Dioxus is a function that takes in <code>Context</code> and <code>Props</code> and returns an <code>Element</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    cx.render(rsx! {
        div { &quot;Hello, world!&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="what-is-this-scope-object"><a class="header" href="#what-is-this-scope-object">What is this <code>Scope</code> object?</a></h3>
<p>Coming from React, the <code>Scope</code> object might be confusing. In React, you'll want to store data between renders with hooks. However, hooks rely on global variables which make them difficult to integrate in multi-tenant systems like server-rendering.</p>
<p>In Dioxus, you are given an explicit <code>Scope</code> object to control how the component renders and stores data. The <code>Scope</code> object provides a handful of useful APIs for features like suspense, rendering, and more.</p>
<p>For now, just know that <code>Scope</code> lets you store state with hooks and render elements with <code>cx.render</code>.</p>
<h2 id="moving-on"><a class="header" href="#moving-on">Moving on</a></h2>
<p>Congrats! You've built your first desktop application with Dioxus. Next, we're going to learn about the basics of building interactive user interfaces.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-topics"><a class="header" href="#core-topics">Core Topics</a></h1>
<p>In this chapter, we'll cover some core topics about how Dioxus works and how to best leverage the features to build a beautiful, reactive app.</p>
<p>At a very high level, Dioxus is simply a Rust framework for <em>declaring</em> user interfaces and <em>reacting</em> to changes.</p>
<ol>
<li>We declare what we want our user interface to look like given a state using Rust-based logic and control flow.</li>
<li>We declare how we want our state to change when the user triggers an event.</li>
</ol>
<h2 id="declarative-ui"><a class="header" href="#declarative-ui">Declarative UI</a></h2>
<p>Dioxus is a <em>declarative</em> framework. This means that instead of manually writing calls to &quot;create element&quot; and &quot;set element background to red,&quot; we simply <em>declare</em> what we want the element to look like and let Dioxus handle the differences.</p>
<p>Let's pretend that we have a stoplight we need to control - it has a color state with red, yellow, and green as options.</p>
<p>Using an imperative approach, we would have to manually declare each element and then handlers for advancing the stoplight.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let container = Container::new();

let green_light = Light::new().color(&quot;green&quot;).enabled(true);
let yellow_light = Light::new().color(&quot;yellow&quot;).enabled(false);
let red_light = Light::new().color(&quot;red&quot;).enabled(false);
container.push(green_light);
container.push(yellow_light);
container.push(red_light);

container.set_onclick(move |_| {
    if red_light.enabled() {
        red_light.set_enabled(false);
        green_light.set_enabled(true);
    } else if yellow_light.enabled() {
        yellow_light.set_enabled(false);
        red_light.set_enabled(true);
    } else if green_light.enabled() {
        green_light.set_enabled(false);
        yellow_light.set_enabled(true);
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>As the UI grows in scale, our logic to keep each element in the proper state would grow exponentially. This can become very unwieldy and lead to out-of-sync UIs that harm user experience.</p>
<p>Instead, with Dioxus, we <em>declare</em> what we want our UI to look like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut state = use_state(&amp;cx, || &quot;red&quot;);

cx.render(rsx!(
    Container {
        Light { color: &quot;red&quot;, enabled: state == &quot;red&quot;, }
        Light { color: &quot;yellow&quot;, enabled: state == &quot;yellow&quot;, }
        Light { color: &quot;green&quot;, enabled: state == &quot;green&quot;, }

        onclick: move |_| {
            state.set(match *state {
                &quot;green&quot; =&gt; &quot;yellow&quot;,
                &quot;yellow&quot; =&gt; &quot;red&quot;,
                &quot;red&quot; =&gt; &quot;green&quot;,
            })
        }
    }
))
<span class="boring">}
</span></code></pre></pre>
<p>Remember: this concept is not new! Many frameworks are declarative - with React being the most popular. Declarative frameworks tend to be much more enjoyable to work with than imperative frameworks.</p>
<p>Here's some reading about declaring UI in React:</p>
<ul>
<li>
<p><a href="https://stackoverflow.com/questions/33655534/difference-between-declarative-and-imperative-in-react-js">Difference between declarative and imperative in React.js</a>, a StackOverflow thread</p>
</li>
<li>
<p><a href="https://medium.com/@myung.kim287/declarative-vs-imperative-251ce99c6c44">Declarative vs Imperative</a>, a blog post by Myung Kim</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-your-first-ui-with-elements"><a class="header" href="#declaring-your-first-ui-with-elements">Declaring your first UI with Elements</a></h1>
<p>Every user interface you've ever used is just a symphony of tiny widgets working together to abstract over larger complex functions. In Dioxus, we call these tiny widgets &quot;Elements.&quot; Using Components, you can easily compose Elements into larger groups to form even larger structures: Apps.</p>
<p>In this chapter, we'll cover:</p>
<ul>
<li>Declaring our first Element</li>
<li>Composing Elements together</li>
<li>Element properties</li>
</ul>
<h2 id="declaring-our-first-element"><a class="header" href="#declaring-our-first-element">Declaring our first Element</a></h2>
<p>Because Dioxus is mostly used with HTML/CSS renderers, the default Element &quot;collection&quot; is HTML. Provided the <code>html</code> feature is not disabled, we can declare Elements using the <code>rsx!</code> macro:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    div {}
)
<span class="boring">}
</span></code></pre></pre>
<p>As you might expect, we can render this call using Dioxus-SSR to produce valid HTML:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dioxus::ssr::render_lazy(rsx!(
    div {}
))
<span class="boring">}
</span></code></pre></pre>
<p>Produces:</p>
<pre><code class="language-html">&lt;div&gt;&lt;/div&gt;
</code></pre>
<p>We can construct any valid HTML tag with the <code>tag {}</code> pattern and expect the resulting HTML structure to resemble our declaration.</p>
<h2 id="composing-elements"><a class="header" href="#composing-elements">Composing Elements</a></h2>
<p>Of course, we need more complex structures to make our apps actually useful! Just like HTML, the <code>rsx!</code> macro lets us nest Elements inside of each other.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use dioxus::prelude::*;
</span>rsx!(
    div {
        h1 {}
        h2 {}
        p {}
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>As you might expect, the generated HTML for this structure would look like:</p>
<pre><code class="language-html">&lt;div&gt;
    &lt;h1&gt;&lt;/h1&gt;
    &lt;h2&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>With the default configuration, any Element defined within the <code>dioxus-html</code> crate can be declared in this way. To create your own new elements, see the <code>Custom Elements</code> Advanced Guide.</p>
<h2 id="text-elements"><a class="header" href="#text-elements">Text Elements</a></h2>
<p>Dioxus also supports a special type of Element: Text. Text Elements do not accept children, just a string literal denoted by double quotes.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx! (
    &quot;hello world&quot;
)
<span class="boring">}
</span></code></pre></pre>
<p>Text Elements can be composed within other Elements:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx! (
    div {
        h1 { &quot;hello world&quot; }
        p { &quot;Some body content&quot; }
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>Text can also be formatted with any value that implements <code>Display</code>. We use the same syntax as Rust <a href="https://www.rustnote.com/blog/format_strings.html">format strings</a> ‚Äì which will already be familiar for Python and JavaScript users:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = &quot;Bob&quot;;
rsx! ( &quot;hello {name}&quot; )
<span class="boring">}
</span></code></pre></pre>
<p>Unfortunately, you cannot drop in arbitrary expressions directly into the string literal. In the cases where we need to compute a complex value, we'll want to use <code>format_args!</code> directly. Due to specifics of the <code>rsx!</code> macro (which we'll cover later), our call to <code>format_args</code> must be contained within square braces.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!( [format_args!(&quot;Hello {}&quot;, if enabled { &quot;Jack&quot; } else { &quot;Bob&quot; } )] )
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, <code>&amp;str</code> can be included directly, though it must also be inside square braces:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!( &quot;Hello &quot;,  [if enabled { &quot;Jack&quot; } else { &quot;Bob&quot; }] )
<span class="boring">}
</span></code></pre></pre>
<p>This is different from React's way of generating arbitrary markup but fits within idiomatic Rust.</p>
<p>Typically, with Dioxus, you'll just want to compute your substrings outside of the <code>rsx!</code> call and leverage the f-string formatting:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = if enabled { &quot;Jack&quot; } else { &quot;Bob&quot; };
rsx! ( &quot;hello {name}&quot; )
<span class="boring">}
</span></code></pre></pre>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<p>Every Element in your user interface will have some sort of properties that the renderer will use when drawing to the screen. These might inform the renderer if the component should be hidden, what its background color should be, or to give it a specific name or ID.</p>
<p>To do this, we use the familiar struct-style syntax that Rust provides:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    div {
        hidden: &quot;true&quot;,
        background_color: &quot;blue&quot;,
        class: &quot;card color-{mycolor}&quot;
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>Each field is defined as a method on the element in the <code>dioxus-html</code> crate. This prevents you from misspelling a field name and lets us provide inline documentation. When you need to use a field not defined as a method, you have two options:</p>
<ol>
<li>file an issue if the attribute <em>should</em> be enabled</li>
<li>add a custom attribute on-the-fly</li>
</ol>
<p>To use custom attributes, simply put the attribute name in quotes:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    div {
        &quot;customAttr&quot;: &quot;important data here&quot;
    }
)
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: the name of the custom attribute must match exactly what you want the renderer to output. All attributes defined as methods in <code>dioxus-html</code> follow the snake_case naming convention. However, they internally translate their snake_case convention to HTML's camelCase convention. When using custom attributes, make sure the name of the attribute <strong>exactly</strong> matches what the renderer is expecting.</p>
</blockquote>
<p>All element attributes must occur <em>before</em> child elements. The <code>rsx!</code> macro will throw an error if your child elements come before any of your attributes. If you don't see the error, try editing your Rust-Analyzer IDE setting to ignore macro-errors. This is a temporary workaround because Rust-Analyzer currently throws <em>two</em> errors instead of just the one we care about.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// settings.json
{
  &quot;rust-analyzer.diagnostics.disabled&quot;: [
    &quot;macro-error&quot;
  ],
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="listeners"><a class="header" href="#listeners">Listeners</a></h2>
<p>Listeners are a special type of Attribute that only accept functions. Listeners let us attach functionality to our Elements by running a provided closure whenever the specified Listener is triggered.</p>
<p>We'll cover listeners in more depth in the Listeners chapter, but for now, just know that every listener must start with the <code>on</code> keyword and accepts closures.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    div {
        onclick: move |_| log::debug!(&quot;div clicked!&quot;),
    }
)
<span class="boring">}
</span></code></pre></pre>
<h2 id="moving-on-1"><a class="header" href="#moving-on-1">Moving On</a></h2>
<p>This chapter just scratches the surface on how Elements can be defined.</p>
<p>We learned:</p>
<ul>
<li>Elements are the basic building blocks of User Interfaces</li>
<li>Elements can contain other elements</li>
<li>Elements can either be a named container or text</li>
<li>Some Elements have properties that the renderer can use to draw the UI to the screen</li>
</ul>
<p>Next, we'll compose Elements together using Rust-based logic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-rendering"><a class="header" href="#conditional-rendering">Conditional Rendering</a></h1>
<p>Your components will often need to display different things depending on different conditions. With Dioxus, we can use Rust's normal control flow to conditional hide, show, and modify the structure of our markup.</p>
<p>In this chapter, you'll learn:</p>
<ul>
<li>How to return different Elements depending on a condition</li>
<li>How to conditionally include an Element in your structure</li>
<li>Common patterns like matching and bool mapping</li>
</ul>
<h2 id="conditionally-returning-elements"><a class="header" href="#conditionally-returning-elements">Conditionally returning Elements</a></h2>
<p>In some components, you might want to render different markup given some condition. The typical example for conditional rendering is showing a &quot;Log In&quot; screen for users who aren't logged into your app. To break down this condition, we can consider two states:</p>
<ul>
<li>Logged in: show the app</li>
<li>Logged out: show the login screen</li>
</ul>
<p>Using the knowledge from the previous section on components, we'll start by making the app's props:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props, PartialEq)]
struct AppProps {
    logged_in: bool
}
<span class="boring">}
</span></code></pre></pre>
<p>Now that we have a &quot;logged_in&quot; flag accessible in our props, we can render two different screens:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope&lt;AppProps&gt;) -&gt; Element {
    if cx.props.logged_in {
        cx.render(rsx!{
            DashboardScreen {}
        })
    } else {
        cx.render(rsx!{
            LoginScreen {}
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>When the user is logged in, then this component will return the DashboardScreen. If they're not logged in, the component will render the LoginScreen.</p>
<h2 id="using-match-statements"><a class="header" href="#using-match-statements">Using match statements</a></h2>
<p>Rust provides us algebraic datatypes: enums that can contain values. Using the <code>match</code> keyword, we can execute different branches of code given a condition.</p>
<p>For instance, we could run a function that returns a Result:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope)-&gt; Element {
    match get_name() {
        Ok(name) =&gt; cx.render(rsx!( &quot;Hello, {name}!&quot; )),
        Err(err) =&gt; cx.render(rsx!( &quot;Sorry, I don't know your name, because an error occurred: {err}&quot; )),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We can even match against values:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope)-&gt; Element {
    match get_name() {
        &quot;jack&quot; =&gt; cx.render(rsx!( &quot;Hey Jack, how's Diane?&quot; )),
        &quot;diane&quot; =&gt; cx.render(rsx!( &quot;Hey Diane, how's Jack?&quot; )),
        name =&gt; cx.render(rsx!( &quot;Hello, {name}!&quot; )),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Do note: the <code>rsx!</code> macro does not return an Element, but rather a wrapper struct for a <code>Closure</code> (an anonymous function). To turn our <code>rsx!</code> into an Element, we need to call <code>cx.render</code>.</p>
<p>To make patterns like these less verbose, the <code>rsx!</code> macro accepts an optional first argument on which it will call <code>render</code>. Our previous component can be shortened with this alternative syntax:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope)-&gt; Element {
    match get_name() {
        &quot;jack&quot; =&gt; rsx!(cx, &quot;Hey Jack, how's Diane?&quot; ),
        &quot;diane&quot; =&gt; rsx!(cx, &quot;Hey Diana, how's Jack?&quot; ),
        name =&gt; rsx!(cx, &quot;Hello, {name}!&quot; ),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, for match statements, we can just return the builder itself and pass it into a final, single call to <code>cx.render</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope)-&gt; Element {
    let greeting = match get_name() {
        &quot;jack&quot; =&gt; rsx!(&quot;Hey Jack, how's Diane?&quot; ),
        &quot;diane&quot; =&gt; rsx!(&quot;Hey Diana, how's Jack?&quot; ),
        name =&gt; rsx!(&quot;Hello, {name}!&quot; ),
    };
    cx.render(greeting)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="nesting-rsx"><a class="header" href="#nesting-rsx">Nesting RSX</a></h2>
<p>By looking at other examples, you might have noticed that it's possible to include <code>rsx!</code> calls inside other <code>rsx!</code> calls. We can include anything in our <code>rsx!</code> that implements <code>IntoVnodeList</code>: a marker trait for iterators that produce Elements. <code>rsx!</code> itself implements this trait, so we can include it directly:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    div {
        rsx!(
            &quot;more rsx!&quot;
        )
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>As you might expect, we can refactor this structure into two separate calls using variables:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let title = rsx!( &quot;more rsx!&quot; );

rsx!(
    div {
        title
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>In the case of a log-in screen, we might want to display the same NavBar and Footer for both logged in and logged out users. We can model this entirely by assigning a <code>screen</code> variable to a different Element depending on a condition:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let screen = match logged_in {
    true =&gt; rsx!(DashboardScreen {}),
    false =&gt; rsx!(LoginScreen {})
};

cx.render(rsx!{
    Navbar {}
    screen,
    Footer {}
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="rendering-nothing"><a class="header" href="#rendering-nothing">Rendering Nothing</a></h2>
<p>Sometimes, you don't want your component to return anything at all. Under the hood, the <code>Element</code> type is just an alias for <code>Option&lt;VNode&gt;</code>, so you can simply return <code>None</code>.</p>
<p>This can be helpful in certain patterns where you need to perform some logical side-effects but don't want to render anything.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn demo(cx: Scope) -&gt; Element {
    None
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="boolean-mapping"><a class="header" href="#boolean-mapping">Boolean Mapping</a></h2>
<p>In the spirit of highly-functional apps, we suggest using the &quot;boolean mapping&quot; pattern when trying to conditionally hide/show an Element.</p>
<p>By default, Rust lets you convert any <code>boolean</code> into an Option of any other type with <a href="https://doc.rust-lang.org/std/primitive.bool.html#method.then"><code>then()</code></a>. We can use this in Components by mapping to some Element.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let show_title = true;
rsx!(
    div {
        // Renders nothing by returning None when show_title is false
        show_title.then(|| rsx!{
            &quot;This is the title&quot;
        })
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>We can use this pattern for many things, including options:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user_name = Some(&quot;bob&quot;);
rsx!(
    div {
        // Renders nothing if user_name is None
        user_name.map(|name| rsx!(&quot;Hello {name}&quot;))
    }
)
<span class="boring">}
</span></code></pre></pre>
<h2 id="moving-forward"><a class="header" href="#moving-forward">Moving Forward:</a></h2>
<p>In this chapter, we learned how to render different Elements from a Component depending on a condition. This is a very powerful building block to assemble complex user interfaces!</p>
<p>In the next chapter, we'll cover how to renderer lists inside your <code>rsx!</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-lists-and-keys"><a class="header" href="#conditional-lists-and-keys">Conditional Lists and Keys</a></h1>
<p>You will often want to display multiple similar components from a collection of data.</p>
<p>In this chapter, you will learn:</p>
<ul>
<li>How to use iterators in <code>rsx!</code></li>
<li>How to filter and transform data into a list of Elements</li>
<li>How to create efficient lists with keys</li>
</ul>
<h2 id="rendering-data-from-lists"><a class="header" href="#rendering-data-from-lists">Rendering data from lists</a></h2>
<p>If we wanted to build the Reddit app, then we need to implement a list of data that needs to be rendered: the list of posts. This list of posts is always changing, so we cannot just hardcode the lists into our app directly, like so:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// we shouldn't ship our app with posts that don't update!
rsx!(
    div {
        Post {
            title: &quot;Post A&quot;,
            votes: 120,
        }
        Post {
            title: &quot;Post B&quot;,
            votes: 14,
        }
        Post {
            title: &quot;Post C&quot;,
            votes: 999,
        }
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>Instead, we need to transform the list of data into a list of Elements.</p>
<p>For convenience, <code>rsx!</code> supports any type in curly braces that implements the <code>IntoVnodeList</code> trait. Conveniently, every iterator that returns something that can be rendered as an Element also implements <code>IntoVnodeList</code>.</p>
<p>As a simple example, let's render a list of names. First, start with our input data:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let names = [&quot;jim&quot;, &quot;bob&quot;, &quot;jane&quot;, &quot;doe&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>Then, we create a new iterator by calling <code>iter</code> and then <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>map</code></a>. In our <code>map</code> function, we'll render our template.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name_list = names.iter().map(|name| rsx!(
    li { &quot;{name}&quot; }
));
<span class="boring">}
</span></code></pre></pre>
<p>We can include this list in the final Element:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    ul {
        name_list
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>Rather than storing <code>name_list</code> in a temporary variable, we could also include the iterator inline:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    ul {
        names.iter().map(|name| rsx!(
            li { &quot;{name}&quot; } 
        ))
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>The rendered HTML list is what you would expect:</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt; jim &lt;/li&gt;
    &lt;li&gt; bob &lt;/li&gt;
    &lt;li&gt; jane &lt;/li&gt;
    &lt;li&gt; doe &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h2 id="filtering-iterators"><a class="header" href="#filtering-iterators">Filtering Iterators</a></h2>
<p>Rust's iterators are extremely powerful, especially when used for filtering tasks. When building user interfaces, you might want to display a list of items filtered by some arbitrary check.</p>
<p>As a very simple example, let's set up a filter where we only list names that begin with the letter &quot;j&quot;.</p>
<p>Using the list from above, let's create a new iterator. Before we render the list with <code>map</code> as in the previous example, we'll <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>filter</code></a> the names to only allow those that start with &quot;j&quot;.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name_list = names
    .iter()
    .filter(|name| name.starts_with('j'))
    .map(|name| rsx!( li { &quot;{name}&quot; }));
<span class="boring">}
</span></code></pre></pre>
<p>Rust's Iterators are very versatile ‚Äì check out <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">their documentation</a> for more things you can do with them!</p>
<p>For keen Rustaceans: notice how we don't actually call <code>collect</code> on the name list. If we <code>collect</code>ed our filtered list into new Vec, we would need to make an allocation to store these new elements, which slows down rendering. Instead, we create an entirely new <em>lazy</em> iterator which Dioxus will consume in the <code>render</code> call. The <code>render</code> method is extraordinarily efficient, so it's best practice to let it do most of the allocations for us.</p>
<h2 id="keeping-list-items-in-order-with-key"><a class="header" href="#keeping-list-items-in-order-with-key">Keeping list items in order with <code>key</code></a></h2>
<p>The examples above demonstrate the power of iterators in <code>rsx!</code> but all share the same issue: if your array items move (e.g. due to sorting), get inserted, or get deleted, Dioxus has no way of knowing what happened. This can cause Elements to be unnecessarily removed, changed and rebuilt when all that was needed was to change their position ‚Äì this is inneficient.</p>
<p>To solve this problem, each item in the list must be <strong>uniquely identifiable</strong>. You can achieve this by giving it a unique, fixed &quot;key&quot;. In Dioxus, a key is a string that identifies an item among others in the list.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!( li { key: &quot;a&quot; } )
<span class="boring">}
</span></code></pre></pre>
<p>Now, if an item has already been rendered once, Dioxus can use the key to match it up later to make the correct updates ‚Äì and avoid unnecessary work.</p>
<p>NB: the language from this section is strongly borrowed from <a href="https://reactjs.org/docs/lists-and-keys.html">React's guide on keys</a>.</p>
<h3 id="where-to-get-your-key"><a class="header" href="#where-to-get-your-key">Where to get your key</a></h3>
<p>Different sources of data provide different sources of keys:</p>
<ul>
<li><em>Data from a database</em>: If your data is coming from a database, you can use the database keys/IDs, which are unique by nature.</li>
<li><em>Locally generated data</em>: If your data is generated and persisted locally (e.g. notes in a note-taking app), keep track of keys along with your data. You can use an incrementing counter or a package like <code>uuid</code> to generate keys for new items ‚Äì but make sure they stay the same for the item's lifetime.</li>
</ul>
<p>Remember: keys let Dioxus uniquely identify an item among its siblings. A well-chosen key provides more information than the position within the array. Even if the position changes due to reordering, the key lets Dioxus identify the item throughout its lifetime.</p>
<h3 id="rules-of-keys"><a class="header" href="#rules-of-keys">Rules of keys</a></h3>
<ul>
<li>Keys must be unique among siblings. However, it‚Äôs okay to use the same keys for Elements in different arrays.</li>
<li>An item's key must not change ‚Äì <strong>don‚Äôt generate them on the fly</strong> while rendering. Otherwise, Dioxus will be unable to keep track of which item is which, and we're back to square one.</li>
</ul>
<p>You might be tempted to use an item's index in the array as its key. In fact, that‚Äôs what Dioxus will use if you don‚Äôt specify a key at all. This is only acceptable if you can guarantee that the list is constant ‚Äì i.e., no re-ordering, additions or deletions. In all other cases, do not use the index for the key ‚Äì it will lead to the performance problems described above.</p>
<p>Note that if you pass the key to a <a href="elements/../components/index.html">custom component</a> you've made, it won't receive the key as a prop. It‚Äôs only used as a hint by Dioxus itself. If your component needs an ID, you have to pass it as a separate prop:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Post { key: &quot;{key}&quot;, id: &quot;{key}&quot; }
<span class="boring">}
</span></code></pre></pre>
<h2 id="moving-on-2"><a class="header" href="#moving-on-2">Moving on</a></h2>
<p>In this section, we learned:</p>
<ul>
<li>How to render lists of data</li>
<li>How to use iterator tools to filter and transform data</li>
<li>How to use keys to render lists efficiently</li>
</ul>
<p>Moving forward, we'll learn more about attributes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="special-attributes"><a class="header" href="#special-attributes">Special Attributes</a></h1>
<p>Dioxus tries its hardest to stay close to React, but there are some divergences and &quot;special behavior&quot; that you should review before moving on.</p>
<p>In this section, we'll cover special attributes built into Dioxus:</p>
<ul>
<li><code>dangerous_inner_html</code></li>
<li>Boolean attributes</li>
<li><code>prevent_default</code></li>
</ul>
<!-- - `..Attributes` -->
<ul>
<li>event handlers as string attributes</li>
<li><code>value</code>, <code>checked</code>, and <code>selected</code></li>
</ul>
<h2 id="the-html-escape-hatch-dangerous_inner_html"><a class="header" href="#the-html-escape-hatch-dangerous_inner_html">The HTML escape hatch: <code>dangerous_inner_html</code></a></h2>
<p>One thing you might've missed from React is the ability to render raw HTML directly to the DOM. If you're working with pre-rendered assets, output from templates, or output from a JS library, then you might want to pass HTML directly instead of going through Dioxus. In these instances, reach for <code>dangerous_inner_html</code>.</p>
<p>For example, shipping a markdown-to-Dioxus converter might significantly bloat your final application size. Instead, you'll want to pre-render your markdown to HTML and then include the HTML directly in your output. We use this approach for the <a href="https://dioxuslabs.com">Dioxus homepage</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn BlogPost(cx: Scope) -&gt; Element {
    let contents = include_str!(&quot;../post.html&quot;);
    cx.render(rsx!{
        div {
            class: &quot;markdown&quot;,
            dangerous_inner_html: &quot;{contents}&quot;,
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note! This attribute is called &quot;dangerous_inner_html&quot; because it is <strong>dangerous</strong> to pass it data you don't trust. If you're not careful, you can easily expose cross-site-scripting (XSS) attacks to your users.</p>
<p>If you're handling untrusted input, make sure to sanitize your HTML before passing it into <code>dangerous_inner_html</code> ‚Äì or just pass it to a Text Element to escape any HTML tags.</p>
</blockquote>
<h2 id="boolean-attributes"><a class="header" href="#boolean-attributes">Boolean Attributes</a></h2>
<p>Most attributes, when rendered, will be rendered exactly as the input you provided. However, some attributes are considered &quot;boolean&quot; attributes and just their presence determines whether or not they affect the output. For these attributes, a provided value of <code>&quot;false&quot;</code> will cause them to be removed from the target element.</p>
<p>So this RSX:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    div {
        hidden: &quot;false&quot;,
        &quot;hello&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>wouldn't actually render the <code>hidden</code> attribute: </p>
<pre><code class="language-html">&lt;div&gt;hello&lt;/div&gt; 
</code></pre>
<p>Not all attributes work like this however. <em>Only the following attributes</em> have this behavior:</p>
<ul>
<li><code>allowfullscreen</code></li>
<li><code>allowpaymentrequest</code></li>
<li><code>async</code></li>
<li><code>autofocus</code></li>
<li><code>autoplay</code></li>
<li><code>checked</code></li>
<li><code>controls</code></li>
<li><code>default</code></li>
<li><code>defer</code></li>
<li><code>disabled</code></li>
<li><code>formnovalidate</code></li>
<li><code>hidden</code></li>
<li><code>ismap</code></li>
<li><code>itemscope</code></li>
<li><code>loop</code></li>
<li><code>multiple</code></li>
<li><code>muted</code></li>
<li><code>nomodule</code></li>
<li><code>novalidate</code></li>
<li><code>open</code></li>
<li><code>playsinline</code></li>
<li><code>readonly</code></li>
<li><code>required</code></li>
<li><code>reversed</code></li>
<li><code>selected</code></li>
<li><code>truespeed</code></li>
</ul>
<p>For any other attributes, a value of <code>&quot;false&quot;</code> will be sent directly to the DOM.</p>
<h2 id="stopping-form-input-and-navigation-with-prevent_default"><a class="header" href="#stopping-form-input-and-navigation-with-prevent_default">Stopping form input and navigation with <code>prevent_default</code></a></h2>
<p>Currently, calling <code>prevent_default</code> on events in EventHandlers is not possible from Desktop/Mobile. Until this is supported, it's possible to prevent default using the <code>prevent_default</code> attribute. </p>
<blockquote>
<p>Note: you cannot conditionally prevent default with this approach. This is a limitation until synchronous event handling is available across the Webview boundary </p>
</blockquote>
<p>To use <code>prevent_default</code>, simply attach the <code>prevent_default</code> attribute to a given element and set it to the name of the event handler you want to prevent default on. We can attach this attribute multiple times for multiple attributes.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    input {
        oninput: move |_| {},
        prevent_default: &quot;oninput&quot;,

        onclick: move |_| {},
        prevent_default: &quot;onclick&quot;,
    }
}
<span class="boring">}
</span></code></pre></pre>
<!-- 
## Passing attributes into children: `..Attributes`

> Note: this is an experimental, unstable feature not available in released versions of Dioxus. Feel free to skip this section.

Just like Dioxus supports spreading component props into components, we also support spreading attributes into elements. This lets you pass any arbitrary attributes through components into elements.


```rust
#[derive(Props)]
pub struct InputProps<'a> {
    pub children: Element<'a>,
    pub attributes: Attribute<'a>
}

pub fn StateInput<'a>(cx: Scope<'a, InputProps<'a>>) -> Element {
    cx.render(rsx! (
        input {
            ..cx.props.attributes,
            &cx.props.children,
        }
    ))
}
``` -->
<h2 id="controlled-inputs-and-value-checked-and-selected"><a class="header" href="#controlled-inputs-and-value-checked-and-selected">Controlled inputs and <code>value</code>, <code>checked</code>, and <code>selected</code></a></h2>
<p>In Dioxus, there is a distinction between controlled and uncontrolled inputs. Most inputs you'll use are controlled, meaning we both drive the <code>value</code> of the input and react to the <code>oninput</code>.</p>
<p>Controlled components:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = use_state(&amp;cx, || String::from(&quot;hello world&quot;));

rsx! {
    input {
        oninput: move |evt| value.set(evt.value.clone()),
        value: &quot;{value}&quot;,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>With uncontrolled inputs, we won't actually drive the value from the component. This has its advantages when we don't want to re-render the component when the user inputs a value. We could either select the element directly - something Dioxus doesn't support across platforms - or we could handle <code>oninput</code> and modify a value without causing an update:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = use_ref(&amp;cx, || String::from(&quot;hello world&quot;));

rsx! {
    input {
        oninput: move |evt| *value.write_silent() = evt.value.clone(),
        // no &quot;value&quot; is driven here ‚Äì the input keeps track of its own value, and you can't change it
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="strings-for-handlers-like-onclick"><a class="header" href="#strings-for-handlers-like-onclick">Strings for handlers like <code>onclick</code></a></h2>
<p>For element fields that take a handler like <code>onclick</code> or <code>oninput</code>, Dioxus will let you attach a closure. Alternatively, you can also pass a string using normal attribute syntax and assign this attribute on the DOM.</p>
<p>This lets you use JavaScript (only if your renderer can execute JavaScript).</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    div {
        // handle oninput with rust
        oninput: move |_| {},

        // or handle oninput with javascript
        oninput: &quot;alert('hello world')&quot;,
    }
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h2>
<p>In this chapter, we learned:</p>
<ul>
<li>How to declare elements</li>
<li>How to conditionally render parts of your UI</li>
<li>How to render lists</li>
<li>Which attributes are &quot;special&quot;</li>
</ul>
<!-- todo
There's more to elements! For further reading, check out:

- [Custom Elements]() 
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-components"><a class="header" href="#introduction-to-components">Introduction to Components</a></h1>
<p>In the previous chapter, we learned about Elements and how they can be composed to create a basic user interface. Now, we'll learn how to group Elements together to form Components. We'll cover:</p>
<ul>
<li>What makes a Component</li>
<li>How to model a component and its properties in Dioxus</li>
<li>How to &quot;think declaratively&quot;</li>
</ul>
<h2 id="what-is-a-component"><a class="header" href="#what-is-a-component">What is a component?</a></h2>
<p>In short, a component is a special function that takes input properties and outputs an Element. Much like a function encapsulates some specific computation task, a Component encapsulates some specific rendering task ‚Äì typically, rendering an isolated part of the user interface.</p>
<h3 id="real-world-example"><a class="header" href="#real-world-example">Real-world example</a></h3>
<p>Let's use a Reddit post as an example:</p>
<p><img src="components/../images/reddit_post.png" alt="Reddit Post" /></p>
<p>If we look at the layout of the component, we notice quite a few buttons and pieces of functionality:</p>
<ul>
<li>Upvote/Downvote</li>
<li>View comments</li>
<li>Share</li>
<li>Save</li>
<li>Hide</li>
<li>Give award</li>
<li>Report</li>
<li>Crosspost</li>
<li>Filter by site</li>
<li>View article</li>
<li>Visit user</li>
</ul>
<p>If we included all this functionality in one <code>rsx!</code> call it would be huge! Instead, let's break the post down into Components:</p>
<p><img src="components/../images/reddit_post_components.png" alt="Post as Component" /></p>
<ul>
<li><strong>VoteButton</strong>: Upvote/Downvote</li>
<li><strong>TitleCard</strong>: Title, Filter-By-Url</li>
<li><strong>MetaCard</strong>: Original Poster, Time Submitted</li>
<li><strong>ActionCard</strong>: View comments, Share, Save, Hide, Give award, Report, Crosspost</li>
</ul>
<p>In this chapter, we'll learn how to define these components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-properties"><a class="header" href="#component-properties">Component Properties</a></h1>
<p>Dioxus components are functions that accept Props as input and output an Element. In fact, the <code>App</code> function you saw in the previous chapter was a component with no Props! Most components, however, will need to take some Props to render something useful ‚Äì so, in this section, we'll learn about props:</p>
<ul>
<li>Deriving the Props trait</li>
<li>Memoization through PartialEq</li>
<li>Optional fields on props</li>
<li>The inline_props macro</li>
</ul>
<h2 id="props"><a class="header" href="#props">Props</a></h2>
<p>The input of your Component must be passed in a single struct, which must implement the <code>Props</code> trait. We can derive this trait automatically with <code>#[derive(Props)]</code>.</p>
<blockquote>
<p>Dioxus <code>Props</code> is very similar to <a href="https://github.com/idanarye">@idanarye</a>'s <a href="https://github.com/idanarye/rust-typed-builder">TypedBuilder crate</a> and supports many of the same parameters.</p>
</blockquote>
<p>There are 2 flavors of Props: owned and borrowed.</p>
<ul>
<li>All Owned Props must implement <code>PartialEq</code></li>
<li>Borrowed props <a href="https://doc.rust-lang.org/beta/rust-by-example/scope/borrow.html">borrow</a> values from the parent Component</li>
</ul>
<h3 id="owned-props"><a class="header" href="#owned-props">Owned Props</a></h3>
<p>Owned Props are very simple ‚Äì they don't borrow anything. Example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remember: owned props must implement PartialEq!
#[derive(PartialEq, Props)]
struct VoteButtonProps {
    score: i32
}

fn VoteButton(cx: Scope&lt;VoteButtonProps&gt;) -&gt; Element {
    cx.render(rsx!{
        div {
            div { &quot;+&quot; }
            div { &quot;{cx.props.score}&quot;}
            div { &quot;-&quot; }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, we can use the VoteButton Component like we would use a regular HTML element:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    dioxus::desktop::launch(App);
}

fn App(cx: Scope) -&gt; Element {
    cx.render(rsx! (
        VoteButton { score: 42 }
    ))
}
</code></pre></pre>
<p>And we can see that the Component indeed gets rendered:</p>
<p><img src="components/component_example_votes.png" alt="Screenshot of running app. Text: &quot;+ \ 42 \ -&quot;" /></p>
<blockquote>
<p>The simplest Owned Props you can have is <code>()</code> - or no value at all. This is what the <code>App</code> Component takes as props. <code>Scope</code> accepts a generic for the Props which defaults to <code>()</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this scope
Scope&lt;()&gt; 

// is the same as this scope
Scope
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<h3 id="borrowed-props"><a class="header" href="#borrowed-props">Borrowed Props</a></h3>
<p>Owning props works well if your props are easy to copy around - like a single number. But what if we need to pass a larger data type, like a String from an <code>App</code> Component to a <code>TitleCard</code> subcomponent? A naive solution might be to <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>.clone()</code></a> the String, creating a copy of it for the subcomponent ‚Äì but this would be inefficient, especially for larger Strings.</p>
<p>Rust allows for something more efficient ‚Äì borrowing the String as a <code>&amp;str</code>. Instead of creating a copy, this will give us a reference to the original String ‚Äì this is what Borrowed Props are for!</p>
<p>However, if we create a reference a String, Rust will require us to show that the String will not go away while we're using the reference. Otherwise, if we referenced something that doesn't exist, Bad Things could happen. To prevent this, Rust asks us to define a lifetime for the reference:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props)]
struct TitleCardProps&lt;'a&gt; {
    title: &amp;'a str,
}

fn TitleCard&lt;'a&gt;(cx: Scope&lt;'a, TitleCardProps&lt;'a&gt;&gt;) -&gt; Element {
    cx.render(rsx!{
        h1 { &quot;{cx.props.title}&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This lifetime <code>'a</code> tells the compiler that as long as <code>title</code> exists, the String it was created from must also exist. Dioxus will happily accept such a component ‚Äì we can now render it alongside our VoteButton!</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    // For the sake of an example, we create the &amp;str here.
    // But you might as well borrow it from an owned String type.
    let hello = &quot;Hello Dioxus!&quot;;

    cx.render(rsx! (
        VoteButton { score: 42 },
        TitleCard { title: hello }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p><img src="components/component_example_title.png" alt="New screenshot of running app, now including a &quot;Hello Dioxus!&quot; heading." /></p>
<h2 id="memoization"><a class="header" href="#memoization">Memoization</a></h2>
<p>Dioxus uses Memoization for a more efficient user interface. Memoization is the process in which we check if a component actually needs to be re-rendered when its props change. If a component's properties change but they wouldn't affect the output, then we don't need to re-render the component, saving time!</p>
<p>For example, let's say we have a component that has two children:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Demo(cx: Scope) -&gt; Element {
    // don't worry about these 2, we'll cover them later
    let name = use_state(&amp;cx, || String::from(&quot;bob&quot;));
    let age = use_state(&amp;cx, || 21);

    cx.render(rsx!{
        Name { name: name }
        Age { age: age }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>If <code>name</code> changes but <code>age</code> does not, then there is no reason to re-render our <code>Age</code> component since the contents of its props did not meaningfully change.</p>
<p>Dioxus memoizes owned components. It uses <code>PartialEq</code> to determine if a component needs rerendering, or if it has stayed the same. This is why you must derive PartialEq!</p>
<blockquote>
<p>This means you can always rely on props with <code>PartialEq</code> or no props at all to act as barriers in your app. This can be extremely useful when building larger apps where properties frequently change. By moving our state into a global state management solution, we can achieve precise, surgical re-renders, improving the performance of our app.</p>
</blockquote>
<p>Borrowed Props cannot be safely memoized. However, this is not a problem ‚Äì Dioxus relies on the memoization of their parents to determine if they need to be rerendered.</p>
<h2 id="optional-props"><a class="header" href="#optional-props">Optional Props</a></h2>
<p>You can easily create optional fields by attaching the <code>optional</code> modifier to a field:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props, PartialEq)]
struct MyProps {
    name: String,

    #[props(optional)]
    description: Option&lt;String&gt;
}

fn Demo(cx: MyProps) -&gt; Element {
    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, we can completely omit the description field when calling the component:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    Demo {
        name: &quot;Thing&quot;.to_string(),
        // description is omitted
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>optional</code> modifier is a combination of two separate modifiers: <code>default</code> and <code>strip_option</code>. The full list of modifiers includes:</p>
<ul>
<li><code>default</code> - automatically add the field using its <code>Default</code> implementation</li>
<li><code>strip_option</code> - automatically wrap values at the call site in <code>Some</code></li>
<li><code>optional</code> - alias for <code>default</code> and <code>strip_option</code></li>
<li><code>into</code> - automatically call <code>into</code> on the value at the callsite</li>
</ul>
<p>For more information on how tags work, check out the <a href="https://github.com/idanarye/rust-typed-builder">TypedBuilder</a> crate. However, all attributes for props in Dioxus are flattened (no need for <code>setter</code> syntax) and the <code>optional</code> field is new.</p>
<h2 id="the-inline_props-macro"><a class="header" href="#the-inline_props-macro">The <code>inline_props</code> macro</a></h2>
<p>So far, every Component function we've seen had a corresponding ComponentProps struct to pass in props. This was quite verbose... Wouldn't it be nice to have props as simple function arguments? Then we wouldn't need to define a Props struct, and instead of typing <code>cx.props.whatever</code>, we could just use <code>whatever</code> directly!</p>
<p><code>inline_props</code> allows you to do just that. Instead of typing the &quot;full&quot; version:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props, PartialEq)]
struct TitleCardProps {
    title: String,
}

fn TitleCard(cx: Scope&lt;TitleCardProps&gt;) -&gt; Element {
    cx.render(rsx!{
        h1 { &quot;{cx.props.title}&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>...you can define a function that accepts props as arguments. Then, just annotate it with <code>#[inline_props]</code>, and the macro will turn it into a regular Component for you:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn TitleCard(cx: Scope, title: String) -&gt; Element {
    cx.render(rsx!{
        h1 { &quot;{title}&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>While the new Component is shorter and easier to read, this macro should not be used by library authors since you have less control over Prop documentation.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reusing-importing-and-exporting-components"><a class="header" href="#reusing-importing-and-exporting-components">Reusing, Importing, and Exporting Components</a></h1>
<p>As your application grows in size, you'll want to start breaking your UI into components and, eventually, different files. This is a great idea to encapsulate functionality of your UI and scale your team.</p>
<p>In this chapter we'll cover:</p>
<ul>
<li>Rust's modules</li>
<li>Pub/Private components</li>
<li>Structure for large components</li>
</ul>
<h2 id="breaking-it-down"><a class="header" href="#breaking-it-down">Breaking it down</a></h2>
<p>Let's say our app looks something like this:</p>
<pre><code class="language-shell">‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">// main.rs
use dioxus::prelude::*;

fn main() {
    dioxus::desktop::launch(App);
}

fn App(Scope) -&gt; Element {}

#[derive(PartialEq, Props)]
struct PostProps{}
fn Post(Scope&lt;PostProps&gt;) -&gt; Element {}

#[derive(PartialEq, Props)]
struct VoteButtonsProps {}
fn VoteButtons(Scope&lt;VoteButtonsProps&gt;) -&gt; Element {}

#[derive(PartialEq, Props)]
struct TitleCardProps {}
fn TitleCard(Scope&lt;TitleCardProps&gt;) -&gt; Element {}

#[derive(PartialEq, Props)]
struct MetaCardProps {}
fn MetaCard(Scope&lt;MetaCardProps&gt;) -&gt; Element {}

#[derive(PartialEq, Props)]
struct ActionCardProps {}
fn ActionCard(Scope&lt;ActionCardProps&gt;) -&gt; Element {}
</code></pre></pre>
<p>That's a lot of components for one file! We've successfully refactored our app into components, but we should probably start breaking it up into a file for each component.</p>
<h2 id="breaking-into-different-files"><a class="header" href="#breaking-into-different-files">Breaking into different files</a></h2>
<p>Fortunately, Rust has a built-in module system that's much cleaner than what you might be used to in JavaScript. Because <code>VoteButtons</code>, <code>TitleCard</code>, <code>MetaCard</code>, and <code>ActionCard</code> all belong to the <code>Post</code> component, let's put them all in a folder together called &quot;post&quot;. We'll make a file for each component and move the props and render function.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/action.rs

use dioxus::prelude::*;

#[derive(PartialEq, Props)]
struct ActionCardProps {}
fn ActionCard(Scope&lt;ActionCardProps&gt;) -&gt; Element {}
<span class="boring">}
</span></code></pre></pre>
<p>We should also create a <code>mod.rs</code> file in the <code>post</code> folder so we can use it from our <code>main.rs</code>. Our <code>Post</code> component and its props will go into this file.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/mod.rs

use dioxus::prelude::*;

#[derive(PartialEq, Props)]
struct PostProps {}
fn Post(Scope&lt;PostProps&gt;) -&gt; Element {}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-shell">‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ main.rs
    ‚îî‚îÄ‚îÄ post
        ‚îú‚îÄ‚îÄ vote.rs
        ‚îú‚îÄ‚îÄ title.rs
        ‚îú‚îÄ‚îÄ meta.rs
        ‚îú‚îÄ‚îÄ action.rs
        ‚îî‚îÄ‚îÄ mod.rs
</code></pre>
<p>In our <code>main.rs</code>, we'll want to declare the <code>post</code> module so we can access our <code>Post</code> component.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// main.rs
use dioxus::prelude::*;

fn main() {
    dioxus::desktop::launch(App);
}

mod post;

fn App(Scope) -&gt; Element {
    cx.render(rsx!{
        post::Post {
            id: Uuid::new_v4(),
            score: 10,
            comment_count: 10,
            post_time: std::Instant::now(),
            url: &quot;example&quot;.to_string(),
            title: &quot;Title&quot;.to_string(),
            original_poster: &quot;me&quot;.to_string()
        }
    })
}
</code></pre></pre>
<p>If you tried to build this app right now, you'll get an error message saying that <code>Post is private, try changing it to public</code>. This is because we haven't properly exported our component! To fix this, we need to make sure both the Props and Component are declared as &quot;public&quot;:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/mod.rs

use dioxus::prelude::*;

#[derive(PartialEq, Props)]
pub struct PostProps {}
pub fn Post(Scope&lt;PostProps&gt;) -&gt; Element {}
<span class="boring">}
</span></code></pre></pre>
<p>While we're here, we also need to make sure each of our subcomponents are included as modules and exported.</p>
<p>Our &quot;post/mod.rs&quot; file will eventually look like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dioxus::prelude::*;

mod vote;
mod title;
mod meta;
mod action;

#[derive(Props, PartialEq)]
pub struct PostProps {
    id: uuid::Uuid,
    score: i32,
    comment_count: u32,
    post_time: std::time::Instant,
    url: String,
    title: String,
    original_poster: String
}

pub fn Post(Scope&lt;PostProps&gt;) -&gt; Element {
    cx.render(rsx!{
        div { class: &quot;post-container&quot;
            vote::VoteButtons {
                score: props.score,
            }
            title::TitleCard {
                title: props.title,
                url: props.url,
            }
            meta::MetaCard {
                original_poster: props.original_poster,
                post_time: props.post_time,
            }
            action::ActionCard {
                post_id: props.id
            }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Ultimately, including and exporting components is governed by Rust's module system. <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">The Rust book is a great resource to learn about these concepts in greater detail.</a></p>
<h2 id="final-structure"><a class="header" href="#final-structure">Final structure:</a></h2>
<pre><code class="language-shell">‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ main.rs
    ‚îî‚îÄ‚îÄ post
        ‚îú‚îÄ‚îÄ vote.rs
        ‚îú‚îÄ‚îÄ title.rs
        ‚îú‚îÄ‚îÄ meta.rs
        ‚îú‚îÄ‚îÄ action.rs
        ‚îî‚îÄ‚îÄ mod.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust edition2018">// main.rs:
use dioxus::prelude::*;

fn main() {
    dioxus::desktop::launch(App);
}

mod post;

fn App(Scope) -&gt; Element {
    cx.render(rsx!{
        post::Post {
            id: Uuid::new_v4(),
            score: 10,
            comment_count: 10,
            post_time: std::Instant::now(),
            url: &quot;example&quot;.to_string(),
            title: &quot;Title&quot;.to_string(),
            original_poster: &quot;me&quot;.to_string()
        }
    })
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/mod.rs
use dioxus::prelude::*;

mod vote;
mod title;
mod meta;
mod action;

#[derive(Props, PartialEq)]
pub struct PostProps {
    id: uuid::Uuid,
    score: i32,
    comment_count: u32,
    post_time: std::time::Instant,
    url: String,
    title: String,
    original_poster: String
}

pub fn Post(Scope&lt;PostProps&gt;) -&gt; Element {
    cx.render(rsx!{
        div { class: &quot;post-container&quot;
            vote::VoteButtons {
                score: props.score,
            }
            title::TitleCard {
                title: props.title,
                url: props.url,
            }
            meta::MetaCard {
                original_poster: props.original_poster,
                post_time: props.post_time,
            }
            action::ActionCard {
                post_id: props.id
            }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/vote.rs
use dioxus::prelude::*;

#[derive(PartialEq, Props)]
pub struct VoteButtonsProps {}
pub fn VoteButtons(Scope&lt;VoteButtonsProps&gt;) -&gt; Element {}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/title.rs
use dioxus::prelude::*;

#[derive(PartialEq, Props)]
pub struct TitleCardProps {}
pub fn TitleCard(Scope&lt;TitleCardProps&gt;) -&gt; Element {}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/meta.rs
use dioxus::prelude::*;

#[derive(PartialEq, Props)]
pub struct MetaCardProps {}
pub fn MetaCard(Scope&lt;MetaCardProps&gt;) -&gt; Element {}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/post/action.rs
use dioxus::prelude::*;

#[derive(PartialEq, Props)]
pub struct ActionCardProps {}
pub fn ActionCard(Scope&lt;ActionCardProps&gt;) -&gt; Element {}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="passing-children-and-attributes"><a class="header" href="#passing-children-and-attributes">Passing children and attributes</a></h1>
<p>Often times, you'll want to wrap some important functionality <em>around</em> your state, not directly nested <em>inside</em> another component. In these cases, you'll want to pass elements and attributes into a component and let the component place them appropriately.</p>
<p>In this chapter, you'll learn about:</p>
<ul>
<li>Passing elements into components</li>
<li>Passing attributes into components</li>
</ul>
<h2 id="the-use-case"><a class="header" href="#the-use-case">The use case</a></h2>
<p>Let's say you're building a user interface and want to make some part of it a clickable link to another website. You would normally start with the HTML <code>&lt;a&gt;</code> tag, like so:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    a {
        href: &quot;https://google.com&quot;
        &quot;Link to google&quot;
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>But, what if we wanted to style our <code>&lt;a&gt;</code> tag? Or wrap it with some helper icon? We could abstract our RSX into its own component:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props)]
struct ClickableProps&lt;'a&gt; {
    href: &amp;'a str,
    title: &amp;'a str
}

fn Clickable&lt;'a&gt;(cx: Scope&lt;'a, ClickableProps&lt;'a&gt;&gt;) -&gt; Element {
    cx.render(rsx!(
        a {
            href: &quot;{cx.props.href}&quot;
            &quot;{cx.props.title}&quot;
        }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>And then use it in our code like so:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    Clickable {
        href: &quot;https://google.com&quot;
        title: &quot;Link to Google&quot;
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>Let's say we don't just want the text to be clickable, but we want another element, like an image, to be clickable. How do we implement that?</p>
<h2 id="passing-children"><a class="header" href="#passing-children">Passing children</a></h2>
<p>If we want to pass an image into our component, we can just adjust our props and component to allow any <code>Element</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props)]
struct ClickableProps&lt;'a&gt; {
    href: &amp;'a str,
    body: Element&lt;'a&gt;
}

fn Clickable&lt;'a&gt;(cx: Scope&lt;'a, ClickableProps&lt;'a&gt;&gt;) -&gt; Element {
    cx.render(rsx!(
        a {
            href: &quot;{cx.props.href}&quot;,
            &amp;cx.props.body
        }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, at the call site, we can render some nodes and pass them in:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    Clickable {
        href: &quot;https://google.com&quot;
        body: cx.render(rsx!(
            img { src: &quot;https://www.google.com/logos/doodles/...&quot; }
        ))
    }
)
<span class="boring">}
</span></code></pre></pre>
<h2 id="auto-conversion-of-the-children-field"><a class="header" href="#auto-conversion-of-the-children-field">Auto Conversion of the <code>Children</code> field</a></h2>
<p>This pattern can become tedious in some instances, so Dioxus actually performs an implicit conversion of any <code>rsx</code> calls inside components into <code>Elements</code> at the <code>children</code> field. This means you must explicitly declare if a component can take children.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props)]
struct ClickableProps&lt;'a&gt; {
    href: &amp;'a str,
    children: Element&lt;'a&gt;
}

fn Clickable&lt;'a&gt;(cx: Scope&lt;'a, ClickableProps&lt;'a&gt;&gt;) -&gt; Element {
    cx.render(rsx!(
        a {
            href: &quot;{cx.props.href}&quot;,
            &amp;cx.props.children
        }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, whenever we use <code>Clickable</code> in another component, we don't need to call <code>render</code> on child nodes - it will happen automatically!</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    Clickable {
        href: &quot;https://google.com&quot;
        img { src: &quot;https://www.google.com/logos/doodles/....&quot; }
    }
)
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: Passing children into components will break any memoization due to the associated lifetime.</p>
</blockquote>
<p>While technically allowed, it's an antipattern to pass children more than once in a component and will probably cause your app to crash.</p>
<p>However, because the <code>Element</code> is transparently a <code>VNode</code>, we can actually match on it to extract the nodes themselves, in case we are expecting a specific format:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn clickable&lt;'a&gt;(cx: Scope&lt;'a, ClickableProps&lt;'a&gt;&gt;) -&gt; Element {
    match cx.props.children {
        Some(VNode::Text(text)) =&gt; {
            // ...
        }
        _ =&gt; {
            // ...
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Passing nodes through props means that they are immutable. If you find yourself needing to mutate nodes passed through props, consider creating a new node in its place that takes on its attributes, children, and listeners.</p>
<!-- ## Passing attributes

In the cases where you need to pass arbitrary element properties into a component - say to add more functionality to the `<a>` tag, Dioxus will accept any quoted fields. This is similar to adding arbitrary fields to regular elements using quotes.

```rust

rsx!(
    Clickable {
        "class": "blue-button",
        "style": "background: red;"
    }
)

```

For a component to accept these attributes, you must add an `attributes` field to your component's properties. We can use the spread syntax to add these attributes to whatever nodes are in our component.

```rust
#[derive(Props)]
struct ClickableProps<'a> {
    attributes: Attributes<'a>
}

fn clickable(cx: Scope<ClickableProps<'a>>) -> Element {
    cx.render(rsx!(
        a {
            ..cx.props.attributes,
            "Any link, anywhere"
        }
    ))
}
```

The quoted escapes are a great way to make your components more flexible.
 -->
<h2 id="passing-handlers"><a class="header" href="#passing-handlers">Passing handlers</a></h2>
<p>Dioxus also provides some implicit conversions from listener attributes into an <code>EventHandler</code> for any field on components that starts with <code>on</code>. IE <code>onclick</code>, <code>onhover</code>, etc. For properties, we want to define our <code>on</code> fields as an event handler:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Props)]
struct ClickableProps&lt;'a&gt; {
    onclick: EventHandler&lt;'a, MouseEvent&gt;
}

fn clickable&lt;'a&gt;(cx: Scope&lt;'a, ClickableProps&lt;'a&gt;&gt;) -&gt; Element {
    cx.render(rsx!(
        a {
            onclick: move |evt| cx.props.onclick.call(evt)
        }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, we can attach a listener at the call site:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!(
    Clickable {
        onclick: move |_| log::info!(&quot;Clicked&quot;),
    }
)
<span class="boring">}
</span></code></pre></pre>
<p>Currently, Dioxus does not support an arbitrary amount of listeners - they must be strongly typed in <code>Properties</code>. If you need this use case, you can pass in an element with these listeners, or dip down into the <code>NodeFactory</code> API.</p>
<h2 id="wrapping-up-1"><a class="header" href="#wrapping-up-1">Wrapping up</a></h2>
<p>In this chapter, we learned:</p>
<ul>
<li>How to pass arbitrary nodes through the tree</li>
<li>How the <code>children</code> field works on component properties</li>
<li>How the <code>attributes</code> field works on component properties</li>
<li>How to convert <code>listeners</code> into <code>EventHandlers</code> for components</li>
<li>How to extend any node with custom attributes and children</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thinking-in-reactively"><a class="header" href="#thinking-in-reactively">Thinking in Reactively</a></h1>
<p>We've finally reached the point in our tutorial where we can talk about the theory of Reactivity. We've talked about defining a declarative view, but not about the aspects that make our code <em>reactive</em>.</p>
<p>Understanding the theory of reactive programming is essential to making sense of Dioxus and writing effective, performant UIs.</p>
<p>In this section, we'll talk about:</p>
<ul>
<li>One-way data flow</li>
<li>Modifying data</li>
<li>Forcing renders</li>
<li>How renders propagate</li>
</ul>
<p>This section is a bit long, but worth the read. We recommend coffee, tea, and/or snacks.</p>
<h2 id="reactive-programming"><a class="header" href="#reactive-programming">Reactive Programming</a></h2>
<p>Dioxus is one of a handful of Rust libraries that provide a &quot;Reactive Programming Model&quot;. The term &quot;Reactive programming&quot; is a classification of programming paradigm - much like functional or imperative programming. This is a very important distinction since it affects how we <em>think</em> about our code.</p>
<p>Reactive programming is a programming model concerned with deriving computations from asynchronous data flow. Most reactive programs are comprised of datasources, intermediate computations, and a final result.</p>
<p>We consider the rendered GUI to be the final result of our Dioxus apps. The datasources for our apps include local and global state.</p>
<p>For example, the model presented in the figure below is comprised of two data sources: time and a constant. These values are passed through our computation graph to achieve a final result: <code>g</code>.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Reactive_programming_glitches.svg/440px-Reactive_programming_glitches.svg.png" alt="Reactive Model" /></p>
<p>Whenever our <code>seconds</code> variable changes, we will then reevaluate the computation for <code>t</code>. Because <code>g</code> relies on <code>t</code>, we will also reevaluate its computation too. Notice that we would've reevaluated the computation for <code>g</code> even if <code>t</code> didn't change because <code>seconds</code> is used to calculate <code>g</code>.</p>
<p>However, if we somehow changed our constant from <code>1</code> to <code>2</code>, then we need to reevaluate <code>t</code>. If, for whatever reason, this change did not affect the result of <code>t</code>, then we wouldn't try to reevaluate <code>g</code>.</p>
<p>In Reactive Programming, we don't think about whether or not we should reevaluate <code>t</code> or <code>g</code>; instead, we simply provide functions of computation and let the framework figure out the rest for us.</p>
<p>In Rust, our reactive app would look something like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute_g(t: i32, seconds: i32) -&gt; bool {
    t &gt; seconds
}

fn compute_t(constant: i32, seconds: i32) -&gt; i32 {
    constant + seconds
}

fn compute_graph(constant: i32, seconds: i32) -&gt; bool {
    let t = compute_t(constant, seconds);
    let g = compute_g(t, seconds);
    g
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="how-is-dioxus-reactive"><a class="header" href="#how-is-dioxus-reactive">How is Dioxus Reactive?</a></h2>
<p>The Dioxus VirtualDom provides us a framework for reactive programming. When we build apps with dioxus, we need to provide our own datasources. This can be either initial props or some values fetched from the network. We then pass this data through our app into components through properties.</p>
<p>If we represented the reactive graph presented above in Dioxus, it would look very similar:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Declare a component that holds our datasources and calculates `g`
fn RenderGraph(cx: Scope) -&gt; Element {
    let seconds = use_datasource(SECONDS);
    let constant = use_state(&amp;cx, || 1);

    cx.render(rsx!(
        RenderG { seconds: seconds }
        RenderT { seconds: seconds, constant: constant }
    ))
}

// &quot;calculate&quot; g by rendering `t` and `seconds`
#[inline_props]
fn RenderG(cx: Scope, seconds: i32) -&gt; Element {
    cx.render(rsx!{ &quot;There are {seconds} seconds remaining...&quot; })
}

// calculate and render `t` in its own component
#[inline_props]
fn RenderT(cx: Scope, seconds: i32, constant: i32) -&gt; Element {
    let res = seconds + constant;
    cx.render(rsx!{ &quot;{res}&quot; })
}
<span class="boring">}
</span></code></pre></pre>
<p>With this app, we've defined three components. Our top-level component provides our datasources (the hooks), computation nodes (child components), and a final value (what's &quot;rendered&quot;).</p>
<p>Now, whenever the <code>constant</code> changes, our <code>RenderT</code> component will be re-rendered. However, if <code>seconds</code> doesn't change, then we don't need to re-render <code>RenderG</code> because the input is the same. If <code>seconds</code> <em>does</em> change, then both RenderG and RenderT will be reevaluated.</p>
<p>Dioxus is &quot;Reactive&quot; because it provides this framework for us. All we need to do is write our own tiny units of computation and Dioxus figures out which components need to be reevaluated automatically.</p>
<p>These extra checks and algorithms add some overhead, which is why you see projects like <a href="http://sycamore-rs.netlify.app">Sycamore</a> and <a href="http://solidjs.com">SolidJS</a> eliminating them altogether. Dioxus is <em>really</em> fast, so we're willing to exchange the added overhead for improved developer experience.</p>
<h2 id="how-do-we-update-values-in-our-dataflow-graph"><a class="header" href="#how-do-we-update-values-in-our-dataflow-graph">How do we update values in our dataflow graph?</a></h2>
<p>Dioxus will automatically figure out how to regenerate parts of our app when datasources change. But how exactly can we update our data sources?</p>
<p>In Dioxus there are two datasources:</p>
<ol>
<li>Local state in <code>use_hook</code> and all other hooks</li>
<li>Global state through <code>provide_context</code>.</li>
</ol>
<p>Technically, the root props of the VirtualDom are a third datasource, but since we cannot modify them, they are not worth talking about.</p>
<h3 id="local-state"><a class="header" href="#local-state">Local State</a></h3>
<p>For local state in hooks, Dioxus gives us the <code>use_hook</code> method which returns an <code>&amp;mut T</code> without any requirements. This means raw hook values are not tracked by Dioxus. In fact, we could write a component that modifies a hook value directly:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let mut count = cx.use_hook(|_| 0);
    cx.render(rsx!{
        button {
            onclick: move |_| *count += 1,
            &quot;Count: {count}&quot;
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>However, when this value is written to, the component does not know to be reevaluated. We must explicitly tell Dioxus that this component is &quot;dirty&quot; and needs to be re-rendered. This is done through the <code>cx.needs_update</code> method:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>button {
    onclick: move |_| {
        *count += 1;
        cx.needs_update();
    },
    &quot;Count: {count}&quot;
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, whenever we click the button, the value will change and the component will be re-rendered.</p>
<blockquote>
<p>Re-rendering is when Dioxus calls your function component <em>again</em>. Component functions will be called over and over throughout their lifetime, so they should be mostly side-effect free.</p>
</blockquote>
<h3 id="understand-this"><a class="header" href="#understand-this">Understand this!</a></h3>
<p>Your component functions will be called (&quot;rendered&quot; in our lingo) for as long as the component is present in the tree.</p>
<p>A single component will be called multiple times, modifying its own internal state or rendering new nodes with new values from its properties.</p>
<h3 id="app-global-state"><a class="header" href="#app-global-state">App-Global State</a></h3>
<p>With the <code>provide_context</code> and <code>consume_context</code> methods on <code>Scope</code>, we can share values to descendants without having to pass values through component props. This has the side-effect of making our datasources less obvious from a high-level perspective, but it makes our components more modular within the same codebase.</p>
<p>To make app-global state easier to reason about, Dioxus makes all values provided through <code>provide_context</code> immutable. This means any library built on top of <code>provide_context</code> needs to use interior mutability to modify shared global state.</p>
<p>In these cases, App-Global state needs to manually track which components need to be re-generated.</p>
<p>To regenerate <em>any</em> component in your app, you can get a handle to the Dioxus' internal scheduler through <code>schedule_update_any</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let force_render = cx.schedule_update_any();

// force a render of the root component
force_render(ScopeId(0));
<span class="boring">}
</span></code></pre></pre>
<h2 id="what-does-it-mean-for-a-component-to-re-render"><a class="header" href="#what-does-it-mean-for-a-component-to-re-render">What does it mean for a component to &quot;re-render&quot;?</a></h2>
<p>In our guides, we frequently use the phrase &quot;re-render&quot; to describe updates to our app. You'll often hear this paired with &quot;preventing unnecessary re-renders.&quot; But what exactly does this mean?</p>
<p>When we call <code>dioxus::desktop::launch</code>, Dioxus will create a new <code>Scope</code> object and call the component we gave it. Our <code>rsx!</code> calls will create new nodes which we return back to the VirtualDom. Dioxus will then look through these nodes for child components, call their functions, and so on until every component has been &quot;rendered.&quot; We consider these nodes &quot;rendered&quot; because they were created because of our explicit actions.</p>
<p>The tree of UI that dioxus creates will roughly look like the tree of components presented earlier:</p>
<p><img src="components/../images/component_tree.png" alt="Tree of UI" /></p>
<p>But what happens when we call <code>needs_update</code> after modifying some important state? Well, if Dioxus called our component's function again, then we would produce new, different nodes. In fact, this is exactly what Dioxus does!</p>
<p>At this point, we have some old nodes and some new nodes. Again, we call this &quot;rendering&quot; because Dioxus had to create new nodes because of our explicit actions. Any time new nodes get created, our VirtualDom is being &quot;rendered.&quot;</p>
<p>These nodes are stored in an extremely efficient memory allocator called a &quot;bump arena.&quot; For example, a div with a handler and attribute would be stored in memory in two locations: the &quot;old&quot; tree and the &quot;new&quot; tree.</p>
<p><img src="components/../images/oldnew.png" alt="Bump Arenas" /></p>
<p>From here, Dioxus computes the difference between these trees and updates the Real DOM to make it look like the new version of what we've declared.</p>
<p><img src="components/../images/diffing.png" alt="Diffing" /></p>
<h2 id="suppressing-renders"><a class="header" href="#suppressing-renders">Suppressing Renders</a></h2>
<p>So, we know how to make Dioxus render, but how do we <em>stop</em> it? What if we <em>know</em> that our state didn't change and we shouldn't render and diff new nodes because they'll be exactly the same as the last time?</p>
<p>In these cases, you want to reach for <em>memoization</em>. In Dioxus, memoization involves preventing a component from rendering again if its props didn't change since the last time it attempted to render.</p>
<p>Visually, you can tell that a component will only re-render if the new value is sufficiently different than the old one.</p>
<table><thead><tr><th>props.val</th><th>re-render</th></tr></thead><tbody>
<tr><td>10</td><td>true</td></tr>
<tr><td>20</td><td>true</td></tr>
<tr><td>20</td><td>false</td></tr>
<tr><td>20</td><td>false</td></tr>
<tr><td>10</td><td>true</td></tr>
<tr><td>30</td><td>false</td></tr>
</tbody></table>
<p>This is why when you <code>derive(Props)</code>, you must also implement the <code>PartialEq</code> trait. To override the memoization strategy for a component, you can simply implement your own PartialEq.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CustomProps {
    val: i32,
}

impl PartialEq for CustomProps {
    fn partial_eq(&amp;self, other: &amp;Self) -&gt; bool {
        // we don't render components that have a val less than 5
        if other.val &gt; 5 &amp;&amp; self.val &gt; 5{
            self.val == other.val
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However, for components that borrow data, it doesn't make sense to implement PartialEq since the actual references in memory might be different.</p>
<p>You can technically override this behavior by implementing the <code>Props</code> trait manually, though it's unsafe and easy to mess up:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe impl Properties for CustomProps {
    fn memoize(&amp;self, other &amp;Self) -&gt; bool {
        self != other
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>TLDR:</p>
<ul>
<li>Dioxus checks if props changed between renders</li>
<li>If props changed according to PartialEq, Dioxus re-renders the component</li>
<li>Props that have a lifetime (ie <code>&lt;'a&gt;</code>) will always be re-rendered</li>
</ul>
<h2 id="wrapping-up-2"><a class="header" href="#wrapping-up-2">Wrapping Up</a></h2>
<p>Wow, that was a lot of material!</p>
<p>Let's see if we can recap what was presented:</p>
<ul>
<li>Reactive programming calculates a final value from datasources and computation</li>
<li>Dioxus is &quot;reactive&quot; since it figures out which computations to check</li>
<li><code>schedule_update</code> must be called to mark a component as dirty</li>
<li>dirty components will be re-rendered (called multiple times) to produce a new UI</li>
<li>Renders can be suppressed with memoization</li>
</ul>
<p>This theory is crucial to understand how to compose components and how to control renders in your app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-interactivity"><a class="header" href="#adding-interactivity">Adding Interactivity</a></h1>
<p>So far, we've learned how to describe the structure and properties of our user interfaces. Unfortunately, they're static and quite uninteresting. In this chapter, we're going to learn how to add interactivity through events, state, and tasks.</p>
<h2 id="primer-on-interactivity"><a class="header" href="#primer-on-interactivity">Primer on interactivity</a></h2>
<p>Before we get too deep into the mechanics of interactivity, we should first understand how Dioxus exactly chooses to handle user interaction and updates to your app.</p>
<h3 id="what-is-state"><a class="header" href="#what-is-state">What is state?</a></h3>
<p>Every app you'll ever build has some sort of information that needs to be rendered to the screen. Dioxus is responsible for translating your desired user interface to what is rendered to the screen. <em>You</em> are responsible for providing the content.</p>
<p>The dynamic data in your user interface is called <code>State</code>.</p>
<p>When you first launch your app with <code>dioxus::web::launch_with_props</code> you'll be providing the initial state. You need to declare the initial state <em>before</em> starting the app.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    // declare our initial state
    let props = PostProps {
        id: Uuid::new_v4(),
        score: 10,
        comment_count: 0,
        post_time: std::time::Instant::now(),
        url: String::from(&quot;dioxuslabs.com&quot;),
        title: String::from(&quot;Hello, world&quot;),
        original_poster: String::from(&quot;dioxus&quot;)
    };

    // start the render loop
    dioxus::desktop::launch_with_props(Post, props);
}
</code></pre></pre>
<p>When Dioxus renders your app, it will pass an immutable reference to <code>PostProps</code> into your <code>Post</code> component. Here, you can pass the state down into children.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope&lt;PostProps&gt;) -&gt; Element {
    cx.render(rsx!{
        Title { title: &amp;cx.props.title }
        Score { score: &amp;cx.props.score }
        // etc
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>State in Dioxus follows a pattern called &quot;one-way data-flow.&quot; As your components create new components as their children, your app's structure will eventually grow into a tree where state gets passed down from the root component into &quot;leaves&quot; of the tree.</p>
<p>You've probably seen the tree of UI components represented using a directed acyclic graph:</p>
<p><img src="interactivity/../images/component_tree.png" alt="image" /></p>
<p>With Dioxus, your state will always flow down from parent components into child components.</p>
<h3 id="how-do-i-change-my-apps-state"><a class="header" href="#how-do-i-change-my-apps-state">How do I change my app's state?</a></h3>
<p>We've talked about the data flow of state, but we haven't yet talked about how to change that state dynamically. Dioxus provides a variety of ways to change the state of your app while it's running.</p>
<p>For starters, we <em>could</em> use the <code>update_root_props</code> method on the VirtualDom to provide an entirely new root state of your App. However, for most applications, you probably don't want to regenerate your entire app just to update some text or a flag.</p>
<p>Instead, you'll want to store state internally in your components and let <em>that</em> flow down the tree. To store state in your components, you'll use something called a <code>hook</code>. Hooks are special functions that reserve a slot of state in your component's memory and provide some functionality to update that state.</p>
<p>The most common hook you'll use for storing state is <code>use_state</code>. <code>use_state</code> provides a slot for some data that allows you to read and update the value without accidentally mutating it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope)-&gt; Element {
    let (post, set_post) = use_state(&amp;cx, || {
        PostData {
            id: Uuid::new_v4(),
            score: 10,
            comment_count: 0,
            post_time: std::time::Instant::now(),
            url: String::from(&quot;dioxuslabs.com&quot;),
            title: String::from(&quot;Hello, world&quot;),
            original_poster: String::from(&quot;dioxus&quot;)
        }
    });

    cx.render(rsx!{
        Title { title: &amp;post.title }
        Score { score: &amp;post.score }
        // etc
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Whenever we have a new post that we want to render, we can call <code>set_post</code> and provide a new value:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_post(PostData {
    id: Uuid::new_v4(),
    score: 20,
    comment_count: 0,
    post_time: std::time::Instant::now(),
    url: String::from(&quot;google.com&quot;),
    title: String::from(&quot;goodbye, world&quot;),
    original_poster: String::from(&quot;google&quot;)
})
<span class="boring">}
</span></code></pre></pre>
<p>We'll dive deeper into how exactly these hooks work later.</p>
<h3 id="when-do-i-update-my-state"><a class="header" href="#when-do-i-update-my-state">When do I update my state?</a></h3>
<p>There are a few different approaches to choosing when to update your state. You can update your state in response to user-triggered events or asynchronously in some background task.</p>
<h3 id="updating-state-in-listeners"><a class="header" href="#updating-state-in-listeners">Updating state in listeners</a></h3>
<p>When responding to user-triggered events, we'll want to &quot;listen&quot; for an event on some element in our component.</p>
<p>For example, let's say we provide a button to generate a new post. Whenever the user clicks the button, they get a new post. To achieve this functionality, we'll want to attach a function to the <code>onclick</code> method of <code>button</code>. Whenever the button is clicked, our function will run, and we'll get new Post data to work with.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope)-&gt; Element {
    let (post, set_post) = use_state(&amp;cx, || PostData::new());

    cx.render(rsx!{
        button {
            onclick: move |_| set_post(PostData::random())
            &quot;Generate a random post&quot;
        }
        Post { props: &amp;post }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>We'll dive much deeper into event listeners later.</p>
<h3 id="updating-state-asynchronously"><a class="header" href="#updating-state-asynchronously">Updating state asynchronously</a></h3>
<p>We can also update our state outside of event listeners with <code>futures</code> and <code>coroutines</code>.</p>
<ul>
<li><code>Futures</code> are Rust's version of promises that can execute asynchronous work by an efficient polling system. We can submit new futures to Dioxus either through <code>push_future</code> which returns a <code>TaskId</code> or with <code>spawn</code>.</li>
<li><code>Coroutines</code> are asynchronous blocks of our component that have the ability to cleanly interact with values, hooks, and other data in the component.</li>
</ul>
<p>Since coroutines and Futures stick around between renders, the data in them must be valid for the <code>'static</code> lifetime. We must explicitly declare which values our task will rely on to avoid the <code>stale props</code> problem common in React.</p>
<p>We can use tasks in our components to build a tiny stopwatch that ticks every second.</p>
<blockquote>
<p>Note: The <code>use_future</code> hook will start our coroutine immediately. The <code>use_coroutine</code> hook provides more flexibility over starting and stopping futures on the fly.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope)-&gt; Element {
    let (elapsed, set_elapsed) = use_state(&amp;cx, || 0);

    use_future(&amp;cx, || {
        to_owned![set_elapsed]; // explicitly capture this hook for use in async
        async move {
            loop {
                TimeoutFuture::from_ms(1000).await;
                set_elapsed.modify(|i| i + 1)
            }
        }
    });

    rsx!(cx, div { &quot;Current stopwatch time: {sec_elapsed}&quot; })
}
<span class="boring">}
</span></code></pre></pre>
<p>Using asynchronous code can be difficult! This is just scratching the surface of what's possible. We have an entire chapter on using async properly in your Dioxus Apps. We have an entire section dedicated to using <code>async</code> properly later in this book.</p>
<h3 id="how-do-i-tell-dioxus-that-my-state-changed"><a class="header" href="#how-do-i-tell-dioxus-that-my-state-changed">How do I tell Dioxus that my state changed?</a></h3>
<p>Whenever you inform Dioxus that the component needs to be updated, it will &quot;render&quot; your component again, storing the previous and current Elements in memory. Dioxus will automatically figure out the differences between the old and the new and generate a list of edits that the renderer needs to apply to change what's on the screen. This process is called &quot;diffing&quot;:</p>
<p><img src="interactivity/../images/diffing.png" alt="Diffing" /></p>
<p>In React, the specifics of when a component gets re-rendered is somewhat blurry. With Dioxus, any component can mark itself as &quot;dirty&quot; through a method on <code>Context</code>: <code>needs_update</code>. In addition, any component can mark any <em>other</em> component as dirty provided it knows the other component's ID with <code>needs_update_any</code>.</p>
<p>With these building blocks, we can craft new hooks similar to <code>use_state</code> that let us easily tell Dioxus that new information is ready to be sent to the screen.</p>
<h3 id="how-do-i-update-my-state-efficiently"><a class="header" href="#how-do-i-update-my-state-efficiently">How do I update my state efficiently?</a></h3>
<p>In general, Dioxus should be plenty fast for most use cases. However, there are some rules you should consider following to ensure your apps are quick.</p>
<ul>
<li>
<ol>
<li><strong>Don't call set_state <em>while rendering</em></strong>. This will cause Dioxus to unnecessarily re-check the component for updates or enter an infinite loop.</li>
</ol>
</li>
<li>
<ol start="2">
<li><strong>Break your state apart into smaller sections.</strong> Hooks are explicitly designed to &quot;unshackle&quot; your state from the typical model-view-controller paradigm, making it easy to reuse useful bits of code with a single function.</li>
</ol>
</li>
<li>
<ol start="3">
<li><strong>Move local state down</strong>. Dioxus will need to re-check child components of your app if the root component is constantly being updated. You'll get best results if rapidly-changing state does not cause major re-renders.</li>
</ol>
</li>
</ul>
<!-- todo: link when the section exists
Don't worry - Dioxus is fast. But, if your app needs *extreme performance*, then take a look at the `Performance Tuning` in the `Advanced Guides` book.
-->
<h2 id="the-scope-object"><a class="header" href="#the-scope-object">The <code>Scope</code> object</a></h2>
<p>Though very similar to React, Dioxus is different in a few ways. Most notably, React components will not have a <code>Scope</code> parameter in the component declaration.</p>
<p>Have you ever wondered how the <code>useState()</code> call works in React without a <code>this</code> object to actually store the state?</p>
<pre><code class="language-javascript">// in React:
function Component(props) {
    // This state persists between component renders, but where does it live?
    let [state, set_state] = useState(10);
}
</code></pre>
<p>React uses global variables to store this information. However, global mutable variables must be carefully managed and are broadly discouraged in Rust programs. Because Dioxus needs to work with the rules of Rust it uses the <code>Scope</code> rather than a global state object to maintain some internal bookkeeping.</p>
<p>That's what the <code>Scope</code> object is: a place for the Component to store state, manage listeners, and allocate elements. Advanced users of Dioxus will want to learn how to properly leverage the <code>Scope</code> object to build robust and performant extensions for Dioxus.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Post(cx: Scope&lt;PostProps&gt;) -&gt; Element {
    cx.render(rsx!(&quot;hello&quot;))
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="moving-on-3"><a class="header" href="#moving-on-3">Moving On</a></h2>
<p>This overview was a lot of information - but it doesn't tell you everything!</p>
<p>In the next sections we'll go over:</p>
<ul>
<li><code>use_state</code> in depth</li>
<li><code>use_ref</code> and other hooks</li>
<li>Handling user input</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handlers"><a class="header" href="#event-handlers">Event handlers</a></h1>
<p>To make our boring UIs less static and more interesting, we want to add the ability to interact to user input. To do this, we need to add some event handlers.</p>
<h2 id="the-most-basic-events-clicks"><a class="header" href="#the-most-basic-events-clicks">The most basic events: clicks</a></h2>
<p>If you've poked around in the Dioxus examples at all, you've definitely noticed the support for buttons and clicks. To add some basic action when a button is clicked, we need to define a button and then attach an &quot;onclick&quot; handler to it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    cx.render(rsx!{
        button {
            onclick: move |evt| println!(&quot;I've been clicked!&quot;),
            &quot;click me!&quot;
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>If you're using the builder pattern, it's pretty simple too. <code>onclick</code> is a method for any builder with HTML elements.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    button(&amp;cx)
        .onclick(move |evt| println!(&quot;I've been clicked!&quot;))
        .text(&quot;click me!&quot;)
        .build()
}
<span class="boring">}
</span></code></pre></pre>
<p>The event handler is different in Dioxus than other libraries. Event handlers in Dioxus may borrow any data that has a lifetime that matches the component's scope. This means we can save a value with <code>use_hook</code> and then use it in our handler.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let val = cx.use_hook(|_| 10);

    button(&amp;cx)
        .onclick(move |evt| println!(&quot;Current number {val}&quot;))
        .text(&quot;click me!&quot;)
        .build()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-event-object"><a class="header" href="#the-event-object">The <code>Event</code> object</a></h2>
<p>When the listener is fired, Dioxus will pass in any related data through the <code>event</code> parameter. This holds helpful state relevant to the event. For instance, on forms, Dioxus will fill in the &quot;values&quot; field.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// the FormEvent is roughly
struct FormEvent {
    value: String,
    values: HashMap&lt;String, String&gt;
}

fn app(cx: Scope) -&gt; Element {
    cx.render(rsx!{
        form {
            onsubmit: move |evt| {
                println!(&quot;Values of form are {evt.values:#?}&quot;);
            }
            input { id: &quot;password&quot;, name: &quot;password&quot; }
            input { id: &quot;username&quot;, name: &quot;username&quot; }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="stopping-propagation"><a class="header" href="#stopping-propagation">Stopping propagation</a></h2>
<p>With a complex enough UI, you might realize that listeners can actually be nested.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div {
    onclick: move |evt| {},
    &quot;outer&quot;,
    div {
        onclick: move |evt| {},
        &quot;inner&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this particular layout, a click on the inner div is transitively also a click on the outer div. If we didn't want the outer div to be triggered every time we trigger the inner div, then we'd want to call &quot;cancel_bubble&quot;.</p>
<p>This will prevent any listeners above the current listener from being triggered.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>div {
    onclick: move |evt| {},
    &quot;outer&quot;,
    div {
        onclick: move |evt| {
            // now, outer won't be triggered
            evt.cancel_bubble();
        },
        &quot;inner&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="prevent-default"><a class="header" href="#prevent-default">Prevent Default</a></h2>
<p>With HTML based renderers, the browser will automatically perform some action. For text inputs, this would be entering the provided key. For forms, this might involve navigating the page.</p>
<p>In some instances, you don't want this default behavior. In these cases, instead of handling the event directly, you'd want to prevent any default handlers.</p>
<p>Normally, in React or JavaScript, you'd call &quot;preventDefault&quot; on the event in the callback. Dioxus does <em>not</em> currently support this behavior. Instead, you need to add an attribute to the element generating the event.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>form {
    prevent_default: &quot;onclick&quot;,
    onclick: move |_|{
        // handle the event without navigating the page.
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks-and-internal-state"><a class="header" href="#hooks-and-internal-state">Hooks and Internal State</a></h1>
<p>In the <a href="interactivity/./interactivity.html">Adding Interactivity</a> section, we briefly covered the concept of hooks and state stored internal to components.</p>
<p>In this section, we'll dive a bit deeper into hooks, exploring both the theory and mechanics.</p>
<h2 id="theory-of-hooks"><a class="header" href="#theory-of-hooks">Theory of Hooks</a></h2>
<p>Over the past several decades, computer scientists and engineers have long sought the &quot;right way&quot; of designing user interfaces. With each new programming language, novel features are unlocked that change the paradigm in which user interfaces are coded.</p>
<p>Generally, a number of patterns have emerged, each with their own strengths and tradeoffs.</p>
<p>Broadly, there are two types of GUI structures:</p>
<ul>
<li>Immediate GUIs: re-render the entire screen on every update</li>
<li>Retained GUIs: only re-render the portion of the screen that changed</li>
</ul>
<p>Typically, immediate-mode GUIs are simpler to write but can slow down as more features, like styling, are added.</p>
<p>Many GUIs today are written in <em>Retained mode</em> - your code changes the data of the user interface but the renderer is responsible for actually drawing to the screen. In these cases, our GUI's state sticks around as the UI is rendered. To help accommodate retained mode GUIs, like the web browser, Dioxus provides a mechanism to keep state around.</p>
<blockquote>
<p>Note: Even though hooks are accessible, you should still prefer one-way data flow and encapsulation. Your UI code should be as predictable as possible. Dioxus is plenty fast, even for the largest apps.</p>
</blockquote>
<h2 id="mechanics-of-hooks"><a class="header" href="#mechanics-of-hooks">Mechanics of Hooks</a></h2>
<p>In order to have state stick around between renders, Dioxus provides the <code>hook</code> through the <code>use_hook</code> API. This gives us a mutable reference to data returned from the initialization function.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(cx: Scope) -&gt; Element {
    let name: &amp;mut String = cx.use_hook(|| &quot;John Doe&quot;.to_string());

    //
}
<span class="boring">}
</span></code></pre></pre>
<p>We can even modify this value directly from an event handler:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(cx: Scope) -&gt; Element {
    let name: &amp;mut String = cx.use_hook(|| &quot;John Doe&quot;.to_string());

    cx.render(rsx!(
        button {
            onclick: move |_| name.push_str(&quot;..&quot;),
        }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>Mechanically, each call to <code>use_hook</code> provides us with <code>&amp;mut T</code> for a new value.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(cx: Scope) -&gt; Element {
    let name: &amp;mut String = cx.use_hook(|| &quot;John Doe&quot;.to_string());
    let age: &amp;mut u32 = cx.use_hook(|| 10);
    let friends: &amp;mut Vec&lt;String&gt; = cx.use_hook(|| vec![&quot;Jane Doe&quot;.to_string()]);

    //
}
<span class="boring">}
</span></code></pre></pre>
<p>Internally, Dioxus is creating a list of hook values with each call to <code>use_hook</code> advancing the index of the list to return the next value.</p>
<p>Our internal HookList would look something like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[
    Hook&lt;String&gt;,
    Hook&lt;u32&gt;,
    Hook&lt;String&gt;,
]
<span class="boring">}
</span></code></pre></pre>
<p>This is why hooks called out of order will fail - if we try to downcast a <code>Hook&lt;String&gt;</code> to <code>Hook&lt;u32&gt;</code>, Dioxus has no choice but to panic. We do provide a <code>try_use_hook</code> but you should never need that in practice.</p>
<p>This pattern might seem strange at first, but it can be a significant upgrade over structs as blobs of state, which tend to be difficult to use in <a href="https://rust-lang.github.io/rfcs/2229-capture-disjoint-fields.html">Rust given the ownership system</a>.</p>
<h2 id="rules-of-hooks"><a class="header" href="#rules-of-hooks">Rules of hooks</a></h2>
<p>Hooks are sensitive to how they are used. To use hooks, you must abide by the
&quot;rules of hooks&quot; (<a href="https://reactjs.org/docs/hooks-rules.html">borrowed from react</a>):</p>
<ul>
<li>Functions with &quot;use_&quot; should not be called in callbacks</li>
<li>Functions with &quot;use_&quot; should not be called out of order</li>
<li>Functions with &quot;use_&quot; should not be called in loops or conditionals</li>
</ul>
<p>Examples of &quot;no-nos&quot; include:</p>
<h3 id="-nested-uses"><a class="header" href="#-nested-uses">‚ùå Nested uses</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå don't call use_hook or any `use_` function *inside* use_hook!
cx.use_hook(|_| {
    let name = cx.use_hook(|_| &quot;ads&quot;);
})

// ‚úÖ instead, move the first hook above
let name = cx.use_hook(|_| &quot;ads&quot;);
cx.use_hook(|_| {
    // do something with name here
})
<span class="boring">}
</span></code></pre></pre>
<h3 id="-uses-in-conditionals"><a class="header" href="#-uses-in-conditionals">‚ùå Uses in conditionals</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå don't call use_ in conditionals!
if do_thing {
    let name = use_state(&amp;cx, || 0);
}

// ‚úÖ instead, *always* call use_state but leave your logic
let name = use_state(&amp;cx, || 0);
if do_thing {
    // do thing with name here
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="-uses-in-loops"><a class="header" href="#-uses-in-loops">‚ùå Uses in loops</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Do not use hooks in loops!
let mut nodes = vec![];

for name in names {
    let age = use_state(&amp;cx, |_| 0);
    nodes.push(cx.render(rsx!{
        div { &quot;{age}&quot; }
    }))
}

// ‚úÖ Instead, consider refactoring your usecase into components 
#[inline_props]
fn Child(cx: Scope, name: String) -&gt; Element {
    let age = use_state(&amp;cx, |_| 0);
    cx.render(rsx!{ div { &quot;{age}&quot; } })
}

// ‚úÖ Or, use a hashmap with use_ref
let ages = use_ref(&amp;cx, || HashMap::new());

names.iter().map(|name| {
    let age = ages.get(name).unwrap();
    cx.render(rsx!{ div { &quot;{age}&quot; } })
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="building-new-hooks"><a class="header" href="#building-new-hooks">Building new Hooks</a></h2>
<p>However, most hooks you'll interact with <em>don't</em> return an <code>&amp;mut T</code> since this is not very useful in a real-world situation.</p>
<p>Consider when we try to pass our <code>&amp;mut String</code> into two different handlers:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(cx: Scope) -&gt; Element {
    let name: &amp;mut String = cx.use_hook(|| &quot;John Doe&quot;.to_string());

    cx.render(rsx!(
        button { onclick: move |_| name.push_str(&quot;yes&quot;), }
        button { onclick: move |_| name.push_str(&quot;no&quot;), }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust will not allow this to compile! We cannot <code>Copy</code> unique mutable references - they are, by definition, unique. However, we <em>can</em> reborrow our <code>&amp;mut T</code> as an <code>&amp;T</code> which are non-unique references and share those between handlers:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(cx: Scope) -&gt; Element {
    let name: &amp;String = &amp;*cx.use_hook(|| &quot;John Doe&quot;.to_string());

    cx.render(rsx!(
        button { onclick: move |_| log::info!(&quot;{}&quot;, name), }
        button { onclick: move |_| log::info!(&quot;{}&quot;, name), }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>So, for any custom hook we want to design, we need to enable mutation through <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">interior mutability</a> - IE move to runtime <a href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html">borrow checking</a>. We might incur a tiny runtime cost for each time we grab a new value from the hook, but this cost is extremely minimal.</p>
<p>This example uses the <code>Cell</code> type to let us replace the value through interior mutability. <code>Cell</code> has practically zero overhead, but is slightly more limited that its <code>RefCell</code> cousin.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(cx: Scope) -&gt; Element {
    let name: &amp;Cell&lt;&amp;'static str&gt; = cx.use_hook(|| Cell::new(&quot;John Doe&quot;));

    cx.render(rsx!(
        button { onclick: move |_| name.set(&quot;John&quot;), }
        button { onclick: move |_| name.set(&quot;Jane&quot;), }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="driving-state-updates-through-hooks"><a class="header" href="#driving-state-updates-through-hooks">Driving state updates through hooks</a></h2>
<p>Hooks like <code>use_state</code> and <code>use_ref</code> wrap this runtime borrow checking in a type that <em>does</em> implement <code>Copy</code>. Additionally, they also mark the component as &quot;dirty&quot; whenever a new value has been set. This way, whenever <code>use_state</code> has a new value <code>set</code>, the component knows to update.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(cx: Scope) -&gt; Element {
    let name = use_state(&amp;cx, || &quot;Jack&quot;);

    cx.render(rsx!(
        &quot;Hello, {name}&quot;
        button { onclick: move |_| name.set(&quot;John&quot;), }
        button { onclick: move |_| name.set(&quot;Jane&quot;), }
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>Internally, our <code>set</code> function looks something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, T&gt; UseState&lt;'a, T&gt; {
    fn set(&amp;self, new: T) {
        // Replace the value in the cell
        self.value.set(new);

        // Mark our component as dirty
        self.cx.needs_update();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Most hooks we provide implement <code>Deref</code> on their values since they are essentially smart pointers. To access the underlying value, you'll often need to use the deref operator:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example(cx: Scope) -&gt; Element {
    let name = use_state(&amp;cx, || &quot;Jack&quot;);

    match *name {
        &quot;Jack&quot; =&gt; {}
        &quot;Jill&quot; =&gt; {}
        _ =&gt; {}
    }

    // ..
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="hooks-provided-by-the-dioxus-hooks-package"><a class="header" href="#hooks-provided-by-the-dioxus-hooks-package">Hooks provided by the <code>Dioxus-Hooks</code> package</a></h2>
<p>By default, we bundle a handful of hooks in the Dioxus-Hooks package. Feel free to click on each hook to view its definition and associated documentation.</p>
<ul>
<li><a href="https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_state.html">use_state</a> - store state with ergonomic updates</li>
<li><a href="https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_ref.html">use_ref</a> - store non-clone state with a refcell</li>
<li><a href="https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_future.html">use_future</a> - store a future to be polled after initialization</li>
<li><a href="https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_coroutine.html">use_coroutine</a> - store a future that can be stopped/started/communicated with</li>
<li><a href="https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context_provider.html">use_context_provider</a> - expose state to descendent components</li>
<li><a href="https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context.html">use_context</a> - consume state provided by <code>use_provide_context</code></li>
<li><a href="https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_suspense.html">use_suspense</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamental-hook-use_state"><a class="header" href="#fundamental-hook-use_state">Fundamental hook: <code>use_state</code></a></h1>
<p>The first fundamental hook for state management is <code>use_state</code>. This particular hook is designed to work well with the entire Dioxus ecosystem including futures, children, and memoization.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage.</a></h2>
<p>The simplest use case of <code>use_state</code> is a simple counter. The handle returned by <code>use_state</code> implements <code>Add</code> and <code>AddAssign</code>. Writing through <code>AddAssign</code> will automatically mark the component as dirty, forcing an update.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let count = use_state(&amp;cx, || 0);

    rsx!(cx, button { onclick: move |_| count += 1, })
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<h3 id="common-ops"><a class="header" href="#common-ops">Common ops</a></h3>
<p>The <code>use_state</code> hook is very similar to its React counterpart. When we use it, we get a smart pointer - essentially an <code>Rc&lt;T&gt;</code> that tracks when we update it.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut count = use_state(&amp;cx, || 0);

// then to set the count
count += 1;
<span class="boring">}
</span></code></pre></pre>
<h3 id="current-value"><a class="header" href="#current-value">Current value</a></h3>
<p>Our <code>count</code> value is more than just an integer. Because it's a smart pointer, it also implements other useful methods helpful in various contexts.</p>
<p>For instance, we can get a handle to the current value at any time:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let current: Rc&lt;T&gt; = count.current();
<span class="boring">}
</span></code></pre></pre>
<p>Or, we can get the inner handle to set the value:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let setter: Rc&lt;dyn Fn(T)&gt; = count.setter();
<span class="boring">}
</span></code></pre></pre>
<h3 id="modify"><a class="header" href="#modify">Modify</a></h3>
<p>Or, we can set a new value using the current value as a reference:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>count.modify(|i| i + 1);
<span class="boring">}
</span></code></pre></pre>
<h3 id="with_mut-and-make_mut"><a class="header" href="#with_mut-and-make_mut"><code>with_mut</code> and <code>make_mut</code></a></h3>
<p>If the value is cheaply cloneable, then we can call <code>with_mut</code> to get a mutable reference to the value:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>count.with_mut(|i| *i += 1);
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, we can call <code>make_mut</code> which gives us a <code>RefMut</code> to the underlying value:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>*count.make_mut() += 1;
<span class="boring">}
</span></code></pre></pre>
<h3 id="use-in-async"><a class="header" href="#use-in-async">Use in Async</a></h3>
<p>Plus, the <code>set_count</code> handle is cloneable into async contexts, so we can use it in futures.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// count up infinitely
cx.spawn({
    let count = count.clone();
    async move {
        loop {
            wait_ms(100).await;
            count += 1;
        }
    }
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="using-usestate-for-simple-data"><a class="header" href="#using-usestate-for-simple-data">Using UseState for simple data</a></h2>
<p>The best use case of <code>use_state</code> is to manage &quot;simple&quot; data local to your component. This should be things like numbers, strings, small maps, and cheaply-clonable types.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let val = use_state(&amp;cx, || 0);
let val = use_state(&amp;cx, || &quot;Hello!&quot;);
let val = use_state(&amp;cx, || vec![1, 3, 3, 7]);
<span class="boring">}
</span></code></pre></pre>
<p>UseState can be sent down into child components too.</p>
<p>You can either pass by reference to always force the child to update when the value changes, or you can clone the handle to take advantage of automatic memoization. In these cases, calling &quot;get&quot; will return stale data - always prefer &quot;current&quot; when &quot;cloning&quot; the UseState. This automatic memoization of UseState solves a performance problem common in React.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let val = use_state(&amp;cx, || 0);

    cx.render(rsx!{
        Child { val: val.clone() }
    })
}

fn Child(cx: Scope, val: UseState&lt;i32&gt;) -&gt; Element {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useref"><a class="header" href="#useref">UseRef</a></h1>
<p>You might've noticed a fundamental limitation to <code>use_state</code>: to modify the value in-place, it must be cheaply cloneable. But what if your type is not cheap to clone?</p>
<p>In these cases, you should reach for <code>use_ref</code> which is essentially just a glorified <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> (Rust <a href="https://doc.rust-lang.org/book/ch15-04-rc.html">smart pointers</a>).</p>
<p>This provides us some runtime locks around our data, trading reliability for performance. For most cases though, you will find it hard to make <code>use_ref</code> crash.</p>
<blockquote>
<p>Note: this is <em>not</em> exactly like its React counterpart since calling <code>write</code> will cause a re-render. For more React parity, use the <code>write_silent</code> method.</p>
</blockquote>
<p>To use the hook:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let names = use_ref(&amp;cx, || vec![&quot;susie&quot;, &quot;calvin&quot;]);
<span class="boring">}
</span></code></pre></pre>
<p>To read the hook values, use the <code>read()</code> method:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.render(rsx!{
    ul {
        names.read().iter().map(|name| {
            rsx!{ &quot;{name}&quot; }
        })
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>And then to write into the hook value, use the <code>write</code> method:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>names.write().push(&quot;Tiger&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>If you don't want to re-render the component when names is updated, then we can use the <code>write_silent</code> method:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>names.write_silent().push(&quot;Transmogrifier&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Again, like <code>UseState</code>, the <code>UseRef</code> handle is clonable into async contexts:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// infinitely push calvin into the list
cx.spawn({
    to_owned![names];
    async move {
        loop {
            wait_ms(100).await;
            names.write().push(&quot;Calvin&quot;);
        }
    }
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="using-useref-for-complex-state"><a class="header" href="#using-useref-for-complex-state">Using UseRef for complex state</a></h2>
<p>The best use case of <code>use_ref</code> is to manage &quot;complex&quot; data local to your component. This should be things like large structs, collections, queues, state machines, and other data where cloning would be expensive.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let val = use_state(&amp;cx, || vec![1, 3, 3, 7]);
let val = use_state(&amp;cx, || (0..10000).collect::&lt;Vec&lt;_&gt;x&gt;());
let val = use_state(&amp;cx, || Configuration {
    a: &quot;asdasd&quot;,
    // .. more complex fields
});
<span class="boring">}
</span></code></pre></pre>
<p>UseRef can be sent down into child components too.</p>
<p>UseRef memoizes with itself, performing a cheap pointer comparison. If the UseRef handle is the same, then the component can be memoized.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let val = use_ref(&amp;cx, || 0);

    cx.render(rsx!{
        Child { val: val.clone() }
    })
}

fn Child(cx: Scope, val: UseRef&lt;i32&gt;) -&gt; Element {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="using-useref-with-models"><a class="header" href="#using-useref-with-models">Using UseRef with &quot;models&quot;</a></h2>
<p>One option for state management that UseRef enables is the development of a &quot;model&quot; for your components. This particular pattern enables you to model your state with regular structs.</p>
<p>For instance, our calculator example uses a struct to model the state.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Calculator {
    display_value: String,
    operator: Option&lt;Operator&gt;,
    waiting_for_operand: bool,
    cur_val: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>Our component is really simple - we just call <code>use_ref</code> to get an initial calculator state.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let state = use_ref(&amp;cx, Calculator::new);

    cx.render(rsx!{
        // the rendering code
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>In our UI, we can then use <code>read</code> and a helper method to get data out of the model.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Our accessor method
impl Calculator {
    fn formatted_display(&amp;self) -&gt; String {
        self.display_value
            .parse::&lt;f64&gt;()
            .unwrap()
            .separated_string()
    }
}

// And then in the UI
cx.render(rsx!{
    div { [state.read().formatted_display()] }
})
<span class="boring">}
</span></code></pre></pre>
<p>To modify the state, we can setup a helper method and then attach it to a callback.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// our helper
impl Calculator {
    fn clear_display(&amp;mut self) {
        self.display_value = &quot;0&quot;.to_string()
    }
}

// our callback
cx.render(rsx!{
    button {
        onclick: move |_| state.write().clear_display(),
    }
})
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-input-and-controlled-components"><a class="header" href="#user-input-and-controlled-components">User Input and Controlled Components</a></h1>
<p>Handling user input is one of the most common things your app will do, but it <em>can</em> be tricky.</p>
<p>The reactive paradigm and one-way-data-flow models were all derived to solve problems that can crop up around user input handling. This section will teach you about two effective patterns for handling user input: controlled and uncontrolled inputs.</p>
<h2 id="controlled-inputs"><a class="header" href="#controlled-inputs">Controlled Inputs</a></h2>
<p>The most common approach to handling input from elements is through &quot;controlled&quot; inputs. With this pattern, we drive the value of the input from our state, while simultaneously updating our state from new values.</p>
<p>This is the most common form of input handling and is widely used because it prevents the UI from being out of sync with your local state.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = use_state(&amp;cx, || &quot;bob&quot;.to_string());

cx.render(rsx!{
    input {
        value: &quot;{name}&quot;,
        oninput: move |evt| name.set(evt.value.clone()),
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>Why not just &quot;bind&quot; like in other frameworks?</p>
<p>In a handful of cases, you don't want the inputted value to match what's rendered to the screen. Let's say we want to implement an input that converts the input to uppercase when the input matches a certain value. With binding, we're forced to share the same input and state value. By explicitly handling the oninput case, we're given the opportunity to set a <em>new</em> value.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = use_state(&amp;cx, || &quot;bob&quot;.to_string());

cx.render(rsx!{
    input {
        value: &quot;{name}&quot;,
        oninput: move |evt| {
            if evt.value == &quot;tim&quot; {
                name.set(&quot;TIM&quot;);
            }
        },
    }
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="binding"><a class="header" href="#binding">Binding</a></h2>
<blockquote>
<p>! Note - binding is currently not implemented in Dioxus. This section represents a future in-progress feature.</p>
</blockquote>
<p>Because the above pattern is so common, we have an additional attribute called &quot;bind&quot; which is essentially a shorthand for our code above.</p>
<p>Bind just connects an oninput to a <code>UseState</code> and is implemented through the signal system.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = use_state(&amp;cx, || &quot;bob&quot;.to_string());

cx.render(rsx!{
    input { bind: name }
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="uncontrolled-inputs"><a class="header" href="#uncontrolled-inputs">Uncontrolled Inputs</a></h2>
<p>When working with large sets of inputs, you might be quickly tired of creating <code>use_state</code> for each value. Additionally, the pattern of one use_state per interaction might deteriorate when you need to have a flexible number of inputs. In these cases, we use &quot;uncontrolled&quot; inputs. Here, we don't drive the value of the input from the use_state, choosing to leave it in an &quot;uncontrolled&quot; state.</p>
<p>This approach can be more performant, more flexible, but more prone to UI inconsistencies than its controlled counterpart.</p>
<p>To use the &quot;uncontrolled&quot; pattern, we simply omit setting the value of the input. Instead, we can react to the change directly on the input itself, or from a form element higher up in the tree.</p>
<p>For this example, we don't attach any <code>use_state</code> handles into the labels. Instead, we simply attach an &quot;oninput&quot; handler to the form element. This will run each time any of the child inputs change, allowing us to perform tasks like form validation.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>form {
    oninput: move |evt| {
        if !validate_input(evt.values) {
            // display what errors validation resulted in
        }
    },
    input { name: &quot;name&quot;, }
    input { name: &quot;age&quot;, }
    input { name: &quot;date&quot;, }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-state"><a class="header" href="#managing-state">Managing State</a></h1>
<p>Every app you'll build with Dioxus will have some sort of state that needs to be maintained and updated as your users interact with it. However, managing state can be particular challenging at times, and is frequently the source of bugs in many GUI frameworks.</p>
<p>In this chapter, we'll cover the various ways to manage state, the appropriate terminology, various patterns, and some problems you might run into.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Why do people say state management is so difficult? What does it mean?</p>
<p>Generally, state management is the code you need to write to ensure that your app renders the <em>correct</em> content. If the user inputs a name, then you need to display the appropriate response - like alerts, validation, and disable/enable various elements on the page. Things can quickly become tricky if you need loading screens and cancellable tasks.</p>
<p>For the simplest of apps, all your state can enter the app from the root props. This is common in server-side rendering - we can collect all of the required state <em>before</em> rendering the content.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let all_content = get_all_content().await;

let output = dioxus::ssr::render_lazy(rsx!{
    div {
        RenderContent { content: all_content }
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>With this incredibly simple setup, it is highly unlikely that you'll have rendering bugs. There simply is barely any state to manage.</p>
<p>However, most of your apps will store state inside of the Dioxus VirtualDom - either through local state or global state.</p>
<h2 id="your-options"><a class="header" href="#your-options">Your options</a></h2>
<p>To deal with complexity, you have a couple of options:</p>
<ul>
<li>Refactor state out of shared state and into reusable components and hooks.</li>
<li>Lift state upwards to be spread across multiple components (fan out).</li>
<li>Use the Context API to share state globally.</li>
<li>Use a dedicated state management solution like Fermi.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-state-1"><a class="header" href="#local-state-1">Local State</a></h1>
<p>The first step to dealing with complexity in your app is to refactor your state to be purely local. This encourages good code reuse and prevents leakage of abstractions across component boundaries.</p>
<h2 id="what-it-looks-like"><a class="header" href="#what-it-looks-like">What it looks like</a></h2>
<p>Let's say we're managing the state for a list of Todos. Whenever we edit the todo, we want the list to update. We might've started building our app but putting everything into a single <code>use_ref</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Todo {
    contents: String,
    is_hovered: bool,
    is_editing: bool,
}

let todos = use_ref(&amp;cx, || vec![Todo::new()]);

cx.render(rsx!{
    ul {
        todos.read().iter().enumerate().map(|(id, todo)| rsx!{
            li {
                h1 { &quot;{todo.contents}&quot; }
                onhover: move |_| *todos.write()[id].is_hovered = true;
            }
        })
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>As shown above, whenever the todo is hovered, we want to set its state:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>todos.write()[0].is_hovered = true;
<span class="boring">}
</span></code></pre></pre>
<p>As the amount of interactions goes up, so does the complexity of our state. Should the &quot;hover&quot; state really be baked into our data model?</p>
<p>Instead, let's refactor our Todo component to handle its own state:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn Todo&lt;'a&gt;(cx: Scope, todo: &amp;'a Todo) -&gt; Element {
    let is_hovered = use_state(&amp;cx, || false);

    cx.render(rsx!{
        li {
            h1 { &quot;{todo.contents}&quot; }
            onhover: move |_| is_hovered.set(true),
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, we can simplify our Todo data model to get rid of local UI state:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Todo {
    contents: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>This is not only better for encapsulation and abstraction, but it's only more performant! Whenever a Todo is hovered, we won't need to re-render <em>every</em> Todo again - only the Todo that's currently being hovered.</p>
<p>Wherever possible, you should try to refactor the &quot;view&quot; layer <em>out</em> of your data model.</p>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p>Storing all of your state inside a <code>use_ref</code> might be tempting. However, you'll quickly run into an issue where the <code>Ref</code> provided by <code>read()</code> &quot;does not live long enough.&quot; An indeed - you can't return locally-borrowed value into the Dioxus tree.</p>
<p>In these scenarios consider breaking your <code>use_ref</code> into individual <code>use_state</code>s.</p>
<p>You might've started modeling your component with a struct and use_ref</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct State {
    count: i32,
    color: &amp;'static str,
    names: HashMap&lt;String, String&gt;
}

// in the component
let state = use_ref(&amp;cx, State::new)
<span class="boring">}
</span></code></pre></pre>
<p>The &quot;better&quot; approach for this particular component would be to break the state apart into different values:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let count = use_state(&amp;cx, || 0);
let color = use_state(&amp;cx, || &quot;red&quot;);
let names = use_state(&amp;cx, HashMap::new);
<span class="boring">}
</span></code></pre></pre>
<p>You might recognize that our &quot;names&quot; value is a HashMap - which is not terribly cheap to clone every time we update its value. To solve this issue, we <em>highly</em> suggest using a library like <a href="https://crates.io/crates/im"><code>im</code></a> which will take advantage of structural sharing to make clones and mutations much cheaper.</p>
<p>When combined with the <code>make_mut</code> method on <code>use_state</code>, you can get really succinct updates to collections:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let todos = use_state(&amp;cx, im_rc::HashMap::default);

todos.make_mut().insert(&quot;new todo&quot;, Todo {
    contents: &quot;go get groceries&quot;,
});
<span class="boring">}
</span></code></pre></pre>
<h2 id="moving-on-4"><a class="header" href="#moving-on-4">Moving on</a></h2>
<p>This particular local patterns are powerful but is not a cure-all for state management problems. Sometimes your state problems are much larger than just staying local to a component.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-state"><a class="header" href="#global-state">Global State</a></h1>
<p>If your app has finally gotten large enough where passing values through the tree ends up polluting the intent of your code, then it might be time to turn to global state.</p>
<p>In Dioxus, global state is shared through the Context API. This guide will show you how to use the Context API to simplify state management.</p>
<h2 id="provide-context-and-consume-context"><a class="header" href="#provide-context-and-consume-context">Provide Context and Consume Context</a></h2>
<p>The simplest way of retrieving shared state in your app is through the Context API. The Context API allows you to provide and consume an item of state between two components.</p>
<p>Whenever a component provides a context, it is then accessible to any child components.</p>
<blockquote>
<p>Note: parent components cannot &quot;reach down&quot; and consume state from below their position in the tree.</p>
</blockquote>
<p>The terminology here is important: <code>provide</code> context means that the component will expose state and <code>consume</code> context means that the child component can acquire a handle to state above it.</p>
<p>Instead of using keys or statics, Dioxus prefers the <code>NewType</code> pattern to search for parent state. This means each state you expose as a context should be its own unique type.</p>
<p>In practice, you'll have a component that exposes some state:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Title(String);

fn app(cx: Scope) -&gt; Element {
    cx.use_hook(|_| {
        cx.provide_context(Title(&quot;Hello&quot;.to_string()));
    });

    cx.render(rsx!{
        Child {}
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>And then in our component, we can consume this state at any time:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Child(cx: Scope) -&gt; Element {
    let name = cx.consume_context::&lt;Title&gt;();

    //
}
<span class="boring">}
</span></code></pre></pre>
<p>Note: calling &quot;consume&quot; state can be a rather expensive operation to perform during each render. Prefer to consume state within a <code>use_hook</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Child(cx: Scope) -&gt; Element {
    // cache our &quot;consume_context&quot; operation
    let name = cx.use_hook(|_| cx.consume_context::&lt;Title&gt;());
}
<span class="boring">}
</span></code></pre></pre>
<p>All <code>Context</code> must be cloned - the item will be cloned into each call of <code>consume_context</code>. To make this operation cheaper, consider wrapping your type in an <code>Rc</code> or <code>Arc</code>.</p>
<!-- ## Coroutines

The `use_coroutine` hook  -->
<!-- # `use_context` and `use_context_provider`

These -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifting-state-and-fanning-out"><a class="header" href="#lifting-state-and-fanning-out">Lifting State and Fanning Out</a></h1>
<p>Maintaining state local to components doesn't always work.</p>
<p>One of the most reliable state management patterns in large Dioxus apps is to <code>lift-up</code> and <code>fan-out</code>. Lifting up and fanning-out state is the ideal way to structure your app to maximize code reuse, testability, and deterministic rendering.</p>
<h2 id="lifting-state"><a class="header" href="#lifting-state">Lifting State</a></h2>
<p>When building complex apps with Dioxus, the best approach is to start by placing your state and an UI all within a single component. Once your component has passed a few hundred lines, then it might be worth refactoring it into a few smaller components.</p>
<p>Here, we're now challenged with how to share state between these various components.</p>
<p>Let's say we refactored our component to separate an input and a display.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    cx.render(rsx!{
        Title {}
        Input {}
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Whenever a value is inputted in our <code>Input</code> component, we need to somehow propagate those changes into the <code>Title</code> component.</p>
<p>A quick-and-dirty solution - which works for many apps - is to simply share a UseState between the two components.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let text = use_state(&amp;cx, || &quot;default&quot;.to_string());

    cx.render(rsx!{
        Title { text: text.clone() }
        Input { text: text.clone() }
    })
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: since we <code>Cloned</code> our <code>text</code> <code>UseState</code> handle, both <code>Title</code> and <code>Input</code> will be memoized.</p>
</blockquote>
<p>Here, we've &quot;lifted&quot; state out of our <code>Input</code> component and brought it up to the closest shared ancestor. In our input component, we can directly use this UseState handle as if it had been defined locally:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn Input(cx: Scope, text: UseState&lt;String&gt;) -&gt; Element {
    cx.render(rsx!{
        input { oninput: move |evt| text.set(evt.value.clone()) }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Similarly, our <code>Title</code> component would be straightforward:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn Title(cx: Scope, text: UseState&lt;String&gt;) -&gt; Element {
    cx.render(rsx!{
        h1 { &quot;{text}&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>For more complicated use cases, we can take advantage of the EventHandler coercion talked about before to pass in any callback. Recall that fields on components that start with &quot;on&quot; are automatically &quot;upgraded&quot; into an <code>EventHandler</code> at the call site.</p>
<p>This lets us abstract over the exact type of state being used to store the data.</p>
<p>For the <code>Input</code> component, we would simply add a new <code>oninput</code> field:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn Input&lt;'a&gt;(cx: Scope&lt;'a&gt;, oninput: EventHandler&lt;'a, String&gt;) -&gt; Element {
    cx.render(rsx!{
        input { oninput: move |evt| oninput.call(evt.value.clone()), }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>For our <code>Title</code> component, we could also abstract it to take any <code>&amp;str</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn Title&lt;'a&gt;(cx: Scope&lt;'a&gt;, text: &amp;'a str) -&gt; Element {
    cx.render(rsx!{
        h1 { &quot;{text}&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="fanning-out"><a class="header" href="#fanning-out">Fanning Out</a></h2>
<p>As your app grows and grows, you might need to start pulling in global state to avoid prop drilling. This tends to solve a lot of problems, but generates even more.</p>
<p>For instance, let's say we built a beautiful <code>Title</code> component. Instead of passing props in, we instead are using a <code>use_read</code> hook from Fermi.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Title(cx: Scope) -&gt; Element {
    let title = use_read(&amp;cx, TITLE);

    cx.render(rsx!{
        h1 { &quot;{title}&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This is great - all is well in the world. We get precise updates, automatic memoization, and a solid abstraction. But, what happens when we want to reuse this component in another project? This component is now deeply intertwined with our global state - which might not be the same in another app.</p>
<p>In this case, we want to &quot;lift&quot; our global state out of &quot;view&quot; components.  With <code>lifting</code>, our individual components at &quot;leaf&quot; position of our VirtualDom are &quot;pure&quot;, making them easily reusable, testable, and deterministic.</p>
<p>To enable our title component to be used across apps, we want to lift our atoms upwards and out of the Title component. We would organize a bunch of other components in this section of the app to share some of the same state.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn DocsiteTitlesection(cx: Scope) {
    // Use our global state in a wrapper component
    let title = use_read(&amp;cx, TITLE);
    let subtitle = use_read(&amp;cx, SUBTITLE);

    let username = use_read(&amp;cx, USERNAME);
    let points = use_read(&amp;cx, POINTS);

    // and then pass our global state in from the outside
    cx.render(rsx!{
        Title { title: title.clone(), subtitle: subtitle.clone() }
        User { username: username.clone(), points: points.clone() }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This particular wrapper component unfortunately cannot be reused across apps. However, because it simply wraps other real elements, it doesn't have to. We are free to reuse our TitleBar and UserBar components across apps with ease. We also know that this particular component is plenty performant because the wrapper doesn't have any props and is always memoized. The only times this component re-renders is when any of the atoms change.</p>
<p>This is the beauty of Dioxus - we always know where our components are likely to be re-rendered. Our wrapper components can easily prevent any large re-renders by simply memoizing their components. This system might not be as elegant or precise as signal systems found in libraries like Sycamore or SolidJS, but it is quite ergonomic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>A selling point of Rust for web development is the reliability of always knowing where errors can occur and being forced to handle them</p>
<p>However, we haven't talked about error handling at all in this guide! In this chapter, we'll cover some strategies in handling errors to ensure your app never crashes.</p>
<h2 id="the-simplest---returning-none"><a class="header" href="#the-simplest---returning-none">The simplest - returning None</a></h2>
<p>Astute observers might have noticed that <code>Element</code> is actually a type alias for <code>Option&lt;VNode&gt;</code>. You don't need to know what a <code>VNode</code> is, but it's important to recognize that we could actually return nothing at all:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    None
}
<span class="boring">}
</span></code></pre></pre>
<p>This lets us add in some syntactic sugar for operations we think <em>shouldn't</em> fail, but we're still not confident enough to &quot;unwrap&quot; on.</p>
<blockquote>
<p>The nature of <code>Option&lt;VNode&gt;</code> might change in the future as the <code>try</code> trait gets upgraded.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    // immediately return &quot;None&quot;
    let name = cx.use_hook(|_| Some(&quot;hi&quot;))?;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="early-return-on-result"><a class="header" href="#early-return-on-result">Early return on result</a></h2>
<p>Because Rust can't accept both Options and Results with the existing try infrastructure, you'll need to manually handle Results. This can be done by converting them into Options or by explicitly handling them.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn App(cx: Scope) -&gt; Element {
    // Convert Result to Option
    let name = cx.use_hook(|_| &quot;1.234&quot;).parse().ok()?;


    // Early return
    let count = cx.use_hook(|_| &quot;1.234&quot;);
    let val = match count.parse() {
        Ok(val) =&gt; val
        Err(err) =&gt; return cx.render(rsx!{ &quot;Parsing failed&quot; })
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice that while hooks in Dioxus do not like being called in conditionals or loops, they <em>are</em> okay with early returns. Returning an error state early is a completely valid way of handling errors.</p>
<h2 id="match-results"><a class="header" href="#match-results">Match results</a></h2>
<p>The next &quot;best&quot; way of handling errors in Dioxus is to match on the error locally. This is the most robust way of handling errors, though it doesn't scale to architectures beyond a single component.</p>
<p>To do this, we simply have an error state built into our component:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let err = use_state(&amp;cx, || None);
<span class="boring">}
</span></code></pre></pre>
<p>Whenever we perform an action that generates an error, we'll set that error state. We can then match on the error in a number of ways (early return, return Element, etc).</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Commandline(cx: Scope) -&gt; Element {
    let error = use_state(&amp;cx, || None);

    cx.render(match *error {
        Some(error) =&gt; rsx!(
            h1 { &quot;An error occured&quot; }
        )
        None =&gt; rsx!(
            input {
                oninput: move |_| error.set(Some(&quot;bad thing happened!&quot;)),
            }
        )
    })
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="passing-error-states-through-components"><a class="header" href="#passing-error-states-through-components">Passing error states through components</a></h2>
<p>If you're dealing with a handful of components with minimal nesting, you can just pass the error handle into child components.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Commandline(cx: Scope) -&gt; Element {
    let error = use_state(&amp;cx, || None);

    if let Some(error) = **error {
        return cx.render(rsx!{ &quot;An error occured&quot; });
    }

    cx.render(rsx!{
        Child { error: error.clone() }
        Child { error: error.clone() }
        Child { error: error.clone() }
        Child { error: error.clone() }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Much like before, our child components can manually set the error during their own actions. The advantage to this pattern is that we can easily isolate error states to a few components at a time, making our app more predictable and robust.</p>
<h2 id="going-global"><a class="header" href="#going-global">Going global</a></h2>
<p>A strategy for handling cascaded errors in larger apps is through signaling an error using global state. This particular pattern involves creating an &quot;error&quot; context, and then setting it wherever relevant. This particular method is not as &quot;sophisticated&quot; as React's error boundary, but it is more fitting for Rust.</p>
<p>To get started, consider using a built-in hook like <code>use_context</code> and <code>use_context_provider</code> or Fermi. Of course, it's pretty easy to roll your own hook too.</p>
<p>At the &quot;top&quot; of our architecture, we're going to want to explicitly declare a value that could be an error.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum InputError {
    None,
    TooLong,
    TooShort,
}

static INPUT_ERROR: Atom&lt;InputError&gt; = |_| InputError::None;
<span class="boring">}
</span></code></pre></pre>
<p>Then, in our top level component, we want to explicitly handle the possible error state for this part of the tree.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn TopLevel(cx: Scope) -&gt; Element {
    let error = use_read(&amp;cx, INPUT_ERROR);

    match error {
        TooLong =&gt; return cx.render(rsx!{ &quot;FAILED: Too long!&quot; }),
        TooShort =&gt; return cx.render(rsx!{ &quot;FAILED: Too Short!&quot; }),
        _ =&gt; {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, whenever a downstream component has an error in its actions, it can simply just set its own error state:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Commandline(cx: Scope) -&gt; Element {
    let set_error = use_set(&amp;cx, INPUT_ERROR);

    cx.render(rsx!{
        input {
            oninput: move |evt| {
                if evt.value.len() &gt; 20 {
                    set_error(InputError::TooLong);
                }
            }
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This approach to error handling is best in apps that have &quot;well defined&quot; error states. Consider using a crate like <code>thiserror</code> or <code>anyhow</code> to simplify the generation of the error types.</p>
<p>This pattern is widely popular in many contexts and is particularly helpful whenever your code generates a non-recoverable error. You can gracefully capture these &quot;global&quot; error states without panicking or mucking up state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="helper-crates"><a class="header" href="#helper-crates">Helper Crates</a></h1>
<p>Because the Dioxus ecosystem is fairly young, there aren't a ton of third-party libraries designed to &quot;get things done.&quot; That's where the Dioxus helper crates come in. These are officially supported crates built on top of existing libraries to solve some of the common barriers to building apps.</p>
<h2 id="router"><a class="header" href="#router">Router</a></h2>
<p>Quickly add a cross-platform router to structure your app.</p>
<p><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/router">Link</a></p>
<h2 id="fermi"><a class="header" href="#fermi">Fermi</a></h2>
<p>Global state as easy as <code>use_state</code>.</p>
<p><a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/fermi">Link</a></p>
<h2 id="query"><a class="header" href="#query">Query</a></h2>
<p>This crate has yet to be developed! However, we do plan on providing a crate for good fetching and query support.</p>
<h2 id="3rd-party---toast"><a class="header" href="#3rd-party---toast">3rd-party - Toast</a></h2>
<p>Toast notifications, curtesy of <a href="https://github.com/mrxiaozhuox">@mrxiaozhuox</a>.</p>
<p><a href="https://github.com/mrxiaozhuox/dioxus-toast">Link</a></p>
<h2 id="3rd-party---heroicon"><a class="header" href="#3rd-party---heroicon">3rd-party - HeroIcon</a></h2>
<p>Collection of helpful hero icons, curtesy of <a href="https://github.com/autarch">@autarch</a>.</p>
<p><a href="https://github.com/houseabsolute/dioxus-heroicons">Link</a></p>
<h2 id="3rd-party---katex"><a class="header" href="#3rd-party---katex">3rd-party - Katex</a></h2>
<p>Draw beautiful equations, curtesy of <a href="https://github.com/oovm">@oovm</a></p>
<p><a href="https://github.com/oovm/katex-wasm/tree/dev/projects/dioxus-katex">Link</a></p>
<h2 id="3rd-party---primsjs"><a class="header" href="#3rd-party---primsjs">3rd-party - PrimsJS</a></h2>
<p>Highlight your code blocks with ease, curtesy of <a href="https://github.com/oovm">@oovm</a></p>
<p><a href="https://github.com/oovm/katex-wasm/tree/dev/projects/dioxus-katex">Link</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fermi-1"><a class="header" href="#fermi-1">Fermi</a></h1>
<p>After having covered local and global state, you're definitely ready to start building some complex Dioxus apps. Before you get too far, check out the Fermi crate. Fermi makes it dead-easy to manage global state and scales to the largest of apps.</p>
<h2 id="what-is-fermi-for"><a class="header" href="#what-is-fermi-for">What is Fermi for?</a></h2>
<p>If you're building an app that has scaled past a few small components, then it'll be worth sketching out and organizing your app's state. Fermi makes it easy to transition from a simple app that relies on <code>use_state</code> to an app with dozens of components.</p>
<blockquote>
<p>To put it simply - Fermi is the ideal crate for managing global state in your Dioxus app.</p>
</blockquote>
<h2 id="how-do-i-use-it"><a class="header" href="#how-do-i-use-it">How do I use it?</a></h2>
<p>To add fermi to your project, simply add the &quot;fermi&quot; feature to your Dioxus dependency.</p>
<pre><code class="language-toml">[dependencies]
dioxus = { version = &quot;0.2&quot;, features = [&quot;desktop&quot;, &quot;fermi&quot;] }
</code></pre>
<p>Fermi is built on the concept of &quot;atoms&quot; of global state. Instead of bundling all our state together in a single mega struct, we actually chose to implement it piece-by-piece with functions.</p>
<p>Each piece of global state in your app is represented by an &quot;atom.&quot;</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static TITLE: Atom&lt;String&gt; = |_| &quot;Defualt Title&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>This atom can be then used the with the <code>use_atom</code> hook as a drop-in replacement for <code>use_state</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static TITLE: Atom&lt;String&gt; = |_| &quot;Defualt Title&quot;.to_string();

fn Title(cx: Scope) -&gt; Element {
    let title = use_atom(&amp;cx, TITLE);

    cx.render(rsx!{
        button { onclick: move |_| title.set(&quot;new title&quot;.to_string()) }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>However, Fermi really becomes useful when we want to share the value between two different components.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static TITLE: Atom&lt;String&gt; = |_| &quot;Defualt Title&quot;.to_string();

fn TitleBar(cx: Scope) -&gt; Element {
    let title = use_atom(&amp;cx, TITLE);

    rsx!{cx, button { onclick: move |_| title.set(&quot;titlebar title&quot;.to_string()) } }
}

fn TitleCard(cx: Scope) -&gt; Element {
    let title = use_atom(&amp;cx, TITLE);

    rsx!{cx, button { onclick: move |_| title.set(&quot;title card&quot;.to_string()) } }
}
<span class="boring">}
</span></code></pre></pre>
<p>These two components can get and set the same value!</p>
<h2 id="use-with-collections"><a class="header" href="#use-with-collections">Use with collections</a></h2>
<p>Fermi gets <em>really</em> powerful when used to manage collections of data. Under the hood, Fermi uses immutable collections and tracks reads and writes of individual keys. This makes it easy to implement things like lists and infinite posts with little performance penalty. It also makes it really easy to refactor our app and add new fields.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static NAMES: AtomRef&lt;Uuid, String&gt; = |builder| {};
static CHECKED: AtomRef&lt;Uuid, bool&gt; = |builder| {};
static CREATED: AtomRef&lt;Uuid, Instant&gt; = |builder| {};
<span class="boring">}
</span></code></pre></pre>
<p>To use these collections:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn Todo(cx: Scope, id: Uuid) -&gt; Element {
    let name = use_atom(&amp;cx, NAMES.select(id));
    let checked = use_atom(&amp;cx, CHECKED.select(id));
    let created = use_atom(&amp;cx, CREATED.select(id));

    // or

    let (name, checked, created) = use_atom(&amp;cx, (NAMES, CHECKED, CREATED).select(id));
}
<span class="boring">}
</span></code></pre></pre>
<p>This particular pattern might seem strange at first - &quot;why isn't all of our state under one struct?&quot; - but eventually shows its worth when dealing with large amounts of data. By composing collections together, we can get get the perks of the Entity-Component-System architecture in our Dioxus apps. Performance is quite predictable here and easy to trace.</p>
<h2 id="atomref"><a class="header" href="#atomref">AtomRef</a></h2>
<p>Much like <code>use_ref</code> can be used to manage complex state locally, <code>AtomRef</code> can be used to manage complex global state. <code>AtomRef</code> is basically a global <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> with mutation tracking.</p>
<p>It too serves as a basic replacement for <code>use_ref</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Todo(cx: Scope) -&gt; Element {
    let cfg = use_atom_ref(&amp;cx, CFG);

    cfg.write().enable_option();
}

<span class="boring">}
</span></code></pre></pre>
<h2 id="future-reading"><a class="header" href="#future-reading">Future Reading</a></h2>
<p>This guide is meant just to be an overview of Fermi. This page is just a short advertisement for what we consider the best state management solution available today for Dioxus apps.</p>
<p>For further reading, check out the <a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/fermi">crate itself</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="router-1"><a class="header" href="#router-1">Router</a></h1>
<p>In many of your apps, you'll want to have different &quot;scenes&quot;. For a webpage, these scenes might be the different webpages with their own content.</p>
<p>You could write your own scene management solution - quite simply too. However, to save you the effort, Dioxus supports a first-party solution for scene management called Dioxus Router.</p>
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>For an app like the Dioxus landing page (https://dioxuslabs.com), we want to have different pages. A quick sketch of an app would be something like:</p>
<ul>
<li>Homepage</li>
<li>Blog</li>
<li>Example showcase</li>
</ul>
<p>Each of these scenes is independent - we don't want to render both the homepage and blog at the same time.</p>
<p>This is where the router crates come in handy. To make sure we're using the router, simply add the <code>&quot;router&quot;</code> feature to your dioxus dependency.</p>
<pre><code class="language-toml">[dependencies]
dioxus = { version = &quot;0.2&quot;, features = [&quot;desktop&quot;, &quot;router&quot;] }
</code></pre>
<h2 id="using-the-router"><a class="header" href="#using-the-router">Using the router</a></h2>
<p>Unlike other routers in the Rust ecosystem, our router is built declaratively. This makes it possible to compose our app layout simply by arranging components.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    Router {
        Route { to: &quot;/home&quot;, Home {} }
        Route { to: &quot;/blog&quot;, Blog {} }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Whenever we visit this app, we will get either the Home component or the Blog component rendered depending on which route we enter at. If neither of these routes match the current location, then nothing will render.</p>
<p>We can fix this one of two ways:</p>
<ul>
<li>A fallback 404 page</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    Router {
        Route { to: &quot;/home&quot;, Home {} }
        Route { to: &quot;/blog&quot;, Blog {} }
        Route { to: &quot;&quot;, NotFound {} }
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Redirect 404 to home</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    Router {
        Route { to: &quot;/home&quot;, Home {} }
        Route { to: &quot;/blog&quot;, Blog {} }
        Redirect { from: &quot;&quot;, to: &quot;/home&quot; }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<p>For our app to navigate these routes, we can provide clickable elements called Links. These simply wrap <code>&lt;a&gt;</code> elements that, when clicked, navigate the app to the given location.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    Link {
        to: &quot;/home&quot;,
        &quot;Go home!&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="more-reading"><a class="header" href="#more-reading">More reading</a></h2>
<p>This page is just meant to be a very brief overview of the router to show you that there's a powerful solution already built for a very common problem. For more information about the router, definitely check out its book or check out some of the examples.</p>
<p>The router has its own documentation! <a href="https://dioxuslabs.com/router_guide/">Available here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-async"><a class="header" href="#working-with-async">Working with Async</a></h1>
<p>Not all apps you'll build can be self-contained with synchronous code. You'll often need to interact with file systems, network interfaces, hardware, or timers.</p>
<p>So far, we've only talked about building apps with synchronous code, so this chapter will focus integrating asynchronous code into your app.</p>
<h2 id="the-runtime"><a class="header" href="#the-runtime">The Runtime</a></h2>
<p>By default, Dioxus-Desktop ships with the <code>Tokio</code> runtime and automatically sets everything up for you. This is currently not configurable, though it would be easy to write an integration for Dioxus desktop that uses a different asynchronous runtime.</p>
<h2 id="sendsync"><a class="header" href="#sendsync">Send/Sync</a></h2>
<p>Writing apps that deal with Send/Sync can be frustrating at times. Under the hood, Dioxus is not currently thread-safe, so any async code you write does <em>not</em> need to be <code>Send/Sync</code>. That means that you can use non-thread-safe structures like <code>Cell</code>, <code>Rc</code>, and <code>RefCell</code>.</p>
<p>All async code in your app is polled on a <code>LocalSet</code>, so you can also use <code>tokio::spawn_local</code>.</p>
<h2 id="spawning-a-future"><a class="header" href="#spawning-a-future">Spawning a future</a></h2>
<p>Currently, all futures in Dioxus must be <code>'static</code>. To spawn a future, simply call <code>cx.spawn()</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rsx!{
    button {
        onclick: move |_| cx.spawn(async move {
            let result = fetch_thing().await;
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Calling <code>spawn</code> will give you a <code>JoinHandle</code> which lets you cancel or pause the future.</p>
<h2 id="setting-state-from-within-a-future"><a class="header" href="#setting-state-from-within-a-future">Setting state from within a future</a></h2>
<p>If you start to write some async code, you'll quickly be greeted with the infamous error about borrowed items in static closures.</p>
<pre><code>error[E0759]: `cx` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement
  --&gt; examples/tasks.rs:13:27
   |
12 | fn app(cx: Scope) -&gt; Element {
   |            ----- this data with an anonymous lifetime `'_`...
13 |     let count = use_state(&amp;cx, || 0);
   |                           ^^^ ...is used here...
14 |
15 |     use_future(&amp;cx, (), move |_| {
   |     ---------- ...and is required to live as long as `'static` here
   |
note: `'static` lifetime requirement introduced by this bound
  --&gt; /Users/jonkelley/Development/dioxus/packages/hooks/src/usefuture.rs:25:29
   |
25 |     F: Future&lt;Output = T&gt; + 'static,
   |                             ^^^^^^^

For more information about this error, try `rustc --explain E0759`.
error: could not compile `dioxus` due to previous error
</code></pre>
<p>Rustc tends to provide great feedback in its errors, but this particular error is actually quite unhelpful. For reference, here's our code:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let count = use_state(&amp;cx, || 0);

    cx.spawn(async move {
        tokio::time::sleep(Duration::from_millis(1000)).await;
        count += 1;
    });

    cx.render(rsx! {
        button {
            onclick: move |_| count.set(0),
            &quot;Reset the count&quot;
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Simple, right? We spawn a future that updates the value after one second has passed. Well, yes, and no. Our <code>count</code> value is only valid for the lifetime of this component, but our future could still be running even after the component re-renders. By default, Dioxus places a requirement on all futures to be <code>'static</code>, meaning they can't just borrow state from our hooks outright.</p>
<p>To get around this, we need to get a <code>'static</code> handle to our state. All Dioxus hooks implement <code>Clone</code>, so you simply need to call clone before spawning your future. Any time you get the particular error above, make sure you call <code>Clone</code> or <code>ToOwned</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.spawn({
    let mut count = count.clone();
    async move {
        tokio::time::sleep(Duration::from_millis(1000)).await;
        count += 1;
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>To make this a little bit easier, Dioxus exports the <code>to_owned!</code> macro which will create a binding as shown above, which can be quite helpful when dealing with many values.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cx.spawn({
    to_owned![count, age, name, description, etc];
    async move {
        tokio::time::sleep(Duration::from_millis(1000)).await;
        count += 1;
    }
});
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usefuture"><a class="header" href="#usefuture">UseFuture</a></h1>
<p>When dealing with asynchronous code, you might need to wait for some action to complete before rendering your component. If you had to build this abstraction yourself, you'd probably end up with some <code>use_state</code> spaghetti code.</p>
<p>One of the core hooks that Dioxus provides is <code>use_future</code> - a simple hook that lets you tap into a running task.</p>
<h2 id="use-case"><a class="header" href="#use-case">Use case</a></h2>
<p>The simplest use case of <code>use_future</code> is to prevent rendering until some asynchronous code has been completed. Dioxus doesn't currently have a library as sophisticated as React Query for prefetching tasks, but we can get some of the way there with <code>use_future</code>. In one of the Dioxus examples, we use <code>use_future</code> to download some search data before rendering the rest of the app:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    // set &quot;breeds&quot; to the current value of the future
    let breeds = use_future(&amp;cx, (), |_| async move {
        reqwest::get(&quot;https://dog.ceo/api/breeds/list/all&quot;)
            .await
            .unwrap()
            .json::&lt;ListBreeds&gt;()
            .await
    });

    let status = match breeds.value() {
        Some(Ok(val)) =&gt; &quot;ready!&quot;,
        Some(Err(err)) =&gt; &quot;errored!&quot;,
        None =&gt; &quot;loading!&quot;,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>On first run, the code inside <code>use_future</code> will be submitted to the Dioxus scheduler once the component has rendered. Since there's no data ready when the component loads the first time, its &quot;value&quot; will be <code>None</code>.</p>
<p>However, once the future is finished, the component will be re-rendered and a new screen will be displayed - Ok or Err, depending on the outcome of our fetch.</p>
<h2 id="restarting-the-future"><a class="header" href="#restarting-the-future">Restarting the Future</a></h2>
<p>The example we showed above will only ever run once. What happens if some value changed on the server and we need to update our future's value?</p>
<p>Well, the UseFuture handle provides a handy &quot;restart&quot; method. We can wire this up to a button or some other comparison code to get a regenerating future.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    // set &quot;breeds&quot; to the current value of the future
    let dog = use_future(&amp;cx, (), |_| async move {
        reqwest::get(&quot;https://dog.ceo/api/breeds/image/random&quot;)
            .await
            .unwrap()
            .json::&lt;RandomDog&gt;()
            .await
    });

    cx.render(match breeds.value() {
        Some(Ok(val)) =&gt; rsx!(div {
            img { src: &quot;{val.message}&quot;}
            button {
                onclick: move |_| dog.restart(),
                &quot;Click to fetch a new dog&quot;
            }
        }),
        Some(Err(err)) =&gt; rsx!(&quot;Failed to load dog&quot;),
        None =&gt; rsx!(&quot;Loading dog image!&quot;),
    })
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="with-dependencies"><a class="header" href="#with-dependencies">With Dependencies</a></h2>
<p>We showed that UseFuture can be regenerated manually, but how can we automatically get it to update whenever some input value changes? This is where the &quot;dependencies&quot; tuple comes into play. We just need to add a value into our tuple argument and it'll be automatically cloned into our future when it starts.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline_props]
fn RandomDog(cx: Scope, breed: String) -&gt; Element {
    let dog = use_future(&amp;cx, (breed,), |(breed)| async move {
        reqwest::get(format!(&quot;https://dog.ceo/api/breed/{breed}/images/random&quot;))
            .await
            .unwrap()
            .json::&lt;RandomDog&gt;()
            .await
    });

    // some code as before
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coroutines"><a class="header" href="#coroutines">Coroutines</a></h1>
<p>Another good tool to keep in your async toolbox are coroutines. Coroutines are futures that can be manually stopped, started, paused, and resumed.</p>
<p>Like regular futures, code in a Dioxus coroutine will run until the next <code>await</code> point before yielding. This low-level control over asynchronous tasks is quite powerful, allowing for infinitely looping tasks like WebSocket polling, background timers, and other periodic actions.</p>
<h2 id="use_coroutine"><a class="header" href="#use_coroutine"><code>use_coroutine</code></a></h2>
<p>The basic setup for coroutines is the <code>use_coroutine</code> hook. Most coroutines we write will be polling loops using async/await.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn app(cx: Scope) -&gt; Element {
    let ws: &amp;UseCoroutine&lt;()&gt; = use_coroutine(&amp;cx, |rx| async move {
        // Connect to some sort of service
        let mut conn = connect_to_ws_server().await;

        // Wait for data on the service
        while let Some(msg) = conn.next().await {
            // handle messages
        }
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>For many services, a simple async loop will handle the majority of use cases.</p>
<p>However, if we want to temporarily disable the coroutine, we can &quot;pause&quot; it using the <code>pause</code> method, and &quot;resume&quot; it using the <code>resume</code> method:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sync: &amp;UseCoroutine&lt;()&gt; = use_coroutine(&amp;cx, |rx| async move {
    // code for syncing
});

if sync.is_running() {
    cx.render(rsx!{
        button {
            onclick: move |_| sync.pause(),
            &quot;Disable syncing&quot;
        }
    })
} else {
    cx.render(rsx!{
        button {
            onclick: move |_| sync.resume(),
            &quot;Enable syncing&quot;
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>This pattern is where coroutines are extremely useful - instead of writing all the complicated logic for pausing our async tasks like we would with JavaScript promises, the Rust model allows us to just not poll our future.</p>
<h2 id="sending-values"><a class="header" href="#sending-values">Sending Values</a></h2>
<p>You might've noticed the <code>use_coroutine</code> closure takes an argument called <code>rx</code>. What is that? Well, a common pattern in complex apps is to handle a bunch of async code at once. With libraries like Redux Toolkit, managing multiple promises at once can be challenging and a common source of bugs.</p>
<p>With Coroutines, we have the opportunity to centralize our async logic. The <code>rx</code> parameter is an Unbounded Channel for code external to the coroutine to send data <em>into</em> the coroutine. Instead of looping on an external service, we can loop on the channel itself, processing messages from within our app without needing to spawn a new future. To send data into the coroutine, we would call &quot;send&quot; on the handle.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ProfileUpdate {
    SetUsername(String),
    SetAge(i32)
}

let profile = use_coroutine(&amp;cx, |mut rx: UnboundedReciver&lt;ProfileUpdate&gt;| async move {
    let mut server = connect_to_server().await;

    while let Ok(msg) = rx.next().await {
        match msg {
            ProfileUpdate::SetUsername(name) =&gt; server.update_username(name).await,
            ProfileUpdate::SetAge(age) =&gt; server.update_age(age).await,
        }
    }
});


cx.render(rsx!{
    button {
        onclick: move |_| profile.send(ProfileUpdate::SetUsername(&quot;Bob&quot;.to_string())),
        &quot;Update username&quot;
    }
})
<span class="boring">}
</span></code></pre></pre>
<p>For sufficiently complex apps, we could build a bunch of different useful &quot;services&quot; that loop on channels to update the app.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let profile = use_coroutine(&amp;cx, profile_service);
let editor = use_coroutine(&amp;cx, editor_service);
let sync = use_coroutine(&amp;cx, sync_service);

async fn profile_service(rx: UnboundedReceiver&lt;ProfileCommand&gt;) {
    // do stuff
}

async fn sync_service(rx: UnboundedReceiver&lt;SyncCommand&gt;) {
    // do stuff
}

async fn editor_service(rx: UnboundedReceiver&lt;EditorCommand&gt;) {
    // do stuff
}
<span class="boring">}
</span></code></pre></pre>
<p>We can combine coroutines with Fermi to emulate Redux Toolkit's Thunk system with much less headache. This lets us store all of our app's state <em>within</em> a task and then simply update the &quot;view&quot; values stored in Atoms. It cannot be understated how powerful this technique is: we get all the perks of native Rust tasks with the optimizations and ergonomics of global state. This means your <em>actual</em> state does not need to be tied up in a system like Fermi or Redux - the only Atoms that need to exist are those that are used to drive the display/UI.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static USERNAME: Atom&lt;String&gt; = |_| &quot;default&quot;.to_string();

fn app(cx: Scope) -&gt; Element {
    let atoms = use_atom_root(&amp;cx);

    use_coroutine(&amp;cx, |rx| sync_service(rx, atoms.clone()));

    cx.render(rsx!{
        Banner {}
    })
}

fn Banner(cx: Scope) -&gt; Element {
    let username = use_read(&amp;cx, USERNAME);

    cx.render(rsx!{
        h1 { &quot;Welcome back, {username}&quot; }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, in our sync service, we can structure our state however we want. We only need to update the view values when ready.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SyncAction {
    SetUsername(String),
}

async fn sync_service(mut rx: UnboundedReceiver&lt;SyncAction&gt;, atoms: AtomRoot) {
    let username = atoms.write(USERNAME);
    let errors = atoms.write(ERRORS);

    while let Ok(msg) = rx.next().await {
        match msg {
            SyncAction::SetUsername(name) =&gt; {
                if set_name_on_server(&amp;name).await.is_ok() {
                    username.set(name);
                } else {
                    errors.make_mut().push(&quot;SetUsernameFailed&quot;);
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="yielding-values"><a class="header" href="#yielding-values">Yielding Values</a></h2>
<p>To yield values from a coroutine, simply bring in a <code>UseState</code> handle and set the value whenever your coroutine completes its work.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sync_status = use_state(&amp;cx, || Status::Launching);
let sync_task = use_coroutine(&amp;cx, |rx: UnboundedReceiver&lt;SyncAction&gt;| {
    to_owned![sync_status];
    async move {
        loop {
            delay_ms(1000).await;
            sync_status.set(Status::Working);
        }
    }
})
<span class="boring">}
</span></code></pre></pre>
<h2 id="automatic-injection-into-the-context-api"><a class="header" href="#automatic-injection-into-the-context-api">Automatic injection into the Context API</a></h2>
<p>Coroutine handles are automatically injected through the context API. <code>use_coroutine_handle</code> with the message type as a generic can be used to fetch a handle.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Child(cx: Scope) -&gt; Element {
    let sync_task = use_coroutine_handle::&lt;SyncAction&gt;(&amp;cx);

    sync_task.send(SyncAction::SetUsername);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="congrats"><a class="header" href="#congrats">Congrats!</a></h1>
<p>Congrats! You've made it through the <code>learning Dioxus</code> book. Throughout this tutorial, you've learned a ton:</p>
<ul>
<li>How to build User Interfaces with Elements</li>
<li>How to compose Element groups together as Components</li>
<li>How to handle user input with event listeners</li>
<li>How to manage local and global state</li>
<li>How to work with async using tasks, coroutines, and suspense</li>
<li>How to build custom hooks and handlers</li>
</ul>
<p>With any luck, you followed through the &quot;Putting it All Together&quot; mini guide and have your very own dog search engine app!</p>
<h1 id="next-steps-and-advanced-topics"><a class="header" href="#next-steps-and-advanced-topics">Next Steps and Advanced Topics</a></h1>
<p>Continuing on your journey with Dioxus, you can try a number of things:</p>
<ul>
<li>Build a simple TUI app</li>
<li>Publish your search engine app</li>
<li>Deploy a WASM app to GitHub</li>
<li>Design a custom hook</li>
<li>Contribute to the ecosystem!</li>
</ul>
<p>There are a number of advanced topics we glossed over:</p>
<ul>
<li>The underlying NodeFactory API</li>
<li>Static elements and templates</li>
<li>Anti-patterns</li>
<li>Bundling/distribution</li>
<li>Working with wasm apps</li>
</ul>
<h1 id="contributing-to-the-ecosystem"><a class="header" href="#contributing-to-the-ecosystem">Contributing to the ecosystem</a></h1>
<p>Dioxus is still quite young and could use your help!</p>
<p>The core team is actively working on:</p>
<ul>
<li>Declarative window management (via Tauri) for Desktop apps</li>
<li>Portals for Dioxus Core</li>
<li>Mobile support</li>
<li>Integration with 3D renderers</li>
<li>Better async story (suspense, error handling)</li>
<li>Global state management</li>
<li>Web development server</li>
<li>LiveView</li>
<li>Broader platform support (iOS/Android/TV/embedded)</li>
</ul>
<p>If there's something specifically interesting to you, don't be afraid to jump in!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>All pull requests (including those made by a team member) must be approved by at least one other team member.
Larger, more nuanced decisions about design, architecture, breaking changes, trade offs, etc are made by team consensus.</p>
<p>Contributors to this guide:</p>
<ul>
<li><a href="https://github.com/jkelleyrtp">jkelleyrtp</a></li>
<li><a href="https://github.com/alexkirsz">alexkirsz</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
                <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
                <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
