<SYSTEM>This is the developer documentation for Dioxus from /learn/0.5/migration/fermi.</SYSTEM>
# Fermi

In dioxus 0.5, fermi atoms have been replaced with global signals and included in the main dioxus library.

The new global signals can be used directly without hooks and include additional functionality like global memos.

Dioxus 0.4:

````rust
use dioxus::prelude::*;
use fermi::*;

static NAME: Atom<String> = Atom(|_| "world".to_string());
static NAMES: AtomRef<Vec<String>> = AtomRef(|_| vec!["world".to_string()]);

fn app(cx: Scope) -> Element {
    use_init_atom_root(cx);
    let set_name = use_set(cx, &NAME);
	let names = use_atom_ref(cx, &NAMES);

    cx.render(rsx! {
        button {
			onclick: move |_| set_name("dioxus".to_string()),
			"reset name"
		}
		"{names.read():?}"
    })
}
````

Dioxus 0.5:

````rs@migration_fermi.rs
use dioxus::prelude::*;

static NAME: GlobalSignal<String> = Signal::global(|| "world".to_string());
// Global signals work for copy and clone types in the same way
static NAMES: GlobalSignal<Vec<String>> = Signal::global(|| vec!["world".to_string()]);

fn app() -> Element {
    // No need to use use_init_atom_root, use_set, or use_atom_ref. Just use the global signal directly
    rsx! {
        button { onclick: move |_| *NAME.write() = "reset name".to_string(), "reset name" }
        "{NAMES:?}"
    }
}
````

## Memos

Dioxus 0.5 introduces global memos which can be used to store computed values globally.

````rs@migration_fermi.rs
static COUNT: GlobalSignal<u32> = Signal::global(|| 0);
static MEMO: GlobalMemo<u32> = Signal::global_memo(|| COUNT() + 1);

fn GlobalMemo() -> Element {
    rsx! {
        button { onclick: move |_| *COUNT.write() += 1, "increment" }
        // Global memos can be used like signals
        "{MEMO}"
    }
}
````
# Fermi

In dioxus 0.5, fermi atoms have been replaced with global signals and included in the main dioxus library.

The new global signals can be used directly without hooks and include additional functionality like global memos.

Dioxus 0.4:

````rust
use dioxus::prelude::*;
use fermi::*;

static NAME: Atom<String> = Atom(|_| "world".to_string());
static NAMES: AtomRef<Vec<String>> = AtomRef(|_| vec!["world".to_string()]);

fn app(cx: Scope) -> Element {
    use_init_atom_root(cx);
    let set_name = use_set(cx, &NAME);
	let names = use_atom_ref(cx, &NAMES);

    cx.render(rsx! {
        button {
			onclick: move |_| set_name("dioxus".to_string()),
			"reset name"
		}
		"{names.read():?}"
    })
}
````

Dioxus 0.5:

````rs@migration_fermi.rs
use dioxus::prelude::*;

static NAME: GlobalSignal<String> = Signal::global(|| "world".to_string());
// Global signals work for copy and clone types in the same way
static NAMES: GlobalSignal<Vec<String>> = Signal::global(|| vec!["world".to_string()]);

fn app() -> Element {
    // No need to use use_init_atom_root, use_set, or use_atom_ref. Just use the global signal directly
    rsx! {
        button { onclick: move |_| *NAME.write() = "reset name".to_string(), "reset name" }
        "{NAMES:?}"
    }
}
````

## Memos

Dioxus 0.5 introduces global memos which can be used to store computed values globally.

````rs@migration_fermi.rs
static COUNT: GlobalSignal<u32> = Signal::global(|| 0);
static MEMO: GlobalMemo<u32> = Signal::global_memo(|| COUNT() + 1);

fn GlobalMemo() -> Element {
    rsx! {
        button { onclick: move |_| *COUNT.write() += 1, "increment" }
        // Global memos can be used like signals
        "{MEMO}"
    }
}
````