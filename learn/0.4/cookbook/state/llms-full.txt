<SYSTEM>This is the developer documentation for Dioxus at /learn/0.4/cookbook/state/external/ and all its subroutes.</SYSTEM>

# Working with External State

This guide will help you integrate your Dioxus application with some external state like a different thread or a websocket connection.

## Working with non-reactive State

[Coroutines](../../../reference/use_coroutine.md) are great tool for dealing with non-reactive (state you don't render directly) state within your application.

You can store your state inside the coroutine async block and communicate with the coroutine with messages from any child components.

````rs@use_coroutine.rs
// import futures::StreamExt to use the next() method
use futures::StreamExt;
let response_state = use_state(cx, || None);
let tx = use_coroutine(cx, |mut rx| {
    to_owned![response_state];
    async move {
        // Define your state before the loop
        let mut state = reqwest::Client::new();
        let mut cache: HashMap<String, String> = HashMap::new();
        loop {
            // Loop and wait for the next message
            if let Some(request) = rx.next().await {
                // Resolve the message
                let response = if let Some(response) = cache.get(&request) {
                    response.clone()
                } else {
                    let response = state
                        .get(&request)
                        .send()
                        .await
                        .unwrap()
                        .text()
                        .await
                        .unwrap();
                    cache.insert(request, response.clone());
                    response
                };
                response_state.set(Some(response));
            } else {
                break;
            }
        }
    }
});
// Send a message to the coroutine
tx.send("https://example.com".to_string());
// Get the current state of the coroutine
let response = response_state.get();
````

## Making Reactive State External

If you have some reactive state (state that is rendered), that you want to modify from another thread, you can use the [use_rw](https://github.com/DioxusLabs/dioxus-std/blob/master/src/utils/rw/use_rw.rs) hook in the [dioxus-std](https://github.com/DioxusLabs/dioxus-std) crate.

The use_rw hook works like the use_ref hook, but it is Send + Sync which makes it possible to move the hook into another thread.
# Custom Hooks

Hooks are a great way to encapsulate business logic. If none of the existing hooks work for your problem, you can write your own.

When writing your hook, you can make a function that accepts `cx: &ScopeState` as a parameter to accept a scope with any Props.

## Composing Hooks

To avoid repetition, you can encapsulate business logic based on existing hooks to create a new hook.

For example, if many components need to access an `AppSettings` struct, you can create a "shortcut" hook:

````rs@hooks_composed.rs
fn use_settings(cx: &ScopeState) -> &UseSharedState<AppSettings> {
    use_shared_state::<AppSettings>(cx).expect("App settings not provided")
}
````

Or if you want to wrap a hook that persists reloads with the storage API, you can build on top of the use_ref hook to work with mutable state:

````rs@hooks_composed.rs
use gloo_storage::{LocalStorage, Storage};
use serde::{de::DeserializeOwned, Serialize};

/// A persistent storage hook that can be used to store data across application reloads.
#[allow(clippy::needless_return)]
pub fn use_persistent<T: Serialize + DeserializeOwned + Default + 'static>(
    cx: &ScopeState,
    // A unique key for the storage entry
    key: impl ToString,
    // A function that returns the initial value if the storage entry is empty
    init: impl FnOnce() -> T,
) -> &UsePersistent<T> {
    // Use the use_ref hook to create a mutable state for the storage entry
    let state = use_ref(cx, move || {
        // This closure will run when the hook is created
        let key = key.to_string();
        let value = LocalStorage::get(key.as_str()).ok().unwrap_or_else(init);
        StorageEntry { key, value }
    });

    // Wrap the state in a new struct with a custom API
    // Note: We use use_hook here so that this hook is easier to use in closures in the rsx. Any values with the same lifetime as the ScopeState can be used in the closure without cloning.
    cx.use_hook(|| UsePersistent {
        inner: state.clone(),
    })
}

struct StorageEntry<T> {
    key: String,
    value: T,
}

/// Storage that persists across application reloads
pub struct UsePersistent<T: 'static> {
    inner: UseRef<StorageEntry<T>>,
}

impl<T: Serialize + DeserializeOwned + Clone + 'static> UsePersistent<T> {
    /// Returns a reference to the value
    pub fn get(&self) -> T {
        self.inner.read().value.clone()
    }

    /// Sets the value
    pub fn set(&self, value: T) {
        let mut inner = self.inner.write();
        // Write the new value to local storage
        LocalStorage::set(inner.key.as_str(), &value);
        inner.value = value;
    }
}
````

## Custom Hook Logic

You can use [`cx.use_hook`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.use_hook) to build your own hooks. In fact, this is what all the standard hooks are built on!

`use_hook` accepts a single closure for initializing the hook. It will be only run the first time the component is rendered. The return value of that closure will be used as the value of the hook – Dioxus will take it, and store it for as long as the component is alive. On every render (not just the first one!), you will get a reference to this value.

 > 
 > Note: You can implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) for your hook value – it will be dropped then the component is unmounted (no longer in the UI)

Inside the initialization closure, you will typically make calls to other `cx` methods. For example:

* The `use_state` hook tracks state in the hook value, and uses [`cx.schedule_update`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.schedule_update) to make Dioxus re-render the component whenever it changes.

Here is a simplified implementation of the `use_state` hook:

````rs@hooks_custom_logic.rs
use std::cell::RefCell;
use std::rc::Rc;
use std::sync::Arc;

#[derive(Clone)]
struct UseState<T> {
    value: Rc<RefCell<T>>,
    update: Arc<dyn Fn()>,
}

fn my_use_state<T: 'static>(cx: &ScopeState, init: impl FnOnce() -> T) -> &UseState<T> {
    cx.use_hook(|| {
        // The update function will trigger a re-render in the component cx is attached to
        let update = cx.schedule_update();
        // Create the initial state
        let value = Rc::new(RefCell::new(init()));

        UseState { value, update }
    })
}

impl<T: Clone> UseState<T> {
    fn get(&self) -> T {
        self.value.borrow().clone()
    }

    fn set(&self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render on the component the state is from
        (self.update)();
    }
}
````

* The `use_context` hook calls [`cx.consume_context`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.consume_context) (which would be expensive to call on every render) to get some context from the scope

Here is an implementation of the `use_context` and `use_context_provider` hooks:

````rs@hooks_custom_logic.rs
pub fn use_context<T: 'static + Clone>(cx: &ScopeState) -> Option<&T> {
    cx.use_hook(|| cx.consume_context::<T>()).as_ref()
}

pub fn use_context_provider<T: 'static + Clone>(cx: &ScopeState, f: impl FnOnce() -> T) -> &T {
    cx.use_hook(|| {
        let val = f();
        // Provide the context state to the scope
        cx.provide_context(val.clone());
        val
    })
}

````

## Hook Anti-Patterns

When writing a custom hook, you should avoid the following anti-patterns:

* !Clone Hooks: To allow hooks to be used within async blocks, the hooks must be Clone. To make a hook clone, you can wrap data in Rc or Arc and avoid lifetimes in hooks.

This version of use_state may seem more efficient, but it is not cloneable:

````rs@hooks_anti_patterns.rs
use std::cell::RefCell;
use std::rc::Rc;
use std::sync::Arc;

struct UseState<'a, T> {
    value: &'a RefCell<T>,
    update: Arc<dyn Fn()>,
}

fn my_use_state<T: 'static>(cx: &ScopeState, init: impl FnOnce() -> T) -> UseState<T> {
    // The update function will trigger a re-render in the component cx is attached to
    let update = cx.schedule_update();
    // Create the initial state
    let value = cx.use_hook(|| RefCell::new(init()));

    UseState { value, update }
}

impl<T: Clone> UseState<'_, T> {
    fn get(&self) -> T {
        self.value.borrow().clone()
    }

    fn set(&self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render on the component the state is from
        (self.update)();
    }
}
````

If we try to use this hook in an async block, we will get a compile error:

````rust
fn FutureComponent(cx: &ScopeState) -> Element {
	let my_state = my_use_state(cx, || 0);
	cx.spawn({
		to_owned![my_state];
		async move {
			my_state.set(1);
		}
	});

	todo!()
}
````

But with the original version, we can use it in an async block:

````rust
fn FutureComponent(cx: &ScopeState) -> Element {
	let my_state = use_state(cx, || 0);
	cx.spawn({
		to_owned![my_state];
		async move {
			my_state.set(1);
		}
	});

	todo!()
}
````
