<SYSTEM>This is the developer documentation for Dioxus from /learn/0.3/describing_ui/.</SYSTEM>
# Describing the UI

Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* what we want the UI to look like using RSX.

You have already seen a simple example of RSX syntax in the "hello world" application:

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

Here, we use the `rsx!` macro to *declare* that we want a `div` element, containing the text `"Hello, world!"`. Dioxus takes the RSX and constructs a UI from it.

## RSX Features

RSX is very similar to HTML in that it describes elements with attributes and children. Here's an empty `div` element in RSX, as well as the resulting HTML:

````rs@rsx_overview.rs
cx.render(rsx!(div {
// attributes / listeners
// children
}))
````

````html
<div></div>
````

### Attributes

Attributes (and [listeners](../interactivity/index.md)) modify the behavior or appearance of the element they are attached to. They are specified inside the `{}` brackets, using the `name: value` syntax. You can provide the value as a literal in the RSX:

````rs@rsx_overview.rs
cx.render(rsx!(a {
href: "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
class: "primary_button",
color: "red",
}))
````

````html
<a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ" class="primary_button" autofocus="true" style="color: red"></a>
````

 > 
 > Note: All attributes defined in `dioxus-html` follow the snake_case naming convention. They transform their `snake_case` names to HTML's `camelCase` attributes.

 > 
 > Note: Styles can be used directly outside of the `style:` attribute. In the above example, `color: "red"` is turned into `style="color: red"`.

#### Custom Attributes

Dioxus has a pre-configured set of attributes that you can use. RSX is validated at compile time to make sure you didn't specify an invalid attribute. If you want to override this behavior with a custom attribute name, specify the attribute in quotes:

````rs@rsx_overview.rs
cx.render(rsx!(b {
    "customAttribute": "value",
}))
````

````html
<b customAttribute="value">
</b>
````

### Interpolation

Similarly to how you can [format](https://doc.rust-lang.org/rust-by-example/hello/print/fmt.html) Rust strings, you can also interpolate in RSX text. Use `{variable}` to Display the value of a variable in a string, or `{variable:?}` to use the Debug representation:

````rs@rsx_overview.rs
let coordinates = (42, 0);
let country = "es";
cx.render(rsx!(div {
class: "country-{country}",
"position": "{coordinates:?}",
// arbitrary expressions are allowed,
// as long as they don't contain `{}`
div {
    "{country.to_uppercase()}"
},
div {
    "{7*6}"
},
// {} can be escaped with {{}}
div {
    "{{}}"
},
}))
````

````html
<div class="country-es" position="(42, 0)">
    <div>ES</div>
    <div>42</div>
    <div>{}</div>
</div>
````

### Children

To add children to an element, put them inside the `{}` brackets after all attributes and listeners in the element. They can be other elements, text, or [components](components.md). For example, you could have an `ol` (ordered list) element, containing 3 `li` (list item) elements, each of which contains some text:

````rs@rsx_overview.rs
cx.render(rsx!(ol {
li {"First Item"}
li {"Second Item"}
li {"Third Item"}
}))
````

````html
<ol>
    <li>First Item</li>
    <li>Second Item</li>
    <li>Third Item</li>
</ol>
````

### Fragments

You can render multiple elements at the top level of `rsx!` and they will be automatically grouped.

````rs@rsx_overview.rs
cx.render(rsx!(
p {"First Item"},
p {"Second Item"},
))
````

````html
<p>First Item</p>
<p>Second Item</p>
````

### Expressions

You can include arbitrary Rust expressions as children within RSX that implements [IntoDynNode](https://docs.rs/dioxus-core/0.3/dioxus_core/trait.IntoDynNode.html). This is useful for displaying data from an [iterator](https://doc.rust-lang.org/stable/book/ch13-02-iterators.html#processing-a-series-of-items-with-iterators):

````rs@rsx_overview.rs
let text = "Dioxus";
cx.render(rsx!(span {
text.to_uppercase(),
// create a list of text from 0 to 9
(0..10).map(|i| rsx!{ i.to_string() })
}))
````

````html
<span>DIOXUS0123456789</span>
````

### Loops

In addition to iterators you can also use for loops directly within RSX:

````rs@rsx_overview.rs
cx.render(rsx!{
// use a for loop where the body itself is RSX
div {
    // create a list of text from 0 to 9
    for i in 0..3 {
        // NOTE: the body of the loop is RSX not a rust statement
        div {
            "{i}"
        }
    }
}
// iterator equivalent
div {
    (0..3).map(|i| rsx!{ div { "{i}" } })
}
})
````

````html
<div>0</div>
<div>1</div>
<div>2</div>
<div>0</div>
<div>1</div>
<div>2</div>
````

### If statements

You can also use if statements without an else branch within RSX:

````rs@rsx_overview.rs
cx.render(rsx!{
// use if statements without an else
if true {
    rsx!(div { "true" })
}
})
````

````html
<div>true</div>
````
# Describing the UI

Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* what we want the UI to look like using RSX.

You have already seen a simple example of RSX syntax in the "hello world" application:

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

Here, we use the `rsx!` macro to *declare* that we want a `div` element, containing the text `"Hello, world!"`. Dioxus takes the RSX and constructs a UI from it.

## RSX Features

RSX is very similar to HTML in that it describes elements with attributes and children. Here's an empty `div` element in RSX, as well as the resulting HTML:

````rs@rsx_overview.rs
cx.render(rsx!(div {
// attributes / listeners
// children
}))
````

````html
<div></div>
````

### Attributes

Attributes (and [listeners](../interactivity/index.md)) modify the behavior or appearance of the element they are attached to. They are specified inside the `{}` brackets, using the `name: value` syntax. You can provide the value as a literal in the RSX:

````rs@rsx_overview.rs
cx.render(rsx!(a {
href: "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
class: "primary_button",
color: "red",
}))
````

````html
<a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ" class="primary_button" autofocus="true" style="color: red"></a>
````

 > 
 > Note: All attributes defined in `dioxus-html` follow the snake_case naming convention. They transform their `snake_case` names to HTML's `camelCase` attributes.

 > 
 > Note: Styles can be used directly outside of the `style:` attribute. In the above example, `color: "red"` is turned into `style="color: red"`.

#### Custom Attributes

Dioxus has a pre-configured set of attributes that you can use. RSX is validated at compile time to make sure you didn't specify an invalid attribute. If you want to override this behavior with a custom attribute name, specify the attribute in quotes:

````rs@rsx_overview.rs
cx.render(rsx!(b {
    "customAttribute": "value",
}))
````

````html
<b customAttribute="value">
</b>
````

### Interpolation

Similarly to how you can [format](https://doc.rust-lang.org/rust-by-example/hello/print/fmt.html) Rust strings, you can also interpolate in RSX text. Use `{variable}` to Display the value of a variable in a string, or `{variable:?}` to use the Debug representation:

````rs@rsx_overview.rs
let coordinates = (42, 0);
let country = "es";
cx.render(rsx!(div {
class: "country-{country}",
"position": "{coordinates:?}",
// arbitrary expressions are allowed,
// as long as they don't contain `{}`
div {
    "{country.to_uppercase()}"
},
div {
    "{7*6}"
},
// {} can be escaped with {{}}
div {
    "{{}}"
},
}))
````

````html
<div class="country-es" position="(42, 0)">
    <div>ES</div>
    <div>42</div>
    <div>{}</div>
</div>
````

### Children

To add children to an element, put them inside the `{}` brackets after all attributes and listeners in the element. They can be other elements, text, or [components](components.md). For example, you could have an `ol` (ordered list) element, containing 3 `li` (list item) elements, each of which contains some text:

````rs@rsx_overview.rs
cx.render(rsx!(ol {
li {"First Item"}
li {"Second Item"}
li {"Third Item"}
}))
````

````html
<ol>
    <li>First Item</li>
    <li>Second Item</li>
    <li>Third Item</li>
</ol>
````

### Fragments

You can render multiple elements at the top level of `rsx!` and they will be automatically grouped.

````rs@rsx_overview.rs
cx.render(rsx!(
p {"First Item"},
p {"Second Item"},
))
````

````html
<p>First Item</p>
<p>Second Item</p>
````

### Expressions

You can include arbitrary Rust expressions as children within RSX that implements [IntoDynNode](https://docs.rs/dioxus-core/0.3/dioxus_core/trait.IntoDynNode.html). This is useful for displaying data from an [iterator](https://doc.rust-lang.org/stable/book/ch13-02-iterators.html#processing-a-series-of-items-with-iterators):

````rs@rsx_overview.rs
let text = "Dioxus";
cx.render(rsx!(span {
text.to_uppercase(),
// create a list of text from 0 to 9
(0..10).map(|i| rsx!{ i.to_string() })
}))
````

````html
<span>DIOXUS0123456789</span>
````

### Loops

In addition to iterators you can also use for loops directly within RSX:

````rs@rsx_overview.rs
cx.render(rsx!{
// use a for loop where the body itself is RSX
div {
    // create a list of text from 0 to 9
    for i in 0..3 {
        // NOTE: the body of the loop is RSX not a rust statement
        div {
            "{i}"
        }
    }
}
// iterator equivalent
div {
    (0..3).map(|i| rsx!{ div { "{i}" } })
}
})
````

````html
<div>0</div>
<div>1</div>
<div>2</div>
<div>0</div>
<div>1</div>
<div>2</div>
````

### If statements

You can also use if statements without an else branch within RSX:

````rs@rsx_overview.rs
cx.render(rsx!{
// use if statements without an else
if true {
    rsx!(div { "true" })
}
})
````

````html
<div>true</div>
````