<SYSTEM>This is the developer documentation for Dioxus at /learn/0.4/getting_started/ and all its subroutes.</SYSTEM>

# Getting Started

This section will help you set up your Dioxus project!

## Prerequisites

### An Editor

Dioxus integrates very well with the [Rust-Analyzer LSP plugin](https://rust-analyzer.github.io) which will provide appropriate syntax highlighting, code navigation, folding, and more.

### Rust

Head over to [https://rust-lang.org](http://rust-lang.org) and install the Rust compiler.

We strongly recommend going through the [official Rust book](https://doc.rust-lang.org/book/ch01-00-getting-started.html) *completely*. However, we hope that a Dioxus app can serve as a great first Rust project. With Dioxus, you'll learn about:

* Error handling
* Structs, Functions, Enums
* Closures
* Macros

We've put a lot of care into making Dioxus syntax familiar and easy to understand, so you won't need deep knowledge of async, lifetimes, or smart pointers until you start building complex Dioxus apps.

## Setup Guides

Dioxus supports multiple platforms. Choose the platform you want to target below to get platform-specific setup instructions:

* [Choosing a Web Renderer](choosing_a_web_renderer.md)
* [Client Side](wasm.md): runs in the browser through WebAssembly
* [Liveview](liveview.md): runs on the server, renders in the browser using WebSockets
* [Fullstack](fullstack.md): renders to HTML text on the server and hydrates it on the client
* [Desktop](desktop.md): runs in a web view on desktop
* [Mobile](mobile.md): runs in a web view on mobile
* [Terminal UI](tui.md): renders text-based graphics in the terminal

 > 
 > More information on any platform you choose is available in the section of the same name in the [Reference](../reference/index.md)
# Choosing a web renderer

Dioxus has three different renderers that target the web:

* [dioxus-web](wasm.md) allows you to render your application to HTML with [WebAssembly](https://rustwasm.github.io/docs/book/) on the client
* [dioxus-liveview](liveview.md) allows you to run your application on the server and render it to HTML on the client with a websocket
* [dioxus-fullstack](fullstack.md) allows you to initially render static HTML on the server and then update that HTML from the client with [WebAssembly](https://rustwasm.github.io/docs/book/)

Each approach has its tradeoffs:

### Dioxus Liveview

* Liveview rendering communicates with the server over a WebSocket connection. It essentially moves all of the work that Client-side rendering does to the server.

* This makes it **easy to communicate with the server, but more difficult to communicate with the client/browser APIS**.

* Each interaction also requires a message to be sent to the server and back which can cause **issues with latency**.

* Because Liveview uses a websocket to render, the page will be blank until the WebSocket connection has been established and the first renderer has been sent from the websocket. Just like with client side rendering, this can make the page **less SEO-friendly**.

* Because the page is rendered on the server and the page is sent to the client piece by piece, you never need to send the entire application to the client. The initial load time can be faster than client-side rendering with large applications because Liveview only needs to send a constant small websocket script regardless of the size of the application.

 > 
 > Liveview is a good fit for applications that already need to communicate with the server frequently (like real time collaborative apps), but don't need to communicate with as many client/browser APIs.

[![](https://mermaid.ink/img/pako:eNplULFOw0AM_RXLc7Mw3sBQVUIMRYgKdcli5ZzkRHIuPl8QqvrvXJICRXiy3nt-9-6dsRHP6DAZGe8CdUpjNd3VEcpsVT4SK1TVPRxYJ1YHL_yeOdkqWMGF3w4U32Y6nSQmXvknMQYNXW8g7bfk2JPBg0g3MCTmdH1rJhenx2is1FiYri43wJ8or3O2H1Liv0w3hw724kMb2MMzdcUYNziyjhR8-f15Pq3Reh65RldWzy3lwWqs46VIKZscPmODzjTzBvPJ__aFrqUhFZR9MNH92uhS7OULYSF1lw?type=png)](https://mermaid.live/edit#pako:eNplULFOw0AM_RXLc7Mw3sBQVUIMRYgKdcli5ZzkRHIuPl8QqvrvXJICRXiy3nt-9-6dsRHP6DAZGe8CdUpjNd3VEcpsVT4SK1TVPRxYJ1YHL_yeOdkqWMGF3w4U32Y6nSQmXvknMQYNXW8g7bfk2JPBg0g3MCTmdH1rJhenx2is1FiYri43wJ8or3O2H1Liv0w3hw724kMb2MMzdcUYNziyjhR8-f15Pq3Reh65RldWzy3lwWqs46VIKZscPmODzjTzBvPJ__aFrqUhFZR9MNH92uhS7OULYSF1lw)

### Dioxus Web

* With Client side rendering, you send your application to the client, and then the client generates all of the HTML of the page dynamically.

* This means that the page will be blank until the JavaScript bundle has loaded and the application has initialized. This can result in **slower first render times and poor SEO performance**.

 > 
 > SEO stands for Search Engine Optimization. It refers to the practice of making your website more likely to appear in search engine results. Search engines like Google and Bing use web crawlers to index the content of websites. Most of these crawlers are not able to run JavaScript, so they will not be able to index the content of your page if it is rendered client-side.

* Client-side rendered applications need to use **weakly typed requests to communicate with the server**.

 > 
 > Client-side rendering is a good starting point for most applications. It is well supported and makes it easy to communicate with the client/browser APIs.

[![](https://mermaid.ink/img/pako:eNpVkDFPwzAQhf-KdXOzMHpgqJAQAwytEIsXK35JLBJfez4Xoar_HSemQtzke9_z2e-u1HMAWcrqFU_Rj-KX7vLgkqm1F_7KENN1j-YIuUCsOeBckLUZmrjx_ezT54rziVNG42-sMBLHSQ0Pd8vH5NU8M48zTAby71sr3CYdkAIEoen37h-y5n3910tSiO81cqIdLZDFx1DDXNerjnTCAke2HgMGX2Z15NKtWn1RPn6nnqxKwY7KKfzFJzv4OVcVISrLa1vQtqfbDzd0ZKY?type=png)](https://mermaid.live/edit#pako:eNpVkDFPwzAQhf-KdXOzMHpgqJAQAwytEIsXK35JLBJfez4Xoar_HSemQtzke9_z2e-u1HMAWcrqFU_Rj-KX7vLgkqm1F_7KENN1j-YIuUCsOeBckLUZmrjx_ezT54rziVNG42-sMBLHSQ0Pd8vH5NU8M48zTAby71sr3CYdkAIEoen37h-y5n3910tSiO81cqIdLZDFx1DDXNerjnTCAke2HgMGX2Z15NKtWn1RPn6nnqxKwY7KKfzFJzv4OVcVISrLa1vQtqfbDzd0ZKY)

### Dioxus Fullstack

Fullstack rendering happens in two parts:

1. The page is rendered on the server. This can include fetching any data you need to render the page.
1. The page is hydrated on the client. (Hydration is taking the HTML page from the server and adding all of the event listeners Dioxus needs on the client). Any updates to the page happen on the client after this point.

Because the page is initially rendered on the server, the page will be fully rendered when it is sent to the client. This results in a faster first render time and makes the page more SEO-friendly.

* **Fast initial render**
* **Works well with SEO**
* **Type safe easy communication with the server**
* **Access to the client/browser APIs**
* **Fast interactivity**

Finally, we can use [server functions](../reference/fullstack/server_functions.md) to communicate with the server in a type-safe way.

This approach uses both the dioxus-web and dioxus-ssr crates. To integrate those two packages and `axum`, `warp`, or `salvo`, Dioxus provides the `dioxus-fullstack` crate.

There can be more complexity with fullstack applications because your code runs in two different places. Dioxus tries to mitigate this with server functions and other helpers.

[![](https://mermaid.ink/img/pako:eNpdkL1uwzAMhF9F4BwvHTV0KAIUHdohQdFFi2CdbQG2mFCUiyDIu9e2-hOUE3H34UDelVoOIEtZvWIffS9-auYHl8wyT8KfGWKa5tEcITPEmgPOBVkrUMXNPyAFCMJK5BOnjIq8scJI7Ac13N1RH4NX88zcjzAZyJX-8bfIl6QQ32qcv7PuhP-ANe_rpb8KJ9rRBJl8DMt71zXAkQ6Y4Mgua0Dny6iOXLotqC_Kx0tqyaoU7Kicwl8hZDs_5kVFiMryWivbmrt9AacxbGg?type=png)](https://mermaid.live/edit#pako:eNpdkL1uwzAMhF9F4BwvHTV0KAIUHdohQdFFi2CdbQG2mFCUiyDIu9e2-hOUE3H34UDelVoOIEtZvWIffS9-auYHl8wyT8KfGWKa5tEcITPEmgPOBVkrUMXNPyAFCMJK5BOnjIq8scJI7Ac13N1RH4NX88zcjzAZyJX-8bfIl6QQ32qcv7PuhP-ANe_rpb8KJ9rRBJl8DMt71zXAkQ6Y4Mgua0Dny6iOXLotqC_Kx0tqyaoU7Kicwl8hZDs_5kVFiMryWivbmrt9AacxbGg)
# Web

Build single-page applications that run in the browser with Dioxus. To run on the Web, your app must be compiled to WebAssembly and depend on the `dioxus` and `dioxus-web` crates.

A build of Dioxus for the web will be roughly equivalent to the size of a React build (70kb vs 65kb) but it will load significantly faster because [WebAssembly can be compiled as it is streamed](https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/).

Examples:

* [TodoMVC](https://github.com/DioxusLabs/example-projects/tree/master/todomvc)
* [ECommerce](https://github.com/DioxusLabs/example-projects/tree/master/ecommerce-site)

[![TodoMVC example](https://github.com/DioxusLabs/example-projects/raw/master/todomvc/example.png)](https://github.com/DioxusLabs/example-projects/blob/master/todomvc)

 > 
 > Note: Because of the limitations of Wasm, [not every crate will work](https://rustwasm.github.io/docs/book/reference/which-crates-work-with-wasm.html) with your web apps, so you'll need to make sure that your crates work without native system calls (timers, IO, etc).

## Support

The Web is the best-supported target platform for Dioxus.

* Because your app will be compiled to WASM you have access to browser APIs through [wasm-bindgen](https://rustwasm.github.io/docs/wasm-bindgen/introduction.html).
* Dioxus provides hydration to resume apps that are rendered on the server. See the [fullstack](fullstack.md) getting started guide for more information.

## Tooling

To develop your Dioxus app for the web, you'll need a tool to build and serve your assets. We recommend using [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli) which includes a build system, Wasm optimization, a dev server, and support hot reloading:

````shell
cargo install dioxus-cli
````

Make sure the `wasm32-unknown-unknown` target for rust is installed:

````shell
rustup target add wasm32-unknown-unknown
````

## Creating a Project

Create a new crate:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the web renderer as dependencies (this will edit your `Cargo.toml`):

````bash
cargo add dioxus
cargo add dioxus-web
````

Edit your `main.rs`:

````rs@hello_world_web.rs
#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the web app
    dioxus_web::launch(App);
}

// create a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}

````

And to serve our app:

````bash
dx serve
````

If you open the browser and navigate to `127.0.0.1` you should see an app that looks like this:

````inject-dioxus
DemoFrame {
    hello_world::HelloWorldCounter {}
}
````

## Hot Reload

1. Hot reloading allows much faster iteration times inside of rsx calls by interpreting them and streaming the edits.
1. It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.

For the web renderer, you can use the dioxus cli to serve your application with hot reloading enabled.

### Setup

Install [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli).

### Usage

1. Run:

````bash
dx serve --hot-reload
````

2. Change some code within a rsx or render macro
2. Open your localhost in a browser
2. Save and watch the style change without recompiling

### Limitations

1. The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the rsx call, it will require a full recompile to capture the expression.
1. Components, Iterators, and some attributes can contain arbitrary rust code and will trigger a full recompile when changed.
# Liveview

Liveview allows apps to *run* on the server and *render* in the browser. It uses WebSockets to communicate between the server and the browser.

Examples:

* [Axum Example](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/axum.rs)
* [Salvo Example](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/salvo.rs)
* [Warp Example](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/warp.rs)

## Support

Liveview is currently limited in capability when compared to the Web platform. Liveview apps run on the server in a native thread. This means that browser APIs are not available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs are accessible, so streaming, WebSockets, filesystem, etc are all viable APIs.

## Setup

For this guide, we're going to show how to use Dioxus Liveview with [Axum](https://docs.rs/axum/latest/axum/).

Make sure you have Rust and Cargo installed, and then create a new project:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the liveview renderer with the Axum feature as dependencies:

````shell
cargo add dioxus
cargo add dioxus-liveview --features axum
````

Next, add all the Axum dependencies. This will be different if you're using a different Web Framework

````
cargo add tokio --features full
cargo add axum
````

Your dependencies should look roughly like this:

````toml
[dependencies]
axum = "0.4.5"
dioxus = { version = "*" }
dioxus-liveview = { version = "*", features = ["axum"] }
tokio = { version = "1.15.0", features = ["full"] }
````

Now, set up your Axum app to respond on an endpoint.

````rs@hello_world_liveview.rs
use axum::{extract::ws::WebSocketUpgrade, response::Html, routing::get, Router};
use dioxus::prelude::*;

#[tokio::main]
async fn main() {
    let addr: std::net::SocketAddr = ([127, 0, 0, 1], 3030).into();

    let view = dioxus_liveview::LiveViewPool::new();

    let app = Router::new()
        // The root route contains the glue code to connect to the WebSocket
        .route(
            "/",
            get(move || async move {
                Html(format!(
                    r#"
                <!DOCTYPE html>
                <html>
                <head> <title>Dioxus LiveView with Axum</title>  </head>
                <body> <div id="main"></div> </body>
                {glue}
                </html>
                "#,
                    // Create the glue code to connect to the WebSocket on the "/ws" route
                    glue = dioxus_liveview::interpreter_glue(&format!("ws://{addr}/ws"))
                ))
            }),
        )
        // The WebSocket route is what Dioxus uses to communicate with the browser
        .route(
            "/ws",
            get(move |ws: WebSocketUpgrade| async move {
                ws.on_upgrade(move |socket| async move {
                    // When the WebSocket is upgraded, launch the LiveView with the app component
                    _ = view.launch(dioxus_liveview::axum_socket(socket), app).await;
                })
            }),
        );

    println!("Listening on http://{addr}");

    axum::Server::bind(&addr.to_string().parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}
````

And then add our app component:

````rs@hello_world_liveview.rs
fn app(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

And that's it!

## Hot Reload

1. Hot reloading allows much faster iteration times inside of rsx calls by interpreting them and streaming the edits.
1. It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.

### Hot Reload Setup

Install [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli).

### Usage

1. Run:

````bash
dx serve --hot-reload --platform desktop
````

2. Change some code within `rsx` or `render` macro
2. Save and watch the style change without recompiling

### Limitations

1. The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the rsx call, it will require a full recompile to capture the expression.
1. Components, Iterators, and some attributes can contain arbitrary rust code and will trigger a full recompile when changed.
# Fullstack

 > 
 > This guide assumes you read the [Web](wasm.md) getting started guide and installed the [Dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli)

# Getting Started

## Setup

For this guide, we're going to show how to use Dioxus with [Axum](https://docs.rs/axum/latest/axum/), but `dioxus-fullstack` also integrates with the [Warp](https://docs.rs/warp/latest/warp/) and [Salvo](https://docs.rs/salvo/latest/salvo/) web frameworks.

Make sure you have Rust and Cargo installed, and then create a new project:

````shell
cargo new --bin demo
cd demo
````

Add `dioxus` and `dioxus-fullstack` as dependencies:

````shell
cargo add dioxus
cargo add dioxus-fullstack
````

Next, set up features for the server (`ssr`) and the client (`web`):

````toml
[features]
default = []
ssr = ["dioxus-fullstack/axum"]
web = ["dioxus-fullstack/web"]
````

Your dependencies should look roughly like this:

````toml
[dependencies]
dioxus = { version = "*" }
dioxus-fullstack = { version = "*" }

[features]
default = []
ssr = ["dioxus-fullstack/axum"]
web = ["dioxus-fullstack/web"]
````

Now, set up your Axum app to serve the Dioxus app.

````rs@server_basic.rs
#![allow(non_snake_case, unused)]
use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;

fn main() {
    LaunchBuilder::new(app).launch();
}

fn app(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    })
}

````

Now, run your app with:

````
dx build --features web --release
cargo run --features ssr --release
````

Finally, open `http://localhost:8080` in your browser. You should see a server-side rendered page with a counter.

````inject-dioxus
SandBoxFrame {
	url: "https://codesandbox.io/p/sandbox/dioxus-fullstack-2nwsrz?file=%2Fsrc%2Fmain.rs%3A5%2C1"
}
````

## Hot Reload

1. Hot reloading allows much faster iteration times inside of rsx calls by interpreting them and streaming the edits.
1. It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.

### Usage

1. Run:

````bash
dx build --features web
dx serve --features ssr --hot-reload --platform desktop
````

2. Change some code within a rsx or render macro
2. Save and watch the style change without recompiling

### Limitations

1. The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the rsx call, it will require a full recompile to capture the expression.
1. Components, Iterators, and some attributes can contain arbitrary rust code and will trigger a full recompile when changed.
# Desktop overview

Build a standalone native desktop app that looks and feels the same across operating systems.

Apps built with Dioxus desktop use the system WebView to render the page. This makes the final size of application much smaller than other WebView renderers (typically under 5MB).

Although desktop apps are rendered in a WebView, your Rust code runs natively. This means that browser APIs are *not* available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs *are* accessible, so streaming, WebSockets, filesystem, etc are all easily accessible though system APIs.

Dioxus desktop is built off [Tauri](https://tauri.app/). Right now there are limited Dioxus abstractions over the menubar, event handling, etc. In some places you may need to leverage Tauri directly – through [Wry](http://github.com/tauri-apps/wry/) and [Tao](http://github.com/tauri-apps/tao).

 > 
 > In the future, we plan to move to a custom web renderer-based DOM renderer with WGPU integrations ([Blitz](https://github.com/DioxusLabs/blitz)).

## Examples

* [File Explorer](https://github.com/DioxusLabs/example-projects/blob/master/file-explorer)
* [WiFi Scanner](https://github.com/DioxusLabs/example-projects/blob/master/wifi-scanner)

[![File Explorer screenshot](https://github.com/DioxusLabs/example-projects/raw/master/file-explorer/assets/image.png)](https://github.com/DioxusLabs/example-projects/tree/master/file-explorer)

Here's a [query](https://github.com/search?q=repo%3ADioxusLabs%2Fdioxus+path%3A%2F%5Eexamples%5C%2F%2F+%22use+dioxus_desktop%22&type=code) for the main repo to find examples which use `dioxus_desktop` (might not be 100% acurrate).

# Getting started

## Platform-specific dependencies

Dioxus desktop renders through a WebView. Depending on your platform, you might need to install some dependencies.

### Windows

Windows apps depend on WebView2 – a library that should be installed in all modern Windows distributions. If you have Edge installed, then Dioxus will work fine. If you *don't* have WebView2, [then you can install it through Microsoft](https://developer.microsoft.com/en-us/microsoft-edge/webview2/). MS provides 3 options:

1. A tiny "evergreen" *bootstrapper* that fetches an installer from Microsoft's CDN.
1. A tiny *installer* that fetches WebView2 from Microsoft's CDN.
1. A statically linked version of WebView2 in your final binary for offline users.

For development purposes, use Option 1.

### Linux

WebView Linux apps require WebkitGtk. When distributing, this can be part of your dependency tree in your `.rpm` or `.deb`. However, likely, your users will already have WebkitGtk.

````bash
sudo apt install libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev
````

When using Debian/bullseye `libappindicator3-dev` is no longer available but replaced by `libayatana-appindicator3-dev`.

````bash
# on Debian/bullseye use:
sudo apt install libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev
````

If you run into issues, make sure you have all the basics installed, as outlined in the [Tauri docs](https://beta.tauri.app/guides/prerequisites/).

### MacOS

Currently – everything for macOS is built right in! However, you might run into an issue if you're using nightly Rust due to some permissions issues in our Tao dependency (which have been resolved but not published).

## Creating a Project

Create a new crate:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the desktop renderer as dependencies (this will edit your `Cargo.toml`):

````shell
cargo add dioxus
cargo add dioxus-desktop
````

Edit your `main.rs`:

````rs@hello_world_desktop.rs
#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the dioxus app in a webview
    dioxus_desktop::launch(App);
}

// define a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

## Hot Reload

1. Hot reloading allows much faster iteration times inside of RSX calls by interpreting them and streaming the edits.
1. It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.

### Setup

Install [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli).

### Usage

1. Run:

````bash
dx serve --hot-reload --platform desktop
````

2. Change some code within a `rsx` or `render` macro.
2. Save and watch the style change without recompiling.

### Limitations

1. The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the RSX call, it will require a full recompile to capture the expression.
1. Components, Iterators, and some attributes can contain arbitrary rust code and will trigger a full recompile when changed.
# Mobile App

Build a mobile app with Dioxus!

Example: [Todo App](https://github.com/DioxusLabs/example-projects/blob/master/ios_demo)

## Support

Mobile is currently the least-supported renderer target for Dioxus. Mobile apps are rendered with either the platform's WebView or experimentally with [WGPU](https://github.com/DioxusLabs/blitz). WebView doesn't support animations, transparency, and native widgets.

Mobile support is currently best suited for CRUD-style apps, ideally for internal teams who need to develop quickly but don't care much about animations or native widgets.

## Getting Set up

Getting set up with mobile can be quite challenging. The tooling here isn't great (yet) and might take some hacking around to get things working.

### Setting up dependencies

#### Android Dependencies

First, install the rust Android targets:

````sh
rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android
````

To develop on Android, you will need to [install Android Studio](https://developer.android.com/studio).

Once you have installed Android Studio, you will need to install the Android SDK and NDK:

1. Create a blank Android project
1. Select `Tools > SDK manager`
1. Navigate to the `SDK tools` window:

![NDK install window](/assets/static/android_ndk_install.png)

Then select:

* The SDK
* The SDK Command line tools
* The NDK (side by side)
* CMAKE

4. Select `apply` and follow the prompts

 > 
 > More details that could be useful for debugging any errors you encounter are available [in the official android docs](https://developer.android.com/studio/intro/update#sdk-manager)

Next set the Java, Android and NDK home variables:

Mac:

````sh
export JAVA_HOME="/Applications/Android Studio.app/Contents/jbr/Contents/Home"
export ANDROID_HOME="$HOME/Library/Android/sdk"
export NDK_HOME="$ANDROID_HOME/ndk/25.2.9519653"
````

Windows:

````powershell
[System.Environment]::SetEnvironmentVariable("JAVA_HOME", "C:\Program Files\Android\Android Studio\jbr", "User")
[System.Environment]::SetEnvironmentVariable("ANDROID_HOME", "$env:LocalAppData\Android\Sdk", "User")
[System.Environment]::SetEnvironmentVariable("NDK_HOME", "$env:LocalAppData\Android\Sdk\ndk\25.2.9519653", "User")
````

 > 
 > The NDK version in the paths should match the version you installed in the last step

#### IOS Dependencies

First, install the rust IOS targets:

````sh
rustup target add aarch64-apple-ios x86_64-apple-ios aarch64-apple-ios-sim
````

To develop on IOS, you will need to [install XCode](https://apps.apple.com/us/app/xcode/id497799835).

 > 
 > Note: On Apple silicon you must run Xcode on rosetta. Goto Application > Right Click Xcode > Get Info > Open in Rosetta.
 > If you are using M1, you will have to run `cargo build --target x86_64-apple-ios` instead of `cargo apple build` if you want to run in simulator.

### Setting up your project

First, we need to create a rust project:

````sh
cargo new dioxus-mobile-test
cd dioxus-mobile-test
````

Next, we can use `cargo-mobile2` to create a project for mobile:

````shell
cargo install --git https://github.com/tauri-apps/cargo-mobile2
cargo mobile init
````

When you run `cargo mobile init`, you will be asked a series of questions about your project. One of those questions is what template you should use. Dioxus currently doesn't have a template in Tauri mobile, instead you can use the `wry` template.

 > 
 > You may also be asked to input your team ID for IOS. You can find your team id [here](https://developer.apple.com/help/account/manage-your-team/locate-your-team-id/) or create a team id by creating a developer account [here](https://developer.apple.com/help/account/get-started/about-your-developer-account)

Next, we need to modify our dependencies to include dioxus:

````sh
cargo add dioxus
cargo add dioxus-desktop --no-default-features --features tokio_runtime
````

Finally, we need to add a component to renderer. Modify your main function:

````rust
use dioxus::prelude::*;

pub fn main() -> Result<()> {
    // Right now we're going through dioxus-desktop but we'd like to go through dioxus-mobile
    // That will seed the index.html with some fixes that prevent the page from scrolling/zooming etc
    dioxus_desktop::launch_cfg(
        app,
        // Note that we have to disable the viewport goofiness of the browser.
        // Dioxus_mobile should do this for us
        dioxus_desktop::Config::default().with_custom_index(r#"<!DOCTYPE html>
        <html>
          <head>
            <title>Dioxus app</title>
            <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
            <!-- CUSTOM HEAD -->
          </head>
          <body>
            <div id="main"></div>
            <!-- MODULE LOADER -->
          </body>
        </html>
       "#.into()),
    );

    Ok(())
}

fn app(cx: Scope) -> Element {
    let items = cx.use_hook(|| vec![1, 2, 3]);

    log::debug!("Hello from the app");

    render! {
        div {
            h1 { "Hello, Mobile"}
            div { margin_left: "auto", margin_right: "auto", width: "200px", padding: "10px", border: "1px solid black",
                button {
                    onclick: move|_| {
                        println!("Clicked!");
                        items.push(items.len());
                        cx.needs_update_any(ScopeId(0));
                        println!("Requested update");
                    },
                    "Add item"
                }
                for item in items.iter() {
                    div { "- {item}" }
                }
            }
        }
    }
}
````

## Running

From there, you'll want to get a build of the crate using whichever platform you're targeting (simulator or actual hardware). For now, we'll just stick with the simulator

### IOS

To build your project for IOS, you can run:

````sh
cargo build --target aarch64-apple-ios-sim
````

Next, open XCode (this might take awhile if you've never opened XCode before):

````sh
cargo apple open
````

This will open XCode with this particular project.

From there, just click the "play" button with the right target and the app should be running!

![ios_demo](/assets/static/IOS-dioxus-demo.png)

Note that clicking play doesn't cause a new build, so you'll need to keep rebuilding the app between changes. The tooling here is very young, so please be patient. If you want to contribute to make things easier, please do! We'll be happy to help.

### Android

To build your project on Android you can run:
`cargo android build`

Next, open Android studio:

````sh
cargo android open
````

This will open an android studio project for this application.

Next we need to create a simulator in Android studio to run our app in. To create a simulator click on the phone icon in the top right of Android studio:

![android studio manage devices](/assets/static/android-studio-simulator.png)

Then click the `create a virtual device` button and follow the prompts:

![android studio devices](/assets/static/android-studio-devices.png)

Finally, launch your device by clicking the play button on the device you created:

![android studio device](/assets/static/android-studio-device.png)

Now you can start your application from your terminal by running:

````sh
cargo android run
````

![android_demo](/assets/static/Android-Dioxus-demo.png)

 > 
 > More information is available in the Android docs:
 > 
 > * https://developer.android.com/ndk/guides
 > * https://developer.android.com/studio/projects/install-ndk
 > * https://source.android.com/docs/setup/build/rust/building-rust-modules/overview
# Terminal UI

You can build a text-based interface that will run in the terminal using Dioxus.

![Hello World screenshot](https://github.com/DioxusLabs/rink/raw/master/examples/example.png)

 > 
 > Note: this book was written with HTML-based platforms in mind. You might be able to follow along with TUI, but you'll have to adapt a bit.

## Support

TUI support is currently quite experimental. But, if you're willing to venture into the realm of the unknown, this guide will get you started.

* It uses flexbox for the layout
* It only supports a subset of the attributes and elements
* Regular widgets will not work in the tui render, but the tui renderer has its own widget components that start with a capital letter. See the [widgets example](https://github.com/DioxusLabs/dioxus/blob/master/packages/dioxus-tui/examples/widgets.rs)
* 1px is one character line height. Your regular CSS px does not translate
* If your app panics, your terminal is wrecked. This will be fixed eventually

## Getting Set up

Start by making a new package and adding Dioxus and the TUI renderer as dependencies.

````shell
cargo new --bin demo
cd demo
cargo add dioxus
cargo add dioxus-tui
````

Then, edit your `main.rs` with the basic template.

````rs@hello_world_tui.rs
#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the app in the terminal
    dioxus_tui::launch(App);
}

// create a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}

````

To run our app:

````shell
cargo run
````

Press "ctrl-c" to close the app. To switch from "ctrl-c" to just "q" to quit you can launch the app with a configuration to disable the default quit and use the root TuiContext to quit on your own.

````rs@hello_world_tui_no_ctrl_c.rs
// todo remove deprecated
#![allow(non_snake_case, deprecated)]

use dioxus::events::{KeyCode, KeyboardEvent};
use dioxus::prelude::*;
use dioxus_tui::TuiContext;

fn main() {
    dioxus_tui::launch_cfg(
        App,
        dioxus_tui::Config::new()
            .without_ctrl_c_quit()
            // Some older terminals only support 16 colors or ANSI colors
            // If your terminal is one of these, change this to BaseColors or ANSI
            .with_rendering_mode(dioxus_tui::RenderingMode::Rgb),
    );
}

fn App(cx: Scope) -> Element {
    let tui_ctx: TuiContext = cx.consume_context().unwrap();

    cx.render(rsx! {
        div {
            width: "100%",
            height: "10px",
            background_color: "red",
            justify_content: "center",
            align_items: "center",
            onkeydown: move |k: KeyboardEvent| if let KeyCode::Q = k.key_code {
                tui_ctx.quit();
            },

            "Hello world!"
        }
    })
}

````

## Hot Reload

1. Hot reloading allows much faster iteration times inside of rsx calls by interpreting them and streaming the edits.
1. It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.

### Setup

Install [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli).

### Usage

1. Run:

````bash
dx serve --hot-reload --platform desktop
````

2. Change some code within a rsx or render macro
2. Save and watch the style change without recompiling

### Limitations

1. The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the rsx call, it will require a full recompile to capture the expression.
1. Components, Iterators, and some attributes can contain arbitrary rust code and will trigger a full recompile when changed.
In this guide, you'll learn to use Dioxus to build user interfaces that run anywhere. We will recreate the hackernews homepage in Dioxus:

````inject-dioxus
DemoFrame {
    hackernews_complete::App {}
}
````

This guide serves a very brief overview of Dioxus. Throughout the guide, there will be links to the [reference](../reference/index.md) with more details about specific concepts.

First, lets setup our dependencies. In addition to the dependencies you added in the [getting started](../getting_started/index.md) guide for your platform, we need to set up a few more dependencies to work with the hacker news API:

````sh
cargo add chrono --features serde
cargo add futures
cargo add reqwest --features json
cargo add serde --features derive
cargo add serde_json
cargo add async_recursion
````
# Your First Component

This chapter will teach you how to create a [Component](../reference/components.md) that displays a link to a post on hackernews.

First, let's define how to display a post. Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* how we want the UI to look.

To declare what you want your UI to look like, you will need to use the `rsx` macro. Let's modify the rsx macro in the `App` function from the [getting started](../getting_started/index.md) to show information about our story:

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    render! {
        "story"
    }
}
````

If you run your application you should see something like this:

````inject-dioxus
DemoFrame {
	hackernews_post::story_v1::App {}
}
````

 > 
 > RSX mirrors HTML. Because of this you will need to know some html to use Dioxus.
 > 
 > Here are some resources to help get you started learning HTML:
 > 
 > * [MDN HTML Guide](https://developer.mozilla.org/en-US/docs/Learn/HTML)
 > * [W3 Schools HTML Tutorial](https://www.w3schools.com/html/default.asp)
 > 
 > In addition to HTML, Dioxus uses CSS to style applications. You can either use traditional CSS (what this guide uses) or use a tool like [tailwind CSS](https://tailwindcss.com/docs/installation):
 > 
 > * [MDN Traditional CSS Guide](https://developer.mozilla.org/en-US/docs/Learn/HTML)
 > * [W3 Schools Traditional CSS Tutorial](https://www.w3schools.com/css/default.asp)
 > * [Tailwind tutorial](https://tailwindcss.com/docs/installation) (used with the [Tailwind setup example](https://github.com/DioxusLabs/dioxus/tree/master/examples/tailwind))
 > 
 > If you have existing html code, you can use the [translate](../CLI/translate.md) command to convert it to RSX. Or if you prefer to write html, you can use the [html! macro](https://github.com/DioxusLabs/dioxus-html-macro) to write html directly in your code.

## Dynamic Text

Let's expand our `App` component to include the story title, author, score, time posted, and number of comments. We can insert dynamic text in the render macro by inserting variables inside `{}`s (this works similarly to the formatting in the [println!](https://doc.rust-lang.org/std/macro.println.html) macro):

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    render! {
        "{title} by {by} ({score}) {time} {comments}"
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v2::App {}
}
````

## Creating Elements

Next, let's wrap our post description in a [`div`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div). You can create HTML elements in Dioxus by putting a `{` after the element name and a `}` after the last child of the element:

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    render! {
        div {
            "{title} by {by} ({score}) {time} {comments}"
        }
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v3::App {}
}
````

 > 
 > You can read more about elements in the [rsx reference](../reference/rsx.md).

## Setting Attributes

Next, let's add some padding around our post listing with an attribute.

Attributes (and [listeners](../reference/event_handlers.md)) modify the behavior or appearance of the element they are attached to. They are specified inside the `{}` brackets before any children, using the `name: value` syntax. You can format the text in the attribute as you would with a text node:

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    render! {
        div {
            padding: "0.5rem",
            position: "relative",
            "{title} by {by} ({score}) {time} {comments}"
        }
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v4::App {}
}
````

 > 
 > Note: All attributes defined in [`dioxus-html`](https://docs.rs/dioxus-html/latest/dioxus_html/) follow the snake_case naming convention. They transform their `snake_case` names to HTML's `camelCase` attributes.

 > 
 > Note: Styles can be used directly outside of the `style:` attribute. In the above example, `color: "red"` is turned into `style="color: red"`.

 > 
 > You can read more about elements in the [attribute reference](../reference/rsx.md)

## Creating a Component

Just like you wouldn't want to write a complex program in a single, long, `main` function, you shouldn't build a complex UI in a single `App` function. Instead, you should break down the functionality of an app in logical parts called components.

A component is a Rust function, named in UpperCamelCase, that takes a `Scope` parameter and returns an `Element` describing the UI it wants to render. In fact, our `App` function is a component!

Let's pull our story description into a new component:

````rs@hackernews_post.rs
fn StoryListing(cx: Scope) -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    render! {
        div {
            padding: "0.5rem",
            position: "relative",
            "{title} by {by} ({score}) {time} {comments}"
        }
    }
}
````

We can render our component like we would an element by putting `{}`s after the component name. Let's modify our `App` component to render our new StoryListing component:

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    render! {
        StoryListing {

        }
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v5::App {}
}
````

 > 
 > You can read more about elements in the [component reference](../reference/components.md)

## Creating Props

Just like you can pass arguments to a function or attributes to an element, you can pass props to a component that customize its behavior!

We can define arguments that components can take when they are rendered (called `Props`) by adding the `#[component]` macro before our function definition and adding extra function arguments.

Currently, our `StoryListing` component always renders the same story. We can modify it to accept a story to render as a prop.

We will also define what a post is and include information for how to transform our post to and from a different format using [serde](https://serde.rs). This will be used with the hackernews API in a later chapter:

````rs@hackernews_post.rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

// Define the Hackernews types
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryPageData {
    #[serde(flatten)]
    pub item: StoryItem,
    #[serde(default)]
    pub comments: Vec<Comment>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Comment {
    pub id: i64,
    /// there will be no by field if the comment was deleted
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub text: String,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    #[serde(default)]
    pub sub_comments: Vec<Comment>,
    pub r#type: String,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryItem {
    pub id: i64,
    pub title: String,
    pub url: Option<String>,
    pub text: Option<String>,
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub score: i64,
    #[serde(default)]
    pub descendants: i64,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    pub r#type: String,
}

#[component]
fn StoryListing(cx: Scope, story: StoryItem) -> Element {
    let StoryItem {
        title,
        by,
        score,
        time,
        kids,
        ..
    } = story;

    let comments = kids.len();

    render! {
        div {
            padding: "0.5rem",
            position: "relative",
            "{title} by {by} ({score}) {time} {comments}"
        }
    }
}
````

Now, let's modify the `App` component to pass the story to our `StoryListing` component like we would set an attribute on an element:

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    render! {
        StoryListing {
            story: StoryItem {
                id: 0,
                title: "hello hackernews".to_string(),
                url: None,
                text: None,
                by: "Author".to_string(),
                score: 0,
                descendants: 0,
                time: chrono::Utc::now(),
                kids: vec![],
                r#type: "".to_string(),
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v6::App {}
}
````

 > 
 > You can read more about Props in the [Props reference](../reference/component_props.md)

## Cleaning Up Our Interface

Finally, by combining elements and attributes, we can make our post listing much more appealing:

Full code up to this point:

````rs@hackernews_post.rs
use dioxus::prelude::*;

// Define the Hackernews types
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryPageData {
    #[serde(flatten)]
    pub item: StoryItem,
    #[serde(default)]
    pub comments: Vec<Comment>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Comment {
    pub id: i64,
    /// there will be no by field if the comment was deleted
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub text: String,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    #[serde(default)]
    pub sub_comments: Vec<Comment>,
    pub r#type: String,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryItem {
    pub id: i64,
    pub title: String,
    pub url: Option<String>,
    pub text: Option<String>,
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub score: i64,
    #[serde(default)]
    pub descendants: i64,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    pub r#type: String,
}

pub fn App(cx: Scope) -> Element {
    render! {
        StoryListing {
            story: StoryItem {
                id: 0,
                title: "hello hackernews".to_string(),
                url: None,
                text: None,
                by: "Author".to_string(),
                score: 0,
                descendants: 0,
                time: Utc::now(),
                kids: vec![],
                r#type: "".to_string(),
            }
        }
    }
}

#[component]
fn StoryListing(cx: Scope, story: StoryItem) -> Element {
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        id,
        ..
    } = story;

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} {}", if *score == 1 { " point" } else { " points" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    cx.render(rsx! {
        div {
            padding: "0.5rem",
            position: "relative",
            div {
                font_size: "1.5rem",
                a {
                    href: url,
                    "{title}"
                }
                a {
                    color: "gray",
                    href: "https://news.ycombinator.com/from?site={hostname}",
                    text_decoration: "none",
                    " ({hostname})"
                }
            }
            div {
                display: "flex",
                flex_direction: "row",
                color: "gray",
                div {
                    "{score}"
                }
                div {
                    padding_left: "0.5rem",
                    "by {by}"
                }
                div {
                    padding_left: "0.5rem",
                    "{time}"
                }
                div {
                    padding_left: "0.5rem",
                    "{comments}"
                }
            }
        }
    })
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_final::App {}
}
````
# Interactivity

In this chapter, we will add a preview for articles you hover over or links you focus on.

## Creating a Preview

First, let's split our app into a Stories component on the left side of the screen, and a preview component on the right side of the screen:

````rs@hackernews_state.rs
pub fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            width: "100%",
            div {
                width: "50%",
                Stories {}
            }
            div {
                width: "50%",
                Preview {}
            }
        }
    })
}

// New
fn Stories(cx: Scope) -> Element {
    render! {
        StoryListing {
            story: StoryItem {
                id: 0,
                title: "hello hackernews".to_string(),
                url: None,
                text: None,
                by: "Author".to_string(),
                score: 0,
                descendants: 0,
                time: chrono::Utc::now(),
                kids: vec![],
                r#type: "".to_string(),
            }
        }
    }
}

// New
#[derive(Clone, Debug)]
enum PreviewState {
    Unset,
    Loading,
    Loaded(StoryPageData),
}

// New
fn Preview(cx: Scope) -> Element {
    let preview_state = PreviewState::Unset;
    match preview_state {
        PreviewState::Unset => render! {
            "Hover over a story to preview it here"
        },
        PreviewState::Loading => render! {
            "Loading..."
        },
        PreviewState::Loaded(story) => {
            let title = &story.item.title;
            let url = story.item.url.as_deref().unwrap_or_default();
            let text = story.item.text.as_deref().unwrap_or_default();
            render! {
                div {
                    padding: "0.5rem",
                    div {
                        font_size: "1.5rem",
                        a {
                            href: "{url}",
                            "{title}"
                        }
                    }
                    div {
                        dangerous_inner_html: "{text}",
                    }
                    for comment in &story.comments {
                        Comment { comment: comment.clone() }
                    }
                }
            }
        }
    }
}

// NEW
#[component]
fn Comment(cx: Scope, comment: Comment) -> Element<'a> {
    render! {
        div {
            padding: "0.5rem",
            div {
                color: "gray",
                "by {comment.by}"
            }
            div {
                dangerous_inner_html: "{comment.text}"
            }
            for kid in &comment.sub_comments {
                Comment { comment: kid.clone() }
            }
        }
    }
}

````

````inject-dioxus
DemoFrame {
    hackernews_state::app_v1::App {}
}
````

## Event Handlers

Next, we need to detect when the user hovers over a section or focuses a link. We can use an [event listener](../reference/event_handlers.md) to listen for the hover and focus events.

Event handlers are similar to regular attributes, but their name usually starts with `on`- and they accept closures as values. The closure will be called whenever the event it listens for is triggered. When an event is triggered, information about the event is passed to the closure though the [Event](https://docs.rs/dioxus/latest/dioxus/prelude/struct.Event.html) structure.

Let's create a [`onmouseenter`](https://docs.rs/dioxus/latest/dioxus/events/fn.onmouseenter.html) event listener in the `StoryListing` component:

````rs@hackernews_state.rs
cx.render(rsx! {
    div {
        padding: "0.5rem",
        position: "relative",
        onmouseenter: move |_| {
            // NEW
        },
        div {
            font_size: "1.5rem",
            a {
                href: url,
                onfocus: move |_event| {
                    // NEW
                },
                "{title}"
            }
            a {
                color: "gray",
                href: "https://news.ycombinator.com/from?site={hostname}",
                text_decoration: "none",
                " ({hostname})"
            }
        }
        div {
            display: "flex",
            flex_direction: "row",
            color: "gray",
            div {
                "{score}"
            }
            div {
                padding_left: "0.5rem",
                "by {by}"
            }
            div {
                padding_left: "0.5rem",
                "{time}"
            }
            div {
                padding_left: "0.5rem",
                "{comments}"
            }
        }
    }
})
````

 > 
 > You can read more about Event Handlers in the [Event Handler reference](../reference/event_handlers.md)

## State

So far our components have had no state like normal rust functions. To make our application change when we hover over a link we need state to store the currently hovered link in the root of the application.

You can create state in dioxus using hooks. Hooks are Rust functions that take a reference to `ScopeState` (in a component, you can pass `cx`), and provide you with functionality and state.

In this case, we will use the `use_shared_state_provider` and `use_shared_state` hooks:

* You can provide a closure to `use_shared_state_provider` that determines the initial value of the shared state and provides the value to all child components
* You can then use the `use_shared_state` hook to read and modify that state in the `Preview` and `StoryListing` components
* When the value updates, `use_shared_state` will make the component re-render, and provides you with the new value

 > 
 > Note: You should prefer local state hooks like use_state or use_ref when you only use state in one component. Because we use state in multiple components, we can use a [global state pattern](../reference/context.md)

````rs@hackernews_state.rs
pub fn App(cx: Scope) -> Element {
    use_shared_state_provider(cx, || PreviewState::Unset);
````

````rs@hackernews_state.rs
#[component]
fn StoryListing(cx: Scope, story: StoryItem) -> Element {
    // New
    let preview_state = use_shared_state::<PreviewState>(cx).unwrap();
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        ..
    } = story;

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} {}", if *score == 1 { " point" } else { " points" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    cx.render(rsx! {
        div {
            padding: "0.5rem",
            position: "relative",
            onmouseenter: move |_event| {
                // NEW
                // set the preview state to this story
                *preview_state.write() = PreviewState::Loaded(StoryPageData {
                    item: story.clone(),
                    comments: vec![],
                });
            },
            div {
                font_size: "1.5rem",
                a {
                    href: url,
                    onfocus: move |_event| {
                        // NEW
                        // set the preview state to this story
                        *preview_state.write() = PreviewState::Loaded(StoryPageData {
                            item: story.clone(),
                            comments: vec![],
                        });
                    },
````

````rs@hackernews_state.rs
fn Preview(cx: Scope) -> Element {
    // New
    let preview_state = use_shared_state::<PreviewState>(cx)?;

    // New
    match &*preview_state.read() {
````

````inject-dioxus
DemoFrame {
    hackernews_state::App {}
}
````

 > 
 > You can read more about Hooks in the [Hooks reference](../reference/hooks.md)

### The Rules of Hooks

Hooks are a powerful way to manage state in Dioxus, but there are some rules you need to follow to insure they work as expected. Dioxus uses the order you call hooks to differentiate between hooks. Because the order you call hooks matters, you must follow these rules:

1. Hooks may be only used in components or other hooks (we'll get to that later)
1. On every call to the component function
   1. The same hooks must be called
   1. In the same order
1. Hooks name's should start with `use_` so you don't accidentally confuse them with regular functions

These rules mean that there are certain things you can't do with hooks:

#### No Hooks in Conditionals

````rs@hooks_bad.rs
// ❌ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy && you_know_it {
    let something = use_state(cx, || "hands");
    println!("clap your {something}")
}

// ✅ instead, *always* call use_state
// You can put other stuff in the conditional though
let something = use_state(cx, || "hands");
if you_are_happy && you_know_it {
    println!("clap your {something}")
}
````

#### No Hooks in Closures

````rs@hooks_bad.rs
// ❌ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
    let b = use_state(cx, || 0);
    b.get()
};

// ✅ instead, move hook `b` outside
let b = use_state(cx, || 0);
let _a = || b.get();
````

#### No Hooks in Loops

````rs@hooks_bad.rs
// `names` is a Vec<&str>

// ❌ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &names {
    let is_selected = use_state(cx, || false);
    println!("selected: {is_selected}");
}

// ✅ Instead, use a hashmap with use_ref
let selection_map = use_ref(cx, HashMap::<&str, bool>::new);

for name in &names {
    let is_selected = selection_map.read()[name];
    println!("selected: {is_selected}");
}
````
# Fetching Data

In this chapter, we will fetch data from the hacker news API and use it to render the list of top posts in our application.

## Defining the API

First we need to create some utilities to fetch data from the hackernews API using [reqwest](https://docs.rs/reqwest/latest/reqwest/index.html):

````rs@hackernews_async.rs
// Define the Hackernews API
use futures::future::join_all;

pub static BASE_API_URL: &str = "https://hacker-news.firebaseio.com/v0/";
pub static ITEM_API: &str = "item/";
pub static USER_API: &str = "user/";
const COMMENT_DEPTH: i64 = 2;

pub async fn get_story_preview(id: i64) -> Result<StoryItem, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    reqwest::get(&url).await?.json().await
}

pub async fn get_stories(count: usize) -> Result<Vec<StoryItem>, reqwest::Error> {
    let url = format!("{}topstories.json", BASE_API_URL);
    let stories_ids = &reqwest::get(&url).await?.json::<Vec<i64>>().await?[..count];

    let story_futures = stories_ids[..usize::min(stories_ids.len(), count)]
        .iter()
        .map(|&story_id| get_story_preview(story_id));
    let stories = join_all(story_futures)
        .await
        .into_iter()
        .filter_map(|story| story.ok())
        .collect();
    Ok(stories)
}

pub async fn get_story(id: i64) -> Result<StoryPageData, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut story = reqwest::get(&url).await?.json::<StoryPageData>().await?;
    let comment_futures = story.item.kids.iter().map(|&id| get_comment(id));
    let comments = join_all(comment_futures)
        .await
        .into_iter()
        .filter_map(|c| c.ok())
        .collect();

    story.comments = comments;
    Ok(story)
}

#[async_recursion::async_recursion(?Send)]
pub async fn get_comment_with_depth(id: i64, depth: i64) -> Result<Comment, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut comment = reqwest::get(&url).await?.json::<Comment>().await?;
    if depth > 0 {
        let sub_comments_futures = comment
            .kids
            .iter()
            .map(|story_id| get_comment_with_depth(*story_id, depth - 1));
        comment.sub_comments = join_all(sub_comments_futures)
            .await
            .into_iter()
            .filter_map(|c| c.ok())
            .collect();
    }
    Ok(comment)
}

pub async fn get_comment(comment_id: i64) -> Result<Comment, reqwest::Error> {
    let comment = get_comment_with_depth(comment_id, COMMENT_DEPTH).await?;
    Ok(comment)
}
````

## Working with Async

[`use_future`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_future.html) is a [hook](./state.md) that lets you run an async closure, and provides you with its result.

For example, we can make an API request (using [reqwest](https://docs.rs/reqwest/latest/reqwest/index.html)) inside `use_future`:

````rs@hackernews_async.rs
fn Stories(cx: Scope) -> Element {
    // Fetch the top 10 stories on Hackernews
    let stories = use_future(cx, (), |_| get_stories(10));

    // check if the future is resolved
    match stories.value() {
        Some(Ok(list)) => {
            // if it is, render the stories
            render! {
                div {
                    // iterate over the stories with a for loop
                    for story in list {
                        // render every story with the StoryListing component
                        StoryListing { story: story.clone() }
                    }
                }
            }
        }
        Some(Err(err)) => {
            // if there was an error, render the error
            render! {"An error occurred while fetching stories {err}"}
        }
        None => {
            // if the future is not resolved yet, render a loading message
            render! {"Loading items"}
        }
    }
}
````

The code inside `use_future` will be submitted to the Dioxus scheduler once the component has rendered.

We can use `.value()` to get the result of the future. On the first run, since there's no data ready when the component loads, its value will be `None`.  However, once the future is finished, the component will be re-rendered and the value will now be `Some(...)`, containing the return value of the closure.

We can then render the result by looping over each of the posts and rendering them with the `StoryListing` component.

````inject-dioxus
DemoFrame {
	hackernews_async::fetch::App {}
}
````

 > 
 > You can read more about working with Async in Dioxus in the [Async reference](../reference/index.md)

## Lazily Fetching Data

Finally, we will lazily fetch the comments on each post as the user hovers over the post.

We need to revisit the code that handles hovering over an item. Instead of passing an empty list of comments, we can fetch all the related comments when the user hovers over the item.

We will cache the list of comments with a [use_ref](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_ref.html) hook. This hook allows you to store some state in a single component. When the user triggers fetching the comments we will check if the response has already been cached before fetching the data from the hackernews API.

````rs@hackernews_async.rs
// New
async fn resolve_story(
    full_story: UseRef<Option<StoryPageData>>,
    preview_state: UseSharedState<PreviewState>,
    story_id: i64,
) {
    if let Some(cached) = &*full_story.read() {
        *preview_state.write() = PreviewState::Loaded(cached.clone());
        return;
    }

    *preview_state.write() = PreviewState::Loading;
    if let Ok(story) = get_story(story_id).await {
        *preview_state.write() = PreviewState::Loaded(story.clone());
        *full_story.write() = Some(story);
    }
}

#[component]
fn StoryListing(cx: Scope, story: StoryItem) -> Element {
    let preview_state = use_shared_state::<PreviewState>(cx).unwrap();
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        id,
        ..
    } = story;
    // New
    let full_story = use_ref(cx, || None);

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} {}", if *score == 1 { " point" } else { " points" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    cx.render(rsx! {
        div {
            padding: "0.5rem",
            position: "relative",
            onmouseenter: move |_event| {
                // New
                // If you return a future from an event handler, it will be run automatically
                resolve_story(full_story.clone(), preview_state.clone(), *id)
            },
            div {
                font_size: "1.5rem",
                a {
                    href: url,
                    onfocus: move |_event| {
                        // New
                        resolve_story(full_story.clone(), preview_state.clone(), *id)
                    },
                    // ...

````

````inject-dioxus
DemoFrame {
	hackernews_async::App {}
}
````
# Conclusion

Well done! You've completed the Dioxus guide and built a hackernews application in Dioxus.

To continue your journey, you can attempt a challenge listed below, or look at the [Dioxus reference](../reference/index.md).

## Challenges

* Organize your components into separate files for better maintainability.
* Give your app some style if you haven't already.
* Integrate your application with the [Dioxus router](../router/index.md).

## The full code for the hacker news project

````rs@hackernews_complete.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

pub fn App(cx: Scope) -> Element {
    use_shared_state_provider(cx, || PreviewState::Unset);

    cx.render(rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            width: "100%",
            div {
                width: "50%",
                Stories {}
            }
            div {
                width: "50%",
                Preview {}
            }
        }
    })
}

fn Stories(cx: Scope) -> Element {
    let story = use_future(cx, (), |_| get_stories(10));

    match story.value() {
        Some(Ok(list)) => render! {
            div {
                for story in list {
                    StoryListing { story: story.clone() }
                }
            }
        },
        Some(Err(err)) => render! {"An error occurred while fetching stories {err}"},
        None => render! {"Loading items"},
    }
}

async fn resolve_story(
    full_story: UseRef<Option<StoryPageData>>,
    preview_state: UseSharedState<PreviewState>,
    story_id: i64,
) {
    if let Some(cached) = &*full_story.read() {
        *preview_state.write() = PreviewState::Loaded(cached.clone());
        return;
    }

    *preview_state.write() = PreviewState::Loading;
    if let Ok(story) = get_story(story_id).await {
        *preview_state.write() = PreviewState::Loaded(story.clone());
        *full_story.write() = Some(story);
    }
}

#[component]
fn StoryListing(cx: Scope, story: StoryItem) -> Element {
    let preview_state = use_shared_state::<PreviewState>(cx).unwrap();
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        id,
        ..
    } = story;
    let full_story = use_ref(cx, || None);

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} {}", if *score == 1 { " point" } else { " points" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    cx.render(rsx! {
        div {
            padding: "0.5rem",
            position: "relative",
            onmouseenter: move |_event| {
                resolve_story(full_story.clone(), preview_state.clone(), *id)
            },
            div {
                font_size: "1.5rem",
                a {
                    href: url,
                    onfocus: move |_event| {
                        resolve_story(full_story.clone(), preview_state.clone(), *id)
                    },
                    "{title}"
                }
                a {
                    color: "gray",
                    href: "https://news.ycombinator.com/from?site={hostname}",
                    text_decoration: "none",
                    " ({hostname})"
                }
            }
            div {
                display: "flex",
                flex_direction: "row",
                color: "gray",
                div {
                    "{score}"
                }
                div {
                    padding_left: "0.5rem",
                    "by {by}"
                }
                div {
                    padding_left: "0.5rem",
                    "{time}"
                }
                div {
                    padding_left: "0.5rem",
                    "{comments}"
                }
            }
        }
    })
}

#[derive(Clone, Debug)]
enum PreviewState {
    Unset,
    Loading,
    Loaded(StoryPageData),
}

fn Preview(cx: Scope) -> Element {
    let preview_state = use_shared_state::<PreviewState>(cx)?;

    match &*preview_state.read() {
        PreviewState::Unset => render! {
            "Hover over a story to preview it here"
        },
        PreviewState::Loading => render! {
            "Loading..."
        },
        PreviewState::Loaded(story) => {
            let title = &story.item.title;
            let url = story.item.url.as_deref().unwrap_or_default();
            let text = story.item.text.as_deref().unwrap_or_default();
            render! {
                div {
                    padding: "0.5rem",
                    div {
                        font_size: "1.5rem",
                        a {
                            href: "{url}",
                            "{title}"
                        }
                    }
                    div {
                        dangerous_inner_html: "{text}",
                    }
                    for comment in &story.comments {
                        Comment { comment: comment.clone() }
                    }
                }
            }
        }
    }
}

#[component]
fn Comment(cx: Scope, comment: Comment) -> Element<'a> {
    render! {
        div {
            padding: "0.5rem",
            div {
                color: "gray",
                "by {comment.by}"
            }
            div {
                dangerous_inner_html: "{comment.text}"
            }
            for kid in &comment.sub_comments {
                Comment { comment: kid.clone() }
            }
        }
    }
}

// Define the Hackernews API and types
use chrono::{DateTime, Utc};
use futures::future::join_all;
use serde::{Deserialize, Serialize};

pub static BASE_API_URL: &str = "https://hacker-news.firebaseio.com/v0/";
pub static ITEM_API: &str = "item/";
pub static USER_API: &str = "user/";
const COMMENT_DEPTH: i64 = 2;

pub async fn get_story_preview(id: i64) -> Result<StoryItem, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    reqwest::get(&url).await?.json().await
}

pub async fn get_stories(count: usize) -> Result<Vec<StoryItem>, reqwest::Error> {
    let url = format!("{}topstories.json", BASE_API_URL);
    let stories_ids = &reqwest::get(&url).await?.json::<Vec<i64>>().await?[..count];

    let story_futures = stories_ids[..usize::min(stories_ids.len(), count)]
        .iter()
        .map(|&story_id| get_story_preview(story_id));
    Ok(join_all(story_futures)
        .await
        .into_iter()
        .filter_map(|story| story.ok())
        .collect())
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryPageData {
    #[serde(flatten)]
    pub item: StoryItem,
    #[serde(default)]
    pub comments: Vec<Comment>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Comment {
    pub id: i64,
    /// there will be no by field if the comment was deleted
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub text: String,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    #[serde(default)]
    pub sub_comments: Vec<Comment>,
    pub r#type: String,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryItem {
    pub id: i64,
    pub title: String,
    pub url: Option<String>,
    pub text: Option<String>,
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub score: i64,
    #[serde(default)]
    pub descendants: i64,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    pub r#type: String,
}

pub async fn get_story(id: i64) -> Result<StoryPageData, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut story = reqwest::get(&url).await?.json::<StoryPageData>().await?;
    let comment_futures = story.item.kids.iter().map(|&id| get_comment(id));
    let comments = join_all(comment_futures)
        .await
        .into_iter()
        .filter_map(|c| c.ok())
        .collect();

    story.comments = comments;
    Ok(story)
}

#[async_recursion::async_recursion(?Send)]
pub async fn get_comment_with_depth(id: i64, depth: i64) -> Result<Comment, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut comment = reqwest::get(&url).await?.json::<Comment>().await?;
    if depth > 0 {
        let sub_comments_futures = comment
            .kids
            .iter()
            .map(|story_id| get_comment_with_depth(*story_id, depth - 1));
        comment.sub_comments = join_all(sub_comments_futures)
            .await
            .into_iter()
            .filter_map(|c| c.ok())
            .collect();
    }
    Ok(comment)
}

pub async fn get_comment(comment_id: i64) -> Result<Comment, reqwest::Error> {
    get_comment_with_depth(comment_id, COMMENT_DEPTH).await
}

````
# Dioxus Reference

This Reference contains more detailed explanations for all concepts covered in the [guide](../guide/index.md) and more.

## Rendering

* [`RSX`](rsx.md) Rsx is a HTML-like macro that allows you to declare UI
* [`Components`](components.md) Components are the building blocks of UI in Dioxus
* [`Props`](component_props.md) Props allow you pass information to Components
* [`Event Listeners`](event_handlers.md) Event listeners let you respond to user input
* [`User Input`](user_input.md) How to handle User input in Dioxus
* [`Dynamic Rendering`](dynamic_rendering.md) How to dynamically render data in Dioxus

## State

* [`Hooks`](hooks.md): Hooks allow you to create components state
* [`Context`](context.md): Context allows you to create state in a parent and consume it in children
* [`Routing`](router.md): The router helps you manage the URL state
* [`UseFuture`](use_future.md): Use future allows you to create an async task and monitor it's state
* [`UseCoroutine`](use_coroutine.md): Use coroutine helps you manage external state
* [`Spawn`](spawn.md): Spawn creates an async task

## Platforms

* [`Desktop`](desktop/index.md): Overview of desktop specific APIS
* [`Web`](web/index.md): Overview of web specific APIS
* [`SSR`](ssr.md): Overview of the SSR renderer
* [`Liveview`](liveview.md): Overview of liveview specific APIS
* [`Fullstack`](fullstack/index.md): Overview of Fullstack specific APIS
  * [`Server Functions`](fullstack/server_functions.md): Server functions make it easy to communicate between your server and client
  * [`Extractors`](fullstack/extractors.md): Extractors allow you to get extra information out of the headers of a request
  * [`Middleware`](fullstack/middleware.md): Middleware allows you to wrap a server function request or response
  * [`Authentication`](fullstack/authentication.md): An overview of how to handle authentication with server functions
  * [`Routing`](fullstack/routing.md): An overview of how to work with the router in the fullstack renderer
# Describing the UI

Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* what we want the UI to look like using RSX.

You have already seen a simple example of RSX syntax in the "hello world" application:

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

Here, we use the `rsx!` macro to *declare* that we want a `div` element, containing the text `"Hello, world!"`. Dioxus takes the RSX and constructs a UI from it.

## RSX Features

RSX is very similar to HTML in that it describes elements with attributes and children. Here's an empty `div` element in RSX, as well as the resulting HTML:

````rs@rsx_overview.rs
cx.render(rsx!(div {
    // attributes / listeners
    // children
}))
````

````inject-dioxus
DemoFrame {
	// old: rsx_overview::Empty {}
	__interactive_04::Empty {}
}
````

### Attributes

Attributes (and [event handlers](event_handlers.md)) modify the behavior or appearance of the element they are attached to. They are specified inside the `{}` brackets, using the `name: value` syntax. You can provide the value as a literal in the RSX:

````rs@rsx_overview.rs
cx.render(rsx!(img {
    src: "https://avatars.githubusercontent.com/u/79236386?s=200&v=4",
    class: "primary_button",
    width: "10px"
}))
````

````inject-dioxus
DemoFrame {
	rsx_overview::Attributes {}
}
````

 > 
 > Note: All attributes defined in `dioxus-html` follow the snake_case naming convention. They transform their `snake_case` names to HTML's `camelCase` attributes.

 > 
 > Note: Styles can be used directly outside of the `style:` attribute. In the above example, `color: "red"` is turned into `style="color: red"`.

#### Custom Attributes

Dioxus has a pre-configured set of attributes that you can use. RSX is validated at compile time to make sure you didn't specify an invalid attribute. If you want to override this behavior with a custom attribute name, specify the attribute in quotes:

````rs@rsx_overview.rs
cx.render(rsx!(div {
    "style": "width: 20px; height: 20px; background-color: red;",
}))
````

````inject-dioxus
DemoFrame {
	rsx_overview::CustomAttributes {}
}
````

### Special Attributes

While most attributes are simply passed on to the HTML, some have special behaviors.

#### The HTML Escape Hatch

If you're working with pre-rendered assets, output from templates, or output from a JS library, then you might want to pass HTML directly instead of going through Dioxus. In these instances, reach for `dangerous_inner_html`.

For example, shipping a markdown-to-Dioxus converter might significantly bloat your final application size. Instead, you'll want to pre-render your markdown to HTML and then include the HTML directly in your output. We use this approach for the [Dioxus homepage](https://dioxuslabs.com):

````rs@dangerous_inner_html.rs
// this should come from a trusted source
let contents = "live <b>dangerously</b>";

cx.render(rsx! {
    div {
        dangerous_inner_html: "{contents}",
    }
})
````

````inject-dioxus
DemoFrame {
	dangerous_inner_html::App {}
}
````

 > 
 > Note! This attribute is called "dangerous_inner_html" because it is **dangerous** to pass it data you don't trust. If you're not careful, you can easily expose [cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks to your users.
 > 
 > If you're handling untrusted input, make sure to sanitize your HTML before passing it into `dangerous_inner_html` – or just pass it to a Text Element to escape any HTML tags.

#### Boolean Attributes

Most attributes, when rendered, will be rendered exactly as the input you provided. However, some attributes are considered "boolean" attributes and just their presence determines whether they affect the output. For these attributes, a provided value of `"false"` will cause them to be removed from the target element.

So this RSX wouldn't actually render the `hidden` attribute:

````rs@boolean_attribute.rs
cx.render(rsx! {
    div {
        hidden: false,
        "hello"
    }
})
````

````inject-dioxus
DemoFrame {
	boolean_attribute::App {}
}
````

Not all attributes work like this however. *Only the following attributes* have this behavior:

* `allowfullscreen`
* `allowpaymentrequest`
* `async`
* `autofocus`
* `autoplay`
* `checked`
* `controls`
* `default`
* `defer`
* `disabled`
* `formnovalidate`
* `hidden`
* `ismap`
* `itemscope`
* `loop`
* `multiple`
* `muted`
* `nomodule`
* `novalidate`
* `open`
* `playsinline`
* `readonly`
* `required`
* `reversed`
* `selected`
* `truespeed`

For any other attributes, a value of `"false"` will be sent directly to the DOM.

### Interpolation

Similarly to how you can [format](https://doc.rust-lang.org/rust-by-example/hello/print/fmt.html) Rust strings, you can also interpolate in RSX text. Use `{variable}` to Display the value of a variable in a string, or `{variable:?}` to use the Debug representation:

````rs@rsx_overview.rs
let coordinates = (42, 0);
let country = "es";
cx.render(rsx!(div {
    class: "country-{country}",
    left: "{coordinates.0:?}",
    top: "{coordinates.1:?}",
    // arbitrary expressions are allowed,
    // as long as they don't contain `{}`
    div {
        "{country.to_uppercase()}"
    },
    div {
        "{7*6}"
    },
    // {} can be escaped with {{}}
    div {
        "{{}}"
    },
}))
````

````inject-dioxus
DemoFrame {
	rsx_overview::Formatting {}
}
````

### Children

To add children to an element, put them inside the `{}` brackets after all attributes and listeners in the element. They can be other elements, text, or [components](components.md). For example, you could have an `ol` (ordered list) element, containing 3 `li` (list item) elements, each of which contains some text:

````rs@rsx_overview.rs
cx.render(rsx!(ol {
    li {"First Item"}
    li {"Second Item"}
    li {"Third Item"}
}))
````

````inject-dioxus
DemoFrame {
	rsx_overview::Children {}
}
````

### Fragments

You can render multiple elements at the top level of `rsx!` and they will be automatically grouped.

````rs@rsx_overview.rs
cx.render(rsx!(
    p {"First Item"},
    p {"Second Item"},
))
````

````inject-dioxus
DemoFrame {
	rsx_overview::ManyRoots {}
}
````

### Expressions

You can include arbitrary Rust expressions as children within RSX that implements [IntoDynNode](https://docs.rs/dioxus-core/0.3/dioxus_core/trait.IntoDynNode.html). This is useful for displaying data from an [iterator](https://doc.rust-lang.org/stable/book/ch13-02-iterators.html#processing-a-series-of-items-with-iterators):

````rs@rsx_overview.rs
let text = "Dioxus";
cx.render(rsx!(span {
    text.to_uppercase(),
    // create a list of text from 0 to 9
    (0..10).map(|i| rsx!{ i.to_string() })
}))
````

````inject-dioxus
DemoFrame {
	rsx_overview::Expression {}
}
````

### Loops

In addition to iterators you can also use for loops directly within RSX:

````rs@rsx_overview.rs
cx.render(rsx! {
    // use a for loop where the body itself is RSX
    div {
        // create a list of text from 0 to 9
        for i in 0..3 {
            // NOTE: the body of the loop is RSX not a rust statement
            div {
                "{i}"
            }
        }
    }
    // iterator equivalent
    div {
        (0..3).map(|i| rsx!{ div { "{i}" } })
    }
})
````

````inject-dioxus
DemoFrame {
	rsx_overview::Loops {}
}
````

### If statements

You can also use if statements without an else branch within RSX:

````rs@rsx_overview.rs
cx.render(rsx! {
    // use if statements without an else
    if true {
        rsx!(div { "true" })
    }
})
````

````inject-dioxus
DemoFrame {
	rsx_overview::IfStatements {}
}
````
# Components

Just like you wouldn't want to write a complex program in a single, long, `main` function, you shouldn't build a complex UI in a single `App` function. Instead, you should break down the functionality of an app in logical parts called components.

A component is a Rust function, named in UpperCamelCase, that takes a `Scope` parameter and returns an `Element` describing the UI it wants to render. In fact, our `App` function is a component!

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

 > 
 > You'll probably want to add `#![allow(non_snake_case)]` to the top of your crate to avoid warnings about UpperCamelCase component names

A Component is responsible for some rendering task – typically, rendering an isolated part of the user interface. For example, you could have an `About` component that renders a short description of Dioxus Labs:

````rs@components.rs
pub fn About(cx: Scope) -> Element {
    cx.render(rsx!(p {
        b {"Dioxus Labs"}
        " An Open Source project dedicated to making Rust UI wonderful."
    }))
}
````

````inject-dioxus
DemoFrame {
	components::About {}
}
````

Then, you can render your component in another component, similarly to how elements are rendered:

````rs@components.rs
pub fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        About {},
        About {},
    })
}
````

````inject-dioxus
DemoFrame {
	components::App {}
}
````

 > 
 > At this point, it might seem like components are nothing more than functions. However, as you learn more about the features of Dioxus, you'll see that they are actually more powerful!
# Component Props

Just like you can pass arguments to a function or attributes to an element, you can pass props to a component that customize its behavior! The components we've seen so far didn't accept any props – so let's write some components that do.

## derive(Props)

Component props are a single struct annotated with `#[derive(Props)]`. For a component to accept props, the type of its argument must be `Scope<YourPropsStruct>`. Then, you can access the value of the props using `cx.props`.

There are 2 flavors of Props structs:

* Owned props:
  * Don't have an associated lifetime
  * Implement `PartialEq`, allow for memoization (if the props don't change, Dioxus won't re-render the component)
* Borrowed props:
  * [Borrow](https://doc.rust-lang.org/beta/rust-by-example/scope/borrow.html) from a parent component
  * Cannot be memoized due to lifetime constraints

### Owned Props

Owned Props are very simple – they don't borrow anything. Example:

````rs@component_owned_props.rs
// Remember: Owned props must implement `PartialEq`!
#[derive(PartialEq, Props)]
struct LikesProps {
    score: i32,
}

fn Likes(cx: Scope<LikesProps>) -> Element {
    cx.render(rsx! {
        div {
            "This post has ",
            b { "{cx.props.score}" },
            " likes"
        }
    })
}
````

You can then pass prop values to the component the same way you would pass attributes to an element:

````rs@component_owned_props.rs
pub fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        Likes {
            score: 42,
        },
    })
}
````

````inject-dioxus
DemoFrame {
    component_owned_props::App {}
}
````

### Borrowed Props

Owned props work well if your props are easy to copy around – like a single number. But what if we need to pass a larger data type, like a String from an `App` Component to a `TitleCard` subcomponent? A naive solution might be to [`.clone()`](https://doc.rust-lang.org/std/clone/trait.Clone.html) the String, creating a copy of it for the subcomponent – but this would be inefficient, especially for larger Strings.

Rust allows for something more efficient – borrowing the String as a `&str` – this is what Borrowed Props are for!

````rs@component_borrowed_props.rs
#[derive(Props)]
struct TitleCardProps<'a> {
    title: &'a str,
}

fn TitleCard<'a>(cx: Scope<'a, TitleCardProps<'a>>) -> Element {
    cx.render(rsx! {
        h1 { "{cx.props.title}" }
    })
}
````

We can then use the component like this:

````rs@component_borrowed_props.rs
pub fn App(cx: Scope) -> Element {
    let hello = "Hello Dioxus!";

    cx.render(rsx!(TitleCard { title: hello }))
}
````

````inject-dioxus
DemoFrame {
    // original: component_borrowed_props::App {}
    __interactive_04::component_borrowed_props {}
}
````

Borrowed props can be very useful, but they do not allow for memorization so they will *always* rerun when the parent scope is rerendered. Because of this Borrowed Props should be reserved for components that are cheap to rerun or places where cloning data is an issue. Using Borrowed Props everywhere will result in large parts of your app rerunning every interaction.

## Prop Options

The `#[derive(Props)]` macro has some features that let you customize the behavior of props.

### Optional Props

You can create optional fields by using the `Option<…>` type for a field:

````rs@component_props_options.rs
#[derive(Props)]
struct OptionalProps<'a> {
    title: &'a str,
    subtitle: Option<&'a str>,
}

fn Title<'a>(cx: Scope<'a, OptionalProps>) -> Element<'a> {
    cx.render(rsx!(h1{
        "{cx.props.title}: ",
        cx.props.subtitle.unwrap_or("No subtitle provided"),
    }))
}
````

Then, you can choose to either provide them or not:

````rs@component_props_options.rs
Title {
title: "Some Title",
},
Title {
title: "Some Title",
subtitle: "Some Subtitle",
},
// Providing an Option explicitly won't compile though:
// Title {
//     title: "Some Title",
//     subtitle: None,
// },
````

### Explicitly Required `Option`s

If you want to explicitly require an `Option`, and not an optional prop, you can annotate it with `#[props(!optional)]`:

````rs@component_props_options.rs
#[derive(Props)]
struct ExplicitOptionProps<'a> {
    title: &'a str,
    #[props(!optional)]
    subtitle: Option<&'a str>,
}

fn ExplicitOption<'a>(cx: Scope<'a, ExplicitOptionProps>) -> Element<'a> {
    cx.render(rsx!(h1 {
        "{cx.props.title}: ",
        cx.props.subtitle.unwrap_or("No subtitle provided"),
    }))
}
````

Then, you have to explicitly pass either `Some("str")` or `None`:

````rs@component_props_options.rs
ExplicitOption {
title: "Some Title",
subtitle: None,
},
ExplicitOption {
title: "Some Title",
subtitle: Some("Some Title"),
},
// This won't compile:
// ExplicitOption {
//     title: "Some Title",
// },
````

### Default Props

You can use `#[props(default = 42)]` to make a field optional and specify its default value:

````rs@component_props_options.rs
#[derive(PartialEq, Props)]
struct DefaultProps {
    // default to 42 when not provided
    #[props(default = 42)]
    number: i64,
}

fn DefaultComponent(cx: Scope<DefaultProps>) -> Element {
    cx.render(rsx!(h1 { "{cx.props.number}" }))
}
````

Then, similarly to optional props, you don't have to provide it:

````rs@component_props_options.rs
DefaultComponent {
number: 5,
},
DefaultComponent {},
````

### Automatic Conversion with `.into`

It is common for Rust functions to accept `impl Into<SomeType>` rather than just `SomeType` to support a wider range of parameters. If you want similar functionality with props, you can use `#[props(into)]`. For example, you could add it on a `String` prop – and `&str` will also be automatically accepted, as it can be converted into `String`:

````rs@component_props_options.rs
#[derive(PartialEq, Props)]
struct IntoProps {
    #[props(into)]
    string: String,
}

fn IntoComponent(cx: Scope<IntoProps>) -> Element {
    cx.render(rsx!(h1 { "{cx.props.string}" }))
}
````

Then, you can use it so:

````rs@component_props_options.rs
IntoComponent {
string: "some &str",
},
````

## The component macro

So far, every Component function we've seen had a corresponding ComponentProps struct to pass in props. This was quite verbose... Wouldn't it be nice to have props as simple function arguments? Then we wouldn't need to define a Props struct, and instead of typing `cx.props.whatever`, we could just use `whatever` directly!

`component` allows you to do just that. Instead of typing the "full" version:

````rust, no_run
#[derive(Props, PartialEq)]
struct TitleCardProps {
    title: String,
}

fn TitleCard(cx: Scope<TitleCardProps>) -> Element {
    cx.render(rsx!{
        h1 { "{cx.props.title}" }
    })
}
````

...you can define a function that accepts props as arguments. Then, just annotate it with `#[component]`, and the macro will turn it into a regular Component for you:

````rust, no_run
#[component]
fn TitleCard(cx: Scope, title: String) -> Element {
    cx.render(rsx!{
        h1 { "{title}" }
    })
}
````

 > 
 > While the new Component is shorter and easier to read, this macro should not be used by library authors since you have less control over Prop documentation.

## Component Children

In some cases, you may wish to create a component that acts as a container for some other content, without the component needing to know what that content is. To achieve this, create a prop of type `Element`:

````rs@component_element_props.rs
#[derive(Props)]
struct ClickableProps<'a> {
    href: &'a str,
    body: Element<'a>,
}

fn Clickable<'a>(cx: Scope<'a, ClickableProps<'a>>) -> Element {
    cx.render(rsx!(
        a {
            href: "{cx.props.href}",
            class: "fancy-button",
            &cx.props.body
        }
    ))
}
````

Then, when rendering the component, you can pass in the output of `cx.render(rsx!(...))`:

````rs@component_element_props.rs
cx.render(rsx! {
    Clickable {
        href: "https://www.youtube.com/watch?v=C-M2hs3sXGo",
        body: cx.render(rsx!("How to " i {"not"} " be seen")),
    }
})
````

 > 
 > Note: Since `Element<'a>` is a borrowed prop, there will be no memoization.

 > 
 > Warning: While it may compile, do not include the same `Element` more than once in the RSX. The resulting behavior is unspecified.

### The children field

Rather than passing the RSX through a regular prop, you may wish to accept children similarly to how elements can have children. The "magic" `children` prop lets you achieve this:

````rs@component_children.rs
#[derive(Props)]
struct ClickableProps<'a> {
    href: &'a str,
    children: Element<'a>,
}

fn Clickable<'a>(cx: Scope<'a, ClickableProps<'a>>) -> Element {
    cx.render(rsx!(
        a {
            href: "{cx.props.href}",
            class: "fancy-button",
            &cx.props.children
        }
    ))
}
````

This makes using the component much simpler: simply put the RSX inside the `{}` brackets – and there is no need for a `render` call or another macro!

````rs@component_children.rs
cx.render(rsx! {
    Clickable {
        href: "https://www.youtube.com/watch?v=C-M2hs3sXGo",
        "How to " i {"not"} " be seen"
    }
})
````

````inject-dioxus
DemoFrame {
    component_children::App {}
}
````
# Event Handlers

Event handlers are used to respond to user actions. For example, an event handler could be triggered when the user clicks, scrolls, moves the mouse, or types a character.

Event handlers are attached to elements. For example, we usually don't care about all the clicks that happen within an app, only those on a particular button.

Event handlers are similar to regular attributes, but their name usually starts with `on`- and they accept closures as values. The closure will be called whenever the event it listens for is triggered and will be passed that event.

For example, to handle clicks on an element, we can specify an `onclick` handler:

````rs@event_click.rs
cx.render(rsx! {
    button {
        onclick: move |event| log::info!("Clicked! Event: {event:?}"),
        "click me!"
    }
})
````

````inject-dioxus
DemoFrame {
    event_click::App {}
}
````

## The Event object

Event handlers receive an [`Event`](https://docs.rs/dioxus-core/latest/dioxus_core/struct.Event.html) object containing information about the event. Different types of events contain different types of data. For example, mouse-related events contain [`MouseData`](https://docs.rs/dioxus/latest/dioxus/events/struct.MouseData.html), which tells you things like where the mouse was clicked and what mouse buttons were used.

In the example above, this event data was logged to the terminal:

````
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
````

To learn what the different event types for HTML provide, read the [events module docs](https://docs.rs/dioxus-html/latest/dioxus_html/events/index.html).

### Event propagation

Some events will trigger first on the element the event originated at upward. For example, a click event on a `button` inside a `div` would first trigger the button's event listener and then the div's event listener.

 > 
 > For more information about event propagation see [the mdn docs on event bubbling](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling)

If you want to prevent this behavior, you can call `stop_propagation()` on the event:

````rs@event_nested.rs
cx.render(rsx! {
    div {
        onclick: move |_event| {},
        "outer",
        button {
            onclick: move |event| {
                // now, outer won't be triggered
                event.stop_propagation();
            },
            "inner"
        }
    }
})
````

## Prevent Default

Some events have a default behavior. For keyboard events, this might be entering the typed character. For mouse events, this might be selecting some text.

In some instances, might want to avoid this default behavior. For this, you can add the `prevent_default` attribute with the name of the handler whose default behavior you want to stop. This attribute can be used for multiple handlers using their name separated by spaces:

````rs@event_prevent_default.rs
cx.render(rsx! {
    a {
        href: "https://example.com",
        prevent_default: "onclick",
        onclick: |_| log::info!("link clicked"),
        "example.com",
    }
})
````

````inject-dioxus
DemoFrame {
    event_prevent_default::App {}
}
````

Any event handlers will still be called.

 > 
 > Normally, in React or JavaScript, you'd call "preventDefault" on the event in the callback. Dioxus does *not* currently support this behavior. Note: this means you cannot conditionally prevent default behavior based on the data in the event.

## Handler Props

Sometimes, you might want to make a component that accepts an event handler. A simple example would be a `FancyButton` component, which accepts an `on_click` handler:

````rs@event_handler_prop.rs
#[derive(Props)]
pub struct FancyButtonProps<'a> {
    on_click: EventHandler<'a, MouseEvent>,
}

pub fn FancyButton<'a>(cx: Scope<'a, FancyButtonProps<'a>>) -> Element<'a> {
    cx.render(rsx!(button {
        class: "fancy-button",
        onclick: move |evt| cx.props.on_click.call(evt),
        "click me pls."
    }))
}
````

Then, you can use it like any other handler:

````rs@event_handler_prop.rs
cx.render(rsx! {
    FancyButton {
        on_click: move |event| println!("Clicked! {event:?}")
    }
})
````

 > 
 > Note: just like any other attribute, you can name the handlers anything you want! Though they must start with `on`, for the prop to be automatically turned into an `EventHandler` at the call site.

## Custom Data

Event Handlers are generic over any type, so you can pass in any data you want to them, e.g:

````rs@event_handler_prop.rs
struct ComplexData(i32);

#[derive(Props)]
pub struct CustomFancyButtonProps<'a> {
    on_click: EventHandler<'a, ComplexData>,
}

pub fn CustomFancyButton<'a>(cx: Scope<'a, CustomFancyButtonProps<'a>>) -> Element<'a> {
    cx.render(rsx!(button {
        class: "fancy-button",
        onclick: move |_| cx.props.on_click.call(ComplexData(0)),
        "click me pls."
    }))
}
````
# Hooks and component state

So far, our components have had no state like a normal Rust function. However, in a UI component, it is often useful to have stateful functionality to build user interactions. For example, you might want to track whether the user has opened a drop-down and render different things accordingly.

Hooks allow us to create state in our components. Hooks are Rust functions that take a reference to [`ScopeState`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html) (in a component, you can pass `cx`), and provide you with functionality and state.

Dioxus provides many built-in hooks, but if those hooks don't fit your specific use case, you also can [create your own hook](../cookbook/state/custom_hooks/index.md)

## use_state hook

[`use_state`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_state.html) is one of the simplest hooks.

* You provide a closure that determines the initial value: `let mut count = use_state(cx, || 0);`
* `use_state` gives you the current value, and a way to update it by setting it to something else
* When the value updates, `use_state` makes the component re-render (along with any other component that references it), and then provides you with the new value.

For example, you might have seen the counter example, in which state (a number) is tracked using the `use_state` hook:

````rs@hooks_counter.rs
pub fn App(cx: Scope) -> Element {
    // count will be initialized to 0 the first time the component is rendered
    let mut count = use_state(cx, || 0);

    cx.render(rsx!(
        h1 { "High-Five counter: {count}" }
        button {
            onclick: move |_| {
                // changing the count will cause the component to re-render
                count += 1
            },
            "Up high!"
        }
        button {
            onclick: move |_| {
                // changing the count will cause the component to re-render
                count -= 1
            },
            "Down low!"
        }
    ))
}
````

````inject-dioxus
DemoFrame {
   hooks_counter::App {}
}
````

Every time the component's state changes, it re-renders, and the component function is called, so you can describe what you want the new UI to look like. You don't have to worry about "changing" anything – describe what you want in terms of the state, and Dioxus will take care of the rest!

 > 
 > `use_state` returns your value wrapped in a smart pointer of type [`UseState`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.UseState.html). This is why you can both read the value and update it, even within an event handler.

You can use multiple hooks in the same component if you want:

````rs@hooks_counter_two_state.rs
pub fn App(cx: Scope) -> Element {
    let mut count_a = use_state(cx, || 0);
    let mut count_b = use_state(cx, || 0);

    cx.render(rsx!(
        h1 { "Counter_a: {count_a}" }
        button { onclick: move |_| count_a += 1, "a++" }
        button { onclick: move |_| count_a -= 1, "a--" }
        h1 { "Counter_b: {count_b}" }
        button { onclick: move |_| count_b += 1, "b++" }
        button { onclick: move |_| count_b -= 1, "b--" }
    ))
}
````

````inject-dioxus
DemoFrame {
  hooks_counter_two_state::App {}
}
````

### Out-of-date UseState

The value `UseState` dereferences to is only set when the use_state hook is called every render. This means that if you move the state into a future, or you write to the state and then immediately read the state, it may return an out-of-date value.

````rs@hooks_out_of_date.rs
pub fn App(cx: Scope) -> Element {
    // count will be initialized to 0 the first time the component is rendered
    let mut count = use_state(cx, || 0);
    let first_count_read = use_state(cx, || 0);

    // Increase the count
    if *count == 0 {
        count += 1;
        first_count_read.set(**count);
    }

    cx.render(rsx!(
        // This uses the deref value
        h1 { "High-Five counter: {first_count_read}" }
    ))
}
````

````inject-dioxus
DemoFrame {
   // original: hooks_out_of_date::App {}
   __interactive_04::hooks_out_of_date {}
}
````

Instead of using deref to get the inner value from UseState, you can use the [`current`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.UseState.html#method.current) function. This function will always return the current value of the state.

````rs@hooks_out_of_date.rs
pub fn App(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);
    let first_count_read = use_state(cx, || 0);

    // Increase the count
    if *count == 0 {
        count += 1;
        first_count_read.set(*count.current());
    }

    cx.render(rsx!(
        // Use .current to get the real current value
        h1 { "High-Five counter: {first_count_read}" }
    ))
}
````

````inject-dioxus
DemoFrame {
   // original: hooks_out_of_date::fixed::App {}
   __interactive_04::hooks_out_of_date_fixed {}
}
````

## Rules of hooks

The above example might seem a bit magic since Rust functions are typically not associated with state. Dioxus allows hooks to maintain state across renders through a reference to `ScopeState`, which is why you must pass `&cx` to them.

But how can Dioxus differentiate between multiple hooks in the same component? As you saw in the second example, both `use_state` functions were called with the same parameters, so how come they can return different things when the counters are different?

````rs@hooks_counter_two_state.rs
let mut count_a = use_state(cx, || 0);
let mut count_b = use_state(cx, || 0);
````

This is only possible because the two hooks are always called in the same order, so Dioxus knows which is which. Because the order you call hooks matters, you must follow certain rules when using hooks:

1. Hooks may be only used in components or other hooks (we'll get to that later).
1. On every call to a component function.
1. The same hooks must be called (except in the case of early returns, as explained later in the [Error Handling chapter](../cookbook/error_handling.md)).
1. In the same order.
1. Hook names should start with `use_` so you don't accidentally confuse them with regular
   functions (`use_state()`, `use_ref()`, `use_future()`, etc...).

These rules mean that there are certain things you can't do with hooks:

### No hooks in conditionals

````rs@hooks_bad.rs
// ❌ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy && you_know_it {
    let something = use_state(cx, || "hands");
    println!("clap your {something}")
}

// ✅ instead, *always* call use_state
// You can put other stuff in the conditional though
let something = use_state(cx, || "hands");
if you_are_happy && you_know_it {
    println!("clap your {something}")
}
````

### No hooks in closures

````rs@hooks_bad.rs
// ❌ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
    let b = use_state(cx, || 0);
    b.get()
};

// ✅ instead, move hook `b` outside
let b = use_state(cx, || 0);
let _a = || b.get();
````

### No hooks in loops

````rs@hooks_bad.rs
// `names` is a Vec<&str>

// ❌ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &names {
    let is_selected = use_state(cx, || false);
    println!("selected: {is_selected}");
}

// ✅ Instead, use a hashmap with use_ref
let selection_map = use_ref(cx, HashMap::<&str, bool>::new);

for name in &names {
    let is_selected = selection_map.read()[name];
    println!("selected: {is_selected}");
}
````

## use_ref hook

`use_state` is great for tracking simple values. However, in the [`UseState` API](https://docs.rs/dioxus/latest/dioxus/hooks/struct.UseState.html), you may notice that the only way to modify its value is to replace it with something else (e.g., by calling `set`, or through one of the `+=`, `-=` operators). This works well when it is cheap to construct a value (such as any primitive). But what if you want to maintain more complex data in the component's state?

For example, suppose we want to maintain a `Vec` of values. If we stored it with `use_state`, the
only way to add a new value to the list would be to copy the existing `Vec`, add our value to it,
and then replace the existing `Vec` in the state with it. This is expensive! We want to modify the
existing `Vec` instead.

Thankfully, there is another hook for that, `use_ref`! It is similar to `use_state`, but it lets you get a mutable reference to the contained data.

Here's a simple example that keeps a list of events in a `use_ref`. We can acquire write access to the state with `.with_mut()`, and then just `.push` a new value to the state:

````rs@hooks_use_ref.rs
pub fn App(cx: Scope) -> Element {
    let list = use_ref(cx, Vec::new);

    cx.render(rsx!(
        p { "Current list: {list.read():?}" }
        button {
            onclick: move |event| {
                list.with_mut(|list| list.push(event));
            },
            "Click me!"
        }
    ))
}
````

````inject-dioxus
DemoFrame {
   // original: hooks_use_ref::App {}
   __interactive_04::hooks_use_ref {}
}
````

 > 
 > The return values of `use_state` and `use_ref` (
 >  [`UseState`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.UseState.html) and
 >  [`UseRef`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.UseRef.html), respectively) are in
 >  some ways similar to [`Cell`](https://doc.rust-lang.org/std/cell/) and
 >  [`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) – they provide interior
 >  mutability. However, these Dioxus wrappers also ensure that the component gets re-rendered
 >  whenever you change the state.

## Additional resources

* [dioxus_hooks API docs](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/)
* [dioxus_hooks source code](https://github.com/DioxusLabs/dioxus/tree/master/packages/hooks)
# User Input

Interfaces often need to provide a way to input data: e.g. text, numbers, checkboxes, etc. In Dioxus, there are two ways you can work with user input.

## Controlled Inputs

With controlled inputs, you are directly in charge of the state of the input. This gives you a lot of flexibility, and makes it easy to keep things in sync. For example, this is how you would create a controlled text input:

````rs@input_controlled.rs
pub fn App(cx: Scope) -> Element {
    let name = use_state(cx, || "bob".to_string());

    cx.render(rsx! {
        input {
            // we tell the component what to render
            value: "{name}",
            // and what to do when the value changes
            oninput: move |evt| name.set(evt.value.clone()),
        }
    })
}
````

````inject-dioxus
DemoFrame {
    input_controlled::App {}
}
````

Notice the flexibility – you can:

* Also display the same contents in another element, and they will be in sync
* Transform the input every time it is modified (e.g. to make sure it is upper case)
* Validate the input every time it changes
* Have custom logic happening when the input changes (e.g. network request for autocompletion)
* Programmatically change the value (e.g. a "randomize" button that fills the input with nonsense)

## Uncontrolled Inputs

As an alternative to controlled inputs, you can simply let the platform keep track of the input values. If we don't tell a HTML input what content it should have, it will be editable anyway (this is built into the browser). This approach can be more performant, but less flexible. For example, it's harder to keep the input in sync with another element.

Since you don't necessarily have the current value of the uncontrolled input in state, you can access it either by listening to `oninput` events (similarly to controlled components), or, if the input is part of a form, you can access the form data in the form events (e.g. `oninput` or `onsubmit`):

````rs@input_uncontrolled.rs
pub fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        form {
            onsubmit: move |event| {
                log::info!("Submitted! {event:?}")
            },
            input { name: "name", },
            input { name: "age", },
            input { name: "date", },
            input { r#type: "submit", },
        }
    })
}
````

````inject-dioxus
DemoFrame {
    input_uncontrolled::App {}
}
````

````
Submitted! UiEvent { data: FormData { value: "", values: {"age": "very old", "date": "1966", "name": "Fred"} } }
````

## Handling files

You can insert a file picker by using an input element of type `file`. This element supports the `multiple` attribute, to let you pick more files at the same time. You can select a folder by adding the `directory` attribute: Dioxus will map this attribute to browser specific attributes, because there is no standardized way to allow a directory to be selected.

`type` is a Rust keyword, so when specifying the type of the input field, you have to write it as `r#type:"file"`.

Extracting the selected files is a bit different from what you may typically use in Javascript.

The `FormData` event contains a `files` field with data about the uploaded files. This field contains a `FileEngine` struct which lets you fetch the filenames selected by the user. This example saves the filenames of the selected files to a `Vec`:

````rs@input_fileengine.rs
pub fn App(cx: Scope) -> Element {
    let filenames: &UseRef<Vec<String>> = use_ref(cx, Vec::new);
    cx.render(rsx! {
        input {
            // tell the input to pick a file
            r#type:"file",
            // list the accepted extensions
            accept: ".txt,.rs",
            // pick multiple files
            multiple: true,
            onchange: move |evt| {
                if let Some(file_engine) = &evt.files {
                    let files = file_engine.files();
                    for file_name in files {
                        filenames.write().push(file_name);
                    }
                }
            }
        }
    })
}
````

If you're planning to read the file content, you need to do it asynchronously, to keep the rest of the UI interactive. This example event handler loads the content of the selected files in an async closure:

````rs@input_fileengine_async.rs
onchange: move |evt| {
    // A helper macro to use hooks in async environments
    to_owned![files_uploaded];
    async move {
        if let Some(file_engine) = &evt.files {
            let files = file_engine.files();
            for file_name in &files {
                // Make sure to use async/await when doing heavy I/O operations,
                // to not freeze the interface in the meantime
                if let Some(file) = file_engine.read_file_to_string(file_name).await{
                    files_uploaded.write().push(file);
                }
            }
        }
    }
}
````

Lastly, this example shows you how to select a folder, by setting the `directory` attribute to `true`.

````rs@input_fileengine_folder.rs
input {
    r#type:"file",
    // Select a folder by setting the directory attribute
    directory: true,
    onchange: |evt| {
        if let Some(file_engine) = &evt.files {
            let files = file_engine.files();
            for file_name in files {
                println!("{}", file_name);
                // Do something with the folder path
            }
        }
    }
}
````
# Sharing State

Often, multiple components need to access the same state. Depending on your needs, there are several ways to implement this.

## Lifting State

One approach to share state between components is to "lift" it up to the nearest common ancestor. This means putting the `use_state` hook in a parent component, and passing the needed values down as props.

Suppose we want to build a meme editor. We want to have an input to edit the meme caption, but also a preview of the meme with the caption. Logically, the meme and the input are 2 separate components, but they need access to the same state (the current caption).

 > 
 > Of course, in this simple example, we could write everything in one component – but it is better to split everything out in smaller components to make the code more reusable, maintainable, and performant (this is even more important for larger, complex apps).

We start with a `Meme` component, responsible for rendering a meme with a given caption:

````rs@meme_editor.rs
#[component]
fn Meme<'a>(cx: Scope<'a>, caption: &'a str) -> Element<'a> {
    let container_style = r#"
        position: relative;
        width: fit-content;
    "#;

    let caption_container_style = r#"
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 16px 8px;
    "#;

    let caption_style = r"
        font-size: 32px;
        margin: 0;
        color: white;
        text-align: center;
    ";

    cx.render(rsx!(
        div {
            style: "{container_style}",
            img {
                src: "https://i.imgflip.com/2zh47r.jpg",
                height: "500px",
            },
            div {
                style: "{caption_container_style}",
                p {
                    style: "{caption_style}",
                    "{caption}"
                }
            }
        }
    ))
}
````

 > 
 > Note that the `Meme` component is unaware where the caption is coming from – it could be stored in `use_state`, `use_ref`, or a constant. This ensures that it is very reusable – the same component can be used for a meme gallery without any changes!

We also create a caption editor, completely decoupled from the meme. The caption editor must not store the caption itself – otherwise, how will we provide it to the `Meme` component? Instead, it should accept the current caption as a prop, as well as an event handler to delegate input events to:

````rs@meme_editor.rs
#[component]
fn CaptionEditor<'a>(
    cx: Scope<'a>,
    caption: &'a str,
    on_input: EventHandler<'a, FormEvent>,
) -> Element<'a> {
    let input_style = r"
        border: none;
        background: cornflowerblue;
        padding: 8px 16px;
        margin: 0;
        border-radius: 4px;
        color: white;
    ";

    cx.render(rsx!(input {
        style: "{input_style}",
        value: "{caption}",
        oninput: move |event| on_input.call(event),
    }))
}
````

Finally, a third component will render the other two as children. It will be responsible for keeping the state and passing down the relevant props.

````rs@meme_editor.rs
fn MemeEditor(cx: Scope) -> Element {
    let container_style = r"
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin: 0 auto;
        width: fit-content;
    ";

    let caption = use_state(cx, || "me waiting for my rust code to compile".to_string());

    cx.render(rsx! {
        div {
            style: "{container_style}",
            h1 { "Meme Editor" },
            Meme {
                caption: caption,
            },
            CaptionEditor {
                caption: caption,
                on_input: move |event: FormEvent| {caption.set(event.value.clone());},
            },
        }
    })
}
````

![Meme Editor Screenshot: An old plastic skeleton sitting on a park bench. Caption: "me waiting for a language feature"](/assets/static/meme_editor_screenshot.png)

## Using Shared State

Sometimes, some state needs to be shared between multiple components far down the tree, and passing it down through props is very inconvenient.

Suppose now that we want to implement a dark mode toggle for our app. To achieve this, we will make every component select styling depending on whether dark mode is enabled or not.

 > 
 > Note: we're choosing this approach for the sake of an example. There are better ways to implement dark mode (e.g. using CSS variables). Let's pretend CSS variables don't exist – welcome to 2013!

Now, we could write another `use_state` in the top component, and pass `is_dark_mode` down to every component through props. But think about what will happen as the app grows in complexity – almost every component that renders any CSS is going to need to know if dark mode is enabled or not – so they'll all need the same dark mode prop. And every parent component will need to pass it down to them. Imagine how messy and verbose that would get, especially if we had components several levels deep!

Dioxus offers a better solution than this "prop drilling" – providing context. The [`use_shared_state_provider`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_shared_state_provider.html) hook is similar to `use_ref`, but it makes it available through [`use_shared_state`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_shared_state.html) for all children components.

First, we have to create a struct for our dark mode configuration:

````rs@meme_editor_dark_mode.rs
struct DarkMode(bool);
````

Now, in a top-level component (like `App`), we can provide the `DarkMode` context to all children components:

````rs@meme_editor_dark_mode.rs
use_shared_state_provider(cx, || DarkMode(false));
````

As a result, any child component of `App` (direct or not), can access the `DarkMode` context.

````rs@meme_editor_dark_mode.rs
let dark_mode_context = use_shared_state::<DarkMode>(cx);
````

 > 
 > `use_shared_state` returns `Option<UseSharedState<DarkMode>>` here. If the context has been provided, the value is `Some(UseSharedState<DarkMode>)`, which you can call `.read` or `.write` on, similarly to `UseRef`. Otherwise, the value is `None`.

For example, here's how we would implement the dark mode toggle, which both reads the context (to determine what color it should render) and writes to it (to toggle dark mode):

````rs@meme_editor_dark_mode.rs
pub fn DarkModeToggle(cx: Scope) -> Element {
    let dark_mode = use_shared_state::<DarkMode>(cx).unwrap();

    let style = if dark_mode.read().0 {
        "color:white"
    } else {
        ""
    };

    cx.render(rsx!(label {
        style: "{style}",
        "Dark Mode",
        input {
            r#type: "checkbox",
            oninput: move |event| {
                let is_enabled = event.value == "true";
                dark_mode.write().0 = is_enabled;
            },
        },
    }))
}
````
# Dynamic Rendering

Sometimes you want to render different things depending on the state/props. With Dioxus, just describe what you want to see using Rust control flow – the framework will take care of making the necessary changes on the fly if the state or props change!

## Conditional Rendering

To render different elements based on a condition, you could use an `if-else` statement:

````rs@conditional_rendering.rs
if *is_logged_in {
    cx.render(rsx! {
        "Welcome!"
        button {
            onclick: move |_| on_log_out.call(()),
            "Log Out",
        }
    })
} else {
    cx.render(rsx! {
        button {
            onclick: move |_| on_log_in.call(()),
            "Log In",
        }
    })
}
````

````inject-dioxus
DemoFrame {
  conditional_rendering::App {}
}
````

 > 
 > You could also use `match` statements, or any Rust function to conditionally render different things.

### Improving the `if-else` Example

You may have noticed some repeated code in the `if-else` example above. Repeating code like this is both bad for maintainability and performance. Dioxus will skip diffing static elements like the button, but when switching between multiple `rsx` calls it cannot perform this optimization. For this example either approach is fine, but for components with large parts that are reused between conditionals, it can be more of an issue.

We can improve this example by splitting up the dynamic parts and inserting them where they are needed.

````rs@conditional_rendering.rs
cx.render(rsx! {
    // We only render the welcome message if we are logged in
    // You can use if statements in the middle of a render block to conditionally render elements
    if *is_logged_in {
        // Notice the body of this if statement is rsx code, not an expression
        "Welcome!"
    }
    button {
        // depending on the value of `is_logged_in`, we will call a different event handler
        onclick: move |_| if *is_logged_in {
            on_log_in.call(())
        }
        else{
            on_log_out.call(())
        },
        if *is_logged_in {
            // if we are logged in, the button should say "Log Out"
            "Log Out"
        } else {
            // if we are not logged in, the button should say "Log In"
            "Log In"
        }
    }
})
````

````inject-dioxus
DemoFrame {
  conditional_rendering::LogInImprovedApp {}
}
````

### Inspecting `Element` props

Since `Element` is a `Option<VNode>`, components accepting `Element` as a prop can inspect its contents, and render different things based on that. Example:

````rs@component_children_inspect.rs
fn Clickable<'a>(cx: Scope<'a, ClickableProps<'a>>) -> Element {
    match cx.props.children {
        Some(VNode { dynamic_nodes, .. }) => {
            todo!("render some stuff")
        }
        _ => {
            todo!("render some other stuff")
        }
    }
}
````

You can't mutate the `Element`, but if you need a modified version of it, you can construct a new one based on its attributes/children/etc.

## Rendering Nothing

To render nothing, you can return `None` from a component. This is useful if you want to conditionally hide something:

````rs@conditional_rendering.rs
if *is_logged_in {
    return None;
}

cx.render(rsx! {
    a {
        "You must be logged in to comment"
    }
})
````

````inject-dioxus
DemoFrame {
  conditional_rendering::LogInWarningApp {}
}
````

This works because the `Element` type is just an alias for `Option<VNode>`

 > 
 > Again, you may use a different method to conditionally return `None`. For example the boolean's [`then()`](https://doc.rust-lang.org/std/primitive.bool.html#method.then) function could be used.

## Rendering Lists

Often, you'll want to render a collection of components. For example, you might want to render a list of all comments on a post.

For this, Dioxus accepts iterators that produce `Element`s. So we need to:

* Get an iterator over all of our items (e.g., if you have a `Vec` of comments, iterate over it with `iter()`)
* `.map` the iterator to convert each item into a `LazyNode` using `rsx!(...)`
  * Add a unique `key` attribute to each iterator item
* Include this iterator in the final RSX (or use it inline)

Example: suppose you have a list of comments you want to render. Then, you can render them like this:

````rs@rendering_lists.rs
let comment_field = use_state(cx, String::new);
let mut next_id = use_state(cx, || 0);
let comments = use_ref(cx, Vec::<Comment>::new);

let comments_lock = comments.read();
let comments_rendered = comments_lock.iter().map(|comment| {
    rsx!(CommentComponent {
        key: "{comment.id}",
        comment: comment.clone(),
    })
});

cx.render(rsx!(
    form {
        onsubmit: move |_| {
            comments.write().push(Comment {
                content: comment_field.get().clone(),
                id: *next_id.get(),
            });
            next_id += 1;

            comment_field.set(String::new());
        },
        input {
            value: "{comment_field}",
            oninput: move |event| comment_field.set(event.value.clone()),
        }
        input {
            r#type: "submit",
        }
    },
    comments_rendered,
))
````

````inject-dioxus
DemoFrame {
  rendering_lists::App {}
}
````

### Inline for loops

Because of how common it is to render a list of items, Dioxus provides a shorthand for this. Instead of using `.iter`, `.map`, and `rsx`, you can use a `for` loop with a body of rsx code:

````rs@rendering_lists.rs
let comment_field = use_state(cx, String::new);
let mut next_id = use_state(cx, || 0);
let comments = use_ref(cx, Vec::<Comment>::new);

cx.render(rsx!(
    form {
        onsubmit: move |_| {
            comments.write().push(Comment {
                content: comment_field.get().clone(),
                id: *next_id.get(),
            });
            next_id += 1;

            comment_field.set(String::new());
        },
        input {
            value: "{comment_field}",
            oninput: move |event| comment_field.set(event.value.clone()),
        }
        input {
            r#type: "submit",
        }
    },
    for comment in &*comments.read() {
        // Notice the body of this for loop is rsx code, not an expression
        CommentComponent {
            key: "{comment.id}",
            comment: comment.clone(),
        }
    }
))
````

````inject-dioxus
DemoFrame {
  rendering_lists::AppForLoop {}
}
````

### The key Attribute

Every time you re-render your list, Dioxus needs to keep track of which items go where to determine what updates need to be made to the UI.

For example, suppose the `CommentComponent` had some state – e.g. a field where the user typed in a reply. If the order of comments suddenly changes, Dioxus needs to correctly associate that state with the same comment – otherwise, the user will end up replying to a different comment!

To help Dioxus keep track of list items, we need to associate each item with a unique key. In the example above, we dynamically generated the unique key. In real applications, it's more likely that the key will come from e.g. a database ID. It doesn't matter where you get the key from, as long as it meets the requirements:

* Keys must be unique in a list
* The same item should always get associated with the same key
* Keys should be relatively small (i.e. converting the entire Comment structure to a String would be a pretty bad key) so they can be compared efficiently

You might be tempted to use an item's index in the list as its key. That’s what Dioxus will use if you don’t specify a key at all. This is only acceptable if you can guarantee that the list is constant – i.e., no re-ordering, additions, or deletions.

 > 
 > Note that if you pass the key to a component you've made, it won't receive the key as a prop. It’s only used as a hint by Dioxus itself. If your component needs an ID, you have to pass it as a separate prop.
# Router

In many of your apps, you'll want to have different "scenes". For a webpage, these scenes might be the different webpages with their own content. For a desktop app, these scenes might be different views in your app.

To unify these platforms, Dioxus provides a first-party solution for scene management called Dioxus Router.

## What is it?

For an app like the Dioxus landing page (https://dioxuslabs.com), we want to have several different scenes:

* Homepage
* Blog

Each of these scenes is independent – we don't want to render both the homepage and blog at the same time.

The Dioxus router makes it easy to create these scenes. To make sure we're using the router, add the `dioxus-router` package to your `Cargo.toml`.

````shell
cargo add dioxus-router
````

## Using the router

Unlike other routers in the Rust ecosystem, our router is built declaratively at compile time. This makes it possible to compose our app layout simply by defining an enum.

````rust
// All of our routes will be a variant of this Route enum
enum Route {
	// if the current location is "/home", render the Home component
	#[route("/home")]
	Home {},
	// if the current location is "/blog", render the Blog component
	#[route("/blog")]
	Blog {},
}
````

Whenever we visit this app, we will get either the Home component or the Blog component rendered depending on which route we enter at. If neither of these routes match the current location, then nothing will render.

We can fix this one of two ways:

* A fallback 404 page

````rust
enum Route {
	#[route("/home")]
	Home {},
	#[route("/blog")]
	Blog {},
	//  if the current location doesn't match any of the above routes, render the NotFound component
	#[route("/:..segments")]
	NotFound { segments: Vec<String> },
}
````

* Redirect 404 to home

````rust
enum Route {
	#[route("/home")]
	//  if the current location doesn't match any of the above routes, redirect to "/home"
	#[redirect("/:..segments", |segments: Vec<String>| Route::Home {})]
	Home {},
	#[route("/blog")]
	Blog {},
	//  if the current location doesn't match any of the above routes, render the NotFound component
	#[route("/:..segments")]
	NotFound { segments: Vec<String> },
}
````

## Links

For our app to navigate these routes, we can provide clickable elements called Links. These simply wrap `<a>` elements that, when clicked, navigate the app to the given location. Because our route is an enum of valid routes, if you try to link to a page that doesn't exist, you will get a compiler error.

````rust
rsx! {
	Link {
		to: Route::Home {},
		"Go home!"
	}
}
````

## More reading

This page is just a very brief overview of the router. For more information, check out the [router book](../router/index.md) or some of the [router examples](https://github.com/DioxusLabs/dioxus/blob/master/examples/router.rs).
# UseFuture

[`use_future`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_future.html) lets you run an async closure, and provides you with its result.

For example, we can make an API request (using [reqwest](https://docs.rs/reqwest/latest/reqwest/index.html)) inside `use_future`:

````rs@use_future.rs
let future = use_future(cx, (), |_| async move {
    reqwest::get("https://dog.ceo/api/breeds/image/random")
        .await
        .unwrap()
        .json::<ApiResponse>()
        .await
});
````

The code inside `use_future` will be submitted to the Dioxus scheduler once the component has rendered.

We can use `.value()` to get the result of the future. On the first run, since there's no data ready when the component loads, its value will be `None`. However, once the future is finished, the component will be re-rendered and the value will now be `Some(...)`, containing the return value of the closure.

We can then render that result:

````rs@use_future.rs
cx.render(match future.value() {
    Some(Ok(response)) => rsx! {
        button {
            onclick: move |_| future.restart(),
            "Click to fetch another doggo"
        }
        div {
            img {
                max_width: "500px",
                max_height: "500px",
                src: "{response.image_url}",
            }
        }
    },
    Some(Err(_)) => rsx! { div { "Loading dogs failed" } },
    None => rsx! { div { "Loading dogs..." } },
})
````

````inject-dioxus
DemoFrame {
    // original: use_future::App {}
    __interactive_04::use_future_ {}
}
````

## Restarting the Future

The `UseFuture` handle provides a `restart` method. It can be used to execute the future again, producing a new value.

## Dependencies

Often, you will need to run the future again every time some value (e.g. a prop) changes. Rather than calling `restart` manually, you can provide a tuple of "dependencies" to the hook. It will automatically re-run the future when any of those dependencies change. Example:

````rs@use_future.rs
let future = use_future(cx, (breed,), |(breed,)| async move {
    reqwest::get(format!("https://dog.ceo/api/breed/{breed}/images/random"))
        .await
        .unwrap()
        .json::<ApiResponse>()
        .await
});
````
# Coroutines

Another tool in your async toolbox are coroutines. Coroutines are futures that can have values sent to them.

Like regular futures, code in a coroutine will run until the next `await` point before yielding. This low-level control over asynchronous tasks is quite powerful, allowing for infinitely looping tasks like WebSocket polling, background timers, and other periodic actions.

## use_coroutine

The `use_coroutine` hook allows you to create a coroutine. Most coroutines we write will be polling loops using await.

````rs@use_coroutine_reference.rs
use futures_util::StreamExt;

fn app(cx: Scope) {
    let ws: &Coroutine<()> = use_coroutine(cx, |rx| async move {
        // Connect to some sort of service
        let mut conn = connect_to_ws_server().await;

        // Wait for data on the service
        while let Some(msg) = conn.next().await {
            // handle messages
        }
    });
}
````

For many services, a simple async loop will handle the majority of use cases.

## Yielding Values

To yield values from a coroutine, simply bring in a `UseState` handle and set the value whenever your coroutine completes its work.

The future must be `'static` – so any values captured by the task cannot carry any references to `cx`, such as a `UseState`.

You can use [to_owned](https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned) to create a clone of the hook handle which can be moved into the async closure.

````rs@use_coroutine_reference.rs
let sync_status = use_state(cx, || Status::Launching);
let sync_task = use_coroutine(cx, |rx: UnboundedReceiver<SyncAction>| {
    let sync_status = sync_status.to_owned();
    async move {
        loop {
            tokio::time::sleep(Duration::from_secs(1)).await;
            sync_status.set(Status::Working);
        }
    }
});
````

To make this a bit less verbose, Dioxus exports the `to_owned!` macro which will create a binding as shown above, which can be quite helpful when dealing with many values.

````rs@use_coroutine_reference.rs
let sync_status = use_state(cx, || Status::Launching);
let load_status = use_state(cx, || Status::Launching);
let sync_task = use_coroutine(cx, |rx: UnboundedReceiver<SyncAction>| {
    to_owned![sync_status, load_status];
    async move {
        // ...
    }
});
````

## Sending Values

You might've noticed the `use_coroutine` closure takes an argument called `rx`. What is that? Well, a common pattern in complex apps is to handle a bunch of async code at once. With libraries like Redux Toolkit, managing multiple promises at once can be challenging and a common source of bugs.

With Coroutines, we can centralize our async logic. The `rx` parameter is an Channel that allows code external to the coroutine to send data *into* the coroutine. Instead of looping on an external service, we can loop on the channel itself, processing messages from within our app without needing to spawn a new future. To send data into the coroutine, we would call "send" on the handle.

````rs@use_coroutine_reference.rs
use futures_util::StreamExt;

enum ProfileUpdate {
    SetUsername(String),
    SetAge(i32),
}

let profile = use_coroutine(cx, |mut rx: UnboundedReceiver<ProfileUpdate>| async move {
    let mut server = connect_to_server().await;

    while let Some(msg) = rx.next().await {
        match msg {
            ProfileUpdate::SetUsername(name) => server.update_username(name).await,
            ProfileUpdate::SetAge(age) => server.update_age(age).await,
        }
    }
});

cx.render(rsx! {
    button {
        onclick: move |_| profile.send(ProfileUpdate::SetUsername("Bob".to_string())),
        "Update username"
    }
})
````

 > 
 > Note: In order to use/run the `rx.next().await` statement you will need to extend the \[`Stream`\] trait (used by \[`UnboundedReceiver`\]) by adding 'futures_util' as a dependency to your project and adding the `use futures_util::stream::StreamExt;`.

For sufficiently complex apps, we could build a bunch of different useful "services" that loop on channels to update the app.

````rs@use_coroutine_reference.rs
let profile = use_coroutine(cx, profile_service);
let editor = use_coroutine(cx, editor_service);
let sync = use_coroutine(cx, sync_service);

async fn profile_service(rx: UnboundedReceiver<ProfileCommand>) {
    // do stuff
}

async fn sync_service(rx: UnboundedReceiver<SyncCommand>) {
    // do stuff
}

async fn editor_service(rx: UnboundedReceiver<EditorCommand>) {
    // do stuff
}
````

We can combine coroutines with [Fermi](https://docs.rs/fermi/latest/fermi/index.html) to emulate Redux Toolkit's Thunk system with much less headache. This lets us store all of our app's state *within* a task and then simply update the "view" values stored in Atoms. It cannot be understated how powerful this technique is: we get all the perks of native Rust tasks with the optimizations and ergonomics of global state. This means your *actual* state does not need to be tied up in a system like Fermi or Redux – the only Atoms that need to exist are those that are used to drive the display/UI.

````rs@use_coroutine_reference.rs
static USERNAME: Atom<String> = Atom(|_| "default".to_string());

fn app(cx: Scope) -> Element {
    let atoms = use_atom_root(cx);

    use_coroutine(cx, |rx| sync_service(rx, atoms.clone()));

    cx.render(rsx! {
        Banner {}
    })
}

fn Banner(cx: Scope) -> Element {
    let username = use_read(cx, &USERNAME);

    cx.render(rsx! {
        h1 { "Welcome back, {username}" }
    })
}
````

Now, in our sync service, we can structure our state however we want. We only need to update the view values when ready.

````rs@use_coroutine_reference.rs

````

## Automatic injection into the Context API

Coroutine handles are automatically injected through the context API. You can use the `use_coroutine_handle` hook with the message type as a generic to fetch a handle.

````rs@use_coroutine_reference.rs
fn Child(cx: Scope) -> Element {
    let sync_task = use_coroutine_handle::<SyncAction>(cx).unwrap();

    sync_task.send(SyncAction::SetUsername);

    todo!()
}
````
# Spawning Futures

The `use_future` and `use_coroutine` hooks are useful if you want to unconditionally spawn the future. Sometimes, though, you'll want to only spawn a future in response to an event, such as a mouse click. For example, suppose you need to send a request when the user clicks a "log in" button. For this, you can use `cx.spawn`:

````rs@spawn.rs
let response = use_state(cx, || String::from("..."));

let log_in = move |_| {
    cx.spawn({
        to_owned![response];

        async move {
            let resp = reqwest::Client::new()
                .get("https://dioxuslabs.com")
                .send()
                .await;

            match resp {
                Ok(_data) => {
                    log::info!("dioxuslabs.com responded!");
                    response.set("dioxuslabs.com responded!".into());
                }
                Err(err) => {
                    log::info!("Request failed with error: {err:?}")
                }
            }
        }
    });
};

render! {
    button {
        onclick: log_in,
        "Response: {response}",
    }
}
````

````inject-dioxus
DemoFrame {
    spawn::App {}
}
````

 > 
 > Note: `spawn` will always spawn a *new* future. You most likely don't want to call it on every render.

Calling `spawn` will give you a `JoinHandle` which lets you cancel or pause the future.

## Spawning Tokio Tasks

Sometimes, you might want to spawn a background task that needs multiple threads or talk to hardware that might block your app code. In these cases, we can directly spawn a Tokio task from our future. For Dioxus-Desktop, your task will be spawned onto Tokio's Multithreaded runtime:

````rs@spawn.rs
cx.spawn(async {
    let _ = tokio::spawn(async {}).await;

    let _ = tokio::task::spawn_local(async {
        // some !Send work
    })
    .await;
});
````
# Desktop

This guide will cover concepts specific to the Dioxus desktop renderer.

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus desktop exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -> Element {
    // Use eval returns a function that can spawn eval instances
    let create_eval = use_eval(cx);

    // You can create as many eval instances as you want
    let mut eval = create_eval(
        r#"
        // You can send messages from JavaScript to Rust with the dioxus.send function
        dioxus.send("Hi from JS!");
        // You can receive messages from Rust to JavaScript with the dioxus.recv function
        let msg = await dioxus.recv();
        console.log(msg);
        "#,
    )
    .unwrap();

    // You can send messages to JavaScript with the send method
    eval.send("Hi from Rust!".into()).unwrap();

    let future = use_future(cx, (), |_| {
        to_owned![eval];
        async move {
            // You can receive any message from JavaScript with the recv method
            eval.recv().await.unwrap()
        }
    });

    match future.value() {
        Some(v) => cx.render(rsx!(
            p { "{v}" }
        )),
        _ => cx.render(rsx!(
            p { "hello" }
        )),
    }
}

````

## Custom Assets

You can link to local assets in dioxus desktop instead of using a url:

````rs@custom_assets.rs
use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            img { src: "examples/assets/logo.png" }
        }
    })
}

````

## Integrating with Wry

In cases where you need more low level control over your window, you can use wry APIs exposed through the [Desktop Config](https://docs.rs/dioxus-desktop/0.3.0/dioxus_desktop/struct.Config.html) and the [use_window hook](https://docs.rs/dioxus-desktop/0.4.0/dioxus_desktop/fn.use_window.html)
# Web

This guide will cover concepts specific to the Dioxus web renderer.

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus desktop exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -> Element {
    // Use eval returns a function that can spawn eval instances
    let create_eval = use_eval(cx);

    // You can create as many eval instances as you want
    let mut eval = create_eval(
        r#"
        // You can send messages from JavaScript to Rust with the dioxus.send function
        dioxus.send("Hi from JS!");
        // You can receive messages from Rust to JavaScript with the dioxus.recv function
        let msg = await dioxus.recv();
        console.log(msg);
        "#,
    )
    .unwrap();

    // You can send messages to JavaScript with the send method
    eval.send("Hi from Rust!".into()).unwrap();

    let future = use_future(cx, (), |_| {
        to_owned![eval];
        async move {
            // You can receive any message from JavaScript with the recv method
            eval.recv().await.unwrap()
        }
    });

    match future.value() {
        Some(v) => cx.render(rsx!(
            p { "{v}" }
        )),
        _ => cx.render(rsx!(
            p { "hello" }
        )),
    }
}

````

If you are targeting web, but don't plan on targeting any other Dioxus renderer you can also use the generated wrappers in the [web-sys](https://rustwasm.github.io/wasm-bindgen/web-sys/index.html) and [gloo](https://gloo-rs.web.app/) crates.

## Customizing Index Template

Dioxus supports providing custom index.html templates. The index.html must include a `div` with the id `main` to be used. Hot Reload is still supported. An example
is provided in the [PWA-Example](https://github.com/DioxusLabs/Dioxus/examples/PWA-example/index.html).
# Server-Side Rendering

For lower-level control over the rendering process, you can use the `dioxus-ssr` crate directly. This can be useful when integrating with a web framework that `dioxus-fullstack` does not support, or pre-rendering pages.

## Setup

For this guide, we're going to show how to use Dioxus SSR with [Axum](https://docs.rs/axum/latest/axum/).

Make sure you have Rust and Cargo installed, and then create a new project:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the ssr renderer as dependencies:

````shell
cargo add dioxus
cargo add dioxus-ssr
````

Next, add all the Axum dependencies. This will be different if you're using a different Web Framework

````
cargo add tokio --features full
cargo add axum
````

Your dependencies should look roughly like this:

````toml
[dependencies]
axum = "0.4.5"
dioxus = { version = "*" }
dioxus-ssr = { version = "*" }
tokio = { version = "1.15.0", features = ["full"] }
````

Now, set up your Axum app to respond on an endpoint.

````rust
use axum::{response::Html, routing::get, Router};
use dioxus::prelude::*;

#[tokio::main]
async fn main() {
	let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 3000));
	println!("listening on http://{}", addr);

	axum::Server::bind(&addr)
		.serve(
			Router::new()
				.route("/", get(app_endpoint))
				.into_make_service(),
		)
		.await
		.unwrap();
}
````

And then add our endpoint. We can either render `rsx!` directly:

````rust
async fn app_endpoint() -> Html<String> {
	// render the rsx! macro to HTML
	Html(dioxus_ssr::render_lazy(rsx! {
		div { "hello world!" }
	}))
}
````

Or we can render VirtualDoms.

````rust
async fn app_endpoint() -> Html<String> {
	// create a component that renders a div with the text "hello world"
	fn app(cx: Scope) -> Element {
		cx.render(rsx!(div { "hello world" }))
	}
	// create a VirtualDom with the app component
	let mut app = VirtualDom::new(app);
	// rebuild the VirtualDom before rendering
	let _ = app.rebuild();

	// render the VirtualDom to HTML
	Html(dioxus_ssr::render_vdom(&app))
}
````

## Multithreaded Support

The Dioxus VirtualDom, sadly, is not currently `Send`. Internally, we use quite a bit of interior mutability which is not thread-safe.
When working with web frameworks that require `Send`, it is possible to render a VirtualDom immediately to a String – but you cannot hold the VirtualDom across an await point. For retained-state SSR (essentially LiveView), you'll need to spawn a VirtualDom on its own thread and communicate with it via channels or create a pool of VirtualDoms.
You might notice that you cannot hold the VirtualDom across an await point. Because Dioxus is currently not ThreadSafe, it *must* remain on the thread it started. We are working on loosening this requirement.
# Liveview

This guide will cover concepts specific to the Dioxus liveview renderer.

## Router Integration

Currently, the Dioxus router does not integrate with the browser history in the liveview renderer. If you are interested in contributing this feature to Dioxus this issue is tracked [here](https://github.com/DioxusLabs/dioxus/issues/1038).

## Managing Latency

Liveview makes it incredibly convenient to talk to your server from the client, but there are some downsides. Mainly in Dioxus Liveview every interaction goes through the server by default.

Because of this, with the liveview renderer you need to be very deliberate about managing latency. Events that would be fast enough on other renderers like [controlled inputs](../reference/user_input.md), can be frustrating to use in the liveview renderer.

To get around this issue you can inject bits of javascript in your liveview application. If you use a raw attribute as a listener, you can inject some javascript that will be run when the event is triggered:

````rust
render! {
    div {
        input {
            "oninput": "console.log('input changed!')"
        }
    }
}
````
# Fullstack development

Dioxus Fullstack contains helpers for:

* Incremental, static, and server side rendering
* Hydrating your application on the Client
* Communicating between a server and a client

This guide will teach you everything you need to know about how to use the utilities in Dioxus fullstack to create amazing fullstack applications.

 > 
 > In addition to this guide, you can find more examples of full-stack apps and information about how to integrate with other frameworks and desktop renderers in the [dioxus-fullstack examples directory](https://github.com/DioxusLabs/dioxus/tree/master/packages/fullstack/examples).
# Communicating with the server

`dioxus-fullstack` provides server functions that allow you to call an automatically generated API on the server from the client as if it were a local function.

To make a server function, simply add the `#[server(YourUniqueType)]` attribute to a function. The function must:

* Be an async function
* Have arguments and a return type that both implement serialize and deserialize (with [serde](https://serde.rs/)).
* Return a `Result` with an error type of ServerFnError

You must call `register` on the type you passed into the server macro in your main function before starting your server to tell Dioxus about the server function.

Let's continue building on the app we made in the [getting started](../../getting_started/fullstack.md) guide. We will add a server function to our app that allows us to double the count on the server.

First, add serde as a dependency:

````shell
cargo add serde
````

Next, add the server function to your `main.rs`:

````rs@server_function.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;

fn main() {
    let config = LaunchBuilder::new(App);
    #[cfg(feature = "ssr")]
    let config = config.incremental(
        IncrementalRendererConfig::default().invalidate_after(std::time::Duration::from_secs(120)),
    );

    config.launch();
}

fn App(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
        button {
            onclick: move |_| {
                to_owned![count];
                async move {
                    // Call the server function just like a local async function
                    if let Ok(new_count) = double_server(*count.current()).await {
                        count.set(new_count);
                    }
                }
            },
            "Double"
        }
    })
}

#[server]
async fn double_server(number: i32) -> Result<i32, ServerFnError> {
    // Perform some expensive computation or access a database on the server
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    let result = number * 2;
    println!("server calculated {result}");
    Ok(result)
}

````

Now, build your client-side bundle with `dx build --features web` and run your server with `cargo run --features ssr`. You should see a new button that multiplies the count by 2.

## Cached data fetching

One common use case for server functions is fetching data from the server:

````rs@server_data_fetch.rs
#![allow(non_snake_case, unused)]

use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;

fn main() {
    LaunchBuilder::new(app).launch();
}

fn app(cx: Scope) -> Element {
    let mut count = use_future(cx, (), |_| async { get_server_data().await });

    cx.render(rsx! {
        "server data is {count.value():?}"
    })
}

#[server]
async fn get_server_data() -> Result<String, ServerFnError> {
    // Access a database
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    Ok("Hello from the server!".to_string())
}

````

If you navigate to the site above, you will first see `server data is None`, then after the `WASM` has loaded and the request to the server has finished, you will see `server data is Some(Ok("Hello from the server!"))`.

This approach works, but it can be slow. Instead of waiting for the client to load and send a request to the server, what if we could get all of the data we needed for the page on the server and send it down to the client with the initial HTML page?

This is exactly what the `use_server_future` hook allows us to do! `use_server_future` is similar to the `use_future` hook, but it allows you to wait for a future on the server and send the result of the future down to the client.

Let's change our data fetching to use `use_server_future`:

````rs@server_data_prefetch.rs
#![allow(non_snake_case, unused)]

use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;

fn main() {
    LaunchBuilder::new(app).launch();
}

fn app(cx: Scope) -> Element {
    let mut count = use_server_future(cx, (), |_| async { get_server_data().await })?;

    cx.render(rsx! {
        "server data is {count.value():?}"
    })
}

#[server]
async fn get_server_data() -> Result<String, ServerFnError> {
    // Access a database
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    Ok("Hello from the server!".to_string())
}

````

 > 
 > Notice the `?` after `use_server_future`. This is what tells Dioxus fullstack to wait for the future to resolve before continuing rendering. If you want to not wait for a specific future, you can just remove the ? and deal with the `Option` manually.

Now when you load the page, you should see `server data is Ok("Hello from the server!")`. No need to wait for the `WASM` to load or wait for the request to finish!

````inject-dioxus
SandBoxFrame {
	url: "https://codesandbox.io/p/sandbox/dioxus-fullstack-server-future-qwpp4p?file=/src/main.rs:3,24"
}
````

## Running the client with dioxus-desktop

The project presented so far makes a web browser interact with the server, but it is also possible to make a desktop program interact with the server in a similar fashion. (The full example code is available in the [Dioxus repo](https://github.com/DioxusLabs/dioxus/tree/master/packages/fullstack/examples/axum-desktop))

First, we need to make two binary targets, one for the desktop program (the `client.rs` file), one for the server (the `server.rs` file). The client app and the server functions are written in a shared `lib.rs` file.

The desktop and server targets have slightly different build configuration to enable additional dependencies or features.
The Cargo.toml in the full example has more information, but the main points are:

* the client.rs has to be run with the `desktop` feature, so that the optional `dioxus-desktop` dependency is included
* the server.rs has to be run with the `ssr` features; this will generate the server part of the server functions and will include the `axum` dependency to run as a server.

Once you create your project, you can run the server executable with:

````bash
cargo run --bin server --features ssr
````

and the client desktop executable with:

````bash
cargo run --bin client --features desktop
````

### Client code

The client file is pretty straightforward. You only need to set the server url in the client code, so it knows where to send the network requests. Then, dioxus_desktop launches the app.

For development, the example project runs the server on `localhost:8080`. **Before you release remember to update the url to your production url.**

### Server code

In the server code, first you have to set the network address and port where the server will listen to.

````rs@server_function_desktop_client.rs
let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 8080));
````

Then, you have to register the types declared in the server function macros into the axum server.
For example, consider this server function:

````rs@server_function_desktop_client.rs
#[server(GetServerData)]
async fn get_server_data() -> Result<String, ServerFnError> {
    Ok("Hello from the server!".to_string())
}
````

The `GetServerData` type has to be registered in the axum server, which will add the corresponding route to the server.

````rs@server_function_desktop_client.rs
let _ = GetServerData::register_explicit();
````

Finally, the server is started and it begins responding to requests.
# Extractors

Server functions are an ergonomic way to call a function on the server. Server function work by registering an endpoint on the server and using requests on the client. Most of the time, you shouldn't need to worry about how server functions operate, but there are some times when you need to get some value from the request other than the data passed in the server function.

For example, requests contain information about the user's browser (called the [user agent](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent)). We can use an extractor to retrieve that information.

You can use the `extract` method within a server function to extract something from the request. You can extract any type that implements `FromServerContext` (or when axum is enabled, you can use axum extractors directly):

````rs@server_function_extract.rs
#[server]
pub async fn log_user_agent() -> Result<(), ServerFnError> {
    let axum::TypedHeader(user_agent): axum::TypedHeader<axum::headers::UserAgent> =
        extract().await?;
    log::info!("{:?}", user_agent);
    Ok(())
}
````
# Middleware

Extractors allow you to wrap your server function in some code that changes either the request or the response. Dioxus fullstack integrates with [Tower](https://docs.rs/tower/latest/tower/index.html) to allow you to wrap your server functions in middleware.

You can use the `#[middleware]` attribute to add a layer of middleware to your server function. Let's add a timeout middleware to a server function. This middleware will stop running the server function if it reaches a certain timeout:

````rs@server_function_middleware.rs
#[server]
// Add a timeout middleware to the server function that will return an error if the function takes longer than 1 second to execute
#[middleware(tower_http::timeout::TimeoutLayer::new(std::time::Duration::from_secs(1)))]
pub async fn timeout() -> Result<(), ServerFnError> {
    tokio::time::sleep(std::time::Duration::from_secs(2)).await;
    Ok(())
}
````
# Authentication

You can use [extractors](./extractors.md) to integrate auth with your Fullstack application.

You can create a custom extractors that extracts the auth session from the request. From that auth session, you can check if the user has the required privileges before returning the private data.

A [full auth example](https://github.com/dioxuslabs/dioxus/blob/master/packages/fullstack/examples/axum-auth/src/main.rs) with the complete implementation is available in the fullstack examples.
# Routing

You can easily integrate your fullstack application with a client side router using the `launch_router` macro. The `launch_router` macro works the same as the `launch` macro except it accepts a Router instead of a Component:

````rs@server_router.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;
use serde::{Deserialize, Serialize};

fn main() {
    let config = LaunchBuilder::<FullstackRouterConfig<Route>>::router();
    #[cfg(feature = "ssr")]
    config
        .incremental(
            IncrementalRendererConfig::default()
                .invalidate_after(std::time::Duration::from_secs(120)),
        )
        .launch();

    #[cfg(not(feature = "ssr"))]
    config.launch();
}

#[derive(Clone, Routable, Debug, PartialEq, Serialize, Deserialize)]
enum Route {
    #[route("/")]
    Home {},
    #[route("/blog/:id")]
    Blog { id: i32 },
}

#[component]
fn Blog(cx: Scope, id: i32) -> Element {
    render! {
        Link { to: Route::Home {}, "Go to counter" }
        table {
            tbody {
                for _ in 0..*id {
                    tr {
                        for _ in 0..*id {
                            td { "hello world!" }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn Home(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);
    let text = use_state(cx, || "...".to_string());

    cx.render(rsx! {
        Link {
            to: Route::Blog {
                id: *count.get()
            },
            "Go to blog"
        }
        div {
            h1 { "High-Five counter: {count}" }
            button { onclick: move |_| count += 1, "Up high!" }
            button { onclick: move |_| count -= 1, "Down low!" }
            button {
                onclick: move |_| {
                    to_owned![text];
                    async move {
                        if let Ok(data) = get_server_data().await {
                            println!("Client received: {}", data);
                            text.set(data.clone());
                            post_server_data(data).await.unwrap();
                        }
                    }
                },
                "Run server function!"
            }
            "Server said: {text}"
        }
    })
}

#[server(PostServerData)]
async fn post_server_data(data: String) -> Result<(), ServerFnError> {
    println!("Server received: {}", data);

    Ok(())
}

#[server(GetServerData)]
async fn get_server_data() -> Result<String, ServerFnError> {
    Ok("Hello from the server!".to_string())
}

````

````inject-dioxus
SandBoxFrame {
	url: "https://codesandbox.io/p/sandbox/dioxus-fullstack-router-s75v5q?file=%2Fsrc%2Fmain.rs%3A7%2C1"
}
````
# Introduction

 > 
 > If you are not familiar with Dioxus itself, check out the [Dioxus guide](../guide/index.md) first.

Whether you are building a website, desktop app, or mobile app, splitting your app's views into "pages" can be an effective method for organization and maintainability.

For this purpose, Dioxus provides a router. Use the `cargo add` command to add the dependency:

````sh
cargo add dioxus-router
````

Then, add this to your `Dioxus.toml` (learn more about configuration [here](../CLI/configure.md)):

````toml
[web.watcher]
index_on_404 = true
````

 > 
 > This configuration only works when using `dx serve`. If you host your app in a different way (which you most likely do in production), you need to find out how to add a fallback 404 page to your app, and make it a copy of the generated `dist/index.html`.

This will instruct `dx serve` to redirect any unknown route to the index, to then be resolved by the router.
The router works on the client. If we connect through the index route (e.g., `localhost:8080`, then click a link to go to `localhost:8080/contact`), the app renders the new route without reloading.
However, when we go to a route *before* going to the index (go straight to `localhost:8080/contact`), we are trying to access a static route from the server, but the only static route on our server is the index (because the Dioxus frontend is a Single Page Application) and it will fail unless we redirect all missing routes to the index.

This book is intended to get you up to speed with Dioxus Router. It is split
into two sections:

1. The [reference](reference/index.md) section explains individual features in
   depth. You can read it from start to finish, or you can read individual chapters
   in whatever order you want.
1. If you prefer a learning-by-doing approach, you can check out the
   *[example project](example/index.md)*. It guides you through
   creating a dioxus app, setting up the router, and using some of its
   functionality.

 > 
 > Please note that this is not the only documentation for the Dioxus Router. You
 > can also check out the [API Docs](https://docs.rs/dioxus-router/).
# Overview

In this guide, you'll learn to effectively use Dioxus Router whether you're
building a small todo app or the next FAANG company. We will create a small
website with a blog, homepage, and more!

 > 
 > To follow along with the router example, you'll need a working Dioxus app.
 > Check out the [Dioxus book](https://dioxuslabs.com/learn/0.4/getting_started) to get started.

 > 
 > Make sure to add Dioxus Router as a dependency, as explained in the
 > [introduction](../index.md).

## You'll learn how to

* Create routes and render "pages".
* Utilize nested routes, create a navigation bar, and render content for a
  set of routes.
* Parse URL parameters to dynamically display content.
* Redirect visitors to different routes.

 > 
 > **Disclaimer**
 > 
 > The example will only display the features of Dioxus Router. It will not
 > include any actual functionality. To keep things simple we will only be using
 > a single file, this is not the recommended way of doing things with a real
 > application.

You can find the complete application in the [full code](full-code.md) chapter.
# Creating Our First Route

In this chapter, we will start utilizing Dioxus Router and add a homepage and a
404 page to our project.

## Fundamentals

The core of the Dioxus Router is the \[`Routable`\] macro and the \[`Router`\] component.

Routable is a trait for anything that can:

* Be parsed from a URL
* Be turned into a URL
* Be rendered as to a Element

Let's create a new router. First, we need an actual page to route to! Let's add a homepage component:

````rs@first_route.rs
#[component]
fn Home(cx: Scope) -> Element {
    render! {
        h1 { "Welcome to the Dioxus Blog!" }
    }
}
````

## Creating Routes

We want to use Dioxus Router to separate our application into different "pages".
Dioxus Router will then determine which page to render based on the URL path.

To start using Dioxus Router, we need to use the \[`Routable`\] macro.

The \[`Routable`\] macro takes an enum with all of the possible routes in our application. Each variant of the enum represents a route and must be annotated with the \[`route(path)`\] attribute.

````rs@first_route.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route("/")]
    // If the name of the component and variant are the same you can omit the component and props name
    // If they are different you can specify them like this:
    // #[route("/", ComponentName, PropsName)]
    Home {},
}
````

All other hooks and components the router provides can only be used as a descendant of a \[`Router`\] component.

If you head to your application's browser tab, you should now see the text
`Welcome to Dioxus Blog!` when on the root URL (`http://localhost:8080/`). If
you enter a different path for the URL, nothing should be displayed.

This is because we told Dioxus Router to render the `Home` component only when
the URL path is `/`.

## Fallback Route

In our example, when a route doesn't exist Dioxus Router doesn't render anything. Many sites also have a "404" page when a path does not exist. Let's add one to our site.

First, we create a new `PageNotFound` component.

````rs@catch_all.rs
#[component]
fn PageNotFound(cx: Scope, route: Vec<String>) -> Element {
    render! {
        h1 { "Page not found" }
        p { "We are terribly sorry, but the page you requested doesn't exist." }
        pre {
            color: "red",
            "log:\nattemped to navigate to: {route:?}"
        }
    }
}
````

Next, register the route in the Route enum to match if all other routes fail.

````rs@catch_all.rs
#[derive(Routable, Clone)]
enum Route {
    #[route("/")]
    Home {},
    // PageNotFound is a catch all route that will match any route and placing the matched segments in the route field
    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}
````

Now when you go to a route that doesn't exist, you should see the page not found
text.

## Conclusion

In this chapter, we learned how to create a route and tell Dioxus Router what
component to render when the URL path is `/`. We also created a 404 page to
handle when a route doesn't exist. Next, we'll create the blog portion of our
site. We will utilize nested routes and URL parameters.
# Building a Nest

In this chapter, we will begin to build the blog portion of our site which will
include links, nested routes, and route parameters.

## Site Navigation

Our site visitors won't know all the available pages and blogs on our site so we
should provide a navigation bar for them. Our navbar will be a list of links going between our pages.

We want our navbar component to be rendered on several different pages on our site. Instead of duplicating the code, we can create a component that wraps all children routes. This is called a layout component. To tell the router where to render the child routes, we use the \[`Outlet`\] component.

Let's create a new `NavBar` component:

````rs@nested_routes.rs
#[component]
fn NavBar(cx: Scope) -> Element {
    render! {
        nav {
            ul {
                li { "links" }
            }
        }
        // The Outlet component will render child routes (In this case just the Home component) inside the Outlet component
        Outlet::<Route> {}
    }
}
````

Next, let's add our `NavBar` component as a layout to our Route enum:

````rs@nested_routes.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // All routes under the NavBar layout will be rendered inside of the NavBar Outlet
    #[layout(NavBar)]
        #[route("/")]
        Home {},
    #[end_layout]
    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}
````

To add links to our `NavBar`, we could always use an HTML anchor element but that has two issues:

1. It causes a full-page reload
1. We can accidentally link to a page that doesn't exist

Instead, we want to use the [`Link`] component provided by Dioxus Router.

The [`Link`] is similar to a regular `<a>` tag. It takes a target and children.

Unlike a regular `<a>` tag, we can pass in our Route enum as the target. Because we annotated our routes with the \[`route(path)`\] attribute, the [`Link`] will know how to generate the correct URL. If we use the Route enum, the rust compiler will prevent us from linking to a page that doesn't exist.

Let's add our links:

````rs@links.rs
#[component]
fn NavBar(cx: Scope) -> Element {
    render! {
        nav {
            Link {
                // The Link component will navigate to the route specified
                // in the target prop which is checked to exist at compile time
                to: Route::Home {},
                "Home"
            }
        }
        Outlet::<Route> {}
    }
}
````

 > 
 > Using this method, the [`Link`] component only works for links within our
 > application. To learn more about navigation targets see
 > [here](./navigation-targets.md).

Now you should see a list of links near the top of your page. Click on one and
you should seamlessly travel between pages.

## URL Parameters and Nested Routes

Many websites such as GitHub put parameters in their URL. For example,
`https://github.com/DioxusLabs` utilizes the text after the domain to
dynamically search and display content about an organization.

We want to store our blogs in a database and load them as needed. We also
want our users to be able to send people a link to a specific blog post.
Instead of listing all of the blog titles at compile time, we can make a dynamic route.

We could utilize a search page that loads a blog when clicked but then our users
won't be able to share our blogs easily. This is where URL parameters come in.

The path to our blog will look like `/blog/myBlogPage`, `myBlogPage` being the
URL parameter.

First, let's create a layout component (similar to the navbar) that wraps the blog content. This allows us to add a heading that tells the user they are on the blog.

````rs@dynamic_route.rs
#[component]
fn Blog(cx: Scope) -> Element {
    render! {
        h1 { "Blog" }
        Outlet::<Route> {}
    }
}
````

Now we'll create another index component, that'll be displayed when no blog post
is selected:

````rs@dynamic_route.rs
#[component]
fn BlogList(cx: Scope) -> Element {
    render! {
        h2 { "Choose a post" }
        ul {
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 1".into() },
                    "Read the first blog post"
                }
            }
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 2".into() },
                    "Read the second blog post"
                }
            }
        }
    }
}
````

We also need to create a component that displays an actual blog post. This component will accept the URL parameters as props:

````rs@dynamic_route.rs
// The name prop comes from the /:name route segment
#[component]
fn BlogPost(cx: Scope, name: String) -> Element {
    render! {
        h2 { "Blog Post: {name}"}
    }
}
````

Finally, let's tell our router about those components:

````rs@dynamic_route.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
            #[route("/")]
            BlogList {},
            #[route("/post/:name")]
            BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
````

That's it! If you head to `/blog/1` you should see our sample post.

## Conclusion

In this chapter, we utilized Dioxus Router's Link, and Route Parameter
functionality to build the blog portion of our application. In the next chapter,
we will go over how navigation targets (like the one we passed to our links)
work.
# Navigation Targets

In the previous chapter, we learned how to create links to pages within our app.
We told them where to go using the `target` property. This property takes something that can be converted to a [`NavigationTarget`].

## What is a navigation target?

A [`NavigationTarget`] is similar to the `href` of an HTML anchor element. It
tells the router where to navigate to. The Dioxus Router knows two kinds of
navigation targets:

* [`Internal`]: We used internal links in the previous chapter. It's a link to a page within our
  app represented as a Route enum.
* [`External`]: This works exactly like an HTML anchors' `href`. Don't use this for in-app
  navigation as it will trigger a page reload by the browser.

## External navigation

If we need a link to an external page we can do it like this:

````rs@external_link.rs
fn GoToDioxus(cx: Scope) -> Element {
    render! {
        Link {
            to: "https://dioxuslabs.com",
            "ExternalTarget target"
        }
    }
}
````
# Redirection Perfection

You're well on your way to becoming a routing master!

In this chapter, we will cover creating redirects

## Creating Redirects

A redirect is very simple. When dioxus encounters a redirect while finding out
what components to render, it will redirect the user to the target of the
redirect.

As a simple example, let's say you want user to still land on your blog, even
if they used the path `/myblog` or `/myblog/:name`.

Redirects are special attributes in the router enum that accept a route and a closure
with the route parameters. The closure should return a route to redirect to.

Let's add a redirect to our router enum:

````rs@full_example.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
                #[route("/")]
                BlogList {},
                #[route("/post/:name")]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest("/myblog")]
        #[redirect("/", || Route::BlogList {})]
        #[redirect("/:name", |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
````

That's it! Now your users will be redirected to the blog.

### Conclusion

Well done! You've completed the Dioxus Router guide. You've built a small
application and learned about the many things you can do with Dioxus Router.
To continue your journey, you attempt a challenge listed below, look at the [router examples](https://github.com/DioxusLabs/dioxus/tree/master/packages/router/examples), or
can check out the [API reference](https://docs.rs/dioxus-router/).

### Challenges

* Organize your components into separate files for better maintainability.
* Give your app some style if you haven't already.
* Build an about page so your visitors know who you are.
* Add a user system that uses URL parameters.
* Create a simple admin system to create, delete, and edit blogs.
* If you want to go to the max, hook up your application to a rest API and database.
# Full Code

````rs@full_example.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;

// ANCHOR: router
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
                #[route("/")]
                BlogList {},
                #[route("/post/:name")]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest("/myblog")]
        #[redirect("/", || Route::BlogList {})]
        #[redirect("/:name", |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
// ANCHOR_END: router

pub fn App(cx: Scope) -> Element {
    render! {
        Router::<Route> {}
    }
}

#[component]
fn NavBar(cx: Scope) -> Element {
    render! {
        nav {
            ul {
                li { Link { to: Route::Home {}, "Home" } }
                li { Link { to: Route::BlogList {}, "Blog" } }
            }
        }
        Outlet::<Route> {}
    }
}

#[component]
fn Home(cx: Scope) -> Element {
    render! {
        h1 { "Welcome to the Dioxus Blog!" }
    }
}

#[component]
fn Blog(cx: Scope) -> Element {
    render! {
        h1 { "Blog" }
        Outlet::<Route> {}
    }
}

#[component]
fn BlogList(cx: Scope) -> Element {
    render! {
        h2 { "Choose a post" }
        ul {
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 1".into() },
                    "Read the first blog post"
                }
            }
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 2".into() },
                    "Read the second blog post"
                }
            }
        }
    }
}

#[component]
fn BlogPost(cx: Scope, name: String) -> Element {
    render! {
        h2 { "Blog Post: {name}"}
    }
}

#[component]
fn PageNotFound(cx: Scope, route: Vec<String>) -> Element {
    render! {
        h1 { "Page not found" }
        p { "We are terribly sorry, but the page you requested doesn't exist." }
        pre {
            color: "red",
            "log:\nattemped to navigate to: {route:?}"
        }
    }
}

````
# Adding the router to your application

In this chapter, we will learn how to add the router to our app. By itself, this
is not very useful. However, it is a prerequisite for all the functionality
described in the other chapters.

 > 
 > Make sure you added the `dioxus-router` dependency as explained in the
 > [introduction](../index.md).

In most cases, we want to add the router to the root component of our app. This
way, we can ensure that we have access to all its functionality everywhere.

First, we define the router with the router macro:

````rs@first_route.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route("/")]
    // If the name of the component and variant are the same you can omit the component and props name
    // If they are different you can specify them like this:
    // #[route("/", ComponentName, PropsName)]
    Home {},
}
````

Then we render the router with the \[`Router`\] component.

````rs@first_route.rs
fn App(cx: Scope) -> Element {
    render! {
        Router::<Route> {}
    }
}
````
# Defining Routes

When creating a \[`Routable`\] enum, we can define routes for our application using the `route("path")` attribute.

## Route Segments

Each route is made up of segments. Most segments are separated by `/` characters in the path.

There are four fundamental types of segments:

1. [Static segments](#static-segments) are fixed strings that must be present in the path.
1. [Dynamic segments](#dynamic-segments) are types that can be parsed from a segment.
1. [Catch-all segments](#catch-all-segments) are types that can be parsed from multiple segments.
1. [Query segments](#query-segments) are types that can be parsed from the query string.

Routes are matched:

* First, from most specific to least specific (Static then Dynamic then Catch All) (Query is always matched)
* Then, if multiple routes match the same path, the order in which they are defined in the enum is followed.

## Static segments

Fixed routes match a specific path. For example, the route `#[route("/about")]` will match the path `/about`.

````rs@static_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // Routes always start with a slash
    #[route("/")]
    Home {},
    // You can have multiple segments in a route
    #[route("/hello/world")]
    HelloWorld {},
}

#[component]
fn Home(cx: Scope) -> Element {
    todo!()
}

#[component]
fn HelloWorld(cx: Scope) -> Element {
    todo!()
}
````

## Dynamic Segments

Dynamic segments are in the form of `:name` where `name` is
the name of the field in the route variant. If the segment is parsed
successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromStr`.

````rs@dynamic_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with : are dynamic segments
    #[route("/post/:name")]
    BlogPost {
        // You must include dynamic segments in child variants
        name: String,
    },

    #[route("/document/:id")]
    Document {
        // You can use any type that implements FromStr
        // If the segment can't be parsed, the route will not match
        id: usize,
    },
}

// Components must contain the same dynamic segments as their corresponding variant
#[component]
fn BlogPost(cx: Scope, name: String) -> Element {
    todo!()
}

#[component]
fn Document(cx: Scope, id: usize) -> Element {
    todo!()
}
````

## Catch All Segments

Catch All segments are in the form of `:..name` where `name` is the name of the field in the route variant. If the segments are parsed successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromSegments`. (`Vec<String>` implements this by default)

Catch All segments must be the *last route segment* in the path (query segments are not counted) and cannot be included in nests.

````rs@catch_all_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with :.. are catch all segments
    #[route("/blog/:..segments")]
    BlogPost {
        // You must include catch all segment in child variants
        segments: Vec<String>,
    },
}

// Components must contain the same catch all segments as their corresponding variant
#[component]
fn BlogPost(cx: Scope, segments: Vec<String>) -> Element {
    todo!()
}
````

## Query Segments

Query segments are in the form of `?:name` where `name` is the name of the field in the route variant.

Unlike [Dynamic Segments](#dynamic-segments) and [Catch All Segments](#catch-all-segments), parsing a Query segment must not fail.

The segment can be of any type that implements `FromQuery`.

Query segments must be the *after all route segments* and cannot be included in nests.

````rs@query_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with ?: are query segments
    #[route("/blog?:query_params")]
    BlogPost {
        // You must include query segments in child variants
        query_params: BlogQuerySegments,
    },
}

#[derive(Debug, Clone, PartialEq)]
struct BlogQuerySegments {
    name: String,
    surname: String,
}

/// The display impl needs to display the query in a way that can be parsed:
impl Display for BlogQuerySegments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "name={}&surname={}", self.name, self.surname)
    }
}

/// The query segment is anything that implements https://docs.rs/dioxus-router/latest/dioxus_router/routable/trait.FromQuery.html. You can implement that trait for a struct if you want to parse multiple query parameters.
impl FromQuery for BlogQuerySegments {
    fn from_query(query: &str) -> Self {
        let mut name = None;
        let mut surname = None;
        let pairs = form_urlencoded::parse(query.as_bytes());
        pairs.for_each(|(key, value)| {
            if key == "name" {
                name = Some(value.clone().into());
            }
            if key == "surname" {
                surname = Some(value.clone().into());
            }
        });
        Self {
            name: name.unwrap(),
            surname: surname.unwrap(),
        }
    }
}

#[component]
fn BlogPost(cx: Scope, query_params: BlogQuerySegments) -> Element {
    render! {
        div{"This is your blogpost with a query segment:"}
        div{format!("{:?}", query_params)}
    }
}

fn App(cx: Scope) -> Element {
    render! { Router::<Route>{} }
}

fn main() {}
````
# Nested Routes

When developing bigger applications we often want to nest routes within each
other. As an example, we might want to organize a settings menu using this
pattern:

````plain
└ Settings
  ├ General Settings (displayed when opening the settings)
  ├ Change Password
  └ Privacy Settings
````

We might want to map this structure to these paths and components:

````plain
/settings		  -> Settings { GeneralSettings }
/settings/password -> Settings { PWSettings }
/settings/privacy  -> Settings { PrivacySettings }
````

Nested routes allow us to do this without repeating /settings in every route.

## Nesting

To nest routes, we use the `#[nest("path")]` and `#[end_nest]` attributes.

The path in nest must not:

1. Contain a [Catch All Segment](index.md#catch-all-segments)
1. Contain a [Query Segment](index.md#query-segments)

If you define a dynamic segment in a nest, it will be available to all child routes and layouts.

To finish a nest, we use the `#[end_nest]` attribute or the end of the enum.

````rs@nest.rs
#[derive(Routable, Clone)]
// Skipping formatting allows you to indent nests
#[rustfmt::skip]
enum Route {
    // Start the /blog nest
    #[nest("/blog")]
        // You can nest as many times as you want
        #[nest("/:id")]
            #[route("/post")]
            PostId {
                // You must include parent dynamic segments in child variants
                id: usize,
            },
        // End nests manually with #[end_nest]
        #[end_nest]
        #[route("/:id")]
        // The absolute route of BlogPost is /blog/:name
        BlogPost {
            id: usize,
        },
    // Or nests are ended automatically at the end of the enum
}

#[component]
fn BlogPost(cx: Scope, id: usize) -> Element {
    todo!()
}

#[component]
fn PostId(cx: Scope, id: usize) -> Element {
    todo!()
}
````
# Layouts

Layouts allow you to wrap all child routes in a component. This can be useful when creating something like a header that will be used in many different routes.

\[`Outlet`\] tells the router where to render content in layouts. In the following example,
the Index will be rendered within the \[`Outlet`\].

This page is built with Dioxus. It uses Layouts in several different places. Here is an outline of how layouts are used on the current page:

````inject-dioxus
LayoutsExplanation {}
````

Here is a more complete example of a layout wrapping the body of a page.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/")]
        Index {},
}

#[component]
fn Wrapper(cx: Scope) -> Element {
    render! {
        header { "header" }
        // The index route will be rendered here
        Outlet::<Route> { }
        footer { "footer" }
    }
}

#[component]
fn Index(cx: Scope) -> Element {
    render! {
        h1 { "Index" }
    }
}
````

The example above will output the following HTML (line breaks added for
readability):

````html
<header>header</header>
<h1>Index</h1>
<footer>footer</footer>
````

## Layouts with dynamic segments

You can combine layouts with [nested routes](./routes/nested.md) to create dynamic layouts with content that changes based on the current route.

Just like routes, layouts components must accept a prop for each dynamic segment in the route. For example, if you have a route with a dynamic segment like `/:name`, your layout component must accept a `name` prop:

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[nest("/:name")]
        #[layout(Wrapper)]
            #[route("/")]
            Index {
                name: String,
            },
}

#[component]
fn Wrapper(cx: Scope, name: String) -> Element {
    render! {
        header { "Welcome {name}!" }
        // The index route will be rendered here
        Outlet::<Route> { }
        footer { "footer" }
    }
}

#[component]
fn Index(cx: Scope, name: String) -> Element {
    render! {
        h1 { "This is a homepage for {name}" }
    }
}
````

Or to get the full route, you can use the [`use_route`](https://docs.rs/dioxus-router/latest/dioxus_router/hooks/fn.use_route.html) hook.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/:name")]
        Index {
            name: String,
        },
}

#[component]
fn Wrapper(cx: Scope) -> Element {
    let full_route = use_route::<Route>(cx).unwrap();
    render! {
        header { "Welcome to {full_route}!" }
        // The index route will be rendered here
        Outlet::<Route> { }
        footer { "footer" }
    }
}

#[component]
fn Index(cx: Scope, name: String) -> Element {
    render! {
        h1 { "This is a homepage for {name}" }
    }
}
````
# Links & Navigation

When we split our app into pages, we need to provide our users with a way to
navigate between them. On regular web pages, we'd use an anchor element for that,
like this:

````html
<a href="/other">Link to an other page</a>
````

However, we cannot do that when using the router for three reasons:

1. Anchor tags make the browser load a new page from the server. This takes a
   lot of time, and it is much faster to let the router handle the navigation
   client-side.
1. Navigation using anchor tags only works when the app is running inside a
   browser. This means we cannot use them inside apps using Dioxus Desktop.
1. Anchor tags cannot check if the target page exists. This means we cannot
   prevent accidentally linking to non-existent pages.

To solve these problems, the router provides us with a \[`Link`\] component we can
use like this:

````rs@links.rs
#[component]
fn NavBar(cx: Scope) -> Element {
    render! {
        nav {
            Link {
                // The Link component will navigate to the route specified
                // in the target prop which is checked to exist at compile time
                to: Route::Home {},
                "Home"
            }
        }
        Outlet::<Route> {}
    }
}
````

The `target` in the example above is similar to the `href` of a regular anchor
element. However, it tells the router more about what kind of navigation it
should perform. It accepts something that can be converted into a
\[`NavigationTarget`\]:

* The example uses a Internal route. This is the most common type of navigation.
  It tells the router to navigate to a page within our app by passing a variant of a \[`Routable`\] enum. This type of navigation can never fail if the link component is used inside a router component.
* \[`External`\] allows us to navigate to URLs outside of our app. This is useful
  for links to external websites. NavigationTarget::External accepts an URL to navigate to. This type of navigation can fail if the URL is invalid.

 > 
 > The \[`Link`\] accepts several props that modify its behavior. See the API docs
 > for more details.
# Programmatic Navigation

Sometimes we want our application to navigate to another page without having the
user click on a link. This is called programmatic navigation.

## Using a Navigator

We can get a navigator with the \[`use_navigator`\] hook. This hook returns a \[`Navigator`\].

We can use the \[`Navigator`\] to trigger four different kinds of navigation:

* `push` will navigate to the target. It works like a regular anchor tag.
* `replace` works like `push`, except that it replaces the current history entry
  instead of adding a new one. This means the prior page cannot be restored with the browser's back button.
* `Go back` works like the browser's back button.
* `Go forward` works like the browser's forward button.

````rs@navigator.rs
#[component]
fn Home(cx: Scope) -> Element {
    let nav = use_navigator(cx);

    // push
    nav.push(Route::PageNotFound { route: vec![] });

    // replace
    nav.replace(Route::Home {});

    // go back
    nav.go_back();

    // go forward
    nav.go_forward();

    render! {
        h1 { "Welcome to the Dioxus Blog!" }
    }
}
````

You might have noticed that, like \[`Link`\], the \[`Navigator`\]s `push` and
`replace` functions take a \[`NavigationTarget`\]. This means we can use either
\[`Internal`\], or \[`External`\] targets.

## External Navigation Targets

Unlike a \[`Link`\], the \[`Navigator`\] cannot rely on the browser (or webview) to
handle navigation to external targets via a generated anchor element.

This means, that under certain conditions, navigation to external targets can
fail.
# History Providers

\[`HistoryProvider`\]s are used by the router to keep track of the navigation history
and update any external state (e.g. the browser's URL).

The router provides two \[`HistoryProvider`\]s, but you can also create your own.
The two default implementations are:

* The \[`MemoryHistory`\] is a custom implementation that works in memory.
* The \[`WebHistory`\] integrates with the browser's URL.

By default, the router uses the \[`MemoryHistory`\]. It might be changed to use
\[`WebHistory`\] when the `web` feature is active, but that is not guaranteed.

You can override the default history:

````rs@history_provider.rs
#[component]
fn App(cx: Scope) -> Element {
    render! {
        Router::<Route> {
            config: || RouterConfig::default().history(WebHistory::default())
        }
    }
}
````
# History Buttons

Some platforms, like web browsers, provide users with an easy way to navigate
through an app's history. They have UI elements or integrate with the OS.

However, native platforms usually don't provide such amenities, which means that
apps wanting users to have access to them, need to implement them. For this
reason, the router comes with two components, which emulate a browser's back and
forward buttons:

* [`GoBackButton`](https://docs.rs/dioxus-router/latest/dioxus_router/components/fn.GoBackButton.html)
* [`GoForwardButton`](https://docs.rs/dioxus-router/latest/dioxus_router/components/fn.GoForwardButton.html)

 > 
 > If you want to navigate through the history programmatically, take a look at
 > [`programmatic navigation`](./navigation/programmatic.md).

````rs@history_buttons.rs
fn HistoryNavigation(cx: Scope) -> Element {
    render! {
        GoBackButton {
            "Back to the Past"
        }
        GoForwardButton {
            "Back to the Future" /* You see what I did there? 😉 */
        }
    }
}
````

As you might know, browsers usually disable the back and forward buttons if
there is no history to navigate to. The router's history buttons try to do that
too, but depending on the \[history provider\] that might not be possible.

Importantly, neither \[`WebHistory`\] supports that feature.
This is due to limitations of the browser History API.

However, in both cases, the router will just ignore button presses, if there is
no history to navigate to.

Also, when using \[`WebHistory`\], the history buttons might
navigate a user to a history entry outside your app.
# Static Generation

## Getting the Sitemap

The \[`Routable`\] trait includes an associated \[`SITE_MAP`\] constant that contains the map of all of the routes in the enum.

By default, the sitemap is a tree of (static or dynamic) RouteTypes, but it can be flattened into a list of individual routes with the `.flatten()` method.

## Generating a Sitemap

To statically render pages, we need to flatten the route tree and generate a file for each route that contains only static segments:

````rs@static_generation.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;

use dioxus_ssr::incremental::{DefaultRenderer, IncrementalRendererConfig};

#[tokio::main]
async fn main() {
    let mut renderer = IncrementalRendererConfig::new()
        .static_dir("./static")
        .build();

    println!(
        "SITE MAP:\n{}",
        Route::SITE_MAP
            .iter()
            .flat_map(|route| route.flatten().into_iter())
            .map(|route| {
                route
                    .iter()
                    .map(|segment| segment.to_string())
                    .collect::<Vec<_>>()
                    .join("")
            })
            .collect::<Vec<_>>()
            .join("\n")
    );

    pre_cache_static_routes::<Route, _>(
        &mut renderer,
        &DefaultRenderer {
            before_body: r#"<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width,
            initial-scale=1.0">
            <title>Dioxus Application</title>
        </head>
        <body>"#
                .to_string(),
            after_body: r#"</body>
        </html>"#
                .to_string(),
        },
    )
    .await
    .unwrap();
}

#[component]
fn Blog(cx: Scope) -> Element {
    render! {
        div {
            "Blog"
        }
    }
}

#[component]
fn Post(cx: Scope, id: usize) -> Element {
    render! {
        div {
            "PostId: {id}"
        }
    }
}

#[component]
fn PostHome(cx: Scope) -> Element {
    render! {
        div {
            "Post"
        }
    }
}

#[component]
fn Home(cx: Scope) -> Element {
    render! {
        div {
            "Home"
        }
    }
}

#[rustfmt::skip]
#[derive(Clone, Debug, PartialEq, Routable)]
enum Route {
    #[nest("/blog")]
        #[route("/")]
        Blog {},
        #[route("/post/index")]
        PostHome {},
        #[route("/post/:id")]
        Post {
            id: usize,
        },
    #[end_nest]
    #[route("/")]
    Home {},
}

````

## Example

* [examples/static-hydrated](https://github.com/DioxusLabs/dioxus/tree/master/packages%2Ffullstack%2Fexamples%2Fstatic-hydrated)
# Routing Update Callback

In some cases, we might want to run custom code when the current route changes. For this reason, the \[`RouterConfig`\] exposes an `on_update` field.

## How does the callback behave?

The `on_update` is called whenever the current routing information changes. It is called after the router updated its internal state, but before dependent components and hooks are updated.

If the callback returns a \[`NavigationTarget`\], the router will replace the current location with the specified target. It will not call the `on_update` again.

If at any point the router encounters a navigation failure, it will go to the appropriate state without calling the `on_update`. It doesn't matter if the invalid target initiated the navigation, was found as a redirect target, or was returned by the `on_update` itself.

## Code Example

````rs@routing_update.rs
#[derive(Routable, Clone, PartialEq)]
enum Route {
    #[route("/")]
    Index {},
    #[route("/home")]
    Home {},
}

#[component]
fn Home(cx: Scope) -> Element {
    render! {
        p { "Home" }
    }
}

#[component]
fn Index(cx: Scope) -> Element {
    render! {
        p { "Index" }
    }
}

fn app(cx: Scope) -> Element {
    render! {
        Router::<Route> {
            config: || RouterConfig::default().on_update(|state|{
                (state.current() == Route::Index {}).then_some(
                    NavigationTarget::Internal(Route::Home {})
                )
            })
        }
    }
}
````
# Cookbook

The cookbook contains common recipes for different patterns within Dioxus.

There are a few different sections in the cookbook:

* [Publishing](publishing.md) will teach you how to present your app in a variety of delicious forms.
* Explore the [Anti-patterns](antipatterns.md) section to discover what ingredients to avoid when preparing your application.
* Within [Error Handling](error_handling.md), we'll master the fine art of managing spoiled ingredients in Dioxus.
* Take a culinary journey through [State management](state/index.md), where we'll explore the world of handling local, global, and external state in Dioxus.
* [Integrations](integrations/index.md) will guide you how to seamlessly blend external libraries into your Dioxus culinary creations.
* [Testing](testing.md) explains how to examine the unique flavor of Dioxus-specific features, like components.
* [Examples](examples.md) is a curated list of delightful recipes that demonstrate the various ways of using Dioxus ingredients.
* [Tailwind](tailwind.md) reveals the secrets of combining your Tailwind and Dioxus ingredients into a complete meal. You will also learn about using other NPM ingredients (packages) with Dioxus.
* In the [Custom Renderer](custom_renderer.md) section, we embark on a cooking adventure, inventing new ways to cook with Dioxus!
* [Optimizing](optimizing.md) will show you how to maximize the quality of your ingredients.
# Publishing

After you have build your application, you will need to publish it somewhere. This reference will outline different methods of publishing your desktop or web application.

## Web: Publishing with GitHub Pages

Edit your `Dioxus.toml` to point your `out_dir` to the `docs` folder and the `base_path` to the name of your repo:

````toml
[application]
# ...
out_dir = "docs"

[web.app]
base_path = "your_repo"
````

Then build your app and publish it to Github:

* Make sure GitHub Pages is set up for your repo to publish any static files in the docs directory
* Build your app with:

````sh
dx build --release
````

* Add and commit with git
* Push to GitHub

## Desktop: Creating an installer

Dioxus desktop app uses your operating system's WebView library, so it's portable to be distributed for other platforms.

In this section, we'll cover how to bundle your app for macOS, Windows, and Linux.

## Preparing your application for bundling

Depending on your platform, you may need to add some additional code to your `main.rs` file to make sure your app is ready for bundling. On Windows, you'll need to add the `#![windows_subsystem = "windows"]` attribute to your `main.rs` file to hide the terminal window that pops up when you run your app. **If you're developing on Windows, only use this when bundling.** It will disable the terminal, so you will not get logs of any kind. You can gate it behind a feature, like so:

````toml
# Cargo.toml
[features]
bundle = []
````

And then your `main.rs`:

````rust
#![cfg_attr(feature = "bundle", windows_subsystem = "windows")]
````

## Install `dioxus CLI`

The first thing we'll do is install the [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli). This extension to cargo will make it very easy to package our app for the various platforms.

To install, simply run

`cargo install dioxus-cli`

## Building

To bundle your application you can simply run `dx bundle --release` (also add `--features bundle` if you're using that, see the [this](#preparing-your-application-for-bundling) for more) to produce a final app with all the optimizations and assets builtin.

Once you've ran the command, your app should be accessible in `dist/bundle/`.

For example, a macOS app would look like this:

![Published App](/assets/static/publish.png)

Nice! And it's only 4.8 Mb – extremely lean!! Because Dioxus leverages your platform's native WebView, Dioxus apps are extremely memory efficient and won't waste your battery.

 > 
 > Note: not all CSS works the same on all platforms. Make sure to view your app's CSS on each platform – or web browser (Firefox, Chrome, Safari) before publishing.
# Antipatterns

This example shows what not to do and provides a reason why a given pattern is considered an "AntiPattern". Most anti-patterns are considered wrong for performance or code re-usability reasons.

## Unnecessarily Nested Fragments

Fragments don't mount a physical element to the DOM immediately, so Dioxus must recurse into its children to find a physical DOM node. This process is called "normalization". This means that deeply nested fragments make Dioxus perform unnecessary work. Prefer one or two levels of fragments / nested components until presenting a true DOM element.

Only Component and Fragment nodes are susceptible to this issue. Dioxus mitigates this with components by providing an API for registering shared state without the Context Provider pattern.

````rs@anti_patterns.rs
// ❌ Don't unnecessarily nest fragments
let _ = cx.render(rsx!(
    Fragment {
        Fragment {
            Fragment {
                Fragment {
                    Fragment {
                        div { "Finally have a real node!" }
                    }
                }
            }
        }
    }
));

// ✅ Render shallow structures
cx.render(rsx!(
    div { "Finally have a real node!" }
))
````

## Incorrect Iterator Keys

As described in the [dynamic rendering chapter](../reference/dynamic_rendering.md#the-key-attribute), list items must have unique keys that are associated with the same items across renders. This helps Dioxus associate state with the contained components and ensures good diffing performance. Do not omit keys, unless you know that the list will never change.

````rs@anti_patterns.rs
let data: &HashMap<_, _> = &cx.props.data;

// ❌ No keys
cx.render(rsx! {
    ul {
        data.values().map(|value| rsx!(
            li { "List item: {value}" }
        ))
    }
});

// ❌ Using index as keys
cx.render(rsx! {
    ul {
        cx.props.data.values().enumerate().map(|(index, value)| rsx!(
            li { key: "{index}", "List item: {value}" }
        ))
    }
});

// ✅ Using unique IDs as keys:
cx.render(rsx! {
    ul {
        cx.props.data.iter().map(|(key, value)| rsx!(
            li { key: "{key}", "List item: {value}" }
        ))
    }
})
````

## Avoid Interior Mutability in Props

While it is technically acceptable to have a `Mutex` or a `RwLock` in the props, they will be difficult to use.

Suppose you have a struct `User` containing the field `username: String`. If you pass a `Mutex<User>` prop to a `UserComponent` component, that component may wish to pass the username as a `&str` prop to a child component. However, it cannot pass that borrowed field down, since it only would live as long as the `Mutex`'s lock, which belongs to the `UserComponent` function. Therefore, the component will be forced to clone the `username` field.

## Avoid Updating State During Render

Every time you update the state, Dioxus needs to re-render the component – this is inefficient! Consider refactoring your code to avoid this.

Also, if you unconditionally update the state during render, it will be re-rendered in an infinite loop.
# Error handling

A selling point of Rust for web development is the reliability of always knowing where errors can occur and being forced to handle them

However, we haven't talked about error handling at all in this guide! In this chapter, we'll cover some strategies in handling errors to ensure your app never crashes.

## The simplest – returning None

Astute observers might have noticed that `Element` is actually a type alias for `Option<VNode>`. You don't need to know what a `VNode` is, but it's important to recognize that we could actually return nothing at all:

````rust
fn App(cx: Scope) -> Element {
	None
}
````

This lets us add in some syntactic sugar for operations we think *shouldn't* fail, but we're still not confident enough to "unwrap" on.

 > 
 > The nature of `Option<VNode>` might change in the future as the `try` trait gets upgraded.

````rust
fn App(cx: Scope) -> Element {
	// immediately return "None"
	let name = cx.use_hook(|_| Some("hi"))?;
}
````

## Early return on result

Because Rust can't accept both Options and Results with the existing try infrastructure, you'll need to manually handle Results. This can be done by converting them into Options or by explicitly handling them.

````rust
fn App(cx: Scope) -> Element {
	// Convert Result to Option
	let name = cx.use_hook(|_| "1.234").parse().ok()?;


	// Early return
	let count = cx.use_hook(|_| "1.234");
	let val = match count.parse() {
		Ok(val) => val
		Err(err) => return cx.render(rsx!{ "Parsing failed" })
	};
}
````

Notice that while hooks in Dioxus do not like being called in conditionals or loops, they *are* okay with early returns. Returning an error state early is a completely valid way of handling errors.

## Match results

The next "best" way of handling errors in Dioxus is to match on the error locally. This is the most robust way of handling errors, though it doesn't scale to architectures beyond a single component.

To do this, we simply have an error state built into our component:

````rust
let err = use_state(cx, || None);
````

Whenever we perform an action that generates an error, we'll set that error state. We can then match on the error in a number of ways (early return, return Element, etc).

````rust
fn Commandline(cx: Scope) -> Element {
	let error = use_state(cx, || None);

	cx.render(match *error {
		Some(error) => rsx!(
			h1 { "An error occurred" }
		)
		None => rsx!(
			input {
				oninput: move |_| error.set(Some("bad thing happened!")),
			}
		)
	})
}
````

## Passing error states through components

If you're dealing with a handful of components with minimal nesting, you can just pass the error handle into child components.

````rust
fn Commandline(cx: Scope) -> Element {
	let error = use_state(cx, || None);

	if let Some(error) = **error {
		return cx.render(rsx!{ "An error occurred" });
	}

	cx.render(rsx!{
		Child { error: error.clone() }
		Child { error: error.clone() }
		Child { error: error.clone() }
		Child { error: error.clone() }
	})
}
````

Much like before, our child components can manually set the error during their own actions. The advantage to this pattern is that we can easily isolate error states to a few components at a time, making our app more predictable and robust.

## Going global

A strategy for handling cascaded errors in larger apps is through signaling an error using global state. This particular pattern involves creating an "error" context, and then setting it wherever relevant. This particular method is not as "sophisticated" as React's error boundary, but it is more fitting for Rust.

To get started, consider using a built-in hook like `use_context` and `use_context_provider` or Fermi. Of course, it's pretty easy to roll your own hook too.

At the "top" of our architecture, we're going to want to explicitly declare a value that could be an error.

````rust
enum InputError {
	None,
	TooLong,
	TooShort,
}

static INPUT_ERROR: Atom<InputError> = |_| InputError::None;
````

Then, in our top level component, we want to explicitly handle the possible error state for this part of the tree.

````rust
fn TopLevel(cx: Scope) -> Element {
	let error = use_read(cx, INPUT_ERROR);

	match error {
		TooLong => return cx.render(rsx!{ "FAILED: Too long!" }),
		TooShort => return cx.render(rsx!{ "FAILED: Too Short!" }),
		_ => {}
	}
}
````

Now, whenever a downstream component has an error in its actions, it can simply just set its own error state:

````rust
fn Commandline(cx: Scope) -> Element {
	let set_error = use_set(cx, INPUT_ERROR);

	cx.render(rsx!{
		input {
			oninput: move |evt| {
				if evt.value.len() > 20 {
					set_error(InputError::TooLong);
				}
			}
		}
	})
}
````

This approach to error handling is best in apps that have "well defined" error states. Consider using a crate like `thiserror` or `anyhow` to simplify the generation of the error types.

This pattern is widely popular in many contexts and is particularly helpful whenever your code generates a non-recoverable error. You can gracefully capture these "global" error states without panicking or mucking up state.
This section of the guide provides getting started guides for common tools used with Dioxus.

* [Logging](./logging.md)
* [Internationalization](./internationalization.md)
# Logging

Dioxus has a wide range of supported platforms, each with their own logging requirements. We'll discuss the different options available to you.

#### The Log Crate

The [Log](https://crates.io/crates/log) crate is the most universally recognized logging facade in Rust. It is also the easiest to work with in Dioxus; therefore we will be focusing on loggers that work with this crate.

The log crate provides a variety of simple `println`-like macros with varying levels of severity.
The available macros are as follows with the highest severity on the bottom:

````rs
fn main() {
    log::trace!("trace");
    log::debug!("debug");
    log::info!("info");
    log::warn!("warn");
    log::error!("error");
}
````

All the loggers provided on this page are, besides configuration and initialization, interfaced using these macros. Often you will also utilize the log crate's `LevelFilter` enum. This enum usually represents the lowest log severity you want your application to emit and can be loaded from a configuration file, environment variable, or other.

For more information, visit log crate's [docs](https://docs.rs/log/latest/log/).

## Dioxus Logger

[Dioxus Logger](https://crates.io/crates/dioxus-logger) is a planned-to-be feature-rich logger that supports all of Dioxus' platforms. Currently only Desktop, Web, and any server-based targets work with Dioxus Logger.

The easiest way to use Dioxus Logger is by calling the `init()` function:

````rs
use log::LevelFilter;

fn main() {
    // Init logger
    dioxus_logger::init(LevelFilter::Info).expect("failed to init logger");
    // Dioxus code
}
````

The `dioxus_logger::init()` function initializes Dioxus Logger with the log crate using the default configuration and provided `LevelFilter`.

#### Custom Format

Dioxus Logger allows you more control with the ability to set a custom format using the `new` function on the `DioxusLogger` struct:

````rs
use log::LevelFilter;

fn main() {
    // Init logger
    dioxus_logger::DioxusLogger::new(LevelFilter::Info)
        .use_format("[{LEVEL}] {PATH} - {ARGS}")
        .build()
        .expect("failed to init logger");

    // Dioxus code
}
````

In this example, we are building a new `DioxusLogger` struct, providing the `LevelFilter`, calling the `use_format()` function, and initializing the logger with the `build()` function (acts as `init()` in the previous example).

The key function call in this example is `use_format()`. This function takes a `&str` that specifies how you want your logs to be formatted. To specify a variable in the format, you wrap it's name in `{}`.

The available variables are:

* LEVEL     - The `LevelFilter` of the emitted log.
* PATH      - The file path of where the log was emitted, or the crate name.
* ARGS      - The arguments passed through the log macro.
* TIMESTAMP - A timestamp of when the log was emitted. (Requires `timestamps` feature)

#### Timestamps

Another feature of Dioxus Logger is the ability to include timestamps with your logs. By default, this feature is disabled and has to be enabled by adding `timestamps` to your features section of the `dioxus-logger` dependency:

````toml
dioxus-logger = { version = "*", features = ["timestamps"] }
````

By enabling this feature, you gain access to the `TIMESTAMP` format variable.

#### Dioxus Logger Platform Intricacies

On web, Dioxus Logger will use [web-sys](https://crates.io/crates/web-sys) to interact with `console.log()` to output your logs to the browser's console. On Desktop and server-based targets, Dioxus Logger will output using `println()`.

#### Final Notes

Dioxus Logger is the preferred logger to use with Dioxus if it suites your needs. There are many more features to come and Dioxus Logger is planned to become an integral part of Dioxus. If there are any feature suggestions or issues with Dioxus Logger, feel free to reach out on the [Dioxus Discord Server](https://discord.gg/XgGxMSkvUM)!

For more information, visit Dioxus Logger's [docs](https://docs.rs/dioxus-logger/latest/dioxus_logger/).

## Desktop and Server

For Dioxus' desktop and server targets, you can generally use the logger of your choice.

Some popular options are:

* [env_logger](https://crates.io/crates/env_logger)
* [simple_logger](https://crates.io/crates/simple_logger)
* [pretty_env_logger](https://crates.io/crates/pretty_env_logger)

To keep this guide short, we will not be covering the usage of these loggers.

For a full list of popular log-based logging crates, visit [this](https://docs.rs/log/latest/log/#available-logging-implementations) list in the log crate's docs.

## Web

[WASM Logger](https://crates.io/crates/wasm-logger) is a logging interface that can be used with Dioxus' web platform.

The easiest way to use WASM Logger is with the `init` function:

````rs
fn main() {
    // Init logger
    wasm_logger::init(wasm_logger::Config::default());

    // Dioxus code
}
````

This starts WASM Logger with a `LevelFilter` of `Debug`.

To specify a custom `LevelFilter`, build the `Config` struct:

````rs
use log::LevelFilter;

fn main() {
    // Init logger
    let log_config = wasm_logger::Config::new(LevelFilter::Info);
    wasm_logger::init(log_config);

    // Dioxus code
}
````

#### Wasm Logger Platform Intricacies

WASM Logger also uses the [web-sys](https://crates.io/crates/web-sys) crate to output to the console.

For more information, visit wasm-logger's [docs](https://docs.rs/wasm-logger/latest/wasm_logger/).

## Android

[Android Logger](https://crates.io/crates/android_logger) is a logging interface that can be used when targeting Android. Android Logger runs whenever an event `native_activity_create` is called by the Android system:

````rs
use log::LevelFilter;
use android_logger::Config;

fn native_activity_create() {
    android_logger::init_once(
        Config::default()
            .with_max_level(LevelFilter::Info)
            .with_tag("myapp");
    );
}
````

The `with_tag()` is what your app's logs will show as.

#### Viewing Android Logs

Android logs are sent to logcat. To use logcat through the Android debugger, run:

````cmd
adb -d logcat
````

Your Android device will need developer options/usb debugging enabled.

For more information, visit android_logger's [docs](https://docs.rs/android_logger/latest/android_logger/).

## iOS

The current option for iOS is the [oslog](https://crates.io/crates/oslog) crate.

````rs
fn main() {
    // Init logger
    OsLogger::new("com.example.test")
        .level_filter(LevelFilter::Debug)
        .init()
        .expect("failed to init logger");
    // Dioxus code
}
````

#### Viewing IOS Logs

You can view the emitted logs in Xcode.

For more information, visit [oslog](https://crates.io/crates/oslog).
# Internationalization

If your application supports multiple languages, the [Dioxus SDK](https://github.com/DioxusLabs/sdk) crate contains helpers to make working with translations in your application easier.

## The full code for internationalization

````rs@i18n.rs
use dioxus::prelude::*;
use dioxus_std::i18n::*;
use dioxus_std::translate;
use std::str::FromStr;

fn main() {
    dioxus_web::launch(app);
}

static EN_US: &str = r#"{
    "id": "en-US",
    "texts": {
        "messages": {
            "hello_world": "Hello World!"
        },
        "messages.hello": "Hello {name}"
    }
}"#;
static ES_ES: &str = r#"{
    "id": "es-ES",
    "texts": {
        "messages": {
            "hello_world": "Hola Mundo!"
        },
        "messages.hello": "Hola {name}"
    }
}"#;

#[allow(non_snake_case)]
fn Body(cx: Scope) -> Element {
    let i18 = use_i18(cx);

    let change_to_english = move |_| i18.set_language("en-US".parse().unwrap());
    let change_to_spanish = move |_| i18.set_language("es-ES".parse().unwrap());

    render!(
        button {
            onclick: change_to_english,
            label {
                "English"
            }
        }
        button {
            onclick: change_to_spanish,
            label {
                "Spanish"
            }
        }
        p { translate!(i18, "messages.hello_world") }
        p { translate!(i18, "messages.hello", name: "Dioxus")  }
    )
}

fn app(cx: Scope) -> Element {
    use_init_i18n(
        cx,
        "en-US".parse().unwrap(),
        "en-US".parse().unwrap(),
        || {
            let en_us = Language::from_str(EN_US).unwrap();
            let es_es = Language::from_str(ES_ES).unwrap();
            vec![en_us, es_es]
        },
    );

    render!(Body {})
}

````
# State Cookbook

* [External State](external/index.md)
* [Custom Hook](custom_hooks/index.md)
# Working with External State

This guide will help you integrate your Dioxus application with some external state like a different thread or a websocket connection.

## Working with non-reactive State

[Coroutines](../../../reference/use_coroutine.md) are great tool for dealing with non-reactive (state you don't render directly) state within your application.

You can store your state inside the coroutine async block and communicate with the coroutine with messages from any child components.

````rs@use_coroutine.rs
// import futures::StreamExt to use the next() method
use futures::StreamExt;
let response_state = use_state(cx, || None);
let tx = use_coroutine(cx, |mut rx| {
    to_owned![response_state];
    async move {
        // Define your state before the loop
        let mut state = reqwest::Client::new();
        let mut cache: HashMap<String, String> = HashMap::new();
        loop {
            // Loop and wait for the next message
            if let Some(request) = rx.next().await {
                // Resolve the message
                let response = if let Some(response) = cache.get(&request) {
                    response.clone()
                } else {
                    let response = state
                        .get(&request)
                        .send()
                        .await
                        .unwrap()
                        .text()
                        .await
                        .unwrap();
                    cache.insert(request, response.clone());
                    response
                };
                response_state.set(Some(response));
            } else {
                break;
            }
        }
    }
});
// Send a message to the coroutine
tx.send("https://example.com".to_string());
// Get the current state of the coroutine
let response = response_state.get();
````

## Making Reactive State External

If you have some reactive state (state that is rendered), that you want to modify from another thread, you can use the [use_rw](https://github.com/DioxusLabs/dioxus-std/blob/master/src/utils/rw/use_rw.rs) hook in the [dioxus-std](https://github.com/DioxusLabs/dioxus-std) crate.

The use_rw hook works like the use_ref hook, but it is Send + Sync which makes it possible to move the hook into another thread.
# Custom Hooks

Hooks are a great way to encapsulate business logic. If none of the existing hooks work for your problem, you can write your own.

When writing your hook, you can make a function that accepts `cx: &ScopeState` as a parameter to accept a scope with any Props.

## Composing Hooks

To avoid repetition, you can encapsulate business logic based on existing hooks to create a new hook.

For example, if many components need to access an `AppSettings` struct, you can create a "shortcut" hook:

````rs@hooks_composed.rs
fn use_settings(cx: &ScopeState) -> &UseSharedState<AppSettings> {
    use_shared_state::<AppSettings>(cx).expect("App settings not provided")
}
````

Or if you want to wrap a hook that persists reloads with the storage API, you can build on top of the use_ref hook to work with mutable state:

````rs@hooks_composed.rs
use gloo_storage::{LocalStorage, Storage};
use serde::{de::DeserializeOwned, Serialize};

/// A persistent storage hook that can be used to store data across application reloads.
#[allow(clippy::needless_return)]
pub fn use_persistent<T: Serialize + DeserializeOwned + Default + 'static>(
    cx: &ScopeState,
    // A unique key for the storage entry
    key: impl ToString,
    // A function that returns the initial value if the storage entry is empty
    init: impl FnOnce() -> T,
) -> &UsePersistent<T> {
    // Use the use_ref hook to create a mutable state for the storage entry
    let state = use_ref(cx, move || {
        // This closure will run when the hook is created
        let key = key.to_string();
        let value = LocalStorage::get(key.as_str()).ok().unwrap_or_else(init);
        StorageEntry { key, value }
    });

    // Wrap the state in a new struct with a custom API
    // Note: We use use_hook here so that this hook is easier to use in closures in the rsx. Any values with the same lifetime as the ScopeState can be used in the closure without cloning.
    cx.use_hook(|| UsePersistent {
        inner: state.clone(),
    })
}

struct StorageEntry<T> {
    key: String,
    value: T,
}

/// Storage that persists across application reloads
pub struct UsePersistent<T: 'static> {
    inner: UseRef<StorageEntry<T>>,
}

impl<T: Serialize + DeserializeOwned + Clone + 'static> UsePersistent<T> {
    /// Returns a reference to the value
    pub fn get(&self) -> T {
        self.inner.read().value.clone()
    }

    /// Sets the value
    pub fn set(&self, value: T) {
        let mut inner = self.inner.write();
        // Write the new value to local storage
        LocalStorage::set(inner.key.as_str(), &value);
        inner.value = value;
    }
}
````

## Custom Hook Logic

You can use [`cx.use_hook`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.use_hook) to build your own hooks. In fact, this is what all the standard hooks are built on!

`use_hook` accepts a single closure for initializing the hook. It will be only run the first time the component is rendered. The return value of that closure will be used as the value of the hook – Dioxus will take it, and store it for as long as the component is alive. On every render (not just the first one!), you will get a reference to this value.

 > 
 > Note: You can implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) for your hook value – it will be dropped then the component is unmounted (no longer in the UI)

Inside the initialization closure, you will typically make calls to other `cx` methods. For example:

* The `use_state` hook tracks state in the hook value, and uses [`cx.schedule_update`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.schedule_update) to make Dioxus re-render the component whenever it changes.

Here is a simplified implementation of the `use_state` hook:

````rs@hooks_custom_logic.rs
use std::cell::RefCell;
use std::rc::Rc;
use std::sync::Arc;

#[derive(Clone)]
struct UseState<T> {
    value: Rc<RefCell<T>>,
    update: Arc<dyn Fn()>,
}

fn my_use_state<T: 'static>(cx: &ScopeState, init: impl FnOnce() -> T) -> &UseState<T> {
    cx.use_hook(|| {
        // The update function will trigger a re-render in the component cx is attached to
        let update = cx.schedule_update();
        // Create the initial state
        let value = Rc::new(RefCell::new(init()));

        UseState { value, update }
    })
}

impl<T: Clone> UseState<T> {
    fn get(&self) -> T {
        self.value.borrow().clone()
    }

    fn set(&self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render on the component the state is from
        (self.update)();
    }
}
````

* The `use_context` hook calls [`cx.consume_context`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.consume_context) (which would be expensive to call on every render) to get some context from the scope

Here is an implementation of the `use_context` and `use_context_provider` hooks:

````rs@hooks_custom_logic.rs
pub fn use_context<T: 'static + Clone>(cx: &ScopeState) -> Option<&T> {
    cx.use_hook(|| cx.consume_context::<T>()).as_ref()
}

pub fn use_context_provider<T: 'static + Clone>(cx: &ScopeState, f: impl FnOnce() -> T) -> &T {
    cx.use_hook(|| {
        let val = f();
        // Provide the context state to the scope
        cx.provide_context(val.clone());
        val
    })
}

````

## Hook Anti-Patterns

When writing a custom hook, you should avoid the following anti-patterns:

* !Clone Hooks: To allow hooks to be used within async blocks, the hooks must be Clone. To make a hook clone, you can wrap data in Rc or Arc and avoid lifetimes in hooks.

This version of use_state may seem more efficient, but it is not cloneable:

````rs@hooks_anti_patterns.rs
use std::cell::RefCell;
use std::rc::Rc;
use std::sync::Arc;

struct UseState<'a, T> {
    value: &'a RefCell<T>,
    update: Arc<dyn Fn()>,
}

fn my_use_state<T: 'static>(cx: &ScopeState, init: impl FnOnce() -> T) -> UseState<T> {
    // The update function will trigger a re-render in the component cx is attached to
    let update = cx.schedule_update();
    // Create the initial state
    let value = cx.use_hook(|| RefCell::new(init()));

    UseState { value, update }
}

impl<T: Clone> UseState<'_, T> {
    fn get(&self) -> T {
        self.value.borrow().clone()
    }

    fn set(&self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render on the component the state is from
        (self.update)();
    }
}
````

If we try to use this hook in an async block, we will get a compile error:

````rust
fn FutureComponent(cx: &ScopeState) -> Element {
	let my_state = my_use_state(cx, || 0);
	cx.spawn({
		to_owned![my_state];
		async move {
			my_state.set(1);
		}
	});

	todo!()
}
````

But with the original version, we can use it in an async block:

````rust
fn FutureComponent(cx: &ScopeState) -> Element {
	let my_state = use_state(cx, || 0);
	cx.spawn({
		to_owned![my_state];
		async move {
			my_state.set(1);
		}
	});

	todo!()
}
````
# Testing

When building application or libraries with Dioxus, you may want to include some tests to check the behavior of parts of your application. This guide will teach you how to test different parts of your Dioxus application.

## Component Testing

You can use a combination of [pretty-assertions](https://docs.rs/pretty_assertions/latest/pretty_assertions/) and [dioxus-ssr](https://docs.rs/dioxus-ssr/latest/dioxus_ssr/) to check that two snippets of rsx are equal:

````rs@component_test.rs
use futures::FutureExt;
use std::{cell::RefCell, sync::Arc};

use dioxus::prelude::*;

#[test]
fn test() {
    assert_rsx_eq(
        rsx! {
            div {
                "Hello world"
            }
            div {
                "Hello world"
            }
        },
        rsx! {
            for _ in 0..2 {
                div {
                    "Hello world"
                }
            }
        },
    )
}

fn assert_rsx_eq(first: LazyNodes<'static, 'static>, second: LazyNodes<'static, 'static>) {
    let first = dioxus_ssr::render_lazy(first);
    let second = dioxus_ssr::render_lazy(second);
    pretty_assertions::assert_str_eq!(first, second);
}

````

## Hook Testing

When creating libraries around Dioxus, it can be helpful to make tests for your [custom hooks](./state/custom_hooks/index.md).

Dioxus does not currently have a full hook testing library, but you can build a bespoke testing framework by manually driving the virtual dom.

````rs@hook_test.rs
use futures::FutureExt;
use std::{cell::RefCell, sync::Arc};

use dioxus::prelude::*;

#[test]
fn test() {
    test_hook(
        |cx| use_ref(cx, || 0).clone(),
        |value, mut proxy| match proxy.generation {
            0 => {
                value.set(1);
            }
            1 => {
                assert_eq!(*value.read(), 1);
                value.set(2);
            }
            2 => {
                proxy.rerun();
            }
            3 => {}
            _ => todo!(),
        },
        |proxy| assert_eq!(proxy.generation, 4),
    );
}

fn test_hook<V: 'static>(
    initialize: impl FnMut(&ScopeState) -> V + 'static,
    check: impl FnMut(V, MockProxy) + 'static,
    mut final_check: impl FnMut(MockProxy) + 'static,
) {
    #[derive(Props)]
    struct MockAppComponent<
        I: FnMut(&ScopeState) -> V + 'static,
        C: FnMut(V, MockProxy) + 'static,
        V,
    > {
        hook: RefCell<I>,
        check: RefCell<C>,
    }

    impl<I: FnMut(&ScopeState) -> V, C: FnMut(V, MockProxy), V> PartialEq
        for MockAppComponent<I, C, V>
    {
        fn eq(&self, _: &Self) -> bool {
            true
        }
    }

    fn mock_app<I: FnMut(&ScopeState) -> V, C: FnMut(V, MockProxy), V>(
        cx: Scope<MockAppComponent<I, C, V>>,
    ) -> Element {
        let value = cx.props.hook.borrow_mut()(cx);

        cx.props.check.borrow_mut()(value, MockProxy::new(cx));

        render! {
            div {}
        }
    }

    let mut vdom = VirtualDom::new_with_props(
        mock_app,
        MockAppComponent {
            hook: RefCell::new(initialize),
            check: RefCell::new(check),
        },
    );

    let _ = vdom.rebuild();

    while vdom.wait_for_work().now_or_never().is_some() {
        let _ = vdom.render_immediate();
    }

    final_check(MockProxy::new(vdom.base_scope()));
}

struct MockProxy {
    rerender: Arc<dyn Fn()>,
    pub generation: usize,
}

impl MockProxy {
    fn new(scope: &ScopeState) -> Self {
        let generation = scope.generation();
        let rerender = scope.schedule_update();

        Self {
            rerender,
            generation,
        }
    }

    pub fn rerun(&mut self) {
        (self.rerender)();
    }
}

````

## End to End Testing

You can use [Playwright](https://playwright.dev/) to create end to end tests for your dioxus application.

In your `playwright.config.js`, you will need to run cargo run or dx serve instead of the default build command. Here is a snippet from the end to end web example:

````js
//...
webServer: [
    {
        cwd: path.join(process.cwd(), 'playwright-tests', 'web'),
        command: 'dx serve',
        port: 8080,
        timeout: 10 * 60 * 1000,
        reuseExistingServer: !process.env.CI,
        stdout: "pipe",
    },
],
````

* [Web example](https://github.com/DioxusLabs/dioxus/tree/master/playwright-tests/web)
* [Liveview example](https://github.com/DioxusLabs/dioxus/tree/master/playwright-tests/liveview)
* [Fullstack example](https://github.com/DioxusLabs/dioxus/tree/master/playwright-tests/fullstack)
# Examples

There's a *lot* of these, so if you're having trouble implementing something, or you just want to see cool things
that you can do with Dioxus, make sure to give these a look!

Each of the examples in the main repository also has a permalink attached, in case the main one doesn't work.
However, permalinks lead to an older "archived" version, so if you're reading this a long time in the future in a galaxy far, far away...
The examples in the permalinks might not work.

* [Main list](https://github.com/DioxusLabs/dioxus/tree/master/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/examples) - This is the largest list.
* Package-specific examples from the [main repository](https://github.com/DioxusLabs/dioxus/). To learn more about these packages, search them up on [crates.io](https://crates.io/), or navigate from the examples to the root of the package.
  * [dioxus-web](https://github.com/DioxusLabs/dioxus/tree/master/packages/web/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/web/examples)
  * [dioxus-fullstack](https://github.com/DioxusLabs/dioxus/tree/master/packages/fullstack/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/fullstack/examples)
  * [dioxus-liveview](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/liveview/examples)
  * [dioxus-router](https://github.com/DioxusLabs/dioxus/tree/master/packages/router/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/router/examples)
  * [dioxus-tui](https://github.com/DioxusLabs/dioxus/tree/master/packages/dioxus-tui/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/dioxus-tui/examples)
  * [plasmo ("rink" is the old name, it will be updated)](https://github.com/DioxusLabs/dioxus/tree/master/packages/rink/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/rink/examples)
  * [rsx-rosetta](https://github.com/DioxusLabs/dioxus/tree/master/packages/rsx-rosetta/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/rsx-rosetta/examples)
  * [native-core](https://github.com/DioxusLabs/dioxus/tree/master/packages/native-core/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/native-core/examples)
  * [signals](https://github.com/DioxusLabs/dioxus/tree/master/packages/signals/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/signals/examples) - This is unreleased, but it's a very exciting project, so stay tuned!
* The [example-projects](https://github.com/DioxusLabs/example-projects) repository. It might be deprecated/removed in the future though. See [\#25](https://github.com/DioxusLabs/example-projects/issues/25).
# Tailwind

You can style your Dioxus application with whatever CSS framework you choose, or just write vanilla CSS.

One popular option for styling your Dioxus application is [Tailwind](https://tailwindcss.com/). Tailwind allows you to style your elements with CSS utility classes. This guide will show you how to setup tailwind CSS with your Dioxus application.

## Setup

1. Install the Dioxus CLI:
   
   ````bash
   cargo install --git https://github.com/DioxusLabs/cli
   ````

1. Install npm: https://docs.npmjs.com/downloading-and-installing-node-js-and-npm

1. Install the tailwind css cli: https://tailwindcss.com/docs/installation

1. Initialize the tailwind css project:
   
   ````bash
   npx tailwindcss init
   ````
   
   This should create a `tailwind.config.js` file in the root of the project.

1. Edit the `tailwind.config.js` file to include rust files:
   
   ````js
   module.exports = {
       mode: "all",
       content: [
           // include all rust, html and css files in the src directory
           "./src/**/*.{rs,html,css}",
           // include all html files in the output (dist) directory
           "./dist/**/*.html",
       ],
       theme: {
           extend: {},
       },
       plugins: [],
   }
   ````

1. Create a `input.css` file with the following content:
   
   ````css
   @tailwind base;
   @tailwind components;
   @tailwind utilities;
   ````

1. Create a `Dioxus.toml` file with the following content that links to the `tailwind.css` file:
   
   ````toml
   [application]
   
   # App (Project) Name
   name = "Tailwind CSS + Dioxus"
   
   # Dioxus App Default Platform
   # desktop, web, mobile, ssr
   default_platform = "web"
   
   # `build` & `serve` dist path
   out_dir = "dist"
   
   # resource (public) file folder
   asset_dir = "public"
   
   [web.app]
   
   # HTML title tag content
   title = "dioxus | ⛺"
   
   [web.watcher]
   
   # when watcher trigger, regenerate the `index.html`
   reload_html = true
   
   # which files or dirs will be watcher monitoring
   watch_path = ["src", "public"]
   
   # uncomment line below if using Router
   # index_on_404 = true
   
   # include `assets` in web platform
   [web.resource]
   
   # CSS style file
   style = ["/tailwind.css"]
   
   # Javascript code file
   script = []
   
   [web.resource.dev]
   
   # serve: [dev-server] only
   
   # CSS style file
   style = []
   
   # Javascript code file
   script = []
   ````

### Bonus Steps

1. Install the tailwind css vs code extension

1. Go to the settings for the extension and find the experimental regex support section. Edit the setting.json file to look like this:
   
   ````json
   "tailwindCSS.experimental.classRegex": ["class: \"(.*)\""],
   "tailwindCSS.includeLanguages": {
       "rust": "html"
   },
   ````

## Development

* Run the following command in the root of the project to start the tailwind css compiler:
  
  ````bash
  npx tailwindcss -i ./input.css -o ./public/tailwind.css --watch
  ````

### Web

* Run the following command in the root of the project to start the dioxus dev server:
  
  ````bash
  dx serve --hot-reload
  ````

* Open the browser to [http://localhost:8080](http://localhost:8080).

### Desktop

* Add a custom head pointing to the generated tailwind CSS file in your `main`. It looks like:
  
  ````rust
  dioxus_desktop::launch_cfg(
    App,
    dioxus_desktop::Config::new()
      .with_custom_head(r#"<link rel="stylesheet" href="public/tailwind.css">"#.to_string()))
  ````

* Launch the dioxus desktop app:
  
  ````bash
  cargo run
  ````
# Custom Renderer

Dioxus is an incredibly portable framework for UI development. The lessons, knowledge, hooks, and components you acquire over time can always be used for future projects. However, sometimes those projects cannot leverage a supported renderer or you need to implement your own better renderer.

Great news: the design of the renderer is entirely up to you! We provide suggestions and inspiration with the 1st party renderers, but only really require processing `Mutations` and sending `UserEvents`.

## The specifics:

Implementing the renderer is fairly straightforward. The renderer needs to:

1. Handle the stream of edits generated by updates to the virtual DOM
1. Register listeners and pass events into the virtual DOM's event system

Essentially, your renderer needs to process edits and generate events to update the VirtualDOM. From there, you'll have everything needed to render the VirtualDOM to the screen.

Internally, Dioxus handles the tree relationship, diffing, memory management, and the event system, leaving as little as possible required for renderers to implement themselves.

For reference, check out the [javascript interpreter](https://github.com/DioxusLabs/dioxus/tree/master/packages/interpreter) or [tui renderer](https://github.com/DioxusLabs/dioxus/tree/master/packages/dioxus-tui) as a starting point for your custom renderer.

## Templates

Dioxus is built around the concept of [Templates](https://docs.rs/dioxus-core/latest/dioxus_core/prelude/struct.Template.html). Templates describe a UI tree known at compile time with dynamic parts filled at runtime. This is useful internally to make skip diffing static nodes, but it is also useful for the renderer to reuse parts of the UI tree. This can be useful for things like a list of items. Each item could contain some static parts and some dynamic parts. The renderer can use the template to create a static part of the UI once, clone it for each element in the list, and then fill in the dynamic parts.

## Mutations

The `Mutation` type is a serialized enum that represents an operation that should be applied to update the UI. The variants roughly follow this set:

````rust
enum Mutation {
	AppendChildren,
	AssignId,
	CreatePlaceholder,
	CreateTextNode,
	HydrateText,
	LoadTemplate,
	ReplaceWith,
	ReplacePlaceholder,
	InsertAfter,
	InsertBefore,
	SetAttribute,
	SetText,
	NewEventListener,
	RemoveEventListener,
	Remove,
	PushRoot,
}
````

The Dioxus diffing mechanism operates as a [stack machine](https://en.wikipedia.org/wiki/Stack_machine) where the [LoadTemplate](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.LoadTemplate), [CreatePlaceholder](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.CreatePlaceholder), and [CreateTextNode](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.CreateTextNode) mutations pushes a new "real" DOM node onto the stack and [AppendChildren](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.AppendChildren), [InsertAfter](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.InsertAfter), [InsertBefore](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.InsertBefore), [ReplacePlaceholder](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.ReplacePlaceholder), and [ReplaceWith](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.ReplaceWith) all remove nodes from the stack.

## Node storage

Dioxus saves and loads elements with IDs. Inside the VirtualDOM, this is just tracked as as a u64.

Whenever a `CreateElement` edit is generated during diffing, Dioxus increments its node counter and assigns that new element its current NodeCount. The RealDom is responsible for remembering this ID and pushing the correct node when id is used in a mutation. Dioxus reclaims the IDs of elements when removed. To stay in sync with Dioxus you can use a sparse Vec (Vec\<Option<T>\>) with possibly unoccupied items. You can use the ids as indexes into the Vec for elements, and grow the Vec when an id does not exist.

### An Example

For the sake of understanding, let's consider this example – a very simple UI declaration:

````rust
rsx!( h1 {"count: {x}"} )
````

#### Building Templates

The above rsx will create a template that contains one static h1 tag and a placeholder for a dynamic text node. The template contains the static parts of the UI, and ids for the dynamic parts along with the paths to access them.

The template will look something like this:

````rust
Template {
	// Some id that is unique for the entire project
	name: "main.rs:1:1:0",
	// The root nodes of the template
	roots: &[
		TemplateNode::Element {
			tag: "h1",
			namespace: None,
			attrs: &[],
			children: &[
				TemplateNode::DynamicText {
					id: 0
				},
			],
		}
	],
	// the path to each of the dynamic nodes
	node_paths: &[
		// the path to dynamic node with a id of 0
		&[
			// on the first root node
			0,
			// the first child of the root node
			0,
		]
	],
	// the path to each of the dynamic attributes
	attr_paths: &'a [&'a [u8]],
}
````

 > 
 > For more detailed docs about the structure of templates see the [Template api docs](https://docs.rs/dioxus-core/latest/dioxus_core/prelude/struct.Template.html)

This template will be sent to the renderer in the [list of templates](https://docs.rs/dioxus-core/latest/dioxus_core/struct.Mutations.html#structfield.templates) supplied with the mutations the first time it is used. Any time the renderer encounters a [LoadTemplate](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.LoadTemplate) mutation after this, it should clone the template and store it in the given id.

For dynamic nodes and dynamic text nodes, a placeholder node should be created and inserted into the UI so that the node can be modified later.

In HTML renderers, this template could look like this:

````html
<h1>""</h1>
````

#### Applying Mutations

After the renderer has created all of the new templates, it can begin to process the mutations.

When the renderer starts, it should contain the Root node on the stack and store the Root node with an id of 0. The Root node is the top-level node of the UI. In HTML, this is the `<div id="main">` element.

````rust
instructions: []
stack: [
	RootNode,
]
nodes: [
	RootNode,
]
````

The first mutation is a `LoadTemplate` mutation. This tells the renderer to load a root from the template with the given id. The renderer will then push the root node of the template onto the stack and store it with an id for later. In this case, the root node is an h1 element.

````rust
instructions: [
	LoadTemplate {
		// the id of the template
		name: "main.rs:1:1:0",
		// the index of the root node in the template
		index: 0,
		// the id to store
		id: ElementId(1),
	}
]
stack: [
	RootNode,
	<h1>""</h1>,
]
nodes: [
	RootNode,
	<h1>""</h1>,
]
````

Next, Dioxus will create the dynamic text node. The diff algorithm decides that this node needs to be created, so Dioxus will generate the Mutation `HydrateText`. When the renderer receives this instruction, it will navigate to the placeholder text node in the template and replace it with the new text.

````rust
instructions: [
	LoadTemplate {
		name: "main.rs:1:1:0",
		index: 0,
		id: ElementId(1),
	},
	HydrateText {
		// the id to store the text node
		id: ElementId(2),
		// the text to set
		text: "count: 0",
	}
]
stack: [
	RootNode,
	<h1>"count: 0"</h1>,
]
nodes: [
	RootNode,
	<h1>"count: 0"</h1>,
	"count: 0",
]
````

Remember, the h1 node is not attached to anything (it is unmounted) so Dioxus needs to generate an Edit that connects the h1 node to the Root. It depends on the situation, but in this case, we use `AppendChildren`. This pops the text node off the stack, leaving the Root element as the next element on the stack.

````rust
instructions: [
	LoadTemplate {
		name: "main.rs:1:1:0",
		index: 0,
		id: ElementId(1),
	},
	HydrateText {
		id: ElementId(2),
		text: "count: 0",
	},
	AppendChildren {
		// the id of the parent node
		id: ElementId(0),
		// the number of nodes to pop off the stack and append
		m: 1
	}
]
stack: [
	RootNode,
]
nodes: [
	RootNode,
	<h1>"count: 0"</h1>,
	"count: 0",
]
````

Over time, our stack looked like this:

````rust
[Root]
[Root, <h1>""</h1>]
[Root, <h1>"count: 0"</h1>]
[Root]
````

Conveniently, this approach completely separates the Virtual DOM and the Real DOM. Additionally, these edits are serializable, meaning we can even manage UIs across a network connection. This little stack machine and serialized edits make Dioxus independent of platform specifics.

Dioxus is also really fast. Because Dioxus splits the diff and patch phase, it's able to make all the edits to the RealDOM in a very short amount of time (less than a single frame) making rendering very snappy. It also allows Dioxus to cancel large diffing operations if higher priority work comes in while it's diffing.

This little demo serves to show exactly how a Renderer would need to process a mutation stream to build UIs.

## Event loop

Like most GUIs, Dioxus relies on an event loop to progress the VirtualDOM. The VirtualDOM itself can produce events as well, so it's important for your custom renderer can handle those too.

The code for the WebSys implementation is straightforward, so we'll add it here to demonstrate how simple an event loop is:

````rust, ignore
pub async fn run(&mut self) -> dioxus_core::error::Result<()> {
	// Push the body element onto the WebsysDom's stack machine
	let mut websys_dom = crate::new::WebsysDom::new(prepare_websys_dom());
	websys_dom.stack.push(root_node);

	// Rebuild or hydrate the virtualdom
	let mutations = self.internal_dom.rebuild();
	websys_dom.apply_mutations(mutations);

	// Wait for updates from the real dom and progress the virtual dom
	loop {
		let user_input_future = websys_dom.wait_for_event();
		let internal_event_future = self.internal_dom.wait_for_work();

		match select(user_input_future, internal_event_future).await {
			Either::Left((_, _)) => {
				let mutations = self.internal_dom.work_with_deadline(|| false);
				websys_dom.apply_mutations(mutations);
			},
			Either::Right((event, _)) => websys_dom.handle_event(event),
		}

		// render
	}
}
````

It's important to decode what the real events are for your event system into Dioxus' synthetic event system (synthetic meaning abstracted). This simply means matching your event type and creating a Dioxus `UserEvent` type. Right now, the virtual event system is modeled almost entirely around the HTML spec, but we are interested in slimming it down.

````rust, ignore
fn virtual_event_from_websys_event(event: &web_sys::Event) -> VirtualEvent {
	match event.type_().as_str() {
		"keydown" => {
			let event: web_sys::KeyboardEvent = event.clone().dyn_into().unwrap();
			UserEvent::KeyboardEvent(UserEvent {
				scope_id: None,
				priority: EventPriority::Medium,
				name: "keydown",
				// This should be whatever element is focused
				element: Some(ElementId(0)),
				data: Arc::new(KeyboardData{
					char_code: event.char_code(),
					key: event.key(),
					key_code: event.key_code(),
					alt_key: event.alt_key(),
					ctrl_key: event.ctrl_key(),
					meta_key: event.meta_key(),
					shift_key: event.shift_key(),
					location: event.location(),
					repeat: event.repeat(),
					which: event.which(),
				})
			})
		}
		_ => todo!()
	}
}
````

## Custom raw elements

If you need to go as far as relying on custom elements/attributes for your renderer – you totally can. This still enables you to use Dioxus' reactive nature, component system, shared state, and other features, but will ultimately generate different nodes. All attributes and listeners for the HTML and SVG namespace are shuttled through helper structs that essentially compile away. You can drop in your elements any time you want, with little hassle. However, you must be sure your renderer can handle the new namespace.

For more examples and information on how to create custom namespaces, see the [`dioxus_html` crate](https://github.com/DioxusLabs/dioxus/blob/master/packages/html/README.md#how-to-extend-it).

# Native Core

If you are creating a renderer in rust, the [native-core](https://github.com/DioxusLabs/dioxus/tree/master/packages/native-core) crate provides some utilities to implement a renderer. It provides an abstraction over Mutations and Templates and contains helpers that can handle the layout and text editing for you.

## The RealDom

The `RealDom` is a higher-level abstraction over updating the Dom. It uses an entity component system to manage the state of nodes. This system allows you to modify insert and modify arbitrary components on nodes. On top of this, the RealDom provides a way to manage a tree of nodes, and the State trait provides a way to automatically add and update these components when the tree is modified. It also provides a way to apply `Mutations` to the RealDom.

### Example

Let's build a toy renderer with borders, size, and text color.
Before we start let's take a look at an example element we can render:

````rust
cx.render(rsx!{
	div{
		color: "red",
		p{
			border: "1px solid black",
			"hello world"
		}
	}
})
````

In this tree, the color depends on the parent's color. The layout depends on the children's layout, the current text, and the text size. The border depends on only the current node.

In the following diagram arrows represent dataflow:

[![](https://mermaid.ink/img/pako:eNqllV1vgjAUhv8K6W4wkQVa2QdLdrHsdlfukmSptEhjoaSWqTH-9xVwONAKst70g5739JzzlO5BJAgFAYi52EQJlsr6fAszS7d1sVhKnCdWJDJFt6peLVs5-9owohK7HFrVcFJ_pxnpmK8VVvRkTJikkWIiaxy1dhP23bUwW1WW5WbPrrqJ4ziR4EJ6dtVN2ls5y1ZztePUcrWZFCvqVEcPPDffvlyS1XoLIQnVgnVvVPR6FU9Zc-6dV453ojjOPbuetRJ57gIeXQR3cez7rjtteZyZQ2j5MqmjqwE0ZW0VKx9RKtgpFewp1aw3sXXFy6TWgiYlv8mfq1scD8ofbBCAfQg8_AMBOAyBxzEIwA4CxgQ99QbQkjnD2KT7_CfxGF8_9WXQEsq5sDZCcjICOXRCri4h6r3NA38Q6Jdi1EOx5w3DGDYYI6MUvJFjM3VoGHUeGoMd6mBnDmh2E3fo7O4Yhf0x4OkBmIKUyhQzol_GfbkcApXQlIYg0EOC5SoEYXbQ-3ChxHyXRSBQsqBTUOREx_7OsAY3BUGM-VqvUsKUkB_1U6vf05gtweEHTk4_HQ?type=png)](https://mermaid.live/edit#pako:eNqllV1vgjAUhv8K6W4wkQVa2QdLdrHsdlfukmSptEhjoaSWqTH-9xVwONAKst70g5739JzzlO5BJAgFAYi52EQJlsr6fAszS7d1sVhKnCdWJDJFt6peLVs5-9owohK7HFrVcFJ_pxnpmK8VVvRkTJikkWIiaxy1dhP23bUwW1WW5WbPrrqJ4ziR4EJ6dtVN2ls5y1ZztePUcrWZFCvqVEcPPDffvlyS1XoLIQnVgnVvVPR6FU9Zc-6dV453ojjOPbuetRJ57gIeXQR3cez7rjtteZyZQ2j5MqmjqwE0ZW0VKx9RKtgpFewp1aw3sXXFy6TWgiYlv8mfq1scD8ofbBCAfQg8_AMBOAyBxzEIwA4CxgQ99QbQkjnD2KT7_CfxGF8_9WXQEsq5sDZCcjICOXRCri4h6r3NA38Q6Jdi1EOx5w3DGDYYI6MUvJFjM3VoGHUeGoMd6mBnDmh2E3fo7O4Yhf0x4OkBmIKUyhQzol_GfbkcApXQlIYg0EOC5SoEYXbQ-3ChxHyXRSBQsqBTUOREx_7OsAY3BUGM-VqvUsKUkB_1U6vf05gtweEHTk4_HQ)

To help in building a Dom, native-core provides the State trait and a RealDom struct. The State trait provides a way to describe how states in a node depend on other states in its relatives. By describing how to update a single node from its relations, native-core will derive a way to update the states of all nodes for you. Once you have a state you can provide it as a generic to RealDom. RealDom provides all of the methods to interact and update your new dom.

Native Core cannot create all of the required methods for the State trait, but it can derive some of them. To implement the State trait, you must implement the following methods and let the `#[partial_derive_state]` macro handle the rest:

````rs@custom_renderer.rs
// All states must derive Component (https://docs.rs/shipyard/latest/shipyard/derive.Component.html)
// They also must implement Default or provide a custom implementation of create in the State trait
#[derive(Default, Component)]
struct MyState;

/// Derive some of the boilerplate for the State implementation
#[partial_derive_state]
impl State for MyState {
    // The states of the parent nodes this state depends on
    type ParentDependencies = ();

    // The states of the child nodes this state depends on
    type ChildDependencies = (Self,);

    // The states of the current node this state depends on
    type NodeDependencies = ();

    // The parts of the current text, element, or placeholder node in the tree that this state depends on
    const NODE_MASK: NodeMaskBuilder<'static> = NodeMaskBuilder::new();

    // How to update the state of the current node based on the state of the parent nodes, child nodes, and the current node
    // Returns true if the node was updated and false if the node was not updated
    fn update<'a>(
        &mut self,
        // The view of the current node limited to the parts this state depends on
        _node_view: NodeView<()>,
        // The state of the current node that this state depends on
        _node: <Self::NodeDependencies as Dependancy>::ElementBorrowed<'a>,
        // The state of the parent nodes that this state depends on
        _parent: Option<<Self::ParentDependencies as Dependancy>::ElementBorrowed<'a>>,
        // The state of the child nodes that this state depends on
        _children: Vec<<Self::ChildDependencies as Dependancy>::ElementBorrowed<'a>>,
        // The context of the current node used to pass global state into the tree
        _context: &SendAnyMap,
    ) -> bool {
        todo!()
    }

    // partial_derive_state will generate a default implementation of all the other methods
}
````

Lets take a look at how to implement the State trait for a simple renderer.

````rs@custom_renderer.rs
struct FontSize(f64);

// All states need to derive Component
#[derive(Default, Debug, Copy, Clone, Component)]
struct Size(f64, f64);

/// Derive some of the boilerplate for the State implementation
#[partial_derive_state]
impl State for Size {
    type ParentDependencies = ();

    // The size of the current node depends on the size of its children
    type ChildDependencies = (Self,);

    type NodeDependencies = ();

    // Size only cares about the width, height, and text parts of the current node
    const NODE_MASK: NodeMaskBuilder<'static> = NodeMaskBuilder::new()
        // Get access to the width and height attributes
        .with_attrs(AttributeMaskBuilder::Some(&["width", "height"]))
        // Get access to the text of the node
        .with_text();

    fn update<'a>(
        &mut self,
        node_view: NodeView<()>,
        _node: <Self::NodeDependencies as Dependancy>::ElementBorrowed<'a>,
        _parent: Option<<Self::ParentDependencies as Dependancy>::ElementBorrowed<'a>>,
        children: Vec<<Self::ChildDependencies as Dependancy>::ElementBorrowed<'a>>,
        context: &SendAnyMap,
    ) -> bool {
        let font_size = context.get::<FontSize>().unwrap().0;
        let mut width;
        let mut height;
        if let Some(text) = node_view.text() {
            // if the node has text, use the text to size our object
            width = text.len() as f64 * font_size;
            height = font_size;
        } else {
            // otherwise, the size is the maximum size of the children
            width = children
                .iter()
                .map(|(item,)| item.0)
                .reduce(|accum, item| if accum >= item { accum } else { item })
                .unwrap_or(0.0);

            height = children
                .iter()
                .map(|(item,)| item.1)
                .reduce(|accum, item| if accum >= item { accum } else { item })
                .unwrap_or(0.0);
        }
        // if the node contains a width or height attribute it overrides the other size
        for a in node_view.attributes().into_iter().flatten() {
            match &*a.attribute.name {
                "width" => width = a.value.as_float().unwrap(),
                "height" => height = a.value.as_float().unwrap(),
                // because Size only depends on the width and height, no other attributes will be passed to the member
                _ => panic!(),
            }
        }
        // to determine what other parts of the dom need to be updated we return a boolean that marks if this member changed
        let changed = (width != self.0) || (height != self.1);
        *self = Self(width, height);
        changed
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Default, Component)]
struct TextColor {
    r: u8,
    g: u8,
    b: u8,
}

#[partial_derive_state]
impl State for TextColor {
    // TextColor depends on the TextColor part of the parent
    type ParentDependencies = (Self,);

    type ChildDependencies = ();

    type NodeDependencies = ();

    // TextColor only cares about the color attribute of the current node
    const NODE_MASK: NodeMaskBuilder<'static> =
        // Get access to the color attribute
        NodeMaskBuilder::new().with_attrs(AttributeMaskBuilder::Some(&["color"]));

    fn update<'a>(
        &mut self,
        node_view: NodeView<()>,
        _node: <Self::NodeDependencies as Dependancy>::ElementBorrowed<'a>,
        parent: Option<<Self::ParentDependencies as Dependancy>::ElementBorrowed<'a>>,
        _children: Vec<<Self::ChildDependencies as Dependancy>::ElementBorrowed<'a>>,
        _context: &SendAnyMap,
    ) -> bool {
        // TextColor only depends on the color tag, so getting the first tag is equivalent to looking through all tags
        let new = match node_view
            .attributes()
            .and_then(|mut attrs| attrs.next())
            .and_then(|attr| attr.value.as_text())
        {
            // if there is a color tag, translate it
            Some("red") => TextColor { r: 255, g: 0, b: 0 },
            Some("green") => TextColor { r: 0, g: 255, b: 0 },
            Some("blue") => TextColor { r: 0, g: 0, b: 255 },
            Some(color) => panic!("unknown color {}", "red"),
            // otherwise check if the node has a parent and inherit that color
            None => match parent {
                Some((parent,)) => *parent,
                None => Self::default(),
            },
        };
        // check if the member has changed
        let changed = new != *self;
        *self = new;
        changed
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Default, Component)]
struct Border(bool);

#[partial_derive_state]
impl State for Border {
    // TextColor depends on the TextColor part of the parent
    type ParentDependencies = (Self,);

    type ChildDependencies = ();

    type NodeDependencies = ();

    // Border does not depended on any other member in the current node
    const NODE_MASK: NodeMaskBuilder<'static> =
        // Get access to the border attribute
        NodeMaskBuilder::new().with_attrs(AttributeMaskBuilder::Some(&["border"]));

    fn update<'a>(
        &mut self,
        node_view: NodeView<()>,
        _node: <Self::NodeDependencies as Dependancy>::ElementBorrowed<'a>,
        _parent: Option<<Self::ParentDependencies as Dependancy>::ElementBorrowed<'a>>,
        _children: Vec<<Self::ChildDependencies as Dependancy>::ElementBorrowed<'a>>,
        _context: &SendAnyMap,
    ) -> bool {
        // check if the node contains a border attribute
        let new = Self(
            node_view
                .attributes()
                .and_then(|mut attrs| attrs.next().map(|a| a.attribute.name == "border"))
                .is_some(),
        );
        // check if the member has changed
        let changed = new != *self;
        *self = new;
        changed
    }
}
````

Now that we have our state, we can put it to use in our RealDom. We can update the RealDom with apply_mutations to update the structure of the dom (adding, removing, and changing properties of nodes) and then update_state to update the States for each of the nodes that changed.

````rs@custom_renderer.rs
fn main() -> Result<(), Box<dyn std::error::Error>> {
    fn app(cx: Scope) -> Element {
        let count = use_state(cx, || 0);

        use_future(cx, (count,), |(count,)| async move {
            loop {
                tokio::time::sleep(std::time::Duration::from_secs(1)).await;
                count.set(*count + 1);
            }
        });

        cx.render(rsx! {
            div{
                color: "red",
                "{count}"
            }
        })
    }

    // create the vdom, the real_dom, and the binding layer between them
    let mut vdom = VirtualDom::new(app);
    let mut rdom: RealDom = RealDom::new([
        Border::to_type_erased(),
        TextColor::to_type_erased(),
        Size::to_type_erased(),
    ]);
    let mut dioxus_intigration_state = DioxusState::create(&mut rdom);

    let mutations = vdom.rebuild();
    // update the structure of the real_dom tree
    dioxus_intigration_state.apply_mutations(&mut rdom, mutations);
    let mut ctx = SendAnyMap::new();
    // set the font size to 3.3
    ctx.insert(FontSize(3.3));
    // update the State for nodes in the real_dom tree
    let _to_rerender = rdom.update_state(ctx);

    // we need to run the vdom in a async runtime
    tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()?
        .block_on(async {
            loop {
                // wait for the vdom to update
                vdom.wait_for_work().await;

                // get the mutations from the vdom
                let mutations = vdom.render_immediate();

                // update the structure of the real_dom tree
                dioxus_intigration_state.apply_mutations(&mut rdom, mutations);

                // update the state of the real_dom tree
                let mut ctx = SendAnyMap::new();
                // set the font size to 3.3
                ctx.insert(FontSize(3.3));
                let _to_rerender = rdom.update_state(ctx);

                // render...
                rdom.traverse_depth_first(|node| {
                    let indent = " ".repeat(node.height() as usize);
                    let color = *node.get::<TextColor>().unwrap();
                    let size = *node.get::<Size>().unwrap();
                    let border = *node.get::<Border>().unwrap();
                    let id = node.id();
                    let node = node.node_type();
                    let node_type = &*node;
                    println!("{indent}{id:?} {color:?} {size:?} {border:?} {node_type:?}");
                });
            }
        })
}
````

## Layout

For most platforms, the layout of the Elements will stay the same. The [layout_attributes](https://docs.rs/dioxus-native-core/latest/dioxus_native_core/layout_attributes/index.html) module provides a way to apply HTML attributes a [Taffy](https://docs.rs/taffy/latest/taffy/index.html) layout style.

## Text Editing

To make it easier to implement text editing in rust renderers, `native-core` also contains a renderer-agnostic cursor system. The cursor can handle text editing, selection, and movement with common keyboard shortcuts integrated.

````rs@custom_renderer.rs
fn text_editing() {
    let mut cursor = Cursor::default();
    let mut text = String::new();

    // handle keyboard input with a max text length of 10
    cursor.handle_input(
        &Code::ArrowRight,
        &Key::ArrowRight,
        &Modifiers::empty(),
        &mut text,
        10,
    );

    // manually select text between characters 0-5 on the first line (this could be from dragging with a mouse)
    cursor.start = Pos::new(0, 0);
    cursor.end = Some(Pos::new(5, 0));

    // delete the selected text and move the cursor to the start of the selection
    cursor.delete_selection(&mut text);
}
````

## Conclusion

That should be it! You should have nearly all the knowledge required on how to implement your renderer. We're super interested in seeing Dioxus apps brought to custom desktop renderers, mobile renderers, video game UI, and even augmented reality! If you're interested in contributing to any of these projects, don't be afraid to reach out or join the [community](https://discord.gg/XgGxMSkvUM).
# Optimizing

*Note: This is written primarily for the web, but the main optimizations will work on other platforms too.*

You might have noticed that Dioxus binaries are pretty big.
The WASM binary of a [TodoMVC app](https://github.com/tigerros/dioxus-todo-app) weighs in at 2.36mb!
Don't worry; we can get it down to a much more manageable 234kb.
This will get obviously lower over time.
For example, the new [event system](https://github.com/DioxusLabs/dioxus/pull/1402) will reduce the binary size of a hello world app to less than 100kb (with unstable features).

We will also discuss ways to optimize your app for increased speed.

However, certain optimizations will sacrifice speed for decreased binary size or the other way around.
That's what you need to figure out yourself. Does your app perform performance-intensive tasks, such as graphical processing or tons of DOM manipulations?
You could go for increased speed. In most cases, though, decreased binary size is the better choice, especially because Dioxus WASM binaries are quite large.

To test binary sizes, we will use [this](https://github.com/tigerros/dioxus-todo-app) repository as a sample app.
The `no-optimizations` package will serve as the base, which weighs 2.36mb as of right now.

Additional resources:

* [WASM book - Shrinking `.wasm` code size](https://rustwasm.github.io/docs/book/reference/code-size.html)
* [min-sized-rust](https://github.com/johnthagen/min-sized-rust)

## Building in release mode

This is the best way to optimize. In fact, the 2.36mb figure at the start of the guide is with release mode.
In debug mode, it's actually a whopping 32mb! It also increases the speed of your app.

Thankfully, no matter what tool you're using to build your app, it will probably have a `--release` flag to do this.

Using the [Dioxus CLI](https://dioxuslabs.com/learn/0.4/CLI) or [Trunk](https://trunkrs.dev/):

* Dioxus CLI: `dx build --release`
* Trunk: `trunk build --release`

## UPX

If you're not targeting web, you can use the [UPX](https://github.com/upx/upx) CLI tool to compress your executables.

Setup:

* Download a [release](https://github.com/upx/upx/releases) and extract the directory inside to a sensible location.
* Add the executable located in the directory to your path variable.

You can run `upx --help` to get the CLI options, but you should also view `upx-doc.html` for more detailed information.
It's included in the extracted directory.

An example command might be: `upx --best -o target/release/compressed.exe target/release/your-executable.exe`.

## Build configuration

*Note: Settings defined in `.cargo/config.toml` will override settings in `Cargo.toml`.*

Other than the `--release` flag, this is the easiest way to optimize your projects, and also the most effective way,
at least in terms of reducing binary size.

### Stable

This configuration is 100% stable and decreases the binary size from 2.36mb to 310kb.
Add this to your `.cargo/config.toml`:

````toml
[profile.release]
opt-level = "z"
debug = false
lto = true
codegen-units = 1
panic = "abort"
strip = true
incremental = false
````

Links to the documentation of each value:

* [`opt-level`](https://doc.rust-lang.org/rustc/codegen-options/index.html#opt-level)
* [`debug`](https://doc.rust-lang.org/rustc/codegen-options/index.html#debuginfo)
* [`lto`](https://doc.rust-lang.org/rustc/codegen-options/index.html#lto)
* [`codegen-units`](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units)
* [`panic`](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic)
* [`strip`](https://doc.rust-lang.org/rustc/codegen-options/index.html#strip)
* [`incremental`](https://doc.rust-lang.org/rustc/codegen-options/index.html#incremental)

### Unstable

This configuration contains some unstable features, but it should work just fine.
It decreases the binary size from 310kb to 234kb.
Add this to your `.cargo/config.toml`:

````toml
[unstable]
build-std = ["std", "panic_abort", "core", "alloc"]
build-std-features = ["panic_immediate_abort"]

[build]
rustflags = [
    "-Clto",
    "-Zvirtual-function-elimination",
    "-Zlocation-detail=none"
]

# Same as in the Stable section
[profile.release]
opt-level = "z"
debug = false
lto = true
codegen-units = 1
panic = "abort"
strip = true
incremental = false
````

*Note: The omitted space in each flag (e.g., `-C<no space here>lto`) is intentional. It is not a typo.*

The values in `[profile.release]` are documented in the [Stable](#stable) section. Links to the documentation of each value:

* [`[build.rustflags]`](https://doc.rust-lang.org/cargo/reference/config.html#buildrustflags)
* [`-C lto`](https://doc.rust-lang.org/rustc/codegen-options/index.html#lto)
* [`-Z virtual-function-elimination`](https://doc.rust-lang.org/stable/unstable-book/compiler-flags/virtual-function-elimination.html)
* [`-Z location-detail`](https://doc.rust-lang.org/stable/unstable-book/compiler-flags/location-detail.html)

## wasm-opt

*Note: In the future, `wasm-opt` will be supported natively through the [Dioxus CLI](https://crates.io/crates/dioxus-cli).*

`wasm-opt` is a tool from the [binaryen](https://github.com/WebAssembly/binaryen) library that optimizes your WASM files.
To use it, install a [binaryen release](https://github.com/WebAssembly/binaryen/releases) and run this command from the package directory:

````
wasm-opt dist/assets/dioxus/APP_NAME_bg.wasm -o dist/assets/dioxus/APP_NAME_bg.wasm -Oz
````

The `-Oz` flag specifies that `wasm-opt` should optimize for size. For speed, use `-O4`.

## Improving Dioxus code

Let's talk about how you can improve your Dioxus code to be more performant.

It's important to minimize the number of dynamic parts in your `rsx`, like conditional rendering.
When Dioxus is rendering your component, it will skip parts that are the same as the last render.
That means that if you keep dynamic rendering to a minimum, your app will speed up, and quite a bit if it's not just hello world.
To see an example of this, check out [Dynamic Rendering](../reference/dynamic_rendering.md).

Also check out [Anti-patterns](antipatterns.md) for patterns that you should avoid.
Obviously, not all of them are just about performance, but some of them are.

## Bundling and minifying the output JS and HTML

This will be added in [dioxus/#1369](https://github.com/DioxusLabs/dioxus/pull/1369).
# Introduction

The ✨**Dioxus CLI**✨ is a tool to get Dioxus projects off the ground.

There's no documentation for commands here, but you can see all commands using `dx --help` once you've installed the CLI! Furthermore, you can run `dx <command> --help` to get help with a specific command.

## Features

* Build and pack a Dioxus project.
* Format `rsx` code.
* Hot Reload for `web` platform.
* Create a Dioxus project from a template repository.
* And more!
# Installation

## Install the stable version (recommended)

````
cargo install dioxus-cli
````

If you get an OpenSSL error on installation, ensure the dependencies listed [here](https://docs.rs/openssl/latest/openssl/#automatic) are installed.

## Install the latest development build through git

To get the latest bug fixes and features, you can install the development version from git. However, this is not fully tested. That means you're probably going to have more bugs despite having the latest bug fixes.

````
cargo install --git https://github.com/DioxusLabs/dioxus dioxus-cli
````

This will download the CLI from the master branch, and install it in Cargo's global binary directory (`~/.cargo/bin/` by default).

Run `dx --help` for a list of all the available commands. Furthermore, you can run `dx <command> --help` to get help with a specific command.
# Create a Project

Once you have the Dioxus CLI installed, you can use it to create your own project!

## Initializing a project

First, run the `dx create` command to create a new project.

 > 
 > It clones this [template](https://github.com/DioxusLabs/dioxus-template), which is used for web apps.
 > 
 > You can create your project from a different template by passing the `template` argument:
 > 
 > ````
 > dx create --template gh:dioxuslabs/dioxus-template
 > ````

Next, navigate into your new project using `cd project-name`, or simply opening it in an IDE.

 > 
 > Make sure the WASM target is installed before running the projects.
 > You can install the WASM target for rust using rustup:
 > 
 > ````
 > rustup target add wasm32-unknown-unknown
 > ````

Finally, serve your project with `dx serve`! The CLI will tell you the address it is serving on, along with additional info such as code warnings.
# Configure Project

This chapter will teach you how to configure the CLI with the `Dioxus.toml` file. There's an [example](#config-example) which has comments to describe individual keys. You can copy that or view this documentation for a more complete learning experience.

"🔒" indicates a mandatory item. Some headers are mandatory, but none of the keys inside them are. In that case, you only need to include the header, but no keys. It might look weird, but it's normal.

## Structure

Each header has its TOML form directly under it.

### Application 🔒

````toml
[application]
````

Application-wide configuration. Applies to both web and desktop.

* **name** 🔒 - Project name & title.
  ````toml
  name = "my_project"
  ````

* **default_platform** 🔒 - The platform this project targets
  ````toml
  # Currently supported platforms: web, desktop
  default_platform = "web"
  ````

* **out_dir** - The directory to place the build artifacts from `dx build` or `dx serve` into. This is also where the `assets` directory will be copied into.
  ````toml
  out_dir = "dist"
  ````

* **asset_dir** - The directory with your static assets. The CLI will automatically copy these assets into the **out_dir** after a build/serve.
  ````toml
  asset_dir = "public"
  ````

* **sub_package** - The sub package in the workspace to build by default.
  ````toml
  sub_package = "my-crate"
  ````

### Web.App 🔒

````toml
[web.app]
````

Web-specific configuration.

* **title** - The title of the web page.
  ````toml
  # HTML title tag content
  title = "project_name"
  ````

* **base_path** - The base path to build the application for serving at. This can be useful when serving your application in a subdirectory under a domain. For example, when building a site to be served on GitHub Pages.
  ````toml
  # The application will be served at domain.com/my_application/, so we need to modify the base_path to the path where the application will be served
  base_path = "my_application"
  ````

### Web.Watcher 🔒

````toml
[web.watcher]
````

Development server configuration.

* **reload_html** - If this is true, the cli will rebuild the index.html file every time the application is rebuilt
  
  ````toml
  reload_html = true
  ````

* **watch_path** - The files & directories to monitor for changes
  
  ````toml
  watch_path = ["src", "public"]
  ````

* **index_on_404** - If enabled, Dioxus will serve the root page when a route is not found.
  *This is needed when serving an application that uses the router*. However, when serving your app using something else than Dioxus (e.g. GitHub Pages), you will have to check how to configure it on that platform. In GitHub Pages, you can make a copy of `index.html` named `404.html` in the same directory.
  
  ````toml
  index_on_404 = true
  ````

### Web.Resource 🔒

````toml
[web.resource]
````

Static resource configuration.

* **style** - CSS files to include in your application.
  
  ````toml
  style = [
     # Include from public_dir.
     "./assets/style.css",
     # Or some asset from online cdn.
     "https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.css"
  ]
  ````

* **script** - JavaScript files to include in your application.
  
  ````toml
  script = [
      # Include from asset_dir.
      "./public/index.js",
      # Or from an online CDN.
      "https://cdn.jsdelivr.net/npm/bootstrap/dist/js/bootstrap.js"
  ]
  ````

### Web.Resource.Dev 🔒

````toml
[web.resource.dev]
````

This is the same as [`[web.resource]`](#webresource-), but it only works in development servers. For example, if you want to include a file in a `dx serve` server, but not a `dx serve --release` server, put it here.

### Web.Proxy

````toml
[[web.proxy]]
````

Configuration related to any proxies your application requires during development. Proxies will forward requests to a new service.

* **backend** - The URL to the server to proxy. The CLI will forward any requests under the backend relative route to the backend instead of returning 404
  ````toml
  backend = "http://localhost:8000/api/"
  ````
  
  This will cause any requests made to the dev server with prefix /api/ to be redirected to the backend server at http://localhost:8000. The path and query parameters will be passed on as-is (path rewriting is currently not supported).

## Config example

This includes all fields, mandatory or not.

````toml
[application]

# App name
name = "project_name"

# The Dioxus platform to default to
default_platform = "web"

# `build` & `serve` output path
out_dir = "dist"

# The static resource path
asset_dir = "public"

[web.app]

# HTML title tag content
title = "project_name"

[web.watcher]

# When watcher is triggered, regenerate the `index.html`
reload_html = true

# Which files or dirs will be monitored
watch_path = ["src", "public"]

# Include style or script assets
[web.resource]

# CSS style file
style = []

# Javascript code file
script = []

[web.resource.dev]

# Same as [web.resource], but for development servers

# CSS style file
style = []

# JavaScript files
script = []

[[web.proxy]]
backend = "http://localhost:8000/api/"
````

## Desktop and TUI

For the desktop and TUI (terminal user interface) renderers,
Dioxus bundles your app using `dx bundle` and the [tauri-bundler](https://docs.rs/crate/tauri-bundler/latest).

You can check out the [tauri-bundler docs.rs](https://docs.rs/tauri-bundler/latest/tauri_bundler/bundle/index.html).
This covers all the different settings. Keep in mind that `FooSettings` becomes just `foo` in the TOML.

Tauri uses a JSON file for the configuration, but Dioxus uses TOML. So this tauri-bundler example:

````json
{
  "package": {
    "productName": "Your Awesome App",
    "version": "0.1.0"
  },
  "tauri": {
    "bundle": {
      "active": true,
      "identifier": "com.my.app",
      "shortDescription": "",
      "longDescription": "",
      "copyright": "Copyright (c) You 2021. All rights reserved.",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ],
      "resources": ["./assets/**/*.png"],
      "deb": {
        "depends": ["debian-dependency1", "debian-dependency2"]
      },
      "macOS": {
        "frameworks": [],
        "minimumSystemVersion": "10.11",
        "license": "./LICENSE"
      },
      "externalBin": ["./sidecar-app"]
    }
  }
}
````

needs to be translated to TOML.

However, Dioxus has Dioxus-specific mandatory TOML fields that we need to include as well.
We can see what fields are mandatory from the documentation above.

Additionally, we also need to remove `tauri` from the TOML headers.

This is our final `Dioxus.toml`:

````toml
# From Dioxus
[application]
name = "Your Awesome App"
default_platform = "desktop"

# You might only be running on desktop, but the following "web" values are still required.
[web.app]
title = "Awesome"

[web.watcher]

[web.resource.dev]

# From the tauri-bundler.
[package]
productName = "Your Awesome App"
version = "0.1.0"

[bundle]
active = true
identifier = "com.my.app"
shortDescription = ""
longDescription = ""
copyright = "Copyright (c) You 2021. All rights reserved."
icon = [
  "icons/32x32.png",
  "icons/128x128.png",
  "icons/128x128@2x.png",
  "icons/icon.icns",
  "icons/icon.ico"
]
resources = [ "./assets/**/*.png" ]
externalBin = [ "./sidecar-app" ]

[bundle.deb]
depends = [ "debian-dependency1", "debian-dependency2" ]

[bundle.macOS]
frameworks = [ ]
minimumSystemVersion = "10.11"
license = "./LICENSE"
````
# Translating existing HTML

Dioxus uses a custom format called RSX to represent the HTML because it is more concise and looks more like Rust code. However, it can be a pain to convert existing HTML to RSX. That's why Dioxus comes with a tool called `dx translate` that can automatically convert HTML to RSX!

Dx translate can make converting large chunks of HTML to RSX much easier! Lets try translating some of the HTML from the Dioxus homepage:

````sh
dx translate --raw  "<div class=\"relative w-full mx-4 sm:mx-auto text-gray-600\"><div class=\"text-[3em] md:text-[5em] font-semibold dark:text-white text-ghdarkmetal font-sans py-12 flex flex-col\"><span>Fullstack, crossplatform,</span><span>lightning fast, fully typed.</span></div><h3 class=\"text-[2em] dark:text-white font-extralight text-ghdarkmetal pt-4 max-w-screen-md mx-auto\">Dioxus is a Rust library for building apps that run on desktop, web, mobile, and more.</h3><div class=\"pt-12 text-white text-[1.2em] font-sans font-bold flex flex-row justify-center space-x-4\"><a href=\"/learn/0.4/getting_started\" dioxus-prevent-default=\"onclick\" class=\"bg-red-600 py-2 px-8 hover:-translate-y-2 transition-transform duration-300\" data-dioxus-id=\"216\">Quickstart</a><a href=\"/learn/0.4/reference\" dioxus-prevent-default=\"onclick\" class=\"bg-blue-500 py-2 px-8 hover:-translate-y-2 transition-transform duration-300\" data-dioxus-id=\"214\">Read the docs</a></div><div class=\"max-w-screen-2xl mx-auto pt-36\"><h1 class=\"text-md\">Trusted by top companies</h1><div class=\"pt-4 flex flex-row flex-wrap justify-center\"><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/futurewei_bw.png\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/airbuslogo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/ESA_logo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/yclogo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/satellite.webp\"></div></div></div></div>"
````

We get the following RSX you can easily copy and paste into your code:

````rs
div { class: "relative w-full mx-4 sm:mx-auto text-gray-600",
   div { class: "text-[3em] md:text-[5em] font-semibold dark:text-white text-ghdarkmetal font-sans py-12 flex flex-col",
      span { "Fullstack, crossplatform," }
      span { "lightning fast, fully typed." }
   }
   h3 { class: "text-[2em] dark:text-white font-extralight text-ghdarkmetal pt-4 max-w-screen-md mx-auto",
      "Dioxus is a Rust library for building apps that run on desktop, web, mobile, and more."
   }
   div { class: "pt-12 text-white text-[1.2em] font-sans font-bold flex flex-row justify-center space-x-4",
      a {
         href: "/learn/0.4/getting_started",
         data_dioxus_id: "216",
         dioxus_prevent_default: "onclick",
         class: "bg-red-600 py-2 px-8 hover:-translate-y-2 transition-transform duration-300",
         "Quickstart"
      }
      a {
         dioxus_prevent_default: "onclick",
         href: "/learn/0.4/reference",
         data_dioxus_id: "214",
         class: "bg-blue-500 py-2 px-8 hover:-translate-y-2 transition-transform duration-300",
         "Read the docs"
      }
   }
   div { class: "max-w-screen-2xl mx-auto pt-36",
      h1 { class: "text-md", "Trusted by top companies" }
      div { class: "pt-4 flex flex-row flex-wrap justify-center",
         div { class: "h-12 w-40 bg-black p-2 m-4 flex justify-center items-center",
            img { src: "static/futurewei_bw.png" }
         }
         div { class: "h-12 w-40 bg-black p-2 m-4 flex justify-center items-center",
            img { src: "static/airbuslogo.svg" }
         }
         div { class: "h-12 w-40 bg-black p-2 m-4 flex justify-center items-center",
            img { src: "static/ESA_logo.svg" }
         }
         div { class: "h-12 w-40 bg-black p-2 m-4 flex justify-center items-center",
            img { src: "static/yclogo.svg" }
         }
         div { class: "h-12 w-40 bg-black p-2 m-4 flex justify-center items-center",
            img { src: "static/satellite.webp" }
         }
      }
   }
}
````

## Usage

The `dx translate` command has several flags you can use to control your html input and rsx output.

You can use the `--file` flag to translate an HTML file to RSX:

````sh
dx translate --file index.html
````

Or you can use the `--raw` flag to translate a string of HTML to RSX:

````sh
dx translate --raw "<div>Hello world</div>"
````

Both of those commands will output the following RSX:

````rs
div { "Hello world" }
````

The `dx translate` command will output the RSX to stdout. You can use the `--output` flag to write the RSX to a file instead.

````sh
dx translate --raw "<div>Hello world</div>" --output index.rs
````

You can automatically create a component with the `--component` flag.

````sh
dx translate --raw "<div>Hello world</div>" --component
````

This will output the following component:

````rs
fn component(cx: Scope) -> Element {
   cx.render(rsx! {
      div { "Hello world" }
   })
}
````

To learn more about the different flags `dx translate` supports, run `dx translate --help`.
# Contributing

Development happens in the [Dioxus GitHub repository](https://github.com/DioxusLabs/dioxus). If you've found a bug or have an idea for a feature, please submit an issue (but first check if someone hasn't [done it already](https://github.com/DioxusLabs/dioxus/issues)).

[GitHub discussions](https://github.com/DioxusLabs/dioxus/discussions) can be used as a place to ask for help or talk about features. You can also join [our Discord channel](https://discord.gg/XgGxMSkvUM) where some development discussion happens.

## Improving Docs

If you'd like to improve the docs, PRs are welcome! Both Rust docs ([source](https://github.com/DioxusLabs/dioxus/tree/master/packages)) and this guide ([source](https://github.com/DioxusLabs/dioxus/tree/master/docs/guide)) can be found in the GitHub repo.

## Working on the Ecosystem

Part of what makes React great is the rich ecosystem. We'd like the same for Dioxus! So if you have a library in mind that you'd like to write and many people would benefit from, it will be appreciated. You can [browse npm.js](https://www.npmjs.com/search?q=keywords:react-component) for inspiration. Once you are done, add your library to the [awesome dioxus](https://github.com/DioxusLabs/awesome-dioxus) list or share it in the `#I-made-a-thing` channel on [Discord](https://discord.gg/XgGxMSkvUM).

## Bugs & Features

If you've fixed [an open issue](https://github.com/DioxusLabs/dioxus/issues), feel free to submit a PR! You can also take a look at [the roadmap](./roadmap.md) and work on something in there. Consider [reaching out](https://discord.gg/XgGxMSkvUM) to the team first to make sure everyone's on the same page, and you don't do useless work!

All pull requests (including those made by a team member) must be approved by at least one other team member.
Larger, more nuanced decisions about design, architecture, breaking changes, trade-offs, etc. are made by team consensus.

## Before you contribute

You might be surprised that a lot of checks fail when making your first PR.
That's why you should first run these commands before contributing, and it will save you *lots* of time, because the
GitHub CI is much slower at executing all of these than your PC.

* Format code with [rustfmt](https://github.com/rust-lang/rustfmt):

````sh
cargo fmt --all
````

* Check all code [cargo check](https://doc.rust-lang.org/cargo/commands/cargo-check.html):

````sh
cargo check --workspace --examples --tests
````

* Check if [Clippy](https://doc.rust-lang.org/clippy/) generates any warnings. Please fix these!

````sh
cargo clippy --workspace --examples --tests -- -D warnings
````

* Test all code with [cargo-test](https://doc.rust-lang.org/cargo/commands/cargo-test.html):

````sh
cargo test --all --tests
````

* More tests, this time with [cargo-make](https://sagiegurari.github.io/cargo-make/). Here are all steps, including installation:

````sh
cargo install --force cargo-make
cargo make tests
````

* Test unsafe crates with [MIRI](https://github.com/rust-lang/miri). Currently, this is used for the two MIRI tests in `dioxus-core` and `dioxus-native-core`:

````sh
cargo miri test --package dioxus-core --test miri_stress
cargo miri test --package dioxus-native-core --test miri_native
````

* Test with Playwright. This tests the UI itself, right in a browser. Here are all steps, including installation:
  **Disclaimer: This might inexplicably fail on your machine without it being your fault.** Make that PR anyway!

````sh
cd playwright-tests
npm ci
npm install -D @playwright/test
npx playwright install --with-deps
npx playwright test
````

## How to test dioxus with local crate

If you are developing a feature, you should test it in your local setup before raising a PR. This process makes sure you are aware of your code functionality before being reviewed by peers.

* Fork the following github repo (DioxusLabs/dioxus):

`https://github.com/DioxusLabs/dioxus`

* Create a new or use an existing rust crate (ignore this step if you will use an existing rust crate):
  This is where we will be testing the features of the forked

````sh
cargo new --bin demo
````

* Add the dioxus dependencies for your rust crate (new/existing) in cargo.toml:

````toml
dioxus = { path = "<path to forked dioxus project>/dioxus/packages/dioxus/" }

dioxus-web = { path = "<path to forked dioxus project>/dioxus/packages/web/" }
````

This above example is for dioxus-web. To know about the dependencies for different renderer visit [here](https://dioxuslabs.com/learn/0.4/getting_started).

* Run and test your feature

````sh
dx serve
````

If this is your first time with dioxus, please read [the guide](https://dioxuslabs.com/learn/0.4/guide) to get familiar with dioxus.
# Project Structure

There are many packages in the Dioxus organization. This document will help you understand the purpose of each package and how they fit together.

## Renderers

* [Desktop](https://github.com/DioxusLabs/dioxus/tree/master/packages/desktop): A Render that Runs Dioxus applications natively, but renders them with the system webview
* [Mobile](https://github.com/DioxusLabs/dioxus/tree/master/packages/mobile): A Render that Runs Dioxus applications natively, but renders them with the system webview. This is currently a copy of the desktop render
* [Web](https://github.com/DioxusLabs/dioxus/tree/master/packages/web): Renders Dioxus applications in the browser by compiling to WASM and manipulating the DOM
* [Liveview](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview): A Render that Runs on the server, and renders using a websocket proxy in the browser
* [Rink](https://github.com/DioxusLabs/dioxus/tree/master/packages/rink): A Renderer that renders a HTML-like tree into a terminal
* [TUI](https://github.com/DioxusLabs/dioxus/tree/master/packages/dioxus-tui): A Renderer that uses Rink to render a Dioxus application in a terminal
* [Blitz-Core](https://github.com/DioxusLabs/blitz/tree/master/blitz-core): An experimental native renderer that renders a HTML-like tree using WGPU.
* [Blitz](https://github.com/DioxusLabs/blitz): An experimental native renderer that uses Blitz-Core to render a Dioxus application using WGPU.
* [SSR](https://github.com/DioxusLabs/dioxus/tree/master/packages/ssr): A Render that Runs Dioxus applications on the server, and renders them to HTML

## State Management/Hooks

* [Hooks](https://github.com/DioxusLabs/dioxus/tree/master/packages/hooks): A collection of common hooks for Dioxus applications
* [Signals](https://github.com/DioxusLabs/dioxus/tree/master/packages/signals): A experimental state management library for Dioxus applications. This currently contains a `Copy` version of UseRef
* [Dioxus STD](https://github.com/DioxusLabs/dioxus-std): A collection of platform agnostic hooks to interact with system interfaces (The clipboard, camera, etc.).
* [Fermi](https://github.com/DioxusLabs/dioxus/tree/master/packages/fermi): A global state management library for Dioxus applications.
* [Router](https://github.com/DioxusLabs/dioxus/tree/master/packages/router): A client-side router for Dioxus applications

## Core utilities

* [core](https://github.com/DioxusLabs/dioxus/tree/master/packages/core): The core virtual dom implementation every Dioxus application uses
  * You can read more about the architecture of the core [in this blog post](https://dioxuslabs.com/blog/templates-diffing/) and the [custom renderer section of the guide](../cookbook/custom_renderer.md)
* [RSX](https://github.com/DioxusLabs/dioxus/tree/master/packages/rsx): The core parsing for RSX used for hot reloading, autoformatting, and the macro
* [core-macro](https://github.com/DioxusLabs/dioxus/tree/master/packages/core-macro): The rsx! macro used to write Dioxus applications. (This is a wrapper over the RSX crate)
* [HTML macro](https://github.com/DioxusLabs/dioxus-html-macro): A html-like alternative to the RSX macro

## Native Renderer Utilities

* [native-core](https://github.com/DioxusLabs/dioxus/tree/master/packages/native-core): Incrementally computed tree of states (mostly styles)
  * You can read more about how native-core can help you build native renderers in the [custom renderer section of the guide](../cookbook/custom_renderer.md#native-core)
* [native-core-macro](https://github.com/DioxusLabs/dioxus/tree/master/packages/native-core-macro): A helper macro for native core
* [Taffy](https://github.com/DioxusLabs/taffy): Layout engine powering Blitz-Core, Rink, and Bevy UI

## Web renderer tooling

* [HTML](https://github.com/DioxusLabs/dioxus/tree/master/packages/html): defines html specific elements, events, and attributes
* [Interpreter](https://github.com/DioxusLabs/dioxus/tree/master/packages/interpreter): defines browser bindings used by the web and desktop renderers

## Developer tooling

* [hot-reload](https://github.com/DioxusLabs/dioxus/tree/master/packages/hot-reload): Macro that uses the RSX crate to hot reload static parts of any rsx! macro. This macro works with any non-web renderer with an [integration](https://crates.io/crates/dioxus-hot-reload)
* [autofmt](https://github.com/DioxusLabs/dioxus/tree/master/packages/autofmt): Formats RSX code
* [rsx-rosetta](https://github.com/DioxusLabs/dioxus/tree/master/packages/rsx-rosetta): Handles conversion between HTML and RSX
* [CLI](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli): A Command Line Interface and VSCode extension to assist with Dioxus usage
# Walkthrough of the Hello World Example Internals

This walkthrough will take you through the internals of the Hello World example program. It will explain how major parts of Dioxus internals interact with each other to take the readme example from a source file to a running application. This guide should serve as a high-level overview of the internals of Dioxus. It is not meant to be a comprehensive guide.

The core crate roughly works like this:

![](https://mermaid.ink/img/pako:eNqNk01v2zAMhv8KocsuTQ876lCgWAb0sGDD0mMAg7PoWogsBvpwWhT976MlJ3OKbKtOEvmIfEWRr6plQ0qrmDDR2uJTwGE1ft55kBXIGwqNHQYyVvywWt3BA3rjKGj4gs5BX0-V_1n4QtUthW_Mh6WzWgryg537OpJPsQJ_zsX9PrmG0fBwWxM2NIH1nmdRFuxTn4C7K4mn9djTpYAjWsnTcQBaSJiWxIcULEVILCIiu5Egyf3RhpTRwfr75tOC73LKggGmQkUcBLcDVUJyFoF_qcEkoxEVzZHDvjIXpnOhtm1PJp8rvcGw37Z8oPu4FlkvhVvbrivGypyP_3dWXRo2WdrAsp-fN391Qd5n1BBnSU0-GDy9sHyGo678xcOyOU7fMHcMHINNtcgIPfP-Wr2WAu6NeeRzGTS0z7fxgEd_7T3_Zi8b5kp1T1IxvvgWfjlu9x-SexHqo1VTN2qgMKA1MoavU6CdkkaSBlJatoY6zC7t1M6_CYo58VZUKZ1CphtVo8yDq3SHLopVJiZx2NTRLhP-9htxEk8q?type=png)

## The Source File

We start will a hello world program. This program renders a desktop app with the text "Hello World" in a webview.

````rs@readme.rs
use dioxus::prelude::*;

pub fn App(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    })
}

````

[![](https://mermaid.ink/img/pako:eNqNkT1vwyAQhv8KvSlR48HphtQtqjK0S6tuSBGBS0CxwcJHk8rxfy_YVqxKVdR3ug_u4YXrQHmNwOFQ-bMyMhB7fReOJbVxfwyyMSy0l7GSpW1ARda727ksUy5MuSyKgvBC5ULA1h5N8WK_kCkfHWHgrBuiXsBynrvdsY9E3u1iM_eyvFOVVadMnELOap-o1911JLPHZ1b-YqLTc3LjTt7WifTZMJPsPdx1ov3Z_ellfcdL8R8vmTy5eUqsTUpZ-vzZzjAEK6gx1NLqtJwuNwSQwRoF8BRqGU4ChOvTORnJf3w7BZxCxBXERkvCjZXpQTXwg6zaVEVtyYe3cdvD0vsf4bucgw?type=png)](https://mermaid.live/edit#pako:eNqNkT1vwyAQhv8KvSlR48HphtQtqjK0S6tuSBGBS0CxwcJHk8rxfy_YVqxKVdR3ug_u4YXrQHmNwOFQ-bMyMhB7fReOJbVxfwyyMSy0l7GSpW1ARda727ksUy5MuSyKgvBC5ULA1h5N8WK_kCkfHWHgrBuiXsBynrvdsY9E3u1iM_eyvFOVVadMnELOap-o1911JLPHZ1b-YqLTc3LjTt7WifTZMJPsPdx1ov3Z_ellfcdL8R8vmTy5eUqsTUpZ-vzZzjAEK6gx1NLqtJwuNwSQwRoF8BRqGU4ChOvTORnJf3w7BZxCxBXERkvCjZXpQTXwg6zaVEVtyYe3cdvD0vsf4bucgw)

## The rsx! Macro

Before the Rust compiler runs the program, it will expand all [macros](https://doc.rust-lang.org/reference/procedural-macros.html). Here is what the hello world example looks like expanded:

````rs@readme_expanded.rs
use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);

    cx.render(
        // rsx expands to LazyNodes::new
        ::dioxus::core::LazyNodes::new(
            move |__cx: &::dioxus::core::ScopeState| -> ::dioxus::core::VNode {
                // The template is every static part of the rsx
                static TEMPLATE: ::dioxus::core::Template = ::dioxus::core::Template {
                    // This is the source location of the rsx that generated this template. This is used to make hot rsx reloading work. Hot rsx reloading just replaces the template with a new one generated from the rsx by the CLI.
                    name: "examples\\readme.rs:14:15:250",
                    // The root nodes are the top level nodes of the rsx
                    roots: &[
                        // The h1 node
                        ::dioxus::core::TemplateNode::Element {
                            // Find the built in h1 tag in the dioxus_elements crate exported by the dioxus html crate
                            tag: dioxus_elements::h1::TAG_NAME,
                            namespace: dioxus_elements::h1::NAME_SPACE,
                            attrs: &[],
                            // The children of the h1 node
                            children: &[
                                // The dynamic count text node
                                // Any nodes that are dynamic have a dynamic placeholder with a unique index
                                ::dioxus::core::TemplateNode::DynamicText {
                                    // This index is used to find what element in `dynamic_nodes` to use instead of the placeholder
                                    id: 0usize,
                                },
                            ],
                        },
                        // The up high button node
                        ::dioxus::core::TemplateNode::Element {
                            tag: dioxus_elements::button::TAG_NAME,
                            namespace: dioxus_elements::button::NAME_SPACE,
                            attrs: &[
                                // The dynamic onclick listener attribute
                                // Any attributes that are dynamic have a dynamic placeholder with a unique index.
                                ::dioxus::core::TemplateAttribute::Dynamic {
                                    // Similar to dynamic nodes, dynamic attributes have a unique index used to find the attribute in `dynamic_attrs` to use instead of the placeholder
                                    id: 0usize,
                                },
                            ],
                            children: &[::dioxus::core::TemplateNode::Text { text: "Up high!" }],
                        },
                        // The down low button node
                        ::dioxus::core::TemplateNode::Element {
                            tag: dioxus_elements::button::TAG_NAME,
                            namespace: dioxus_elements::button::NAME_SPACE,
                            attrs: &[
                                // The dynamic onclick listener attribute
                                ::dioxus::core::TemplateAttribute::Dynamic { id: 1usize },
                            ],
                            children: &[::dioxus::core::TemplateNode::Text { text: "Down low!" }],
                        },
                    ],
                    // Node paths is a list of paths to every dynamic node in the rsx
                    node_paths: &[
                        // The first node path is the path to the dynamic node with an id of 0 (the count text node)
                        &[
                            // Go to the index 0 root node
                            0u8, //
                            // Go to the first child of the root node
                            0u8,
                        ],
                    ],
                    // Attr paths is a list of paths to every dynamic attribute in the rsx
                    attr_paths: &[
                        // The first attr path is the path to the dynamic attribute with an id of 0 (the up high button onclick listener)
                        &[
                            // Go to the index 1 root node
                            1u8,
                        ],
                        // The second attr path is the path to the dynamic attribute with an id of 1 (the down low button onclick listener)
                        &[
                            // Go to the index 2 root node
                            2u8,
                        ],
                    ],
                };
                // The VNode is a reference to the template with the dynamic parts of the rsx
                ::dioxus::core::VNode {
                    parent: None,
                    key: None,
                    // The static template this node will use. The template is stored in a Cell so it can be replaced with a new template when hot rsx reloading is enabled
                    template: std::cell::Cell::new(TEMPLATE),
                    root_ids: dioxus::core::exports::bumpalo::collections::Vec::with_capacity_in(
                        3,
                        __cx.bump(),
                    )
                    .into(),
                    dynamic_nodes: __cx.bump().alloc([
                        // The dynamic count text node (dynamic node id 0)
                        __cx.text_node(format_args!("High-Five counter: {0}", count)),
                    ]),
                    dynamic_attrs: __cx.bump().alloc([
                        // The dynamic up high button onclick listener (dynamic attribute id 0)
                        dioxus_elements::events::onclick(__cx, move |_| count += 1),
                        // The dynamic down low button onclick listener (dynamic attribute id 1)
                        dioxus_elements::events::onclick(__cx, move |_| count -= 1),
                    ]),
                }
            },
        ),
    )
}

````

The rsx macro separates the static parts of the rsx (the template) and the dynamic parts (the [dynamic_nodes](https://docs.rs/dioxus-core/0.3.2/dioxus_core/prelude/struct.VNode.html#structfield.dynamic_nodes) and [dynamic_attributes](https://docs.rs/dioxus-core/0.3.2/dioxus_core/prelude/struct.VNode.html#structfield.dynamic_attrs)).

The static template only contains the parts of the rsx that cannot change at runtime with holes for the dynamic parts:

[![](https://mermaid.ink/img/pako:eNqdksFuwjAMhl8l8wkkKtFx65njdtm0E0GVSQKJoEmVOgKEeHecUrXStO0wn5Lf9u8vcm6ggjZQwf4UzspiJPH2Ib3g6NLuELG1oiMkp0TsLs9EDu2iUeSCH8tz2HJmy3lRFPrqsXGq9mxeLzcbCU6LZSUGXWRdwnY7tY7Tdoko-Dq1U64fODgiUfzJMeuOe7_ZGq-ny2jNhGQu9DqT8NUK6w72RcL8dxgdzv4PnHLAKf-Fk80HoBUDrfkqeBkTUd8EC2hMbNBpXtYtJySQNQ0PqPioMR4lSH_nOkwUPq9eQUUxmQWkViOZtUN-UwPVHk8dq0Y7CvH9uf3-E9wfrmuk1A?type=png)](https://mermaid.live/edit#pako:eNqdksFuwjAMhl8l8wkkKtFx65njdtm0E0GVSQKJoEmVOgKEeHecUrXStO0wn5Lf9u8vcm6ggjZQwf4UzspiJPH2Ib3g6NLuELG1oiMkp0TsLs9EDu2iUeSCH8tz2HJmy3lRFPrqsXGq9mxeLzcbCU6LZSUGXWRdwnY7tY7Tdoko-Dq1U64fODgiUfzJMeuOe7_ZGq-ny2jNhGQu9DqT8NUK6w72RcL8dxgdzv4PnHLAKf-Fk80HoBUDrfkqeBkTUd8EC2hMbNBpXtYtJySQNQ0PqPioMR4lSH_nOkwUPq9eQUUxmQWkViOZtUN-UwPVHk8dq0Y7CvH9uf3-E9wfrmuk1A)

The dynamic_nodes and dynamic_attributes are the parts of the rsx that can change at runtime:

[![](https://mermaid.ink/img/pako:eNp1UcFOwzAM_RXLVzZpvUbighDiABfgtkxTlnirtSaZUgc0df130hZEEcwny35-79nu0EZHqHDfxA9bmyTw9KIDlGjz7pDMqQZ3DsazhVCQ7dQbwnEiKxwDvN3NqhN4O4C3q_VaIztYKXjkQ7184HcCG3MQSgq6Mes1bjbTPAV3RdqIJN5l-V__2_Fcf5iY68dgG7ZHBT4WD5ftZfIBN7dQ_Tj4w1B9MVTXGZa_GMYdcIGekjfsymW7oaFRavKkUZXUmXTUqENfcCZLfD0Hi0pSpgXmkzNC92zKATyqvWnaUiXHEtPz9KrxY_0nzYOPmA?type=png)](https://mermaid.live/edit#pako:eNp1UcFOwzAM_RXLVzZpvUbighDiABfgtkxTlnirtSaZUgc0df130hZEEcwny35-79nu0EZHqHDfxA9bmyTw9KIDlGjz7pDMqQZ3DsazhVCQ7dQbwnEiKxwDvN3NqhN4O4C3q_VaIztYKXjkQ7184HcCG3MQSgq6Mes1bjbTPAV3RdqIJN5l-V__2_Fcf5iY68dgG7ZHBT4WD5ftZfIBN7dQ_Tj4w1B9MVTXGZa_GMYdcIGekjfsymW7oaFRavKkUZXUmXTUqENfcCZLfD0Hi0pSpgXmkzNC92zKATyqvWnaUiXHEtPz9KrxY_0nzYOPmA)

## Launching the App

The app is launched by calling the `launch` function with the root component. Internally, this function will create a new web view using [wry](https://docs.rs/wry/latest/wry/) and create a virtual dom with the root component (`fn app()` in the readme example). This guide will not explain the renderer in-depth, but you can read more about it in the [custom renderer](../cookbook/custom_renderer.md) section.

## The Virtual DOM

Before we dive into the initial render in the virtual DOM, we need to discuss what the virtual DOM is. The virtual DOM is a representation of the DOM that is used to diff the current DOM from the new DOM. This diff is then used to create a list of mutations that need to be applied to the DOM to bring it into sync with the virtual DOM.

The Virtual DOM roughly looks like this:

````rust, no_run
pub struct VirtualDom {
    // All the templates that have been created or set during hot reloading
    pub(crate) templates: FxHashMap<TemplateId, FxHashMap<usize, Template<'static>>>,

    // A slab of all the scopes that have been created
    pub(crate) scopes: ScopeSlab,

    // All scopes that have been marked as dirty
    pub(crate) dirty_scopes: BTreeSet<DirtyScope>,

    // Every element is actually a dual reference - one to the template and the other to the dynamic node in that template
    pub(crate) elements: Slab<ElementRef>,

    // This receiver is used to receive messages from hooks about what scopes need to be marked as dirty
    pub(crate) rx: futures_channel::mpsc::UnboundedReceiver<SchedulerMsg>,

    // The changes queued up to be sent to the renderer
    pub(crate) mutations: Mutations<'static>,
}
````

 > 
 > What is a [slab](https://docs.rs/slab/latest/slab/)?
 > 
 > A slab acts like a hashmap with integer keys if you don't care about the value of the keys. It is internally backed by a dense vector which makes it more efficient than a hashmap. When you insert a value into a slab, it returns an integer key that you can use to retrieve the value later.

 > 
 > How does Dioxus use slabs?
 > 
 > Dioxus uses "synchronized slabs" to communicate between the renderer and the VDOM. When a node is created in the Virtual DOM, an (elementId, mutation) pair is passed to the renderer to identify that node, which the renderer will then render in actual DOM. These ids are also used by the Virtual Dom to reference that node in future mutations, like setting an attribute on a node or removing a node. When the renderer sends an event to the Virtual Dom, it sends the ElementId of the node that the event was triggered on. The Virtual DOM uses this id to find that node in the slab and then run the necessary event handlers.

The virtual DOM is a tree of scopes. A new `Scope` is created for every component when it is first rendered and recycled when the component is unmounted.

Scopes serve three main purposes:

1. They store the state of hooks used by the component
1. They store the state for the context API (for example: using
   [use_shared_state_provider](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_shared_state_provider.html)).
1. They store the current and previous versions of the `VNode` that was rendered, so they can be
   diffed to generate the set of mutations needed to re-render it.

### The Initial Render

The root scope is created and rebuilt:

1. The root component is run
1. The root component returns a `VNode`
1. Mutations for this `VNode` are created and added to the mutation list (this may involve creating new child components)
1. The `VNode` is stored in the root's `Scope`.

After the root's `Scope` is built, all generated mutations are sent to the renderer, which applies them to the DOM.

After the initial render, the root `Scope` looks like this:

[![](https://mermaid.ink/img/pako:eNqtVE1P4zAQ_SuzPrWikRpWXCLtBRDisItWsOxhCaqM7RKricdyJrQV8N93QtvQNCkfEnOynydv3nxkHoVCbUQipjnOVSYDwc_L1AFbWd3dB-kzuEQkuFLoDUwDFkCZAek9nGDh0RlHK__atA1GkUUHf45f0YbppAqB_aOzIAvz-t7-chN_Y-1bw1WSJKsglIu2w9tktWXxIIuHURT5XCqTYa5NmDguw2R8c5MKq2GcgF46WTB_jafi9rZL0yi5q4jQTSrf9altO4okCn1Ratwyz55Qxuku2ITlTMgs6HCQimsPmb3PvqVi-L5gjXP3QcnxWnL8JZLrwGvR31n0KV-Bx6-r-oVkT_-3G1S-NQLbk9i8rj7udP2cixed2QcDCitHJiQw7ub3EVlNecrPjudG2-6soFO5VbMECmR9T5OnlUY4-AFxfw9aTFst3McU9TK1Otm6NEn_DubBYlX2_dglLXOz48FgwJmJ5lZTlhz6xWgNaFnyDgpymcARHO0W2a9J_l5w2wYXvHuGPcqaQ-rESBQmFNJq3nCPNZoK3l4sUSR81DLMUpG6Z_aTFeHV0imRUKjMSFReSzKnVnKGhUimMi8ZNdoShl-rlfmyOUfCS_cPcePz_B_Wl4pc?type=png)](https://mermaid.live/edit#pako:eNqtVE1P4zAQ_SuzPrWikRpWXCLtBRDisItWsOxhCaqM7RKricdyJrQV8N93QtvQNCkfEnOynydv3nxkHoVCbUQipjnOVSYDwc_L1AFbWd3dB-kzuEQkuFLoDUwDFkCZAek9nGDh0RlHK__atA1GkUUHf45f0YbppAqB_aOzIAvz-t7-chN_Y-1bw1WSJKsglIu2w9tktWXxIIuHURT5XCqTYa5NmDguw2R8c5MKq2GcgF46WTB_jafi9rZL0yi5q4jQTSrf9altO4okCn1Ratwyz55Qxuku2ITlTMgs6HCQimsPmb3PvqVi-L5gjXP3QcnxWnL8JZLrwGvR31n0KV-Bx6-r-oVkT_-3G1S-NQLbk9i8rj7udP2cixed2QcDCitHJiQw7ub3EVlNecrPjudG2-6soFO5VbMECmR9T5OnlUY4-AFxfw9aTFst3McU9TK1Otm6NEn_DubBYlX2_dglLXOz48FgwJmJ5lZTlhz6xWgNaFnyDgpymcARHO0W2a9J_l5w2wYXvHuGPcqaQ-rESBQmFNJq3nCPNZoK3l4sUSR81DLMUpG6Z_aTFeHV0imRUKjMSFReSzKnVnKGhUimMi8ZNdoShl-rlfmyOUfCS_cPcePz_B_Wl4pc)

### Waiting for Events

The Virtual DOM will only ever re-render a `Scope` if it is marked as dirty. Each hook is responsible for marking the `Scope` as dirty if the state has changed. Hooks can mark a scope as dirty by sending a message to the Virtual Dom's channel. You can see the [implementations](https://github.com/DioxusLabs/dioxus/tree/master/packages/hooks) for the hooks dioxus includes by default on how this is done. Calling `needs_update()` on a hook will also cause it to mark its scope as dirty.

There are generally two ways a scope is marked as dirty:

1. The renderer triggers an event: An event listener on this event may be called, which may mark a
   component as dirty, if processing the event resulted in any generated any mutations.
1. The renderer calls
   [`wait_for_work`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.VirtualDom.html#method.wait_for_work):
   This polls dioxus internal future queue. One of these futures may mark a component as dirty.

Once at least one `Scope` is marked as dirty, the renderer can call [`render_with_deadline`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.VirtualDom.html#method.render_with_deadline) to diff the dirty scopes.

### Diffing Scopes

When a user clicks the "up high" button, the root `Scope` will be marked as dirty by the `use_state` hook. The desktop renderer will then call `render_with_deadline`, which will diff the root `Scope`.

To start the diffing process, the component function is run. After the root component is run it, the root `Scope` will look like this:

[![](https://mermaid.ink/img/pako:eNrFVlFP2zAQ_iuen0BrpCaIl0i8AEJ72KQJtpcRFBnbJVYTn-U4tBXw33dpG5M2CetoBfdkny_ffb67fPIT5SAkjekkhxnPmHXk-3WiCVpZ3T9YZjJyDeDIDQcjycRCQVwmCTOGXEBhQEvtVvG1CWUldwo0-XX-6vVIF5W1GB9cWVbI1_PNL5v8jW3uPFbpmFOc2HK-GfA2WG1ZeJSFx0EQmJxxmUEupE01liEd394mVAkyjolYaFYgfu1P6N1dF8Yzua-cA51WphtTWzsLc872Zan9CnEGUkktuk6fFm_i5NxFRwn9bUimHrIvCT3-N2EBM70j5XBNOTwI5TrxmvQJkr7ELcHx67Jeggz0v92g8q0RaE-iP1193On6NyxecKUeJeFQaSdtTMLu_Xah5ctT_u94Nty2ZwU0zxWfxqQA5PecPq84kq9nfRw7SK0WDiEFZ4O37d34S_-08lFBVfb92KVb5HIrAp0WpjKYKeGyODLz0dohWIkaZNkiJqfkdLvIH6oRaTSoEmm0n06k0a5K0ZdpL61Io0Yt0nfpxc7UQ0_9cJrhyZ8syX-6brS706Mc489Vjja7fbWj3cxDqIdfJJqOaCFtwZTAV8hT7U0ovjBQRmiMS8HsNKGJfsE4Vjm4WWhOY2crOaKVEczJS8WwgAWNJywv0SuFcmB_rJ41y9fNiBqm_wA0MS9_AUuAiy0?type=png)](https://mermaid.live/edit#pako:eNrFVlFP2zAQ_iuen0BrpCaIl0i8AEJ72KQJtpcRFBnbJVYTn-U4tBXw33dpG5M2CetoBfdkny_ffb67fPIT5SAkjekkhxnPmHXk-3WiCVpZ3T9YZjJyDeDIDQcjycRCQVwmCTOGXEBhQEvtVvG1CWUldwo0-XX-6vVIF5W1GB9cWVbI1_PNL5v8jW3uPFbpmFOc2HK-GfA2WG1ZeJSFx0EQmJxxmUEupE01liEd394mVAkyjolYaFYgfu1P6N1dF8Yzua-cA51WphtTWzsLc872Zan9CnEGUkktuk6fFm_i5NxFRwn9bUimHrIvCT3-N2EBM70j5XBNOTwI5TrxmvQJkr7ELcHx67Jeggz0v92g8q0RaE-iP1193On6NyxecKUeJeFQaSdtTMLu_Xah5ctT_u94Nty2ZwU0zxWfxqQA5PecPq84kq9nfRw7SK0WDiEFZ4O37d34S_-08lFBVfb92KVb5HIrAp0WpjKYKeGyODLz0dohWIkaZNkiJqfkdLvIH6oRaTSoEmm0n06k0a5K0ZdpL61Io0Yt0nfpxc7UQ0_9cJrhyZ8syX-6brS706Mc489Vjja7fbWj3cxDqIdfJJqOaCFtwZTAV8hT7U0ovjBQRmiMS8HsNKGJfsE4Vjm4WWhOY2crOaKVEczJS8WwgAWNJywv0SuFcmB_rJ41y9fNiBqm_wA0MS9_AUuAiy0)

Next, the Virtual DOM will compare the new VNode with the previous VNode and only update the parts of the tree that have changed. Because of this approach, when a component is re-rendered only the parts of the tree that have changed will be updated in the DOM by the renderer.

The diffing algorithm goes through the list of dynamic attributes and nodes and compares them to the previous VNode. If the attribute or node has changed, a mutation that describes the change is added to the mutation list.

Here is what the diffing algorithm looks like for the root `Scope` (red lines indicate that a mutation was generated, and green lines indicate that no mutation was generated)

[![](https://mermaid.ink/img/pako:eNrFlFFPwjAQx7_KpT7Kko2Elya8qCE-aGLAJ5khpe1Yw9Zbug4k4He3OJjbGPig0T5t17tf_nf777aEo5CEkijBNY-ZsfAwDjW4kxfzhWFZDGNECxOOmYTIYAo2lsCyDG4xzVBLbcv8_RHKSG4V6orSIN0Wxrh8b2RYKr_uTyubd1W92GiWKg7aac6bOU3G803HbVk82xfP_Ok0JEqAT-FeLWJvpFYSOBbaSkMhCMnra5MgtfhWFrPWqHlhL2urT6atbU-oa0PNE8WXFFJ0-nazXakRroddGk9IwYEUnCd5w7Pddr5UTT8ZuVJY5F0fM7ebRLYyXNDgUnprJWxM-9lb7xAQLHe-M2xDYQCD9pD_2hez_kVn-P_rjLq6n3qjYv2iO5qz9DyvPdyv1ETp5eTTJ_7BGvQq8v1TVtl5jXUcRRcrqFh-dI4VtFlBN6t_ynLNkh5JpUmZEm5rbvfhkLiN6H4BQt2jYGYZklC_uzxWWJxsNCfUmkL2SJEJZuWdYs4cKaERS3IXlUJZNI_lGv7cxj2SMf2CeMx5_wBcbK19?type=png)](https://mermaid.live/edit#pako:eNrFlFFPwjAQx7_KpT7Kko2Elya8qCE-aGLAJ5khpe1Yw9Zbug4k4He3OJjbGPig0T5t17tf_nf777aEo5CEkijBNY-ZsfAwDjW4kxfzhWFZDGNECxOOmYTIYAo2lsCyDG4xzVBLbcv8_RHKSG4V6orSIN0Wxrh8b2RYKr_uTyubd1W92GiWKg7aac6bOU3G803HbVk82xfP_Ok0JEqAT-FeLWJvpFYSOBbaSkMhCMnra5MgtfhWFrPWqHlhL2urT6atbU-oa0PNE8WXFFJ0-nazXakRroddGk9IwYEUnCd5w7Pddr5UTT8ZuVJY5F0fM7ebRLYyXNDgUnprJWxM-9lb7xAQLHe-M2xDYQCD9pD_2hez_kVn-P_rjLq6n3qjYv2iO5qz9DyvPdyv1ETp5eTTJ_7BGvQq8v1TVtl5jXUcRRcrqFh-dI4VtFlBN6t_ynLNkh5JpUmZEm5rbvfhkLiN6H4BQt2jYGYZklC_uzxWWJxsNCfUmkL2SJEJZuWdYs4cKaERS3IXlUJZNI_lGv7cxj2SMf2CeMx5_wBcbK19)

## Conclusion

This is only a brief overview of how the Virtual Dom works. There are several aspects not yet covered in this guide including:

* How the Virtual DOM handles async-components
* Keyed diffing
* Using [bump allocation](https://github.com/fitzgen/bumpalo) to efficiently allocate VNodes.

If you need more information about the Virtual Dom, you can read the code of the [core](https://github.com/DioxusLabs/dioxus/tree/master/packages/core) crate or reach out to us on [Discord](https://discord.gg/XgGxMSkvUM).
# Overall Goals

This document outlines some of the overall goals for Dioxus. These goals are not set in stone, but they represent general guidelines for the project.

The goal of Dioxus is to make it easy to build **cross-platform applications that scale**.

## Cross-Platform

Dioxus is designed to be cross-platform by default. This means that it should be easy to build applications that run on the web, desktop, and mobile. However, Dioxus should also be flexible enough to allow users to opt into platform-specific features when needed. The `use_eval` is one example of this. By default, Dioxus does not assume that the platform supports JavaScript, but it does provide a hook that allows users to opt into JavaScript when needed.

## Performance

As Dioxus applications grow, they should remain relatively performant without the need for manual optimizations. There will be cases where manual optimizations are needed, but Dioxus should try to make these cases as rare as possible.

One of the benefits of the core architecture of Dioxus is that it delivers reasonable performance even when components are rerendered often. It is based on a Virtual Dom which performs diffing which should prevent unnecessary re-renders even when large parts of the component tree are rerun. On top of this, Dioxus groups static parts of the RSX tree together to skip diffing them entirely.

## Type Safety

As teams grow, the Type safety of Rust is a huge advantage. Dioxus should leverage this advantage to make it easy to build applications with large teams.

To take full advantage of Rust's type system, Dioxus should try to avoid exposing public `Any` types and string-ly typed APIs where possible.

## Developer Experience

Dioxus should be easy to learn and ergonomic to use.

* The API of Dioxus attempts to remain close to React's API where possible. This makes it easier for people to learn Dioxus if they already know React

* We can avoid the tradeoff between simplicity and flexibility by providing multiple layers of API: One for the very common use case, one for low-level control
  
  * Hooks: the hooks crate has the most common use cases, but `cx.hook` provides a way to access the underlying persistent reference if needed.
  * The builder pattern in platform Configs: The builder pattern is used to default to the most common use case, but users can change the defaults if needed.
* Documentation:
  
  * All public APIs should have rust documentation
  * Examples should be provided for all public features. These examples both serve as documentation and testing. They are checked by CI to ensure that they continue to compile
  * The most common workflows should be documented in the guide
# Roadmap & Feature-set

This feature set and roadmap can help you decide if what Dioxus can do today works for you.

If a feature that you need doesn't exist or you want to contribute to projects on the roadmap, feel free to get involved by [joining the discord](https://discord.gg/XgGxMSkvUM).

Generally, here's the status of each platform:

* **Web**: Dioxus is a great choice for pure web-apps – especially for CRUD/complex apps. However, it does lack the ecosystem of React, so you might be missing a component library or some useful hook.

* **SSR**: Dioxus is a great choice for pre-rendering, hydration, and rendering HTML on a web endpoint. Be warned – the VirtualDom is not (currently) `Send + Sync`.

* **Desktop**: You can build very competent single-window desktop apps right now. However, multi-window apps require support from Dioxus core and are not ready.

* **Mobile**: Mobile support is very young. You'll be figuring things out as you go and there are not many support crates for peripherals.

* **LiveView**: LiveView support is very young. You'll be figuring things out as you go. Thankfully, none of it is too hard and any work can be upstreamed into Dioxus.

## Features

---

|Feature|Status|Description|
|-------|------|-----------|
|Conditional Rendering|x|if/then to hide/show component|
|Map, Iterator|x|map/filter/reduce to produce rsx!|
|Keyed Components|x|advanced diffing with keys|
|Web|x|renderer for web browser|
|Desktop (webview)|x|renderer for desktop|
|Shared State (Context)|x|share state through the tree|
|Hooks|x|memory cells in components|
|SSR|x|render directly to string|
|Component Children|x|cx.children() as a list of nodes|
|Headless components|x|components that don't return real elements|
|Fragments|x|multiple elements without a real root|
|Manual Props|x|Manually pass in props with spread syntax|
|Controlled Inputs|x|stateful wrappers around inputs|
|CSS/Inline Styles|x|syntax for inline styles/attribute groups|
|Custom elements|x|Define new element primitives|
|Suspense|x|schedule future render from future/promise|
|Integrated error handling|x|Gracefully handle errors with ? syntax|
|NodeRef|x|gain direct access to nodes|
|Re-hydration|x|Pre-render to HTML to speed up first contentful paint|
|Jank-Free Rendering|x|Large diffs are segmented across frames for silky-smooth transitions|
|Effects|x|Run effects after a component has been committed to render|
|Portals|\*|Render nodes outside of the traditional tree structure|
|Cooperative Scheduling|\*|Prioritize important events over non-important events|
|Server Components|\*|Hybrid components for SPA and Server|
|Bundle Splitting|i|Efficiently and asynchronously load the app|
|Lazy Components|i|Dynamically load the new components as the page is loaded|
|1st class global state|x|redux/recoil/mobx on top of context|
|Runs natively|x|runs as a portable binary w/o a runtime (Node)|
|Subtree Memoization|x|skip diffing static element subtrees|
|High-efficiency templates|x|rsx! calls are translated to templates on the DOM's side|
|Compile-time correct|x|Throw errors on invalid template layouts|
|Heuristic Engine|x|track component memory usage to minimize future allocations|
|Fine-grained reactivity|i|Skip diffing for fine-grain updates|

* x = implemented and working
* \* = actively being worked on
* i = not yet implemented or being worked on

## Roadmap

These Features are planned for the future of Dioxus:

### Core

* [x] Release of Dioxus Core
* [x] Upgrade documentation to include more theory and be more comprehensive
* [x] Support for HTML-side templates for lightning-fast dom manipulation
* [ ] Support for multiple renderers for same virtualdom (subtrees)
* [ ] Support for ThreadSafe (Send + Sync)
* [ ] Support for Portals

### SSR

* [x] SSR Support + Hydration
* [ ] Integrated suspense support for SSR

### Desktop

* [ ] Declarative window management
* [ ] Templates for building/bundling
* [ ] Access to Canvas/WebGL context natively

### Mobile

* [ ] Mobile standard library
  * [ ] GPS
  * [ ] Camera
  * [ ] filesystem
  * [ ] Biometrics
  * [ ] WiFi
  * [ ] Bluetooth
  * [ ] Notifications
  * [ ] Clipboard
* [ ] Animations

### Bundling (CLI)

* [x] Translation from HTML into RSX
* [x] Dev server
* [x] Live reload
* [x] Translation from JSX into RSX
* [ ] Hot module replacement
* [ ] Code splitting
* [ ] Asset macros
* [ ] Css pipeline
* [ ] Image pipeline

### Essential hooks

* [x] Router
* [x] Global state management
* [ ] Resize observer

## Work in Progress

### Build Tool

We are currently working on our own build tool called [Dioxus CLI](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli) which will support:

* an interactive TUI
* on-the-fly reconfiguration
* hot CSS reloading
* two-way data binding between browser and source code
* an interpreter for `rsx!`
* ability to publish to github/netlify/vercel
* bundling for iOS/Desktop/etc

### Server Component Support

While not currently fully implemented, the expectation is that LiveView apps can be a hybrid between Wasm and server-rendered where only portions of a page are "live" and the rest of the page is either server-rendered, statically generated, or handled by the host SPA.

### Native rendering

We are currently working on a native renderer for Dioxus using WGPU called [Blitz](https://github.com/DioxusLabs/blitz/). This will allow you to build apps that are rendered natively for iOS, Android, and Desktop.
# 0.3 Migration Guide

This guide will outline the API changes between the `0.3` and `0.4` releases. The two major breaking changes in this release are how hot reloading works on desktop platforms and how the router works:

* [Hot reload](hot_reload.md)
* [Router](router.md)
# Router

The router has been entirely rewritten in the `0.4` release to provide type safe routes. This guide serves to help you upgrade your project to the new router. For more information on the router, see the [router guide](../router/index.md).

## Defining Your Router

Previously, you defined your route with components:

````rust
rsx! {
    Router::<Route> {
        Route { to: "/home", Home {} }
        Route { to: "/blog", Blog {} }
        // BlogPost has a dynamic id
        Route { to: "/blog/:id", BlogPost {} }
    }
}
````

Now you must define your routes as an enum of possible routes:

````rust
use dioxus::prelude::*;

#[derive(Routable, PartialEq, Debug, Clone)]
enum Route {
    #[route("/home")]
    // This route will render the Home component with the HomeProps props. (make sure you have the props imported)
    // You can modify the props by passing extra arguments to the macro. For example, if you want the Home variant to render a component called Homepage, you could use:
    // #[route("/home", Homepage)]
    Home {},
    #[route("/blog")]
    Blog {},
    // BlogPost has a dynamic id
    #[route("/blog/:id")]
    BlogPost {
        id: usize
    }
}

#[component]
fn Home(cx: Scope) -> Element {
    todo!()
}

#[component]
fn Blog(cx: Scope) -> Element {
    todo!()
}

#[component]
fn BlogPost(cx: Scope, id: usize) -> Element {
    // Note that you have access to id here in a type safe way without calling any extra functions!
    todo!()
}
````

## Linking to routes

Now that routes are enums, you should use the enum as the route in Links. If you try to link to a route that does not exist, you will get a compiler error.

````rust
use dioxus::prelude::*;

fn Component(cx: Scope) -> Element {
    render! {
        Link {
            to: Route::BlogPost { id: 123 },
            "blog post"
        }
    }
}
````

## External Links

To link to external routes, you can use a string:

````rust
use dioxus::prelude::*;

fn Component(cx: Scope) -> Element {
    render! {
        Link {
            to: "https://google.com",
            "google"
        }
    }
}
````

## use_router

The `use_router` hook has been split into two separate hooks: the `use_route` hook and the `use_navigator` hook.

### use_route

The new use_route hook lets you read the current route:

````rust
use dioxus::prelude::*;

#[derive(Clone, Routable)]
enum Route {
    #[route("/")]
    Index {},
}

fn App(cx: Scope) -> Element {
    render! {
        h1 { "App" }
        Router::<Route> {}
    }
}

#[component]
fn Index(cx: Scope) -> Element {
    // Read from (and subscribe to the current route)
    let path = use_route(&cx).unwrap();
    render! {
        h2 { "Current Path" }
        p { "{path}" }
    }
}
````

### use_navigator

`use_navigator` lets you change the route programmatically:

````rs@navigator.rs
#[component]
fn Home(cx: Scope) -> Element {
    let nav = use_navigator(cx);

    // push
    nav.push(Route::PageNotFound { route: vec![] });

    // replace
    nav.replace(Route::Home {});

    // go back
    nav.go_back();

    // go forward
    nav.go_forward();

    render! {
        h1 { "Welcome to the Dioxus Blog!" }
    }
}
````

You can read more about programmatic navigation in the [Router Book](../router/reference/navigation/programmatic.md).

### New features

In addition to these changes, there have been many new features added to the router:

* [static generation support](../router/reference/static-generation.md)
* [Layouts](../router/reference/layouts.md)
* [Nesting](../router/reference/routes/nested.md)
# Hot reloading

Desktop hot reloading has changed in the `0.4` release to use the [Dioxus CLI](../CLI/index.md) for all platforms.

Previously, you may have included the `hot_reload_init!` macro in your main function. This is no longer needed.

old:

````rust
fn main() {
    hot_reload_init!();
    // ...
}
````

new:

````rust
fn main() {
    // ...
}
````

Now you can run your project with the dioxus CLI by passing the `--platform` flag:

````sh
dx serve --platform desktop --hot-reload
````
