<SYSTEM>This is the developer documentation for Dioxus at /learn/0.4/router/example/first-route and all its subroutes.</SYSTEM>

# Creating Our First Route

In this chapter, we will start utilizing Dioxus Router and add a homepage and a
404 page to our project.

## Fundamentals

The core of the Dioxus Router is the \[`Routable`\] macro and the \[`Router`\] component.

Routable is a trait for anything that can:

* Be parsed from a URL
* Be turned into a URL
* Be rendered as to a Element

Let's create a new router. First, we need an actual page to route to! Let's add a homepage component:

````rs@first_route.rs
#[component]
fn Home(cx: Scope) -> Element {
    render! {
        h1 { "Welcome to the Dioxus Blog!" }
    }
}
````

## Creating Routes

We want to use Dioxus Router to separate our application into different "pages".
Dioxus Router will then determine which page to render based on the URL path.

To start using Dioxus Router, we need to use the \[`Routable`\] macro.

The \[`Routable`\] macro takes an enum with all of the possible routes in our application. Each variant of the enum represents a route and must be annotated with the \[`route(path)`\] attribute.

````rs@first_route.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route("/")]
    // If the name of the component and variant are the same you can omit the component and props name
    // If they are different you can specify them like this:
    // #[route("/", ComponentName, PropsName)]
    Home {},
}
````

All other hooks and components the router provides can only be used as a descendant of a \[`Router`\] component.

If you head to your application's browser tab, you should now see the text
`Welcome to Dioxus Blog!` when on the root URL (`http://localhost:8080/`). If
you enter a different path for the URL, nothing should be displayed.

This is because we told Dioxus Router to render the `Home` component only when
the URL path is `/`.

## Fallback Route

In our example, when a route doesn't exist Dioxus Router doesn't render anything. Many sites also have a "404" page when a path does not exist. Let's add one to our site.

First, we create a new `PageNotFound` component.

````rs@catch_all.rs
#[component]
fn PageNotFound(cx: Scope, route: Vec<String>) -> Element {
    render! {
        h1 { "Page not found" }
        p { "We are terribly sorry, but the page you requested doesn't exist." }
        pre {
            color: "red",
            "log:\nattemped to navigate to: {route:?}"
        }
    }
}
````

Next, register the route in the Route enum to match if all other routes fail.

````rs@catch_all.rs
#[derive(Routable, Clone)]
enum Route {
    #[route("/")]
    Home {},
    // PageNotFound is a catch all route that will match any route and placing the matched segments in the route field
    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}
````

Now when you go to a route that doesn't exist, you should see the page not found
text.

## Conclusion

In this chapter, we learned how to create a route and tell Dioxus Router what
component to render when the URL path is `/`. We also created a 404 page to
handle when a route doesn't exist. Next, we'll create the blog portion of our
site. We will utilize nested routes and URL parameters.
# Building a Nest

In this chapter, we will begin to build the blog portion of our site which will
include links, nested routes, and route parameters.

## Site Navigation

Our site visitors won't know all the available pages and blogs on our site so we
should provide a navigation bar for them. Our navbar will be a list of links going between our pages.

We want our navbar component to be rendered on several different pages on our site. Instead of duplicating the code, we can create a component that wraps all children routes. This is called a layout component. To tell the router where to render the child routes, we use the \[`Outlet`\] component.

Let's create a new `NavBar` component:

````rs@nested_routes.rs
#[component]
fn NavBar(cx: Scope) -> Element {
    render! {
        nav {
            ul {
                li { "links" }
            }
        }
        // The Outlet component will render child routes (In this case just the Home component) inside the Outlet component
        Outlet::<Route> {}
    }
}
````

Next, let's add our `NavBar` component as a layout to our Route enum:

````rs@nested_routes.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // All routes under the NavBar layout will be rendered inside of the NavBar Outlet
    #[layout(NavBar)]
        #[route("/")]
        Home {},
    #[end_layout]
    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}
````

To add links to our `NavBar`, we could always use an HTML anchor element but that has two issues:

1. It causes a full-page reload
1. We can accidentally link to a page that doesn't exist

Instead, we want to use the [`Link`] component provided by Dioxus Router.

The [`Link`] is similar to a regular `<a>` tag. It takes a target and children.

Unlike a regular `<a>` tag, we can pass in our Route enum as the target. Because we annotated our routes with the \[`route(path)`\] attribute, the [`Link`] will know how to generate the correct URL. If we use the Route enum, the rust compiler will prevent us from linking to a page that doesn't exist.

Let's add our links:

````rs@links.rs
#[component]
fn NavBar(cx: Scope) -> Element {
    render! {
        nav {
            Link {
                // The Link component will navigate to the route specified
                // in the target prop which is checked to exist at compile time
                to: Route::Home {},
                "Home"
            }
        }
        Outlet::<Route> {}
    }
}
````

 > 
 > Using this method, the [`Link`] component only works for links within our
 > application. To learn more about navigation targets see
 > [here](./navigation-targets.md).

Now you should see a list of links near the top of your page. Click on one and
you should seamlessly travel between pages.

## URL Parameters and Nested Routes

Many websites such as GitHub put parameters in their URL. For example,
`https://github.com/DioxusLabs` utilizes the text after the domain to
dynamically search and display content about an organization.

We want to store our blogs in a database and load them as needed. We also
want our users to be able to send people a link to a specific blog post.
Instead of listing all of the blog titles at compile time, we can make a dynamic route.

We could utilize a search page that loads a blog when clicked but then our users
won't be able to share our blogs easily. This is where URL parameters come in.

The path to our blog will look like `/blog/myBlogPage`, `myBlogPage` being the
URL parameter.

First, let's create a layout component (similar to the navbar) that wraps the blog content. This allows us to add a heading that tells the user they are on the blog.

````rs@dynamic_route.rs
#[component]
fn Blog(cx: Scope) -> Element {
    render! {
        h1 { "Blog" }
        Outlet::<Route> {}
    }
}
````

Now we'll create another index component, that'll be displayed when no blog post
is selected:

````rs@dynamic_route.rs
#[component]
fn BlogList(cx: Scope) -> Element {
    render! {
        h2 { "Choose a post" }
        ul {
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 1".into() },
                    "Read the first blog post"
                }
            }
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 2".into() },
                    "Read the second blog post"
                }
            }
        }
    }
}
````

We also need to create a component that displays an actual blog post. This component will accept the URL parameters as props:

````rs@dynamic_route.rs
// The name prop comes from the /:name route segment
#[component]
fn BlogPost(cx: Scope, name: String) -> Element {
    render! {
        h2 { "Blog Post: {name}"}
    }
}
````

Finally, let's tell our router about those components:

````rs@dynamic_route.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
            #[route("/")]
            BlogList {},
            #[route("/post/:name")]
            BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
````

That's it! If you head to `/blog/1` you should see our sample post.

## Conclusion

In this chapter, we utilized Dioxus Router's Link, and Route Parameter
functionality to build the blog portion of our application. In the next chapter,
we will go over how navigation targets (like the one we passed to our links)
work.
# Navigation Targets

In the previous chapter, we learned how to create links to pages within our app.
We told them where to go using the `target` property. This property takes something that can be converted to a [`NavigationTarget`].

## What is a navigation target?

A [`NavigationTarget`] is similar to the `href` of an HTML anchor element. It
tells the router where to navigate to. The Dioxus Router knows two kinds of
navigation targets:

* [`Internal`]: We used internal links in the previous chapter. It's a link to a page within our
  app represented as a Route enum.
* [`External`]: This works exactly like an HTML anchors' `href`. Don't use this for in-app
  navigation as it will trigger a page reload by the browser.

## External navigation

If we need a link to an external page we can do it like this:

````rs@external_link.rs
fn GoToDioxus(cx: Scope) -> Element {
    render! {
        Link {
            to: "https://dioxuslabs.com",
            "ExternalTarget target"
        }
    }
}
````
# Redirection Perfection

You're well on your way to becoming a routing master!

In this chapter, we will cover creating redirects

## Creating Redirects

A redirect is very simple. When dioxus encounters a redirect while finding out
what components to render, it will redirect the user to the target of the
redirect.

As a simple example, let's say you want user to still land on your blog, even
if they used the path `/myblog` or `/myblog/:name`.

Redirects are special attributes in the router enum that accept a route and a closure
with the route parameters. The closure should return a route to redirect to.

Let's add a redirect to our router enum:

````rs@full_example.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
                #[route("/")]
                BlogList {},
                #[route("/post/:name")]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest("/myblog")]
        #[redirect("/", || Route::BlogList {})]
        #[redirect("/:name", |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
````

That's it! Now your users will be redirected to the blog.

### Conclusion

Well done! You've completed the Dioxus Router guide. You've built a small
application and learned about the many things you can do with Dioxus Router.
To continue your journey, you attempt a challenge listed below, look at the [router examples](https://github.com/DioxusLabs/dioxus/tree/master/packages/router/examples), or
can check out the [API reference](https://docs.rs/dioxus-router/).

### Challenges

* Organize your components into separate files for better maintainability.
* Give your app some style if you haven't already.
* Build an about page so your visitors know who you are.
* Add a user system that uses URL parameters.
* Create a simple admin system to create, delete, and edit blogs.
* If you want to go to the max, hook up your application to a rest API and database.
# Full Code

````rs@full_example.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;

// ANCHOR: router
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
                #[route("/")]
                BlogList {},
                #[route("/post/:name")]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest("/myblog")]
        #[redirect("/", || Route::BlogList {})]
        #[redirect("/:name", |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
// ANCHOR_END: router

pub fn App(cx: Scope) -> Element {
    render! {
        Router::<Route> {}
    }
}

#[component]
fn NavBar(cx: Scope) -> Element {
    render! {
        nav {
            ul {
                li { Link { to: Route::Home {}, "Home" } }
                li { Link { to: Route::BlogList {}, "Blog" } }
            }
        }
        Outlet::<Route> {}
    }
}

#[component]
fn Home(cx: Scope) -> Element {
    render! {
        h1 { "Welcome to the Dioxus Blog!" }
    }
}

#[component]
fn Blog(cx: Scope) -> Element {
    render! {
        h1 { "Blog" }
        Outlet::<Route> {}
    }
}

#[component]
fn BlogList(cx: Scope) -> Element {
    render! {
        h2 { "Choose a post" }
        ul {
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 1".into() },
                    "Read the first blog post"
                }
            }
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 2".into() },
                    "Read the second blog post"
                }
            }
        }
    }
}

#[component]
fn BlogPost(cx: Scope, name: String) -> Element {
    render! {
        h2 { "Blog Post: {name}"}
    }
}

#[component]
fn PageNotFound(cx: Scope, route: Vec<String>) -> Element {
    render! {
        h1 { "Page not found" }
        p { "We are terribly sorry, but the page you requested doesn't exist." }
        pre {
            color: "red",
            "log:\nattemped to navigate to: {route:?}"
        }
    }
}

````
