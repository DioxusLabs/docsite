<SYSTEM>This is the developer documentation for Dioxus at /learn/0.7/getting_started/ and all its subroutes.</SYSTEM>

# Getting Started

## Pick an Editor

We recommend using [VSCode](https://code.visualstudio.com) since Dioxus ships with its [own VSCode extension](https://marketplace.visualstudio.com/items?itemName=DioxusLabs.dioxus). Our build tool `dx` is standalone and is meant to be used through a terminal.

Most editors support the [Rust-Analyzer LSP plugin](https://rust-analyzer.github.io) which provides appropriate syntax highlighting, code navigation, folding, and more. You can follow the [installation instructions](https://rust-analyzer.github.io/manual.html#installation) for your editor of choice: [VSCode](https://rust-analyzer.github.io/manual.html#vs-code), [Zed](https://rust-analyzer.github.io/manual.html#zed), [Emacs](https://rust-analyzer.github.io/manual.html#emacs), or [Vim](https://rust-analyzer.github.io/manual.html#vimneovim).

## Install Rust

Head over to [https://rust-lang.org](http://rust-lang.org) and install the Rust compiler (preferably using `rustup`). Once installed, make sure you add the `stable` toolchain and any relevant toolchains (ie wasm32-unknown-unknown for web apps):

````sh
rustup toolchain install stable
rustup target add wasm32-unknown-unknown
````

We strongly recommend going through the [official Rust book](https://doc.rust-lang.org/book/ch01-00-getting-started.html) *completely*. However, we hope that a Dioxus app can serve as a great first Rust project.

We've put a lot of care into making Dioxus syntax familiar and easy to understand, so you won't need deep knowledge of async, lifetimes, or smart pointers until you start building complex Dioxus apps.

## Install the Dioxus CLI

Dioxus ships with its own build tool that leverages `cargo` to provide integrated hot-reloading, bundling, and development servers for web and mobile. You can download the prebuilt binary with the following command:

````sh
curl -sSL https://dioxus.dev/install.sh | bash
````

You can also download with `cargo-binstall`:

````sh
cargo binstall dioxus-cli --force
````

If you want to build the CLI from source, you can install it with the following command:

````sh
cargo install dioxus-cli
````

 > 
 > ðŸ“£ Installing from source can take up to 10 minutes and requires several dependencies. We *strongly* recommend downloading the prebuilt binaries.

If you get an OpenSSL error on installation, ensure the dependencies listed [here](https://docs.rs/openssl/latest/openssl/#automatic) are installed.

## Platform-specific dependencies

Most platforms don't require any additional dependencies, but if you are targeting desktop, you might need to install additional dependencies.

You can use the `dx doctor` command to see if `dx` can properly understand your install. This command helps provide insight into missing toolchains and tools required for cross-platform development.

### macOS

There are no extra dependencies for macOS! However, if you want to build iOS apps, read the [iOS section](#ios) below.

### Windows

Windows apps depend on WebView2 â€“ a library that should be installed in all modern Windows distributions.

If you have Edge installed, then Dioxus will work fine. If you *don't* have WebView2, then you can [install it through Microsoft](https://developer.microsoft.com/en-us/microsoft-edge/webview2/). Microsoft provides 3 options:

1. A tiny "evergreen" *bootstrapper* that fetches an installer from Microsoft's CDN.
1. A tiny *installer* that fetches WebView2 from Microsoft's CDN.
1. A statically linked version of WebView2 in your final binary for offline users.

We recommend using Option 1.

### Linux

WebView Linux apps require WebkitGtk and xdotool. When distributing, these should be part of your dependency tree in your `.rpm` or `.deb`.

If you run into issues, make sure you have all the basics installed.

For Ubuntu, make sure everything is installed:

````sh
sudo apt update
sudo apt install libwebkit2gtk-4.1-dev \
  build-essential \
  curl \
  wget \
  file \
  libxdo-dev \
  libssl-dev \
  libayatana-appindicator3-dev \
  librsvg2-dev \
  lld
````

For arch:

````sh
sudo pacman -Syu
sudo pacman -S --needed \
  webkit2gtk-4.1 \
  base-devel \
  curl \
  wget \
  file \
  openssl \
  appmenu-gtk-module \
  libappindicator-gtk3 \
  librsvg \
  xdotool
````

For all other Linux targets, [check the Tauri docs which cover the same dependencies](https://tauri.app/start/prerequisites/#linux).

In addition to the Tauri docs, for Fedora:

````sh
sudo dnf install libxdo-devel
````

### WSL

While doable, it can be tricky to setup development in WSL for Dioxus desktop. Not everything has been figured out and some stuff may not work.

Here are the steps we used to get Dioxus running through WSL:

1. Update your kernel to the latest version and update WSL to version 2.
1. Add `export DISPLAY=:0` to `~/.zshrc`
1. Install Tauri's Linux dependencies found [here](https://beta.tauri.app/start/prerequisites/).
1. For file dialogs to work, you need to install a fallback like `zenity`

When running Dioxus desktop on WSL, you may get warnings from `libEGL`. There is currently no way to silence these, but the app should still render.

### iOS

Building iOS apps requires a device running macOS with XCode installed.

Download and install XCode from one of the following places:

* [Mac App Store](https://apps.apple.com/gb/app/xcode/id497799835?mt=12)
* [Apple Developer website](https://developer.apple.com/xcode/resources/)

You will need to download the iOS SDK and install some simulators.

For more details, we recommend reading the [dedicated guide for iOS development](../guides/platforms/mobile.md).

### Android

Android apps require the Android SDK and NDK to be installed. This can be a substantial amount of setup, so we recommend reading the [dedicated guide for Android development](../guides/platforms/mobile.md).
# Dioxus Tutorial

In this tutorial, we'll be building a small app called: *HotDog* - basically Tinder, but for dogs! This app will serve as a great way to learn about building UIs, adding state, and deploying.

By the end of this tutorial, you will launch your very own web, desktop, and mobile apps and a backend deployed to [Fly.io](http://fly.io).

![Photo of HotDog](/assets/06_docs/dog_app_styled.png)

We will primarily focus on the higher-level concepts of Dioxus without diving deep into the details of specific APIs. We recommend experimenting with the APIs yourself or reading the [Core Concepts](../essentials/index.md) and specific [Guides](../guides/index.md) for more information.

## What will we be learning?

This guide will cover the "core" Dioxus features including:

* [Tooling Setup](tooling.md)
* [Creating a new app](new_app.md)
* [How Components Work](component.md)
* [Creating UI with RSX](rsx.md)
* [Styling and Assets](assets.md)
* [Adding State](state.md)
* [Fetching Data](data_fetching.md)
* [Adding a Backend](backend.md)
* [Integrating a Database](databases.md)
* [App Routing](routing.md)
* [Bundling](bundle.md)
* [Deployment](deploy.md)
* [Next Steps](next_steps.md)

Dioxus is a very full-featured framework, so we encourage you to follow up this tutorial by building your own larger apps.

## What are we building?

The features of *HotDog* are fairly simple:

* Engage with a stream of cute dog photos
* Swipe right if we want to save the dog photo to our collection
* Swipe left if we don't want to save the dog photo
* View the dog photos we saved later

At the end of the tutorial, you'll have your very own *HotDog* app to remix and download to your device.
# Setting up Tooling

Before we get started, make sure you've followed the [Getting Started](../getting_started/index.md) page on installing the required dependencies. We will be primarily developing *HotDog* as web application, but we still recommend setting up the relevant tooling for desktop and mobile development as well.

## Checklist

We covered the setup instructions in [Getting Started](../getting_started/index.md), but first verify your setup:

* Rust and Cargo are installed
* The wasm32-unknown-unknown Rust target is installed
* The `dioxus-cli` is installed and up-to-date
* System-specific dependencies are installed

Refer to the `dx doctor` command to see what `dx` uses to build your app.

## All the Commands

Before proceeding, make sure you have the `dioxus-cli` installed and up-to-date. Verify the returned version matches this guide by running:

````sh
dx --version
````

You can also run `dx help` which will give you a list of useful commands and some information on how to use `dx`.

````txt
Build, Bundle & Ship Dioxus Apps

Usage: dx [OPTIONS] <COMMAND>

Commands:
  build      Build the Dioxus project and all of its assets
  translate  Translate a source file into Dioxus code
  serve      Build, watch & serve the Dioxus project and all of its assets
  new        Create a new project for Dioxus
  init       Init a new project for Dioxus in the current directory (by default). Will attempt to keep your project in a good state
  clean      Clean output artifacts
  bundle     Bundle the Dioxus app into a shippable object
  fmt        Automatically format RSX
  check      Check the project for any issues
  run        Run the project without any hotreloading
  config     Dioxus config file controls
  help       Print this message or the help of the given subcommand(s)

Options:
      --verbose      Use verbose output [default: false]
      --trace        Use trace output [default: false]
      --json-output  Output logs in JSON format
  -h, --help         Print help
  -V, --version      Print version
````

If `dx` is installed properly, then you're ready to proceed!
# Creating a new project

You can create a new Dioxus project by running the following command and following the prompts:

````sh
dx new hot_dog
````

![dxnew](/assets/06_docs/dx_new_06.mp4)

You'll need to select a template to use to get started.

* Bare-bones: a very simple setup with just a `main.rs` and an `assets` folder.
* Jumpstart: a scaffolded app with components, views, and suggested structure.
* Workspace: a full cargo workspace setup with different crates per platform.

We're going to use the bare-bones template for *HotDog* since our app will be quite simple.

* Select "false" when asked if you want to create a fullstack website.
* Select "false" for the router, though we *will* eventually add the router to the app.
* Select "true" for TailwindCSS.
* Select "false" for prompts for LLMs.
* Select "Web" as the default platform.

 > 
 > ðŸ“£ You don't need `dx new` to create new Dioxus apps! Dioxus apps are Rust projects and can also be built with tools like cargo.

## Running the project

Once the project is generated, you can start it with the following command:

````sh
cd hot_dog
dx serve
````

![Serve](/assets/06_docs/dx_serve_06.mp4)

This will start the cargo build and launch a web server to serve your app. If you visit the "serve" address (in this case, `http://127.0.0.1:8080`), then you'll receive a loading screen in your browser:

![loading](/assets/06_docs/hotdog_loading.png)

Once the app is loaded, you should be greeted with the default Dioxus template app:

![app](/assets/06_docs/default_dioxus_app.png)

Congrats! You have your very first Dioxus app.

## Structure of the app

Open the app in your editor and take a look at its structure:

````sh
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Dioxus.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ assets
â”‚Â Â  â”œâ”€â”€ favicon.ico
â”‚Â Â  â”œâ”€â”€ header.svg
â”‚Â Â  â””â”€â”€ main.css
â””â”€â”€ src
    â””â”€â”€ main.rs
````

All Rust apps are comprised of a root `Cargo.toml` with a `main.rs` file located in the `src` folder. Our CLI `dx` pre-filled these files with the `dioxus` dependency and some starter code for us to get building quickly.

Assets in Dioxus can be placed anywhere in the project, but we suggest leaving them in the `assets` folder.

### The Cargo.toml

The `Cargo.toml` outlines the dependencies to our app and specifies compiler settings. All Rust apps are *compiled*: we execute the Rust tool `cargo` which aggregates our `.rs` files together and generates a final binary executable (like a `.exe`) that runs our app.

All Dioxus apps will include `dioxus` as a dependency:

````toml
[dependencies]
dioxus = { version = "0.7.0" }
````

The prebuilt Dioxus templates initialize different cargo features for your app. `dx` will use these to decide which cargo features to enable when you specify the `--web`, or `--desktop` flags. For example, if you use `dx serve --desktop` to build your app for desktop, `dx` will call `cargo build --no-default-features --features desktop`.

````toml
[features]
default = ["web"]
web = ["dioxus/web"]
desktop = ["dioxus/desktop"]
mobile = ["dioxus/mobile"]
````

### Dioxus.toml

The `Dioxus.toml` file contains Dioxus-specific configuration for bundling and deploying your app. We won't need to configure the `Dioxus.toml` for our app just yet.

### Assets Folder

To include assets in your Dioxus app, you'll want to use the `asset!()` macro that we'll cover later in the [Styling and Assets](assets.md) chapter. You can include assets from anywhere within your app's file tree, but we recommend using the pregenerated `assets` folder.

### tailwind.css

Dioxus has built-in support for TailwindCSS! When serving and building your app, `dx` automatically runs the TailwindCSS CLI if it detects a `tailwind.css` at the root of your app. The default output for the tailwind compiler is in the assets folder.

### main.rs

Finally, the `main.rs`. The `main.rs` file is the entrypoint of our app, containing the `fn main` function. All Rust executables start their life at `main`.

The `main` of our HotDog app looks like this:

````rs@guide_new_app.rs
use dioxus::prelude::*;

fn main() {
    dioxus::launch(App);
}
````

The `launch` function calls the platform-specific `launch` function depending on which feature (web/desktop/mobile) is enabled on `dioxus`. `launch` accepts a root component, typically called `App`.

We'll cover components more in-depth in the [next chapter](component.md).

## Resetting to Basics

The bare-bones template provides basic starter code for our app. However, we want to start *truly* from scratch, so we'll wipe away the `Hero` component and empty the `App` component to its basics:

````rs@guide_new_app.rs
use dioxus::prelude::*;

fn main() {
    dioxus::launch(App);
}

#[component]
fn App() -> Element {
    rsx! { "HotDog!" }
}
````
# Your First Component

Now that we've initialized our *HotDog* app, we can start building out its components.

## What is a component?

In Dioxus, apps are comprised of individual functions called *Components* that take in some *Properties* and render an *Element*:

````rs@guide_component.rs
fn DogApp(props: DogAppProps) -> Element {
    todo!()
}
````

## Component Properties

All components take an object that outlines which parameters the component can accept. All `Props` structs in Dioxus need to derive the `Properties` trait which requires both `Clone` and `PartialEq`:

````rs@guide_component.rs
#[derive(Props, PartialEq, Clone)]
struct DogAppProps {
    breed: String,
}
````

Dioxus provides the `#[component]` macro for simplifying how components are defined. This macro converts the parameters of the annotated function into a hidden accompanying struct.

````rs@guide_component.rs
#[component]
fn DogApp(breed: String) -> Element {
    todo!()
}
````

When building apps, you'll frequently use the `#[component]` macro. When building libraries, we generally suggest deriving Props instead.

## Properties are Immutable

If you're familiar with JavaScript, then you might also be familiar with libraries like [React](http://react.dev). Dioxus is *very* similar to React: if you know React then you will feel comfortable with Dioxus.

Just like React, Dioxus components are rendered by calling the function component. On every render, Dioxus makes a `.clone()` of the component's props. This ensures you can't accidentally modify your props which can lead to hard-to-track issues with state management.

````rs@guide_component.rs
#[component]
fn DogApp(breed: String) -> Element {
    tracing::info!("Rendered with breed: {breed}");

    todo!()
}
````

Dioxus provides types that make `.clone()` cheaper to call, so don't worry about performance gotchas here.

## Component Functions are Called Multiple Times

Just like React, Dioxus will call your component function multiple times throughout its lifecycle. This is called *re-rendering*. In Dioxus, re-renders are extremely cheap (much cheaper than React!). In most cases you shouldn't worry about re-rendering too frequently.

When Dioxus re-renders your component, it compares the `Element` from the last render with the `Element` from the current render.

For example, when the `breed` property changes on the DogApp component, Dioxus will call the DogApp function a second time and compare the previous Element against the new Element.

````rs@guide_component.rs
#[component]
fn DogApp(breed: String) -> Element {
    rsx! {
        "Breed: {breed}"
    }
}
````

![Diffing](/assets/06_docs/diffing_diagram.png)

Dioxus will re-render your component in only two circumstances:

* When the `Props` change as determined by `PartialEq`
* When a function like `signal.set()` or `signal.write()` calls `Scope.needs_update()`

Unlike React, all Dioxus components are *memoized by default* meaning Dioxus will always compare `Props` before deciding to re-render your component. As an additional optimization, Dioxus only compares dynamic parts of your RSX. Elements that don't contain dynamic data won't be checked for changes.

## Composing Components

In Dioxus, *Components* are composed together to create *Apps*. Each component will hold onto its own state and handle its own updates. This makes it easy to abstract your app into different parts and even share pieces of your app as libraries for others to use.

To compose components together, we'll use the `rsx! {}` macro to define the structure of our app.

````rs@guide_component.rs
#[component]
fn App() -> Element {
    rsx! {
        Header {}
        DogApp { breed: "corgi" }
        Footer {}
    }
}
````

We'll cover `rsx! {}` in more depth in the [next chapter](rsx.md).
# Describing the UI

Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* what we want the UI to look like using RSX.

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App() -> Element {
    rsx! {
        div { "Hello, world!" }
    }
}
````

Here, we use the `rsx!` macro to *declare* that we want a `div` element, containing the text `"Hello, world!"`. Dioxus takes the RSX and constructs a user interface from it.

## Editing RSX with Hot-Reloading

When using `dx serve`, your app's RSX is automatically hot-reloaded whenever you edit and save the file. You can edit RSX structure, add new elements, and style your markup without a full rebuild.

Whenever you edit *Rust* code, then `dx` will automatically force a "full rebuild" of your app.

As of Dioxus 0.7, you can run `dx serve --hotpatch` to enable hot-reloading of Rust code at runtime.

![Dog App Hotreloading](/assets/06_docs/dog_app_hotreload.mp4)

For an in-depth guide in what can and can't be hot-reloaded, check the [hot-reload guide](../essentials/ui/hotreload.md).

## RSX is just HTML

Dioxus provides the `rsx! {}` macro for assembling `Element`s in your app. The `rsx! {}` macro primarily speaks HTML: the web, desktop, and mobile Dioxus first-party renderers all use HTML and CSS as the layout and styling technologies.

This means you can reuse your knowledge of the web and build your app using `div`, `span`, `img`, `style`, `button`, and more.

The RSX syntax is a "strict" form of Rust that uses Rust's `Struct` syntax for assembling elements:

````rs@guide_rsx.rs
rsx! {
    div {
        class: "bg-red-100"
    }
}
````

Elements in RSX differ slightly from Rust struct syntax: they can also contain child structs placed immediately after the final attribute.

````rs@guide_rsx.rs
rsx! {
    div { class: "bg-red-100",
        button {
            onclick: move |_| info!("Clicked"),
            "Click me!"
        }
    }
}
````

Additionally, all quoted strings in RSX imply `format!()` automatically, so you can define a variable outside your markup and use it in your strings without an explicit format call:

````rs@guide_rsx.rs
rsx! {
    div { "Breed: {breed}" }
}
````

Any expression that can be rendered to a String can be included directly in RSX. RSX also accepts `Option<Element>` and iterators of Elements:

````rs@guide_rsx.rs
rsx! {
    // Anything that's `Display`
    {"Something"}

    // Optionals
    {show_title.then(|| rsx! { "title!" } )}

    // And iterators
    ul {
        {(0..5).map(|i| rsx! { li { "{i}" } })}
    }
}
````

Dioxus provides two items of syntax sugar for these common cases: `for` loops and `if` chains. These blocks return the contained RSX directly.

````rs@guide_rsx.rs
rsx! {
    if show_title {
        "title!"
    }

    ul {
        for item in 0..5 {
            li { "{item}" }
        }
    }
}
````

For lists, Dioxus uses the `key` attribute to ensure it's comparing the right elements between renders. If you forget to add a `key` attribute to your list item, you might run into performance and state management issues. Usually you can find a unique key to differentiate your list items:

````rs@guide_rsx.rs
rsx! {
    for user in users {
        div {
            key: "{user.id}",
            "{user.name}"
        }
    }
}
````

## Adding UI to our *HotDog* App

Let's add a basic UI to our app. We'll add a header, a body image for the dog photo, and some basic buttons.

````rs@guide_rsx.rs
#[component]
fn App() -> Element {
    rsx! {
        div { id: "title",
            h1 { "HotDog! ðŸŒ­" }
        }
        div { id: "dogview",
            img { src: "https://images.dog.ceo/breeds/pitbull/dog-3981540_1280.jpg" }
        }
        div { id: "buttons",
            button { id: "skip", "skip" }
            button { id: "save", "save!" }
        }
    }
}
````

Our app is coming together!

![Unstyled Dog App](/assets/06_docs/unstyled_dog_app.png)

Unfortunately, it's not very beautiful yet. Let's move on to [styling our app](assets.md).
# Styling and Assets

## Dioxus uses CSS for Styling

As mentioned earlier, Dioxus apps use HTML and CSS as the core markup and styling technology. Instead of re-inventing the wheel like Flutter and React-Native, we designed Dioxus to use HTML and CSS.

CSS is by-far the most popular styling system and is extremely capable. For example, here's a screenshot of [ebou](https://github.com/terhechte/Ebou), a very beautiful Mastodon client built with Dioxus.

![Ebou](/assets/06_docs/ebou-following.png)

## Adding the CSS File with asset!()

The bare-bones template already includes a base `main.css` in the `assets` folder.

````sh
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ assets
â”‚Â Â  â””â”€â”€ main.css
â””â”€â”€ src
    â””â”€â”€ main.rs
````

To include the CSS in our app, we can use the `asset!()` macro. This macro ensures the asset will be included in the final app bundle.

````rs@guide_assets.rs
static CSS: Asset = asset!("/assets/main.css");
````

We also need to load the asset into our app using the `document::Stylesheet` component. This component is equivalent to the `<link>` HTML element but also ensures the CSS will be pre-loaded during server-side-rendering.

````rs@guide_assets.rs
fn App() -> Element {
    rsx! {
        document::Stylesheet { href: CSS }
    }
}
````

Unlike Rust's `include_str!()` macro, the `asset!()` macro does not actually include the *contents* of the asset in our final executable. Instead, it generates a unique path so that the asset can be loaded at runtime. This is ideal for web apps where assets are loaded in parallel through different HTTP requests.

 > 
 > ðŸ“£ The `asset!()` macro generates a unique name that won't exactly match the input name. This helps prevents name collisions and improves caching.

## Hot-Reloading

All assets in Dioxus participate in hot-reloading. Try editing your app's `main.css` and watch changes propagate in real time.

![CSS Hot-reloading](/assets/06_docs/dog-asset-hotreload.mp4)

## Including Images

In Dioxus, you can include images in two ways:

* Dynamically with a URL
* Statically with the `asset!()` macro.

When including assets with a URL, simply fill the `src` attribute of `img {}`. Note that when the app is offline, URL-based images won't download.

````rs@guide_assets.rs
rsx! {
    // ...
    div {
        img { src: "https://images.dog.ceo/breeds/pitbull/dog-3981540_1280.jpg" }
    }
}
````

For static images, you can use the same `asset!()` macro that we used to include the app's CSS.

````rs@guide_assets.rs
static ICON: Asset = asset!("/assets/icon.png");

rsx! {
    img { src: ICON }
}
````

## Optimizations

By default, the `asset!()` macro will lightly optimize CSS, JavaScript, JSON, and images. The name of the asset will also be modified to include a content hash.

````rs@guide_assets.rs
// would output main-j1238nask123.css
asset!("/assets/main.css").to_string();
````

You can optimize assets even further, with an optional `Options` struct. For example, `dx` can automatically convert `.png` images to a more optimized `.avif` format:

````rs@guide_assets.rs
// outputs icon-j1238jd2.avif
asset!("/assets/icon.png", AssetOptions::image().with_avif());
````

For many apps, asset optimization is the most effective way of improving load times. As developers, we frequently overlook the size of images and accidentally make our sites load slower.

Check out the [assets guide](../essentials/ui/assets.md) for a more in-depth explanation of how the Dioxus asset system works.

## The Final CSS

We can use the asset hot-reload system of `dx` and our knowledge of CSS to create a beautiful app:

![Styled Dog App](/assets/06_docs/dog_app_styled.png)

The final CSS is here for reference:

````css
/* App-wide styling */
html, body {
    background-color: #0e0e0e;
    color: white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    height: 100%;
    width: 100%;
    overflow: hidden;
    margin: 0;
}

#main {
    display: flex;
    flex-direction: column;
    height: 100%;
    justify-content: space-between;
}

#dogview {
    max-height: 80vh;
    flex-grow: 1;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

#dogview img {
    display: block;
    max-width: 50%;
    max-height: 50%;
    transform: scale(1.8);
    border-radius: 5px;
    border: 1px solid rgb(233, 233, 233);
    box-shadow: 0px 0px 5px 1px rgb(216, 216, 216, 0.5);
}

#title {
    text-align: center;
    padding-top: 10px;
    border-bottom: 1px solid #a8a8a8;
    display: flex;
    flex-direction: row;
    justify-content: space-evenly;
    align-items: center;
}

#title a {
    text-decoration: none;
    color: white;
}

a#heart {
    background-color: white;
    color: red;
    padding: 5px;
    border-radius: 5px;
}

#title span {
    width: 20px;
}

#title h1 {
    margin: 0.25em;
    font-style: italic;
}

#buttons {
    display: flex;
    flex-direction: row;
    justify-content: center;
    gap: 20px;
    /* padding-top: 20px; */
    padding-bottom: 20px;
}

#skip { background-color: gray }
#save { background-color: green; }

#skip, #save {
    padding: 5px 30px 5px 30px;
    border-radius: 3px;
    font-size: 2rem;
    font-weight: bold;
    color: rgb(230, 230, 230)
}

#navbar {
    border: 1px solid rgb(233, 233, 233);
    border-width: 1px 0px 0px 0px;
    display: flex;
    flex-direction: row;
    justify-content: space-evenly;
    padding: 20px;
    gap: 20px;
}

#navbar a {
    background-color: #a8a8a8;
    border-radius: 5px;
    border: 1px solid black;
    text-decoration: none;
    color: black;
    padding: 10px 30px 10px 30px;
}

#favorites {
    flex-grow: 1;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    padding: 10px;
}

#favorites-container {
    overflow-y: auto;
    overflow-x: hidden;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    padding: 10px;
}

.favorite-dog {
    max-height: 180px;
    max-width: 60%;
    position: relative;
}

.favorite-dog img {
    max-height: 150px;
    border-radius: 5px;
    margin: 5px;
}

.favorite-dog:hover button {
    display: block;
}

.favorite-dog button {
    display: none;
    position: absolute;
    bottom: 10px;
    left: 10px;
    z-index: 10;
}
````
# Interactivity

Now that our *HotDog* app is scaffolded and styled, we can finally add some interactive elements.

## Encapsulating State

Before we get too far, let's split our app into two parts: the `Title` and the `DogView`. This will help us organize our app and keep the `DogView` state separated from `Title` state.

````rs@guide_state.rs
#[component]
fn App() -> Element {
    rsx! {
        document::Stylesheet { href: CSS }
        Title {}
        DogView {}
    }
}

#[component]
fn Title() -> Element {
    rsx! {
        div { id: "title",
            h1 { "HotDog! ðŸŒ­" }
        }
    }
}

#[component]
fn DogView() -> Element {
    rsx! {
        div { id: "dogview",
            img { src: "https://images.dog.ceo/breeds/pitbull/dog-3981540_1280.jpg" }
        }
        div { id: "buttons",
            button { id: "skip", "skip" }
            button { id: "save", "save!" }
        }
    }
}
````

## Event Handlers

In the `DogView` component, we want to attach an action to the click of the buttons. For example: skipping or saving the current dog photo. We can use an [EventHandler](../essentials/basics/event_handlers.md) to listen for the `click` events.

Event handlers are similar to regular attributes, but their name usually starts with `on` - and they accept closures as values. The closure will be called whenever its corresponding event is triggered. The listener receives information about the event from the [Event](https://docs.rs/dioxus/latest/dioxus/prelude/struct.Event.html) object.

We'll add some closures inline and then pass them to the `onclick` attribute for both the *skip* and *save* buttons:

````rs@guide_state.rs
#[component]
fn DogView() -> Element {
    let skip = move |evt| {};
    let save = move |evt| {};

    rsx! {
        // ...
        div { id: "buttons",
            button { onclick: skip, id: "skip",  "skip" }
            button { onclick: save, id: "save",  "save!" }
        }
    }
}
````

 > 
 > You can read more about Event Handlers in the [Event Handler reference](../essentials/basics/event_handlers.md)

## State with use_hook

So far, our components have no internal state. For our `DogView`, we want to change the currently displayed dog photo whenever the user clicks *skip* or *save*.

To store state in components, Dioxus provides the `use_hook` function. This makes it possible for bare Rust functions to store and load state without the use of an extra struct.

When called in a component, the `use_hook` function will return a `.clone()` of the originally stored value:

````rs@guide_state.rs
#[component]
fn DogView() -> Element {
    let img_src = use_hook(|| "https://images.dog.ceo/breeds/pitbull/dog-3981540_1280.jpg");

    // ..

    rsx! {
        div { id: "dogview",
            img { src: "{img_src}" }
        }
        // ..
    }
}
````

Dioxus hooks are very similar to React's hooks and need to follow some [simple rules](../essentials/basics/hooks.md) to function properly.

## Signals and use_signal

While `use_hook` makes it possible to store any value that implements `Clone`, you'll frequently want a more capable form of state management. Built-in to Dioxus are *signals*.

`Signal` is a wrapper type around an ordinary Rust value that tracks reads and writes, bringing your app to life. You can wrap any Rust value in a signal. Signals can be created manually with `Signal::new()` but we strongly recommend using the `use_signal` hook instead.

 > 
 > ðŸ“£ Manually creating Signals requires remembering to call `.manually_drop()` on the signal whereas `use_signal` cleans the Signal up for you automatically.

Whenever a signal's value changes, its containing "reactive scope" will be "marked dirty" and re-run. By default, Dioxus components are reactive scopes, and thus, will re-render whenever a signal value changes.

![Basic Interactivity](/assets/06_docs/hotdog-interactivity.mp4)

Signals are core to Dioxus and take time to master. We recommend reading the [basics](../essentials/basics/index.md) guide in depth before diving into your first large app.

## Global State with Context

While hooks are good for state *local* to components, occasionally you'll want to manage state for your *entire* app. Dioxus provides two mechanisms: `Context` and `GlobalSignal`.

The `Context` API makes it possible for parent components to share state with child components without explicitly declaring an additional property field. This is used by larger apps and libraries to share state across the app without modifying component signatures.

To "provide" context, simply call `use_context_provider()` with a struct that implements `Clone`. To read the context in a child, call `use_context()`.

````rs@guide_state.rs
// Create a new wrapper type
#[derive(Clone)]
struct TitleState(String);

fn App() -> Element {
    // Provide that type as a Context
    use_context_provider(|| TitleState("HotDog".to_string()));
    rsx! {
        Title {}
    }
}

fn Title() -> Element {
    // Consume that type as a Context
    let title = use_context::<TitleState>();
    rsx! {
        h1 { "{title.0}" }
    }
}
````

You can combine `use_signal` and `Context` to provide reactive state to your app:

````rs@guide_state.rs
#[derive(Clone, Copy)]
struct MusicPlayer {
    song: Signal<String>,
}

fn use_music_player_provider() {
    let song = use_signal(|| "Drift Away".to_string());
    use_context_provider(|| MusicPlayer { song });
}
````

With `use_context` and `consume_context`, you can easily reach up to modify that state:

````rs@guide_state.rs
#[component]
fn Player() -> Element {
    rsx! {
        button {
            onclick: move |_| consume_context::<MusicPlayer>().song.set("Vienna".to_string()),
            "Shuffle"
        }
    }
}
````

Any components that read the song signal will automatically re-render when the value changes.

## Global Signals

Occasionally you'll want a simple global value. This is where `GlobalSignal` helps. GlobalSignals are a combination of the Context system and Signals that require no additional structs or setup.

Simply declare a GlobalSignal somewhere in your app:

````rs@guide_state.rs
static SONG: GlobalSignal<String> = Signal::global(|| "Drift Away".to_string());
````

And then read and write to it from anywhere:

````rs@guide_state.rs
#[component]
fn Player() -> Element {
    rsx! {
        h3 { "Now playing {SONG}" }
        button {
            onclick: move |_| *SONG.write() = "Vienna".to_string(),
            "Shuffle"
        }
    }
}
````

GlobalSignals are only global to one app - not the entire program. On the server, every app gets its own GlobalSignal. We won't need either GlobalSignal or Context for *HotDog*, but it's useful to know that these are available to you.
# Fetching Data

## Adding Dependencies

Dioxus does not provide any built-in utilities for fetching data. Crates like [dioxus-query](https://github.com/marc2332/dioxus-query) exist, but for this tutorial we'll implement data-fetching from scratch.

First, we need to add two new dependencies to our app: [serde](https://crates.io/crates/serde) and [reqwest](https://crates.io/crates/reqwest).

* Reqwest provides an HTTP client for fetching.
* Serde will let us derive a JSON Deserializer to decode the response.

In a new terminal window, add these crates to your app with `cargo add`.

````bash
cargo add reqwest --features json
cargo add serde --features derive
````

## Defining a Response Type

We'll be using the amazing [dog.ceo/dog-api](https://dog.ceo/dog-api/) to fetch images of dogs for *HotDog*. Fortunately, the API response is quite simple to deserialize. Let's create a new Rust struct that matches the format of the API and derive `Deserialize` for it.

The Dog API docs outline a sample API response:

````json
{
    "message": "https://images.dog.ceo/breeds/leonberg/n02111129_974.jpg",
    "status": "success"
}
````

Our Rust struct needs to match that format, though for now we'll only include the "message" field.

````rs@guide_data_fetching.rs
#[derive(serde::Deserialize)]
struct DogApi {
    message: String,
}
````

## Using `reqwest` and `async`

Dioxus has great support for asynchronous Rust. We can simply convert our `onclick` handler to be `async` and then set the `img_src` after the future has resolved.

![Dog Fetching](/assets/06_docs/fetch-dog.mp4)

The changes to our code are quite simple - just add the `reqwest::get` call and then call `.set()` on `img_src` with the result.

````rs@guide_data_fetching.rs
#[component]
fn DogView() -> Element {
    let mut img_src = use_signal(|| "".to_string());

    let save = move |_| async move {
        let response = reqwest::get("https://dog.ceo/api/breeds/image/random")
            .await
            .unwrap()
            .json::<DogApi>()
            .await
            .unwrap();

        img_src.set(response.message);
    };

    // ..

    rsx! {
        div { id: "dogview",
            img { src: "{img_src}" }
        }
        div { id: "buttons",
            // ..
            button { onclick: save, id: "save", "save!" }
        }
    }
}
````

Dioxus automatically calls `dioxus::spawn` on asynchronous closures. You can also use `dioxus::spawn` to perform async work *without* async closures - just call `dioxus::spawn()` on any async block. Futures spawned with `dioxus::spawn` automatically run on the current async executor and are dropped automatically.

````rs@guide_data_fetching.rs
rsx! {
    button {
        onclick: move |_| {
            spawn(async move {
                // do some async work...
            });
        }
    }
}
````

The futures passed to `dioxus::spawn` can not borrow data from outside the async block. Data that is `Copy` *can* be captured by async blocks, but all other data must be *moved*, usually by calling `.clone()`.

## Data Fetching with `use_resource`

Eventually, using bare `async` calls might lead to race conditions and weird state bugs. For example, if the user clicks the *fetch* button too quickly, then two requests will be made in parallel. If the request is updating data somewhere else, the wrong request might finish early and causes a race condition.

In Dioxus, *Resources* are pieces of state whose value is dependent on the completion of some asynchronous work. The `use_resource` hook provides a `Resource` object with helpful methods to start, stop, pause, and modify the asynchronous state.

Let's change our component to use a resource instead:

````rs@guide_data_fetching.rs
#[component]
fn DogView() -> Element {
    let mut img_src = use_resource(|| async move {
        reqwest::get("https://dog.ceo/api/breeds/image/random")
            .await
            .unwrap()
            .json::<DogApi>()
            .await
            .unwrap()
            .message
    });

    rsx! {
        div { id: "dogview",
            img { src: img_src.cloned().unwrap_or_default() }
        }
        div { id: "buttons",
            button { onclick: move |_| img_src.restart(), id: "skip", "skip" }
            button { onclick: move |_| img_src.restart(), id: "save", "save!" }
        }
    }
}
````

Resources are very powerful: they integrate with Suspense, Streaming HTML, reactivity, and more.

The details of the `Resource` API are not terribly important right now, but you'll be using Resources frequently in larger apps, so it's a good idea to [read the docs](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_resource.html).
# Adding a Backend

Dioxus is a *fullstack* framework, enabling you to seamlessly build your frontend alongside your backend.

We provide a number of utilities like *Server Functions*, *Server Futures*, and *Server State* for you to integrate into your apps. In this chapter, we'll cover loading and saving state to our backend with *Server Functions*. For an in-depth guide on fullstack, check out the dedicated [Fullstack Guide](../essentials/fullstack/index.md).

## Enabling Fullstack

Before we can start using server functions, we need to enable the "fullstack" feature on Dioxus in our Cargo.toml.

````toml
[dependencies]
dioxus = { version = "0.7.0", features = ["fullstack"] }
````

We also need to add the "server" feature to our app's features in the Cargo.toml and remove the default web target.

````toml
[features]
default = [] # <----- remove the default web target
web = ["dioxus/web"]
desktop = ["dioxus/desktop"]
mobile = ["dioxus/mobile"]
server = ["dioxus/server"] # <----- add this additional target
````

If you selected *yes* to the "use fullstack?" prompt when creating your app, you will already have this set up!

 > 
 > ðŸ“£ Unfortunately, `dx` doesn't know how to hot-reload this change, so we'll need to restart the dev server.

Now instead of running `dx serve`, you need to run with a manual platform with `dx serve --web`. Give your app a moment to build again and make sure that the "fullstack" feature is enabled in the dashboard.

![Fullstack Enabled](/assets/06_docs/serve_with_fullstack.png)

## Server Functions: an inline RPC system

Dioxus integrates with the [axum](https://crates.io/crates/axum) crate to provide a simple inline communication system for your apps. Server functions makes it easy to build your app's backend with just basic Rust functions. Server Functions are `async` functions annotated with the a procedural macro (like post/get).

A typical server function looks like this:

````rs@guide_backend.rs
#[post("/api/save_dog")]
async fn save_dog(image: String) -> Result<()> {
    Ok(())
}
````

Every server function is an async function that takes some parameters and returns a `Result<()>`. Whenever the client calls the server function, it sends an HTTP request to a corresponding endpoint on the server. The parameters of the server function are serialized as the body of the HTTP request. As a result, each argument must be serializable.

On the client, the server function expands to a `reqwest` call:

````rs@guide_backend.rs
// on the client:
async fn save_dog(image: String) -> Result<()> {
    reqwest::Client::new()
        .post("http://localhost:8080/api/save_dog")
        .json(&image)
        .send()
        .await?;
    Ok(())
}
````

On the server, the server function expands to an [axum](https://github.com/tokio-rs/axum) handler:

````rs@guide_backend.rs
// on the server:
struct SaveDogArgs {
    image: String,
}

async fn save_dog(Json(args): Json<SaveDogArgs>) -> Result<()> {
    Ok(())
}
````

When `dioxus::launch` is called, the server functions are automatically registered for you and set up as an Axum router.

In some cases, the `dioxus::launch` function might be too limiting for your use-case on the server. Dioxus provides an alternative entrypoint for your app on the server with `dioxus::serve`. This lets you return an Axum router while still having hot-reload, logging, and devtools wired up automatically.

````rs@guide_backend.rs
fn main() {
    #[cfg(not(feature = "server"))]
    dioxus::launch(App);

    #[cfg(feature = "server")]
    dioxus::serve(|| async move {
        // Create a new axum router for our Dioxus app
        let router = dioxus::server::router(App);

        // .. customize it however you want ..

        // And then return it
        Ok(router)
    })
}
````

## The Client/Server split

When Dioxus builds your fullstack apps, it actually creates two separate applications: the server and the client. To achieve this, `dx` passes different features to each build.

* The client is built with `--features web`
* The server is built with `--features server`

![Server Client Split](/assets/06_docs/server_split.png)

When embedding server code in our apps, we need to be careful about which code gets compiled. The body of the server function is designed to only be *executed on the server* - not the client. Any code configured by the `"server"` feature will not be present in the final app. Conversely, any code not configured by the `"server"` feature *will* make it into the final app.

````rs@guide_backend.rs
// âŒ this will leak your DB_PASSWORD to your client app!
static DB_PASSWORD: &str = "1234";

#[post("/api/do_thing")]
async fn DoThing() -> Result<()> {
    connect_to_db(DB_PASSWORD).await
    // ...
}
````

Instead, we recommend placing server-only code within modules configured for the `"server"` feature.

````rs@guide_backend.rs
// âœ… code in this module can only be accessed on the server
#[cfg(feature = "server")]
mod server_utils {
    pub static DB_PASSWORD: &str = "1234";
}
````

In addition to the "server" feature, Dioxus expects a client side rendering feature like "web" or "desktop". Some libraries like web-sys only work when running in the browser, so make sure to not run specific client code in your server functions or before your `launch`. You can place client only code under a config for a client target feature like "web".

````rs@guide_backend.rs
fn main() {
    // âŒ attempting to use web_sys on the server will panic!
    let window = web_sys::window();

    // ..

    dioxus::launch(App);
}
````

## Managing Dependencies

Some dependencies like [Tokio](https://github.com/tokio-rs/tokio) only compile properly when targeting native platforms. Other dependencies like [jni-sys](https://github.com/jni-rs/jni-sys) only work properly when running on a specific platform. In these cases, you'll want to make sure that these dependencies are only compiled when a particular feature is enabled. To do this, we can use Rust's `optional` [flag on dependencies in our Cargo.toml](https://doc.rust-lang.org/cargo/reference/features.html#optional-dependencies).

````toml
[dependencies]
tokio = { version = "1", optional = true }

[features]
default = []
server = ["dep:tokio"]
````

Eventually, if your project becomes large enough, you might want to pull your server functions out into their own crate to be used across different apps. We'd create a `server` crate in our workspace:

````sh
â”œâ”€â”€ Cargo.toml
â””â”€â”€ crates
 Â Â  â”œâ”€â”€ dashboard
 Â Â  â”œâ”€â”€ marketplace
 Â Â  â””â”€â”€ server
````

And then we'd import the server functions in our app, disabling their `"server"` feature.

````toml
[dependencies]
server = { workspace = true, default-features = false }
````

We provide a longer guide about the details of managing dependencies across the server and the client [here](../essentials/fullstack/project_setup.md).

## Our HotDog Server Function

Revisiting our HotDog app, let's create a new server function that saves our favorite dog to a file called `dogs.txt`. In production, you'd want to use a proper database as covered in [the next chapter](databases.md), but for now we'll use a simple file to test things out.

````rs@guide_backend.rs
// Expose a `save_dog` endpoint on our server that takes an "image" parameter
#[post("/api/save_dog")]
async fn save_dog(image: String) -> Result<()> {
    use std::io::Write;

    // Open the `dogs.txt` file in append-only mode, creating it if it doesn't exist;
    let mut file = std::fs::OpenOptions::new()
        .write(true)
        .append(true)
        .create(true)
        .open("dogs.txt")
        .unwrap();

    // And then write a newline to it with the image url
    file.write_fmt(format_args!("{image}\n"));

    Ok(())
}
````

### Calling the server function

Now, in our client code, we can actually call the server function.

````rs@guide_backend.rs
fn DogView() -> Element {
    let mut img_src = use_resource(snipped!());

    // ...
    rsx! {
        // ...
        div { id: "buttons",
            // ...
            button {
                id: "save",
                onclick: move |_| async move {
                    let current = img_src.cloned().unwrap();
                    img_src.restart();
                    _ = save_dog(current).await;
                },

                "save!"
            }
        }
    }
}
}
````

Wow, our app is really coming together!

![Working Server Functions](/assets/06_docs/dog-save-serverfn.mp4)

Server functions are extremely capable and can even be used during server-side-rendering. Check out the complete [fullstack guide](../essentials/fullstack/index.md) for more information.
# Working with Databases

Our HotDog app is coming together nicely! We implemented a very simple backend that saves the user's favorite dog images to a local "dogs.txt" file.

In practice, you will likely want to store data in a proper database. Modern databases are *much* more powerful than a text file!

If you already have a good understanding of databases, jump ahead to the [section where we integrate Sqlite with HotDog](#adding-database-operations-to-hotdog).

## Choosing a Database

In today's age of app development, there are *many* databases to choose from, each with their own strengths, weaknesses, and tradeoffs to consider. For apps with just a few users, it is fine to select a "simpler" database that's easier to manage. For apps with many users, you might want to consider more advanced databases with additional tooling to meet stricter requirements.

Here is a (incomplete!) list of databases and a short summary of each:

* [PostgreSQL](https://www.postgresql.org): Advanced database known for its powerful plugin system.
* [MySQL](https://www.mysql.com): World's most popular open source database good for all apps.
* [SQLite](https://www.sqlite.org): Simple file-based engine known for its reliability and embeddability.
* [Oracle](https://www.oracle.com/database/): Advanced commercial database known for its enterprise features.
* [Redis](http://redis.io): Simple key-value database known for its great performance.
* [MongoDB](https://www.mongodb.com/): A database ideal for data that doesn't fit into rows and columns.
* [SurrealDB](https://surrealdb.com/): A new "all-in-one" database that combines many models.
* [CockroachDB](https://www.cockroachlabs.com): Distributed SQL database designed for high-availability.
* [and many more](https://dev.to/shreyvijayvargiya/list-of-45-databases-in-the-world-57e8)!

There are many different types of databases, each good at different tasks. These might include:

* **Relational**: traditional row/column/table approach.
* **Document**: storing unstructured or loosely structured blobs of data.
* **Timeseries**: storing and querying lots of data that changes over time.
* **Graph**: querying data based on its connections to other data.
* **Key-value**: storing just key-value pairs - a fast concurrent HashMap.
* **In-memory**: designed for low-latency operations usually used as a cache.
* **Embedded**: a database that is shipped *inside* your app.

For most apps - unless you have specific requirements - we recommend a mainstream relational database like PostgreSQL or MySQL.

 > 
 > ðŸ“£ PostgreSQL is currently a very interesting option: it can be extended to support time-series, vector, graph, search and geo-spatial data with plugins.

In some cases, you might want a database that's specific to *just one app instance* or the *user's machine*. In these cases, you'll want to use an embedded database like [SQLite](https://www.sqlite.org) or [RocksDB](https://rocksdb.org).

## Adding Database operations to HotDog

For *HotDog*, we're going to use Sqlite. *HotDog* is a very simple app and will only ever have one user: you!

To add sqlite functionality to *HotDog*, we'll pull in the `rusqlite` crate. Note that `rusqlite` is only meant to be compiled on the server, so we'll feature gate it behind the `"server"` feature in our Cargo.toml.

````toml
[dependencies]
# ....
rusqlite = { version = "0.32.1", optional = true } # <--- add rusqlite

[features]
# ....
server = ["dioxus/server", "dep:rusqlite"] # <---- add dep:rusqlite
````

To connect to our database, we're going to use the `rusqlite::Connection`. Rusqlite connections are not thread-safe and must exist once-per-thread, so we'll need to wrap it in a thread_local.

When the connection is initialized, we'll run a SQL action to create the "dogs" table with our data.

````rs@guide_databases.rs
// The database is only available to server code
#[cfg(feature = "server")]
thread_local! {
    pub static DB: rusqlite::Connection = {
        // Open the database from the persisted "hotdog.db" file
        let conn = rusqlite::Connection::open("hotdog.db").expect("Failed to open database");

        // Create the "dogs" table if it doesn't already exist
        conn.execute_batch(
            "CREATE TABLE IF NOT EXISTS dogs (
                id INTEGER PRIMARY KEY,
                url TEXT NOT NULL
            );",
        ).unwrap();

        // Return the connection
        conn
    };
}
````

Now, in our `save_dog` server function, we can use SQL to insert the value into the database:

````rs@guide_databases.rs
#[server]
async fn save_dog(image: String) -> Result<()> {
    DB.with(|f| f.execute("INSERT INTO dogs (url) VALUES (?1)", &[&image]))?;
    Ok(())
}
````

Once the app is launched, you should see a "hotdog.db" file in your crate's directory. Let's save a few dog photos and then open the database in a database viewer. If all goes well, you should see the saved dog photos!

![Databaseview](/assets/06_docs/hotdog-db-view.mp4)

## Notes on Databases and Rust

While there are many database providers, Rust support can be limited. Rust is still a new choice for web development. In this section we'll provide our own (biased!) opinions on what libraries we recommend for interacting with databases.

It's also important to note that several libraries exist at a higher level abstraction than raw SQL. These are called an *Object Relationship Mapper (ORM)*. Rust ORM libraries map the SQL language into ordinary Rust functions. We generally recommend just sticking with SQL, but ORMs can make working writing some queries easier.

* [Sqlx](https://github.com/launchbadge/sqlx): A straightforward yet large interface to Postgres, MySql, and Sqlite.
* [SeaORM](https://github.com/SeaQL/sea-orm): An ORM built on top of Sqlx for deriving databases.
* [rusqlite](https://github.com/rusqlite/rusqlite): An intuitive sqlite interface with no special ORM magic.
* [rust-postgres](https://github.com/sfackler/rust-postgres): An interface to Postgres with an API similar to rusqlite.
* [Turbosql](https://github.com/trevyn/turbosql): A *very* terse interface to Sqlite with automatic derives.

We aren't including libraries like [Diesel](http://diesel.rs) in this list since it seems that the Rust ecosystem has evolved towards newer projects with 1st-class async support.

There are many libraries we haven't tested yet, but might be worth checking out:

* [firebase-rs](https://github.com/emreyalvac/firebase-rs): Firebase client crate
* [postgrest-rs](https://github.com/supabase-community/postgrest-rs): Supabase client crate
* [mongo-rust-driver](https://github.com/mongodb/mongo-rust-driver): Official MongoDB client crate

## Choosing a Database Provider

While there are just a handful of databases you might consider for your app, there are many *database providers*, each with their own strengths and weaknesses. We are not sponsored by any of these providers - this is just a list of providers we have seen in use by Rust apps.

You *do not* need to use a database provider. Databases providers provide paid database hosting. It will cost you money to use these providers! Many have a free tier and some support "scale-to-zero" to help you save money on small apps. At any time, you are free to host and manage your own database.

For popular relational databases:

* [GCP](https://cloud.google.com/products/databases): Provides AlloyDB (enterprise postgres), CloudSQL (MySql, Postgres), and more.
* [AWS](https://aws.amazon.com/products/databases/): Provides RDS, Aurora, DynamoDB, and more.
* [PlanetScale](https://planetscale.com): Reliable MySQL-compatible database with sharding designed for scale.
* [Firebase](https://firebase.google.com): Google's comprehensive real-time database designed for rapid app development.
* [Supabase](https://supabase.com): Hosted Postgres known for its great dashboard and tooling.
* [Neon](https://neon.tech): Hosted Postgres that separates compute and storage for scale-to-zero apps.

For Sqlite:

* [LiteFS](https://fly.io/docs/litefs/): A distributed Sqlite sync engine designed to be used with Fly.io
* [Turso](https://turso.tech): A "multi-tenant" sqlite provider that maintains one isolated database per user

The "scale-to-zero" relational solutions:

* [AWS Aurora](https://aws.amazon.com/rds/aurora/)
* [LiteFS](https://fly.io/docs/litefs/)

We don't suggest any particular database provider.

* If you have lots of free cloud credits, consider AWS/GCP/Azure.
* If you want Postgres with a good dashboard, consider Supabase or Neon.
* If you want a simple experience, consider Turso or LiteFS.
# Adding More Routes

So far, our app has only had a single page. Let's change that!

In this chapter, we'll be adding a Navbar, a welcome screen, and a "favorites" page where we can revisit our favorite dogs.

## Organizing our Project

Before we get too far with adding new pages to our app, let's organize our codebase a bit better. For larger projects you might want to break your app into different smaller crates. For HotDog, we'll keep it simple.

 > 
 > The `dx new` Jumpstart and Workspace templates provide great scaffolding for new apps!

We generally recommend splitting your components, models, and backend functionality into different files. For HotDog, we're going to use a simple directory structure:

````sh
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ assets
â”‚   â””â”€â”€ main.css
â””â”€â”€ src
    â”œâ”€â”€ backend.rs
    â”œâ”€â”€ components
    â”‚   â”œâ”€â”€ favorites.rs
    â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”œâ”€â”€ nav.rs
    â”‚   â””â”€â”€ view.rs
    â””â”€â”€ main.rs
````

We'll have a `backend.rs` that contains our server functions and a `components` folder that contains our components. We don't have a `NavBar` or a `Favorites` component yet, but we'll still create the relevant files before adding them. By splitting out our server functions into a `backend.rs` file, we'll make it easier to extract our backend functionality as a shared library for different apps in the future.

Our `components/mod.rs` file will simply import and re-export the components in `view.rs`, `nav.rs`, and `favorites.rs`:

````rust
mod favorites;
mod nav;
mod view;

pub use favorites::*;
pub use nav::*;
pub use view::*;
````

Finally, we need to bring `backend` and `components` into scope in our `main.rs` file:

````rust
mod components;
mod backend;

use crate::components::*;
````

For more information on organizing Rust projects with modules, see the [Modules section](https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html) of the Rust Book.

## Creating a Route

Most Dioxus apps you'll build will have different screens. This could include pages like *Login*, *Settings*, and *Profile*. Our HotDog app will have two screens: a *DogView* page and a *Favorites* page.

Dioxus provides a first-party router that natively integrates with web, desktop, and mobile. For example, on web, whenever you visit the `/favorites` url in your browser, the corresponding *Favorites* page will load. The Dioxus router is very powerful, and most importantly, type-safe. You can rest easy knowing that users will never be sent to an invalid route. To achieve this, we first need to add the "Router" feature to the Cargo.toml file:

````toml
[dependencies]
dioxus = { version = "0.7.0", features = ["fullstack", "router"] } # <----- add "router"
````

Next, the Dioxus router is defined as an enum with the `Routable` derive attribute:

````rs@guide_router.rs
#[derive(Routable, Clone, PartialEq)]
enum Route {
    #[route("/")]
    DogView,
}
````

With the Dioxus router, every route is an enum variant with a `#[route]` attribute that specifies the route's URL. Whenever the router renders our route, the component of the same name will be rendered.

````rs@guide_router.rs
use dioxus::prelude::*;

#[derive(Routable, Clone, PartialEq)]
enum Route {
    #[route("/")]
    DogView, // <---- a DogView component must be in scope
}

fn DogView() -> Element {
    todo!()
}
````

## Rendering the Route

Now that we have our app's `Route` defined, we need to render it. Let's change our `app` component to render the `Route {}` component instead of the `DogView`.

````rs@guide_router.rs
fn app() -> Element {
    rsx! {
        document::Stylesheet { href: asset!("/assets/main.css") }

        // ðŸ“£ delete Title and DogView and replace it with the Router component.
        Router::<Route> {}
    }
}
````

When the `Router {}` component renders, it will parse the document's current URL into a `Route` variant. If the url doesn't parse properly, the router will render nothing unless you add a "catch-all" route:

````rs@guide_router.rs
#[derive(Routable, Clone, PartialEq)]
enum Route {
    // ...
    // We can collect the segments of the URL into a Vec<String>
    #[route("/:..segments")]
    PageNotFound { segments: Vec<String> },
}
````

Note here that the `PageNotFound` route takes the "segments" parameter. Dioxus routes are not only type-safe as variants, but also type-safe with URL parameters. For more information on how this works, [check the router guide](../essentials/router/index.md).

At this point, we should see our app, but this time without its Title.

![No Navbar](/assets/06_docs/no_navbar.png)

## Rendering the NavBar with a Layout

We're rendering our DogView component, but unfortunately we no longer see our Title. Let's add that back and turn it into a NavBar!

In our `src/components/nav.rs` file, we'll add back our Title code, but rename it to NavBar and modify it with two new items: the `Link {}` and `Outlet` components.

````rust@guide_router.rs
use crate::Route;
use dioxus::prelude::*;

#[component]
pub fn NavBar() -> Element {
    rsx! {
        div { id: "title",
            Link { to: Route::DogView,
                h1 { "ðŸŒ­ HotDog! " }
            }
        }
        Outlet::<Route> {}
    }
}
````

The `Link {}` component wraps the anchor `<a>` element with a type-safe interface. This means any struct that implements `Routable` - anything that can `.to_string()` - is a valid navigation target.

````rs@guide_router.rs
// Using the Link with Route
Link { to: Route::DogView }

// Or passing in a "/" route directly
Link { to: "/" }
````

The Link component takes many different arguments, making it possible to extend and customize for your use-case.

In `NavBar`, we also added an `Outlet::<Route> {}` component. When the Router component renders, it first looks for any child `Outlet` components. If one is present, it renders the current route *under the outlet*. This lets us wrap the current page in extra elements - in this case, the NavBar. If no Outlet is present, then the current route is simply rendered where the `Router {}` is declared.

To actually add the NavBar component to our app, we need to update our `Route` enum with the `#[layout]` attribute. This forces the router to render the `NavBar` component *first* so it can expose its `Outlet {}`.

````rs@guide_router.rs
#[derive(Routable, PartialEq, Clone)]
enum Route {
    #[layout(NavBar)] // <---- add the #[layout] attribute
    #[route("/")]
    DogView,
}
````

The `layout` attribute instructs the Router to wrap the following enum variants in the given component.

````rust, ignore
Router  {
    NavBar {
        Outlet {
            if route == â€œ/â€ {
                DogView {}
            }
        }
    }
}
````

Visually, this should be straight-forward to understand. Note that the Router and Outlet share the same `Route` generic type.

![RouterLayout](/assets/06_docs/routeroutlet.png)

## Adding a Favorites Route

Now that we understand the fundamentals of routing, let's finally add our *Favorites* page so we can view the dog photos we saved.

We'll start by creating an empty component `src/components/favorites.rs`:

````rs@guide_router.rs
use dioxus::prelude::*;

#[component]
pub fn Favorites() -> Element {
    rsx! { "favorites!" }
}
````

And then let's make sure to add a new variant in our `Route` enum:

````rs@guide_router.rs
#[derive(Routable, PartialEq, Clone)]
enum Route {
    #[layout(NavBar)]
    #[route("/")]
    DogView,

    #[route("/favorites")]
    Favorites, // <------ add this new variant
}
````

To make sure the user can reach this page, let's also add a button in the nav that points to it.

````rust@guide_router.rs
use crate::Route;
use dioxus::prelude::*;

#[component]
pub fn NavBar() -> Element {
    rsx! {
        div { id: "title",
            Link { to: Route::DogView,
                h1 { "ðŸŒ­ HotDog! " }
            }
            Link { to: Route::Favorites, id: "heart", "â™¥ï¸" } // <------- add this Link
        }
        Outlet::<Route> {}
    }
}
````

## Our Favorites Page

Finally, we can build our favorites page. Let's add a new `list_dogs` server function that fetches the 10 most recently saved dog photos:

````rs@guide_router.rs
// Query the database and return the last 10 dogs and their url
#[server]
pub async fn list_dogs() -> Result<Vec<(usize, String)>, ServerFnError> {
    let dogs = DB.with(|f| {
        f.prepare("SELECT id, url FROM dogs ORDER BY id DESC LIMIT 10")
            .unwrap()
            .query_map([], |row| Ok((row.get(0)?, row.get(1)?)))
            .unwrap()
            .map(|r| r.unwrap())
            .collect()
    });

    Ok(dogs)
}
````

Now, we can fill in our component. Resolving the request from the server might take some time, so we'll use the `use_server_future(...)?` to wait for the request to finish before mapping the contents to a list. `use_server_future` is very similar to `use_resource`, but it waits for the future to finish before continuing rendering and integrates with dioxus fullstack to serialize that data from the server to the client.

````rs@guide_router.rs
use dioxus::prelude::*;

#[component]
pub fn Favorites() -> Element {
    // Create a pending resource that resolves to the list of dogs from the backend
    // Wait for the favorites list to resolve with `?`
    let mut favorites = use_server_future(super::backend::list_dogs)?;

    rsx! {
        div { id: "favorites",
            div { id: "favorites-container",
                for (id, url) in favorites().unwrap().unwrap() {
                    // Render a div for each photo using the dog's ID as the list key
                    div {
                        key: "{id}",
                        class: "favorite-dog",
                        img { src: "{url}" }
                    }
                }
            }
        }
    }
}
````

As a stretch goal, try adding a button that lets the user also delete items from the database.

![FullDemo](/assets/06_docs/hotdogfull.mp4)
# Bundling

Congratulations! You built your first fully-functional Dioxus app, completely loaded with Routing, asynchronous data-fetching, Server Functions, and a database! That's incredible for just a few minutes of work.

Let's get your app bundled for multiple platforms and then ready to deploy.

## Testing on iOS

To test iOS, your development environment needs to be setup to build iOS apps. This involves a few steps:

* Make sure you are developing on a device running macOS
* Install XCode
* [Download a recent iOS SDK and Emulator pack](https://developer.apple.com/ios/)
* Install the iOS Rust toolchains (`aarch64-apple-ios aarch64-apple-ios-sim`)

This is a multi-step process and requires creating an Apple Developer account. You shouldn't need to pay any fees until you want to sign your app. Signing your app is required for deploying to the Apple App Store and testing on your iOS device.

Simply run run `dx serve --ios` and your app should load in the iOS Simulator.

![DogApp](/assets/06_docs/dog-app-ios.mp4)

Fantastic - our app works seamlessly with no changes.

## Testing on Android

Setting up your environment for Android development takes time, so make sure to read the [mobile tooling guide](../guides/platforms/mobile.md).

* Install the Android NDK and SDK
* Set JAVA_HOME, ANDROID_HOME, NDK_HOME, and fix PATH issues to use the `emulator` tool
* Install and set up an Android emulator
* Install the Android rustup targets (`aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android`)

Getting your Android install correct might be somewhat tricky, so try enabling "verbose" mode on dx to debug any issues.

If all goes well, we can simply serve and our app should show up in our Android simulator.

````
dx serve --android
````

![Android DogApp](/assets/06_docs/android-dogapp.mp4)

## Testing on Desktop

HotDog also works on macOS, Windows, and Linux! We can use `dx serve --desktop` to serve our app as a desktop app.

![HotDogDesktop](/assets/06_docs/hotdog-desktop.png)

## Bundling for the web

After we're done making changes to our server and client apps, we can build bundles that are ready to distribute.

We're going to follow the same pattern as `dx serve` but with `dx bundle`. To start, let's build the web version of our app.

````sh
dx bundle --web
````

We should receive a series of INFO traces from the CLI as it builds, and then finally a path to the `public` folder it generates. Let's `cd` into its public directory and then check out its parent directory (cd ..) (the "web" folder).

````sh
â¯ tree -L 3 --gitignore
.
â”œâ”€â”€ public
â”‚   â”œâ”€â”€ assets
â”‚   â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”‚   â”œâ”€â”€ header.svg
â”‚   â”‚   â”œâ”€â”€ main-14aa55e73f669f3e.css
â”‚   â”‚   â”œâ”€â”€ main.css
â”‚   â”‚   â””â”€â”€ screenshot.png
â”‚   â”œâ”€â”€ index.html
â”‚   â””â”€â”€ wasm
â”‚       â”œâ”€â”€ hot_dog.js
â”‚       â”œâ”€â”€ hot_dog.js.br
â”‚       â”œâ”€â”€ hot_dog_bg.wasm
â”‚       â”œâ”€â”€ hot_dog_bg.wasm.br
â”‚       â””â”€â”€ snippets
â””â”€â”€ server
````

`dx` built a `public` folder containing our assets, index.html, and various JavaScript snippets. Alongside our public folder is a `server` binary. When we deploy our web assets, we'll also want to deploy the server since it provides our server functions.

We can manually run the server simply by executing it. If you're using a default `dioxus::launch` setup, then the server will read the `IP` and `PORT` environment variables to serve.

 > 
 > ðŸ“£ If you intend to serve from within a container (e.g., Docker), then you need to override the default `127.0.0.1` address with `IP=0.0.0.0` to listen for external connections.

![Serving the server](/assets/06_docs/serving_server.png)

## Bundling for Desktop and Mobile

To bundle desktop and mobile apps for deployment, we'll again use `dx bundle`. As of today, `dx bundle` only builds desktop apps for the native platform and architecture. Unfortunately, you can't build macOS apps from Windows, Linux apps from Mac, etc. We recommend using a Continuous Integration Matrix (like [Github Actions](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow)) to perform a "cross-build" of your app in multiple different containers.

When bundling installable apps, there are many distribution formats to choose from. We can specify these formats using the `--package-types` flag on `dx bundle`. Dioxus supports packaging a broad number of package types:

* macOS: `.app`, `.dmg`
* Linux: `.appimage`, `.rpm`, `.deb`
* Windows: `.msi`, `.exe`
* iOS: `.app`
* Android: `.apk`

You can specify package types like so:

````sh
dx bundle --desktop \
    --package-types "macos" \
    --package-types "dmg"
````

Note that not all package-types are compatible with each platform - eg. only `.exe` can be built when specifying `--desktop`.

We should see the outputs in our terminal:

````sh
18.252s  INFO Bundled app successfully!
18.252s  INFO App produced 2 outputs:
18.252s  INFO app - [./target/dx/hot_dog/bundle/macos/bundle/macos/HotDog.app]
18.252s  INFO dmg - [./target/dx/hot_dog/bundle/macos/bundle/dmg/HotDog_0.1.0_aarch64.dmg]
````

Generally, you can distribute desktop apps without needing an app store. However, some platforms like macOS might require you to sign and notarize your application to be considered "safe" for your users to open.

When distributing mobile apps, you *are required* to sign and notarize your apps. Currently, Dioxus doesn't provide built-in utilities for this, so you'll need to figure out signing by reading 3rd-party documentation.

Tauri provides documentation on the signing process:

* [macOS](https://tauri.app/distribute/sign/macos/)
* [iOS](https://tauri.app/distribute/sign/iOS/)
* [Android](https://tauri.app/distribute/sign/android/)
* [Windows](https://tauri.app/distribute/sign/Windows/)
* [Linux](https://tauri.app/distribute/sign/Linux/)

## Customizing your Bundle

Before you ship your app, you might want to configure how your app icon looks, what entitlements it has, and other details. Our `dx bundle` tool can help you configure your bundles in a variety of ways.

To configure our bundle, we'll use our `Dioxus.toml` and modify the bundle section.

````toml
[application]
name = "docsite"

[bundle]
identifier = "com.dioxuslabs"
publisher = "DioxusLabs"
icon = ["assets/icon.png"]
````

For a full list of options, see the [reference page on the `bundle` section](../guides/deploy/config.md).

## Automating dx bundle with JSON mode

Also added in Dioxus 0.6 is a JSON output mode for `dx`. This makes it possible to parse the output of the CLI using tools like [jq](https://jqlang.github.io/jq/) which provide stdin/stdout support for JSON parsing.

This mode is not particular friendly to humans, but does contain more information than the standard trace output.

````sh
{"timestamp":"   9.927s","level":"INFO","message":"Bundled app successfully!","target":"dx::cli::bundle"}
{"timestamp":"   9.927s","level":"INFO","message":"App produced 2 outputs:","target":"dx::cli::bundle"}
{"timestamp":"   9.927s","level":"DEBUG","message":"Bundling produced bundles: [\n    Bundle {\n        package_type: MacOsBundle,\n        bundle_paths: [\n            \"/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/macos/HotDog.app\",\n        ],\n    },\n    Bundle {\n        package_type: Dmg,\n        bundle_paths: [\n            \"/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/dmg/HotDog_0.1.0_aarch64.dmg\",\n        ],\n    },\n]","target":"dx::cli::bundle"}
{"timestamp":"   9.927s","level":"INFO","message":"app - [/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/macos/HotDog.app]","target":"dx::cli::bundle"}
{"timestamp":"   9.927s","level":"INFO","message":"dmg - [/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/dmg/HotDog_0.1.0_aarch64.dmg]","target":"dx::cli::bundle"}
{"timestamp":"   9.927s","level":"DEBUG","json":"{\"BundleOutput\":{\"bundles\":[\"/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/macos/HotDog.app\",\"/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/dmg/HotDog_0.1.0_aarch64.dmg\"]}}","target":"dx"}
````

JSON mode works with all `dx` commands. However, it is most useful with `dx build` and `dx bundle`. The CLI always guarantees that the last emitted line is the result of the command. To collect the list of bundles from the `dx bundle` command, we can use `tail -1` and simple jq.

````sh
dx bundle --desktop \
    --json-output \
    --verbose \
    | tail -1 \
    | jq -r '.json | fromjson | .BundleOutput.bundles []'
````

This returns the list of bundles:

````
./target/dx/hot_dog/bundle/macos/bundle/macos/HotDog.app
./target/dx/hot_dog/bundle/macos/bundle/dmg/HotDog_0.1.0_aarch64.dmg
````
# Deploying

We're *finally* ready to deploy our bundled apps into the world. Congrats on making it this far!

This step is optional for the tutorial but worth covering to understand the process. Feel free to skip ahead to [next steps](next_steps.md) if you're not interested in deploying.

## Dioxus Deploy

As mentioned in the [introduction](../index.md#whos-funding-dioxus), Dioxus is an independent project with aspirations to fund itself through a paid deploy platform. Hopefully, one day, enough people ship apps with [Dioxus Deploy](https://dioxuslabs.com/deploy) to fund development on Dioxus itself!

Currently, Dioxus does not provide its own deploy platform. If you want to sign-up for the beta and help us design the ideal "end-to-end app-development experience," please [join the waitlist!](https://forms.gle/zeBZmrjSkajqg7hUA)

![Deploy](/assets/06_docs/deploy_screenshot.png)

## Deploying your Desktop and Mobile apps

Generally, deploying a desktop app is as simple as distributing the bundle directly. Simply upload your app bundles to a host like GitHub or S3. With a download link, your users can easily download and install your apps.

 > 
 > ðŸ“£ When shipping fullstack apps to production, you'll want to make sure to set your backend API URL properly as [covered later](#fullstack-desktop-and-mobile).

If you'd like to distribute your app through app stores, you'll need to follow some additional steps.

* [iOS](https://developer.apple.com/ios/submit/): Directly publish to the Apple App Store
* [macOS](https://developer.apple.com/macos/submit/): Directly publish to the Apple App Store
* [Android](https://developer.android.com/studio/publish): Directly publish to the Google Play Store

Tauri provides some [helpful guides](https://tauri.app/distribute/) for deploying Tauri apps which, while not Dioxus apps, need to follow many of the same steps for deploying to app stores.

Making native app distribution easier is a top priority for Dioxus Deploy!

## Deploy Requirements

Dioxus web apps are structured as a Client bundle and a Server executable. Generally, any deploy provider that exposes a simple container will be sufficient for a Dioxus fullstack web application.

Some providers like [Cloudflare Workers](http://workers.cloudflare.com) and [Fermyon Spin](https://www.fermyon.com/spin) provide WASM-based containers for apps. WASM runtimes are typically cheaper to operate and can horizontally scale better than a traditional virtual-machine based container. When deploying on WASM runtimes, you will need to create a WASM build of your server manually.

Running the webserver is as simple as executing `./server`. Make sure to set the IP and PORT environment variables correctly:

![Serving a Server](/assets/06_docs/serving_server.png)

## Choosing a deploy provider

There are *many* deploy providers! We're not going to get too deep into the pros/cons of any particular provider. Generally, providers are good at one of a few categories: price, performance, UI/UX, advanced features, and enterprise requirements.

Depending on your app, you might have strict requirements like SOC2 or HIPAA compliance. Make sure to do your own research for your own use-case.

* [AWS](http://aws.amazon.com): Full-featured cloud provider powered by Amazon.
* [GCP](https://cloud.google.com): Full-featured cloud provider powered by Google.
* [Azure](http://azure.microsoft.com): Full-featured cloud provider powered by Microsoft.
* [Fly.io](http://fly.io): Simple scale-to-zero micro-vm-based cloud with integrated wireguard.
* [Vercel](https://vercel.com): Developer-focused cloud built on AWS cloud functions popular with JavaScript frameworks.
* [Render](http://render.com): A "Modern Heroku" focused on developer experience and simplicity.
* [Digital Ocean](https://www.digitalocean.com): A cloud built around virtual machines, databases, and storage.

For *HotDog* we're going to deploy on [Fly.io](http://fly.io). We like [Fly.io](http://fly.io) for a number of reasons. Most importantly, Fly is built on Amazon's [Firecracker](https://firecracker-microvm.github.io) project which is entirely written in Rust!

Fly is also quite simple to get started - just log in with either your GitHub account or Google account.

## Building a Dockerfile

Some deploy providers have prebuilt solutions for various runtimes. For example, some have dedicated NodeJS and Python runtimes with strict requirements.

With Rust apps, there generally isn't a prebuilt "pack" to target. In these cases, we need to write a simple Dockerfile which compiles and starts our apps.

Our Dockerfile will have three phases. The first phase downloads and caches dependencies so incremental builds stay fast:

````dockerfile
FROM rust:1 AS chef
RUN cargo install cargo-chef
WORKDIR /app

FROM chef AS planner
COPY . .
RUN cargo chef prepare --recipe-path recipe.json
````

In the second phase, we use cargo chef to load cached dependencies and perform the build:

````dockerfile
FROM chef AS builder
COPY --from=planner /app/recipe.json recipe.json
RUN cargo chef cook --release --recipe-path recipe.json
COPY . .

# Install `dx`
RUN curl -L --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash
RUN cargo binstall dioxus-cli --root /.cargo -y --force
ENV PATH="/.cargo/bin:$PATH"

# Create the final bundle folder. Bundle with release build profile to enable optimizations.
RUN dx bundle --web --release
````

Finally, we copy the built "web" folder to the "slim" runtime that serves our app.

````dockerfile
FROM chef AS runtime
COPY --from=builder /app/target/dx/hot_dog/release/web/ /usr/local/app

# set our port and make sure to listen for all connections
ENV PORT=8080
ENV IP=0.0.0.0

# expose the port 8080
EXPOSE 8080

WORKDIR /usr/local/app
ENTRYPOINT [ "/usr/local/app/server" ]
````

It's also a smart idea to set up a `.dockerignore` file:

````
**/target
**/dist
LICENSES
LICENSE
temp
README.md
````

## Deploying to Fly

To get started with Fly, we need to go through the [Sign Up flow](https://fly.io/app/sign-up) and enter our details. This shouldn't take too long.

We'll add the dockerfile from above along with the dockerignore. We'll want to [install `flyctl`](https://fly.io/docs/flyctl/install/) which also installs the `fly` CLI.

Let's call [`fly launch`](https://fly.io/docs/flyctl/launch/) which will automatically initialize our `fly.toml`.

![Fly Launch](/assets/06_docs/fly_launch.png)

`fly launch` will spin up a build machine for us and build our app. In a minute or two, our app should be fully built and deployed.

If we ever want to re-deploy our code, we can run `fly deploy`.

![Running fly deploy](/assets/06_docs/fly_deploy.mp4)

We can also add a volume to our app to persist our Sqlite database by adding a `[mounts]` section to our Fly.toml:

````toml
[mounts]
  source = "hotdogdb"
  destination = "/usr/local/app/hotdogdb"
````

Once the build is complete, Fly will assign our app a URL that we can customize later. With any luck, our app should be live!

![Live App](/assets/06_docs/fly-deployed.png)

## Continuous Deployment

Fly also supports [continuous deployment](https://fly.io/docs/app-guides/continuous-deployment-with-github-actions/). Whenever we push to our GitHub repository, we can execute `fly deploy` automatically. This can serve as a foundation for staging environments and automatic releases.

Our app just needs a `.github/workflows/fly-deploy.yml`.

````yml
name: Fly Deploy
on:
  push:
    branches:
      - main
jobs:
  deploy:
    name: Deploy app
    runs-on: ubuntu-latest
    concurrency: deploy-group
    steps:
      - uses: actions/checkout@v4
      - uses: superfly/flyctl-actions/setup-flyctl@master
      - run: flyctl deploy --remote-only
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
````

## Fullstack Desktop and Mobile

Now that our backend is live, we can wire up the API to our native apps. By default, Dioxus doesn't know where to find your API, so you'll need to specify the URL manually by calling `server_fn::client::set_server_url`.

````rs@guide_deploy.rs
fn main() {
    #[cfg(not(feature = "server"))]
    server_fn::client::set_server_url("https://hot-dog.fly.dev");

    dioxus::launch(App);
}
````

Note that as our app changes, the "true" endpoint of our server functions might change. The `#[server]` macro generates an API endpoint with the form of `/api/fetch_dogs-jkhj12` where the trailing data is a unique hash. As we update our server functions, the hash will change.

To make server functions maintain a stable endpoint, we can manually name them with the `endpoint = "xyz"` attribute.

````rs@guide_deploy.rs
#[server(endpoint = "list_dogs")]
pub async fn list_dogs() -> Result<Vec<(usize, String)>, ServerFnError> {
    todo!()
}

#[server(endpoint = "remove_dog")]
pub async fn remove_dog(id: usize) -> Result<(), ServerFnError> {
    todo!()
}

#[server(endpoint = "save_dog")]
pub async fn save_dog(image: String) -> Result<(), ServerFnError> {
    todo!()
}
````

Let's re-deploy our web app with `fly deploy`. This deploy should complete faster thanks to `cargo chef` caching our build.

Now, with `dx serve --desktop`, we should be able to interact with the same backend across web and desktop.

Amazing! Our startup is coming along nicely.

![Full Cross Build](/assets/06_docs/full-crossplatform.png)

## Next Steps

Our app isn't done yet, but this guide has become pretty long!

There's so much extra to do:

* Adding users, login, and auth.
* Protecting our site from DDOS with tools Cloudflare.
* Adding more features
* Marketing and sharing with friends!
# Wrapping Up

Congrats on making it through our *HotDog* tutorial!

Hopefully this isn't the end of our journey, but rather, a bold new beginning.

## Up Next

We strongly recommend moving on to the [Essential Topics](../essentials/index.md) to become familiar with the important details of Dioxus.

The essentials section will guide you through key concepts in Dioxus:

* [Building UIs with RSX](../essentials/ui/index.md) will teach you how to define html inside your Dioxus app with rsx.

* [Managing State](../essentials/basics/index.md) guides you through how state works in Dioxus. It will teach you how to create state with `use_signal`, derive state with `use_memo`, and integrate state with asynchronous tasks with `use_resource`. Along the way, you will learn about how you can use reactivity to declaratively describe your UI.

* [Advanced Reactivity](../essentials/advanced/index.md) teaches you deeper concepts about Dioxus like building custom hooks, optimizing your app, and breaking out of the Dioxus framework.

## Ideas for New Features

Challenge yourself by adding new features to *HotDog*.

* Add animations to your app with CSS or [dioxus-motion](https://github.com/wheregmis/dioxus-motion).
* Style your app with a library like [TailwindCSS](http://tailwindcss.com).
* Add inputs to allow users to upload their own dog photos.
* Make it social! Add login, user accounts, and a feed.
* Remix HotDog for something entirely new.

## FAQ

You might be curious how particular features work in Dioxus. Let's try to address a few popular question:

### Is Dioxus Fast?

Dioxus is really fast. Dioxus is built around an *extremely* performant VirtualDom. While a VirtualDom might sound like ["pure overhead"](https://svelte.dev/blog/virtual-dom-is-pure-overhead), Dioxus leverages compile-time optimizations that make it faster than nearly all UI frameworks.

On the web, Dioxus [is on par with frameworks like Solid and Svelte](https://krausest.github.io/js-framework-benchmark/2023/table_chrome_120.0.6099.62.html) which leverage new reactivity models or custom compilers.

### Is Rust too hard?

Rust is a notoriously difficult language to learn, but it's extremely powerful. Dioxus has been designed to use the "easy" parts of Rust. For example, Dioxus primarily uses single-threaded code and avoids complicated generic interfaces.

All-in-all, the productivity you gain by building once and deploying everywhere usually makes up for the steeper learning curve. Plus, as Dioxus matures, interfaces become easier to use and the ecosystem improves.

### Does Dioxus support "xyz"?

* TailwindCSS: Yes, but it requires an additional step, see the [docs for more info](../guides/utilities/tailwind.md).
* Native Widgets: Yes, but you might need to write this code yourself. The Rust ecosystem is young.
* Shadcn-ui: Not yet, a radix-ui port to Dioxus is underway but we're not done yet.
* Actix/Rocket: Yes, kind-of. In Dioxus, Server-Functions are built on axum, but you can use server-side-rendering with any framework.
* Static-site-generation: Yes! The docs are currently under construction, so stay tuned. ðŸ—ï¸
* Animations: Yes, you can use CSS animations, [dioxus-motion](https://github.com/wheregmis/dioxus-motion), or integrate with the system animation APIs.
* Accessibility: Yes. Use semantic HTML and aria-tags for good screen-reader support.
* WGPU: Yes, kinda. You can overlay Dioxus on a WGPU scene or experiment with Dioxus-Native which renders with WGPU.
* AI: Yes, you can interface with providers like [OpenAI](https://crates.io/crates/openai-api-rs) or even [build your own provider](https://github.com/DioxusLabs/dioxus-ai).

If you have an FAQ not covered here, suggest an edit!

### Why RSX instead of HTML?

If you've seen React's JSX or the `html!{}` Rust macro, you might be curious as to why Dioxus chose to use its own syntax instead of a syntax that looks more similar to HTML.

A few reasons:

* RSX gets token coloring and code-folding without additional tooling
* RSX is faster to type since curly braces are auto-closed
* Not all RSX is HTML - Dioxus can be used in non-HTML contexts
* HTML is not valid Rust - not all HTML can be used in html!{}

We want the out-of-the-box experience for Dioxus to be great without setting up any custom tooling.

The Dioxus [VSCode Extension](http://marketplace.visualstudio.com/items?itemName=DioxusLabs.dioxus) can convert HTML to RSX as well as the CLI with `dx translate`.

### Should I use Dioxus or Tauri or Leptos or Iced or...?

There's a budding ecosystem of Rust projects for building apps and websites! We have a good comparison in our [Readme.md](https://github.com/DioxusLabs/dioxus#dioxus-vs-other-frameworks)

Dioxus is an "all-in-one" solution for building apps with Rust. We try to be helpful every step of the way: getting started, iterating, testing, bundling, and deploying.

* **Tauri**: You can use Dioxus with Tauri, but we focus primarily on the standalone Dioxus experience. Tauri is a good choice if you want to use a JavaScript frontend or need full-featured access to the Webview DOM.
* **Leptos**: Dioxus and Leptos are both good choices for fullstack web development with differences in syntax and reactivity models. Dioxus is architected to support desktop and mobile "1st-class" whereas Leptos is primarily a web framework.
* **Iced:** Iced is GUI framework that renders using its own render engine, making it highly customizable. Iced is a good choice for apps that need access to lower-level rendering through WGPU. Dioxus will be releasing its own WGPU renderer in early 2025, so stay tuned!

Dioxus is quite a large project and has been a bit slower to mature than other projects with larger development teams or smaller scopes. With 0.6, Dioxus is more mature but still has some ground to cover.
# Core Concepts

Dioxus is a Rust framework for building cross-platform apps with a single codebase. Every app leverages a user interface (UI) to display content and allow the user to take action. The UI is built from small units like buttons, text, and images and then organized into components that encapsulate functionality. Dioxus apps are built by combining components into a larger interactive tree.

![Widget Tree](/assets/07/widget-tree.png)

With Dioxus, you simply declare what you want your app to look like, and the lightweight Dioxus runtime ensures your widgets render properly across web, desktop, and mobile.

## A high-level overview

Dioxus builds upon decades of UI research. Constructing interactive, beautiful, and efficient user interfaces can be challenging. We designed Dioxus to address the complexity of frontend development with a simple mental model:

1. User Interfaces are constructed *declaratively* to describe the layout and style of widgets
1. The state of the application is stored in small, composable, functions called "hooks"
1. Modifications to state are performed as a response to user interaction which result in a "re-render"

Manually creating and modifying UI elements can be tedious and error prone. The declarative UI approach Dioxus uses requires some training to master, but ultimately it results in efficient and easy-to-maintain frontend code. We recommend thoroughly walking through the Core Concepts to understand how the Dioxus UI and reactivity model works.

## Table of Contents

In the Core Concepts, we cover three important topics:

* [Building User Interfaces](./ui/index.md): Constructing a UI by assembling text, elements, and components.
* [The Basics](./basics/index.md): Making our UI interactive, responsive, and efficient.
* [Advanced](./advanced/index.md): Reactivity in depth, the Component Life-cycle, breaking out of dioxus, and more.

We also cover two additional topics which aren't necessarily essential to UI development, but are still essential to building great apps:

* [App Routing](./router/index.md): Adding multiple screens and routes for the users to visit.
* [Fullstack](./fullstack/index.md): Integrating backend services, server-side-rendering, remote-procedure-calls, and more.
# Building User Interfaces

Welcome to Dioxus! This first chapter teaches you how to build beautiful user interfaces in Rust and Dioxus.

Dioxus allows you to write user interfaces in HTML and CSS. On the web, your UI is native and accessible, and on desktop and mobile, your widgets are rendered either in a webview or natively with hybrid native components.

HTML and CSS allow you to build very beautiful, rich, interactive experiences. The world's top companies all use HTML and CSS for their sites and applications. Even this doc site is built in HTML and CSS:

![Animated Homepage](/assets/07/anim-homepage.mp4)

## What Dioxus Gives You

Dioxus gives you all the tools you need to leverage HTML, CSS, and Rust in their full glory.

This includes:

* Hot-reloading for Rust code, UI, styles, and assets
* Cross-platform renderers for web, desktop, and mobile
* Reactivity system for managing and updating state
* Growing SDK of cross-platform APIs
* Backend integration for building fullstack web apps
* Tools for bundling and deploying to production

You can do anything in Dioxus that you could do with HTML and CSS alone.

## What HTML and CSS Gives You

HTML and CSS are powerful technologies (albet, with lots of baggage) that make it easy to build beautiful UIs that work across billions of devices.

HTML and CSS give you lots of tools:

* Multiple layout algorithms (flexbox, grid, table, float, block, etc)
* Stylesheets for app-level theming
* Per-element styling
* Great accessibility and screen-reader support
* Inline SVG support
* CSS Animations
* Multimedia elements like `img`, `video`, and `audio`
* and more!

HTML and CSS might not be the *absolute best* tools for UI work, but they are widely used, work nearly everywhere, and are extremely well documented.

## What Rust Gives You

Why write a UI framework in Rust? Why build an app with Rust? Rust was originally intended for systems programming, though we at Dioxus are working on making it suitable for high-level programming like app dev.

Rust has a rather steep learning curve, but the benefits are tremendous:

* Great, standardized tooling (cargo, rustc)
* Huge ecosystem and great package manager (crates.io, Cargo.toml)
* Runs everywhere - Mac, Windows, Linux, iOS, Android, Web, etc
* Strong type system that prevents many logic bugs at compile time
* Great performance, rivaling languages like C / C++
* Reliable, even at massive scale

There are drawbacks too, like slower compile times, steep learning curve, and ergonomic papercuts. Our goal is to improve the "high-level Rust" experience to make it on par with languages like TypeScript, but with the added benefits of Rust.

We've been pushing Rust forward *so much* that we gave a long-form keynote at RustConf 2025 to talk about our work on things like hot-patching and automatic ref-counting.

<iframe style="width: 100%" height="500px" class="centered-overflow" src="https://www.youtube.com/embed/Kl90J5RmPxY" title="High-Level Rust" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

# Introducing RSX

Dioxus apps are comprised of small elements composed into components and then assembled into a tree. To construct our components, we use a combination of Rust code and a simplified dialect of Rust that we call "RSX".

RSX is designed to look and feel like a blend between HTML and SwiftUI:

````rust
rsx! {
    h1 { "Welcome to Dioxus!" }
    h3 { "Brought to you by {author}" }
    p { class: "main-content", {article.content} }
}
````

Currently, RSX is the primary syntax that developers use to build Dioxus apps. There are other options, but RSX has the best developer tooling like instant hot-reloading, code-folding, and syntax highlighting.

## The `rsx!` macro

If you're familiar with libraries like React or Vue, you will likely be familiar with the JSX markup language. JSX is an alternative form of JavaScript that lets developers blend JavaScript code and XML in one file. These libraries rely on compiler plugins to transform the syntax into pure JavaScript code which then renders HTML.

With Rust, we achieve a similar experience through the use of [procedural macros](https://doc.rust-lang.org/reference/procedural-macros.html) (proc macros). Proc macros are tiny compiler plugins that transform Rust tokens into Rust code. You can recognize that a function is a proc macro thanks to the `!` modifier. For example, the `rsx!` macro transforms RSX syntax into Rust code:

````rust
// This macro...
rsx! {
    div { "hello {world}!" }
}

// Expands to this template:
static TEMPLATE: Template = Template {
    nodes: [
        ElementNode {
            tag: div,
            children: [
                TextNode {
                    contents: DynamicText(0)
                }
            ]
        }
    ]
}
TEMPLATE.render([
    format!("hello {world}")
])
````

RSX does a *lot* of heavy lifting for us, significantly cutting down on the verbosity of declaring UI. It also constructs our UIs in the *most* efficient representation, making rendering extremely fast.

## Dioxus renders HTML and CSS

We want to ensure Dioxus is easy to learn and extremely portable. Instead of inventing a new styling, layout, and markup system, we instead opted to simply rely on HTML and CSS everywhere. For the web, this is handy - websites are already built with HTML and CSS. On desktop and mobile, we ship a renderer that converts your HTML and CSS to native widgets automatically.

Our hybrid HTML approach combines the best parts of frameworks like Flutter and React Native. Teams get maximum code-reuse, get to work with a familiar markup language, and AI tools are immediately helpful. Instead of building bespoke native apps for each platform, teams can simply write their components once and render them everywhere.

Our rendering engine [Blitz](https://github.com/dioxuslabs/blitz) is open source and is often indistinguishable from browser-grade engines:

![Blitz vs Safari](/assets/07/blitz-vs-safari.png)

If you are not familiar with HTML, this guide will help you get started with the basics. For more detail, the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTML) are a great resource. Many tools provide visual designers or AI assistance for constructing UI from HTML elements.

## A Variety of Renderers

Dioxus is extremely modular. Because the RSX representation is generic, you can even swap out the elements, choosing to render UI that is *not* made of HTML and CSS. While the Dioxus team intends to only maintain HTML/CSS-based renderers, third-party renderers exist that unlock extended functionality.

For example, the [Freya](https://freyaui.dev) project renders the Dioxus tree using Google's Skia renderer. Skia has a CPU-only architecture, works across a wide range of devices, and enables deeper control over UI effects:

![Example Freya App](/assets/07/freya-todo.webm)

The Dioxus team maintains three first-party renderers:

* Dioxus-Web: A web-compatible engine that renders directly to HTML DOM Nodes
* Dioxus-Webview: A desktop and mobile engine that renders to the system webview
* Dioxus-Native: A desktop and mobile engine that renders to native elements

The Web and Webview renderers are the most mature engines while Dioxus-Native is still undergoing substantial improvements.
# Elements and Text

User interfaces are assembled by combining text and UI elements together in a useful and visually appealing tree. An example of some text and elements with RSX may look like:

````rs@building_uis_with_rsx.rs
let author = "Dioxus Labs";
let content = "Build cool things âœŒï¸";

rsx! {
    h1 { "Welcome to Dioxus!" }
    h3 { "Brought to you by {author}" }
    p { class: "main-content", {content} }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::Basic {}
}
````

## Text Nodes

Any content surrounded by quotes is rendered as a text node in RSX:

````rs@building_uis_with_rsx.rs
rsx! { "Hello world" }
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::Text {}
}
````

Text nodes in Dioxus automatically implement the same rules as Rust's [`format!`](https://doc.rust-lang.org/std/macro.format.html) macro, including [Display](https://doc.rust-lang.org/std/fmt/trait.Display.html) and [Debug](https://doc.rust-lang.org/std/fmt/trait.Debug.html) printing.

````rs@building_uis_with_rsx.rs
let world = "earth";
rsx! { "Hello {world}!" }
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::SimpleFormattedText {}
}
````

Unlike Rust's format macro, `rsx!` lets us embed entire Rust expressions which can be quite handy when working with complex objects or calling functions inline.

````rs@building_uis_with_rsx.rs
let user = use_signal(|| User {
    name: "Dioxus".to_string(),
});
rsx! { "Hello {user.read().name}" }
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::FormattedText {}
}
````

## Elements

The most basic building block of HTML is an element. In RSX, an element is declared with a name and then curly braces. One of the most common elements is the `input` element. The input element creates an interactive input box:

````rs@building_uis_with_rsx.rs
rsx! {
    input {}
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::Input {}
}
````

Elements can take additional parameters called attributes that modify how the element is rendered. Attributes are added inline, similar to adding fields to a struct instantiation:

````rs@building_uis_with_rsx.rs
rsx! {
    input { placeholder: "type something cool!" }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputPlaceholder {}
}
````

There are a huge number of HTML elements available, including, but not limited to:

* Text and Content: `p`, `h1`, `span`, `div`, `a`, `pre`, etc.
* Forms and Input: `form`, `input`, `textarea`, `select`, `button`, etc.
* Media and Content: `img`, `video`, `audio`, `source`, `canvas`, `svg`, `iframe`, etc.
* Tables: `table`, `thead`, `tbody`, `tfoot`, `tr`, `th`, `td`, etc.
* Semantic Elements: `details`, `summary`, `dialog`, `progress`, `meter`, `time`, etc.

Check the [HTML Element reference](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements) for the full list.

## The `Element` type

The `rsx!` macro returns an object with the type of `Element`. These objects can be assigned to variables, cheaply cloned, and stored in state.

````rust
let header: Element = rsx! {
    div {
        h1 { "Dioxus!" }
    }
}
````

We can even create functions that return an `Element`:

````rust
fn create_description(content: &str) -> Element {
    rsx! {
        span { class: "description", "{content}" }
    }
}
````

Under the hood, the `Element` type is actually an alias for `Result<VNode>`. In Rust, a [Result](https://doc.rust-lang.org/std/result/) is an enumerated value that can either be an `Ok(value)` or an `Err(error)`. This means we can match on an Element, or even throw errors while rendering it:

````rust
fn create_description(content: &str) -> Element {
    if content.is_empty() {
        return Err("Missing description".into());
    }

    rsx! {
        span { class: "description", "{content}" }
    }
}
````

Dioxus defines its own error based on the [`anyhow`](https://docs.rs/anyhow/latest/anyhow/) error which then composes with other utilities like Error Boundaries and Server Functions.
# Attributes

While we could build a UI by assembling unstyled elements and text, we typically want to customize their appearance and behavior. This is where we use *element attributes*. Attributes provide extra information to the renderer on how to display the UI.

You can specify attributes by adding the name of the attribute, a colon, and then the value to the body of an element. For example, we might want to style a div with a particular [class](https://www.w3schools.com/html/html_classes.asp) and [ID](https://www.w3schools.com/html/html_id.asp), which we add as attributes:

````rust
rsx! {
    div {
        class: "container",
        id: "root-container"
    }
}
````

We can use an attribute to set the `type` of an input element. The default type is `text` which shows a text input box, but we can set it to `number` to only accept numbers:

````rs@building_uis_with_rsx.rs
rsx! {
    input { type: "number" }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputType {}
}
````

Just like text nodes, attributes can include formatted segments. We can set the value of the input element to a signal to control it:

````rs@building_uis_with_rsx.rs
let mut value = use_signal(|| "Hello world".to_string());
rsx! {
    input { value: "{value}" }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputValue {}
}
````

## Attribute Scope

Every element has two sets of attributes:

* [Global Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes): attributes which can be applied to *every* element
* [Specific Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes): attributes that only apply to one specific element

For example, all elements support the `id` and `class` attributes, but only `video` elements support the `autoplay` attribute. For a full list of attributes, visit the relevant links above.

## IDE Support

RSX provides autocomplete and inline docs support for elements and their attributes. To get autocomplete suggestions, simply start typing in your editor:

![Autocomplete](/assets/07/ide_autocomplete.png)

We've documented every element with documentation pulled from the [Mozilla Developer Docs](https://developer.mozilla.org/en-US/docs/Web). Simply hover over the element with your cursor for more information:

![Element Hover](/assets/07/ide_hover.png)

The same docs apply for attributes as well:

![Element Hover](/assets/07/ide_listener.png)

## Non-Text Attributes

Typically, you'll add attributes to your elements using formatted text. However, attributes can accept a wide range of value types, including:

* `Text`: Formatted text, the `String` type, or anything that implements `Display`.
* `Float`: Floating point numbers, typically on sliders and inputs.
* `Int`: Integer numbers for discrete gradations.
* `Bool`: A boolean value indicating true/false.
* `Listener`: A Rust callback that will be executed when the attribute is triggered.
* `Any`: A type-erased [`Rc<dyn Any>`](https://doc.rust-lang.org/std/any/index.html), typically used by 3rd-party renderers.
* `None`: The attribute will be removed from the element entirely.

Most commonly, you might use the `bool` attribute to set a boolean state:

````rust
rsx! {
    input {
        type: "checkbox",
        checked: true
    }
}
````

Or the `Some`/`None` variant for setting an HTML Boolean Attribute:

````rust
rsx! {
    div { itemscope: Some("scope") }
}
````

Note that Dioxus automatically converts `false` for some attributes to `None` in order to match the behavior of the [HTML Boolean Attribute](https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML).

## Event Listeners

While some attributes influence how an element is rendered, other attributes influence its interactive behavior. These attributes, called Event Listeners, allow you to respond to user input.

In RSX, event handlers always start with `on`. The syntax is the same as normal attributes, but event handlers only accept a closure that responds to the event. We can attach an event listener to the `oninput` event of the input element to listen for changes to the input:

````rs@building_uis_with_rsx.rs
rsx! {
    input {
        oninput: move |event| {
            println!("Input changed to: {}", event.value());
        },
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::OnInputSimple {}
}
````

More information about event listeners including how events bubble and how to prevent default behavior can be found later in the [Event Handlers](../basics/event_handlers.md) of the Reactivity section.

There are a wide range of event listeners available - see the full [HTML list](https://developer.mozilla.org/en-US/docs/Web/Events) for more details.

## Spreading Attributes

Occasionally, the set of attributes you want to pass to an element might either be dynamic or defined elsewhere in your application. In these cases, you can spread attribute lists into elements with the `..` syntax. Typically, lists of attributes will be passed into a component via its Properties, which we cover in a later chapter.

````rust
let attributes = vec![
    Attribute {
        name: "id",
        namespace: None,
        volatile: false,
        value: "cool-button".into_value(),
    }
];

rsx! {
    button { ..attributes, "button" }
}
````

Attributes lists will be merged in the order they appear, so later attributes in the list take precedence over earlier attributes. Attribute spreading becomes very useful when refactoring your UI into a reusable component libraries.

## Special Attributes

Most attributes in RSX are rendered verbatim, but there are a few exceptions. In some cases, RSX deviates from traditional HTML to simplify development or work better with the ecosystem tools.

### Conditional Attributes

You can conditionally set an attribute by setting the attribute value to an unterminated if statement. If the if statement evaluates to true, the attribute will be set:

````rs@building_uis_with_rsx.rs
let number_type = use_signal(|| false);
rsx! {
    input { type: if number_type() { "number" } }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputDisabled {}
}
````

### Style attributes

In addition to the standard `style` attribute, each style can also be passed as a separate attribute. For example, we can set the `color` and `font-size` of an element using the `color` and `font_size` attributes:

````rs@building_uis_with_rsx.rs
rsx! {
    div { style: "width: 20px; height: 20px; background-color: red; margin: 10px;" }
    div {
        width: "20px",
        height: "20px",
        background_color: "red",
        margin: "10px",
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::StyleAttributes {}
}
````

### Class attribute

Most attributes can only be defined once per element, but the `class` attribute can be defined multiple times. Each class will be added to the element's class list. This can be convenient when adding many optional classes to an element in a styling system like TailwindCSS:

````rs@building_uis_with_rsx.rs
rsx! {
    span {
        class: if red { "bg-red-500" },
        class: if blue_border { "border border-blue-500" },
        class: "w-4 h-4 block",
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::ClassAttribute {}
}
````

This feature is especially important when using TailwindCSS since the class compiler does not understand formatted Rust strings when collecting classes. By placing the dynamic class in a sibling attribute, the Tailwind compiler sees *both* class lists at compile time.

### onresize and onvisible

Dioxus provides two custom HTML attributes *not* found in the HTML specification.

* onresize
* onvisible

Dioxus automatically constructs a cross-platform `IntersectionObserver` that emits the respective events for you.

With onresize, you can watch for changes to an element's size and position:

````rust
fn app() -> Element {
    let mut items = use_signal(|| 100);

    rsx! {
        // Adding a value will cause the `div` to be re-rendered with an extra div
        button { onclick: move |_| items += 1, "Add one" }

        div {
            // This will be called when the `div` is resized
            onresize: move |data| {
                info!("resized to {:#?}", data.get_border_box_size().unwrap());
            },

            for x in 0..items() {
                div { "{x}" }
            }
        }
    }
}
````

With `onvisible`, you can handle the cases when an element enters and exits the viewport. This is useful for implementing things like lazy loading, infinite scrolls, and virtual lists:

````rust
fn app() -> Element {
    rsx! {
        div {
            onvisible: move |data| info!("visibility changed"),
            "Hello world!"
        }
    }
}
````

You can add rich scroll-aware animations to your app without needing to write custom JavaScript.

![gif_of_visible_working.mp4](/assets/06assets/onvisible.mp4)

### Custom Attributes

Dioxus has a pre-configured set of attributes that are validated at compile time. If you surround the attribute name in quotes, you can use a custom attribute outside of the pre-defined set:

````rs@building_uis_with_rsx.rs
rsx! {
    div { "style": "width: 20px; height: 20px; background-color: red;" }
}
````

````inject-dioxus
DemoFrame {
	building_uis_with_rsx::CustomAttributes {}
}
````

Note that this works even with event listeners. We occasionally use this to insert small snippets of JavaScript into our apps when writing the corresponding web-sys code might be verbose:

````rust
rsx! {
    button {
        "onclick": "navigator.clipboard.writeText(window.document.title);",
        "Copy to clipboard"
    }
}
````

````inject-dioxus
DemoFrame {
	building_uis_with_rsx::CustomAttributesEvents {}
}
````

### The HTML Escape Hatch

If you're working with pre-rendered assets, output from templates, or output from a JS library, then you might want to pass HTML directly instead of going through Dioxus. In these instances, reach for `dangerous_inner_html`.

`dangerous_inner_html` sets the text content of the element to the provided value. This will overwrite any other attributes or children of the element.

For example, shipping a markdown-to-Dioxus converter might significantly bloat your final application size. Instead, you'll want to pre-render your markdown to HTML and then include the HTML directly in your output. We use this approach for the [Dioxus homepage](https://dioxuslabs.com):

````rs@dangerous_inner_html.rs
// this should come from a trusted source
let contents = "live <b>dangerously</b>";

rsx! {
    div { dangerous_inner_html: "{contents}" }
}
````

````inject-dioxus
DemoFrame {
	dangerous_inner_html::App {}
}
````

 > 
 > Note! This attribute is called "dangerous_inner_html" because it is **dangerous** to pass it data you don't trust. If you're not careful, you can easily expose [cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks to your users.
 > 
 > If you're handling untrusted input, make sure to sanitize your HTML before passing it into `dangerous_inner_html` â€“ or just pass it to a Text Element to escape any HTML tags.
# Conditional Rendering

Our user interfaces have been quite static so far. However, most apps we build with Dioxus usually contain lots of dynamic content. Our UIs will react to changes in buttons, form inputs, sliders, or external data sources like the network. Dioxus apps generally store this dynamic state in Hooks or Context.

In this chapter, we're not going to dive too deep in how we store this state - future chapters cover state in depth.

## Expressions

Just like JSX, RSX allows you to easily compose `Element` objects together using plain Rust code. You can write Rust expressions directly within your RSX. As long as the expression evaluates to an `Element` or anything that implements `IntoDynNode`, you can simply wrap it in curly braces (`{}`):

````rust
let content = "world!";
rsx! {
    h1 {
        "Hello"
        {content}
    }
}
````

For example, we might need to create a string from some complex formatting functions:

````rust
rsx! {
    span {
        {
            format!(
                "The time is: {now}, your timezone is {zone}",
                now = current_time(),
                zone = current_timezone()
            ).to_ascii_uppercase()
        }
    }
}
````

Or, we might want to render some RSX dynamically and assign it to a variable:

````rust
let header = match current_timezone() {
    TimeZone::PST => rsx! {
        h1 { "Welcome home" }
    },
    _ => rsx! {
        h1 { "Bon voyage!" }
    },
}

rsx! {
    div {
        {header}
    }
}
````

Rust's expression system makes evaluation of RSX from `match` statements and `if` blocks quite nice. While in JavaScript you might use a ternary:

````jsx
let screen = authenticated ? renderApp() : renderLogin();

return <div>{screen}</div>;
````

In Dioxus, you'd simply use an if/else statement:

````rust
let screen = if authenticated { render_app() } else { render_login() };
rsx! {
    div {
        {screen}
    }
}
````

Rust's guards can be especially helpful in these scenarios, letting us select match arms with inline `if` statements.

````rust
let header = match current_timezone() {
    TimeZone::PST => rsx! {
        h1 { "Welcome home" }
    },
    _ if app.snoozed() => rsx! {
        h1 { "snoozed..." }
    },
    _ => rsx! {
        h1 { "Bon voyage!" }
    },
}

rsx! {
    div {
        {header}
    }
}
````

## The IntoDynNode Trait

Dioxus uses the [`IntoDynNode`](https://docs.rs/dioxus-core/latest/dioxus_core/trait.IntoDynNode.html) trait to determine if an expression can be used within RSX. The conversion will take a Rust expression and turn it into one of four `DynamicNode` variants:

* Component: Functions that take Properties and render an Element
* Text: The Rust `String` type
* Placeholder: An optimized `None` value
* List: A Vec of Elements

Many things implement this trait. For example, empty expressions are valid:

````rust
rsx! {
    div {
        { /* empty.. */}
    }
}
````

Other Element objects are valid:

````rust
let inner = rsx! { "inner" };
rsx! {
    div {
        {inner}
    }
}
````

All the string types (str, String, Arguments) are valid:

````rust
rsx! {
    div {
        // Strings
        {"abc"}

        // lazy formatting
        {format_args!("lazy fmt -> {}", arg())}
    }
}
````

The Rust `Option` type is valid provided the inner type implements `IntoDynNode`:

````rust
let inner = Some(rsx! { "inner" });
rsx! {
    div {
        {inner}
    }
}
````

And even iterators can become a VNode through the List variant:

````rust
let cards = (0..10).map(|i| rsx! {
    li { "Card: {i}" }
});

rsx! {
    ol {
        {cards}
    }
}
````

Iterators are very interesting since IntoDynNode is implemented for anything that is an iterator. For example, we could build a custom iterator that returns an `Element`.

````rust
let mut count = 0;
let cards = std::iter::from_fn(move || {
    count += 1;
    if count > 6 {
        return None;
    }

    Some(rsx! { "card {count}" })
})

rsx! {
    ol {
        {cards}
    }
}
````

## Inline `If` Statements

When rendering content derived from a boolean condition (eg, "active" or "inactive"), RSX provides some small "syntax sugar" that enables inline `if` statements in RSX.

````rs@building_uis_with_rsx.rs
let logged_in = use_signal(|| false);

rsx! {
    div {
        if logged_in() {
            "You are logged in"
        } else {
            "You are not logged in"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::IfStatement {}
}
````

Note that the body of inline `if` statements *is* RSX, not Rust expressions. This syntax sugar helps keep RSX blocks tidy and idiomatic.

````rust
rsx! {
    div {
        if logged_in() {
            LoggedInScreen {}
        } else {
            LoggedOutScreen {}
        }
    }
}
````

Inline `if` statements deviate from Rust in one way: they still evaluate to an `Element` even without an `else` branch. If RSX doesn't find an `else` branch on your `if` statement, it automatically returns a placeholder element instead.

````rust
rsx! {
    div {
        if logged_out() {
            span { "You should log in!" }
        }
    }
}
````

## More syntax sugar?

Syntax can be very subjective and syntax sugar like inline `if` and `for` blocks can open the door to inconsistent behavior. We don't plan to introduce any further syntax sugar to RSX. Our goal is to maintain similarity to React's JSX while slightly massaging ergonomics for Rust developers.

The RSX syntax was carefully designed to work well with your normal development flow:

* Typing an RSX element involves typing the name, and then a single curly
* RSX does not require additional editor extensions for superb support
* RSX follows Rust tokenization for automatic highlighting and code-folding

Definitely spend some time with RSX to get a feel for it.
# Rendering Lists

## Iterators and inline `for`

In the [Conditional Rendering](./conditional.md) chapter we showed how Rust expressions become Dynamic Nodes in RSX blocks.

Any iterator that returns `Element` or an object that implements `IntoVnode` can be used inside RSX blocks to render lists:

````rust
rsx! {
    // mapping existing iterators
    {(0..10).map(|idx| rsx! { "item {idx}" })}

    // or calling .iter()
    {users.iter().map(|user| rsx!{ User { id: user.id } })}
}
````

Dioxus provides a small amount of syntax sugar to make using iterators a bit nicer. Instead of wrapping your iterator in an expression, you can instead move it to an inline `for` block:

````rust
rsx! {
    for idx in 0..10 {
        "Item {idx}"
    }

    for user in users.iter() {
        User { id: user.id }
    }
}
````

Just like inline `if` blocks, the bodies of `for` loops are RSX - not Rust expressions. If you need to create temporary variables or do some extra computation while iterating, you can use an inline expression:

````rust
rsx! {
    for user in users.iter() {
        {
            let id = user.id();
            rsx! {
                User { id }
            }
        }
    }
}
````

If we're using iterators alongside wrapper types like a `Signal<T>`, we need to call `.iter()` first:

````rs@building_uis_with_rsx.rs
let mut items = use_signal(|| vec!["Hello", "Dioxus"]);

rsx! {
    ul {
        for item in items.iter() {
            li { "{item}" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::ForLoop {}
}
````

## Keys are Required

Each item in your list should have unique value that is stable across rerenders called a key. Keys are used to identify how items move between renders. Without keys, it is easy to accidentally lose or move state when you reorder items in a list. We can add keys to our list items by using the `key` attribute:

````rs@building_uis_with_rsx.rs
let mut items = use_signal(|| vec!["Hello", "Dioxus"]);

rsx! {
    ul {
        for item in items.iter() {
            li { key: "{item}", "{item}" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::KeyedForLoop {}
}
````

You can usually find a suitable key from your state itself. Most data in your UI has some unique identifier that can be used to disambiguate it from other entries in the collection. For example, users typically have a unique ID, time samples have a unique timestamp, and emails have a unique sender address.

````rust
rsx! {
    for user in users {
        div { key: "{user.id}", "{user.name}" }
    }
}
````

Note that some fields might *seem* like a suitable unique ID, but are not. Two users might share the same name, two data points might share a timestamp, or not every entry actually has the required data present. In these cases, we recommend creating a unique ID for each item based on a global "generation" counter. Typically, a database might provide this, but we can also use state to manage this:

````rust
let mut generation = use_signal(|| 0);
let mut items = use_signal(|| vec![]);

let mut add_item = move |name| {
    let id = generation();
    generation.set(id + 1);
    items.write().push(Item { id, name })
};

rsx! {
    for item in items.iter() {
        div { key: "{item.id}", "{item.name}" }
    }
    // ...
}
````

The *worst* key to use is the index of the item in the collection. The index for an item will change as you mutate the list and almost certainly cause either performance issues or loss of state in components.

````rust
// âŒ do not do this!
rsx! {
    for (idx, user) in users.iter().enumerate() {
        div { key: "{idx}", "{user.name}" }
    }
}
````

## The Fragment Component

In some cases, your iterators might return multiple root elements. This doesn't give us a great location to place a key. RSX automatically uses the first element's key as iterator key, if it exists:

````rust
rsx! {
    for item in items.iter() {
        h1 { key: "{item.id}", "{item.name}" }
        p { "content" }
    }
}
````

If there's no easy way to attach a key to the first element, you can use a `Fragment` component to wrap the elements and give that the key instead:

````rust
rsx! {
    for item in items.iter() {
        Fragment {
            key: "{item.id}",
            for child in item.children.iter() {
                div { "{child}" }
            }
        }
    }
}
````

The `Fragment` component is nothing special. It is plainly a component that forwards its children as its body. However, RSX sees it as valid element syntax and is able to assign the key properly.

````rust
#[component]
fn Fragment(children: Element) -> Element {
    children
}
````

## Borrowed State

When rendering lists, you might want to borrow some of data contents into child components. The common Dioxus container, Signal, is not capable of providing references to child components.

````rust
let items = use_signal(|| vec![]);

rsx! {
    for item in items.iter() {
        Card {
            // âŒ not possible to forward a reference to the child.
            content: item.name.as_str()
        }
    }
}
````

While earlier versions of Dioxus did allow forwarding references, we eventually disabled this feature since it relied on some unsound Rust semantics. Instead, we recommend three strategies:

* Use owned data and `clone` if its cheap to do so
* Pass the collection *and* the index to the component
* Use a `Store` to provide a reactive reference to a slice of data within the collection

Stores make it possible to zoom into reactive state efficiently. They are covered in more detail in the [Stores](../basics/collections.md) chapter, but here's a quick preview of how to use them:

````rust
fn app() -> Element {
    let mut vec = use_store(|| vec![]);

    rsx! {
        div {
            // Iterating over a store provides references to reactive items within the store
            // without cloning them.
            for count in vec.iter() {
                Child { count }
            }
        }
    }
}

#[component]
fn Child(count: ReadSignal<i32>) -> Element {
    rsx! { "{count}" }
}
````

For complex apps, we recommend using building a system around global context or using a Store.
# Components and Properties

In Dioxus, components are simple functions that encapsulate your UI's presentation, state, and interactions. As your apps grow in size, consider combining shared functionality into smaller reusable components. Modular components make working in large teams easier, prevent annoying bugs, and enable better code reuse across all platforms.

## Defining Components

In its simplest form, a component is a function that returns an Element. For example, the base `app` component:

````rust
fn app() -> Element {
  rsx! { "hello world!" }
}
````

If you want to use a component from another component, then you must annotate the function with the `#[component]` macro. This macro provides essential metadata to the RSX macro, allowing function arguments to become fields in the component's properties. Your function must meet the following requirements:

* Either start with a capital letter (`MyComponent`) or contain an underscore (`my_component`)
* Take arguments that implement [`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html) and [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html)
* Return an [`Element`](https://docs.rs/dioxus/latest/dioxus/prelude/type.Element.html)

We call the arguments a component takes its **properties**. Properties are used to pass data into the component, similar to how you would pass arguments to a function.

For example, we can define a simple component that takes a `name` property and renders a greeting:

````rs@components.rs
#[component]
pub fn MyComponent(name: String) -> Element {
    rsx! {
        div {
            h3 { "Hello, {name}!" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
	components::MyComponent { name: "world" }
}
````

## Using Components in RSX

Once you have defined a component, you can use it in your RSX markup just like any other element:

````rs@components.rs
rsx! {
    MyComponent { name: "World" }
}
````

````inject-dioxus
DemoFrame {
	components::MyComponentCall {}
}
````

 > 
 > Although components are defined as functions, they should not be called like
 > regular functions. When you use a component in RSX, Dioxus will create
 > a new instance of the component that controls its own state and lifecycle.

## Component Properties

A component's properties is the object passed to the component when it renders. These properties are similar to a function's arguments - this is why the property fields are defined as function arguments in components. In some cases, you might find it useful to extract the component properties to a separate struct. Instead of defining properties inline, we can simply use an argument named "props" and then define the props in an accompanying struct.

````rust
#[derive(PartialEq, Clone, Props)]
struct CardProps {
  title: String,
  content: String
}

#[component]
fn Card(props: CardProps) -> Element {
  rsx! {
      h1 { "{props.title}" }
      span { "{props.content}" }
    }
}
````

When we extract properties into a struct, we need to make sure the struct implements three required traits:

* `PartialEq`: used to identify if a component needs to be rerendered
* `Clone`: on each render, the properties object is cloned
* `Props`: derives the `Properties` trait which Dioxus uses for rendering and building

Each of these bounds has implications for how we structure our component's properties.

### PartialEq

`PartialEq` is used by the Dioxus runtime to determine if a component's properties have changed due to some user action. Because components are called by other components, small changes to properties up the component tree can result in a cascade of work for the Dioxus runtime. The `PartialEq` implementation is used to minimize the amount of work the Dioxus runtime needs to do when reacting to these changes.

For advanced use cases, it can be worth customizing a properties' `PartialEq` implementation for performance. For example, we might want to compare large datasets just by their ID, not their actual contents. In these cases, we'd manually implement the `PartialEq` trait to skip the dataset equality check:

````rust
#[derive(Clone, Props)]
struct DatasetViewer {
  id: Uuid,
  contents: Vec<u8>
}

impl PartialEq for DatasetViewer {
  fn eq(&self, other: &Self) -> bool {
      self.id.eq(&other.id)
  }
}
````

Many Dioxus utilities use comparison-by-pointer instead of comparison-by-contents to improve performance.

### Clone

The `Clone` bound is a particularly interesting requirement for component properties. The Dioxus component tree architecture is designed around an idea called "unidirectional data flow." This is a design pattern that prevents components down the component tree from modifying their input properties. By preventing these accidental mutations, user interfaces generally have fewer bugs. Rust itself generally solves this problem its borrow checker system, but the borrow checker does not work well with asynchronous work which is quite prevalent in app development.

Generally, it's fine to `.clone()` most component properties, but some objects might be too expensive to clone and negatively impact performance. In most cases, you can simply wrap the value in the \[`ReadSignal`\] wrapper type and the object will be automatically wrapped in a smart pointer:

````rust
// previously...
struct CardProps {
  content: String
}

// with ReadSignal:
struct CardProps {
  content: ReadSignal<String>
}
````

Fortunately, there are no code changes required on the calling side:

````rust
rsx! {
  CardProps {
    content: query.content()
  }
}
````

Note that `ReadSignal` is not the only smart pointer available. The Rust smart pointers (Arc, Rc) also make clones cheaper as can a custom `Clone` implementation.

### Props

The `Props` derive macro implements the `Properties` trait for the properties object. This trait and its implementation are an implementation detail in Dioxus and not generally meant to be implemented manually. The `Props` derive is useful because it derives a strongly typed builder for the Properties. We can even use this builder outside RSX:

````rust
let props = CardProps::builder().content("body".to_string()).build();
````

## The `#[component]` macro

Properties can be modified to accept a wider variety of inputs than a normal function argument. We don't cover all of the details here, but you can find information in the [component macro](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html) documentation.

For example, the Dioxus Router `Link` component uses the modifiers extensively:

````rust
/// The properties for a [`Link`].
#[derive(Props, Clone, PartialEq)]
pub struct LinkProps {
    /// The class attribute for the `a` tag.
    pub class: Option<String>,

    /// A class to apply to the generate HTML anchor tag if the `target` route is active.
    pub active_class: Option<String>,

    /// The children to render within the generated HTML anchor tag.
    pub children: Element,

    /// When [`true`], the `target` route will be opened in a new tab.
    ///
    /// This does not change whether the [`Link`] is active or not.
    #[props(default)]
    pub new_tab: bool,

    /// The onclick event handler.
    pub onclick: Option<EventHandler<MouseEvent>>,

    /// Whether the default behavior should be executed if an `onclick` handler is provided.
    ///
    /// 1. When `onclick` is [`None`] (default if not specified), `onclick_only` has no effect.
    /// 2. If `onclick_only` is [`false`] (default if not specified), the provided `onclick` handler
    ///    will be executed after the links regular functionality.
    /// 3. If `onclick_only` is [`true`], only the provided `onclick` handler will be executed.
    #[props(default)]
    pub onclick_only: bool,

    /// The rel attribute for the generated HTML anchor tag.
    ///
    /// For external `a`s, this defaults to `noopener noreferrer`.
    pub rel: Option<String>,

    /// The navigation target. Roughly equivalent to the href attribute of an HTML anchor tag.
    #[props(into)]
    pub to: NavigationTarget,

    #[props(extends = GlobalAttributes)]
    attributes: Vec<Attribute>,
}
````

You can use the `#[props()]` attribute on each field to modify properties your component accepts:

* [`#[props(default)]`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#default-props) - Makes the field optional in the component and uses the default value if it is not set when creating the component.
* [`#[props(!optional)]`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#optional-props) - Makes a field with the type `Option<T>` required.
* [`#[props(into)]`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#converting-props) - Converts a field into the correct type by using the \[`Into`\] trait.
* [`#[props(extends = GlobalAttributes)]`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#extending-elements) - Extends the props with all the attributes from an element or the global element attributes.

Props also act slightly differently when used with:

* [`Option<T>`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#optional-props) - The field is automatically optional with a default value of `None`.
* [`ReadOnlySignal<T>`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#reactive-props) - The props macro will automatically convert `T` into `ReadOnlySignal<T>` when it is passed as a prop.
* [`String`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#formatted-props) - The props macro will accept formatted strings for any prop field with the type `String`.
* [`children: Element`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#children-props) - The props macro will accept child elements if you include the `children` prop.
* `EventHandler<T>` enforces closures

Note that these attributes work both for struct-based property definitions as well as inline definitions:

````rust
#[component]
fn Link(
  /// When [`true`], the `target` route will be opened in a new tab.
  #[props(default)]
  new_tab: bool,

  /// The navigation target. Roughly equivalent to the href attribute of an HTML anchor tag.
  #[props(into)]
  to: NavigationTarget,
) -> Element {
  // ...
}
````

Because documentation comments are parsed by the `#[component]` macro, they become available as inline documentation when calling the component:

![Doc Comment Fields](/assets/07/doc-comment-props.png)

The docs on the component are also available when hovering its use:

![Doc Comment Components](/assets/07/doc-comment-components.png)

## Spreading Props

For more composability, we can create a component's properties manually and then pass them directly using Rust's spread syntax with `..some_props`.

````rust
let props = CardProps::lorem_ipsum();
rsx! {
  Card { ..props }
}
````

This mechanism behaves similar to Rust's struct spreading, allowing you to override various fields of the spread, enabling default and overrides:

````rust
let props = CardProps::lorem_ipsum();
rsx! {
  Card { title: "Chapter 1", ..props }
}
````

## Children

Properties have a special field called "children" that contain a component's child elements. For example, we can build a wrapper component that wraps its children in a red div. This component takes a special argument named "children" which is an Element that is used in RSX expressions.

````rust
#[component]
fn RedDiv(children: Element) {
  rsx! {
    div {
      background_color: "red",
      {children}
    }
  }
}
````

When calling the component, we can simply add nested children like an element:

````rust
rsx! {
  RedDiv {
    h1 { "Lorem Ipsum Dolor" }
    p { "..." }
  }
}
````
# Reconciliation: How Components Render

We've covered extensively how components and their properties are defined, but we haven't yet covered how they actually work. Dioxus components are *not* normal Rust functions. While technically possible to call them like regular Rust functions, components rely on an *active* Dioxus runtime to function properly.

To use components properly, it's important to understand the fundamentals of how state flows, how elements are created, and how state is stored. We are going to outline how state works here, but state can be complex so we've given it its own [chapter](../basics/index.md).

## Components Render

In Dioxus, the term "rendering" refers to the process that Dioxus uses to call your component functions and draw elements to the screen. When you call `dioxus::launch`, Dioxus sets up the app's runtime and then calls the provided initial component to create the initial `Element`. This element declares styles, layouts, children, and event listeners. Dioxus converts your elements into draw calls and converts your event listeners into native event handlers.

![Component Loop](/assets/07/render-calls.png)

Because Dioxus uses a "virtual" tree, the elements in your RSX tree are not actual handles to "real" nodes in the renderer. For example, the Dioxus `Element` type is not a full [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) object. When Dioxus receives your initial Element, it converts your virtual elements into real elements and draw calls using a platform-specific renderer.

## Components Rerender

Components will be rerun when the state they depend on changes. After the initial Element has been drawn with the platform-specific renderer, Dioxus listens for events on your elements. When an event is received, the corresponding event listeners are called, and your code has an opportunity to mutate state. Mutating state is the primary mechanism by which Dioxus knows to run your component functions again and look for changes in the tree.

![Component Loop](/assets/07/render-loop.png)

Dioxus considers state to have been changed in two situations:

* The component's properties change, as determined its `PartialEq` implementation
* Internal [state](../basics/index.md) the component depends on changes (e.g. `signal.write()`) and an "update" is scheduled

````rs@components.rs
// When the name property changes, the component will rerender
#[component]
fn Button(name: String) -> Element {
    let mut count = use_signal(|| 0);
    log!("Component rerendered with name: {name} count: {count}");

    rsx! {
        h3 { "Hello, {name}!" }
        // MyComponent reads the `count` signal, so it will rerender
        // whenever `count` changes.
        "Count: {count}"
        button {
            // When the button is clicked, it increments the count signal
            onclick: move |_| count += 1,
            "Increment"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    components::ButtonDemo {}
}
````

After a component runs again, Dioxus will compare the old `Element` and the new `Element` to look for changes. The Dioxus runtime will identify the least amount of draw calls required to change the old UI to match your desired UI. This comparison process is called "diffing". Dioxus optimizes diffing by only comparing dynamic parts of the RSX, so static elements are not checked for changes (see this [blog post](https://dioxuslabs.com/blog/templates-diffing) for details). This entire loop - Render, Display, Listen, Mutate - is called "reconciliation" and Dioxus has one of the most performant implementations of any UI framework.

## Components are Functions of State

Components are a pure function of your current application state in the form `fn(State) -> Element`. They read state from various sources like props, [hooks](../basics/hooks.md), or [context](../basics/context.md) and return a view of the current UI as an `Element`.

We have already seen how components map the props state into UI, but state can also come from the component itself in the form of hooks. For example, we can use a signal to keep track of a count in our component. The component defines the mapping from the current state of the signal to the UI that should be rendered:

````rs@components.rs
#[component]
pub fn MyStatefulComponent() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        div {
            h3 { "Count: {count}" }
            button { onclick: move |_| count += 1, "Increment" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    components::MyStatefulComponent {}
}
````

When building Dioxus apps, it's important to understand that your UI code is a declaration of what you want your UI to be - it does not contain any logic on how to update the UI to get there. Dioxus itself is responsible for making the UI match your desired input.

## Components are Pure Functions

The body of a component must be pure. Pure functions always return the same output for the same input and do not have side effects. For example, this double function is pure:

````rs@components.rs
fn double(x: i32) -> i32 {
    x * 2
}
````

If you call `double(2)`, it will always return `4`.

However, this function is not pure because it modifies external state:

````rs@components.rs
static GLOBAL_COUNT: AtomicI32 = AtomicI32::new(0);

fn increment_global_count() -> i32 {
    GLOBAL_COUNT.fetch_add(1, Ordering::SeqCst)
}
````

When you call `increment_global_count()` the first time, it will return `0`, but the next time you call it, it will return `1`. This function has side effects because it modifies the global state.

In addition to global variables, context and hooks are also external state in components. Components shouldn't modify state from context or hooks while rendering:

````rs@components.rs
#[component]
fn MyImpureComponent() -> Element {
    let mut count = use_signal(|| 0);

    // âŒ Modifying the count signal from a hook is a side effect.
    // Dioxus may try to rerender the component with the new value,
    // which can lead to unexpected behavior or infinite loops.
    count += 1;

    rsx! {
        div {
            h3 { "Count: {count}" }
        }
    }
}
````

Side effects that modify state should be placed in event handlers or [effects](../advanced/breaking_out.md#synchronizing-dom-updates-with-use_effect) which run after the component has rendered. This ensures that the component's output is stable and predictable.

````rs@components.rs
#[component]
fn MyPureComponent() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        div {
            h3 { "Count: {count}" }
            button {
                // âœ… Event handlers can modify state and have side effects.
                onclick: move |_| count += 1,
                "Increment"
            }
        }
    }
}
````

If you find yourself writing components that *are not* pure, then you are likely misusing or misunderstanding the reactive paradigm. Mutations should be placed either in event handlers as a response to user input, or in long running async tasks as a response to background processing.

## Similar to React

If you're familiar with libraries like ReactJS, then this paradigm is familiar to you. Dioxus borrows many ideas from React and your existing knowledge will be extremely helpful. If anything here is confusing to you, check out the [React docs](https://react.dev/learn) or do some extra research on React's reactivity system.
# Assets

Assets are files that are included in the final build of the application. They can be images, fonts, stylesheets, or any other file that is not a source file. Dioxus includes first class support for assets, and provides a simple way to include them in your application and automatically optimize them for production.

Assets in dioxus are also compatible with libraries! If you are building a library, you can include assets in your library and they will be automatically included in the final build of any application that uses your library.

## Including images

To include an image in your application, you can simply wrap the path to the asset in the `asset!` macro:

````rs@assets.rs
use dioxus::prelude::*;

fn App() -> Element {
    // You can link to assets that are relative to the package root or even link to an asset from a url
    // These assets will automatically be picked up by the dioxus cli, optimized, and bundled with your final applications
    let ferrous = asset!("/assets/static/ferrous_wave.png");

    rsx! {
        img { src: "{ferrous}" }
    }
}
````

The asset macro takes a path to the asset relative to the root of your app. The path is *not* absolute to your machine, making it possible to use the same asset paths across multiple machines.

````rust
// âŒ does not work!
let ferrous = asset!("/Users/dioxus/Downloads/image.png");
````

The asset macro is `const`, meaning we can use it inline or as a static/const item:

````rust
// as a static item
static FERROUS: Asset = asset!("/assets/static/ferrous_wave.png");

// or inline
rsx! {
    img { src: asset!("/assets/static/ferrous_wave.png") }
}
````

## Customizing Image Processing Options

You can also optimize, resize, and preload images using the `asset!` macro. Choosing an optimized file type (like Avif) and a reasonable quality setting can significantly reduce the size of your images which helps your application load faster. For example, you can use the following code to include an optimized image in your application:

````rs@assets.rs
pub const ENUM_ROUTER_IMG: Asset = asset!(
    "/assets/static/enum_router.png",
    // You can pass a second argument to the asset macro to set up options for the asset
    ImageAssetOptions::new()
        // You can set the image size in pixels at compile time to send the smallest possible image to the client
        .with_size(ImageSize::Manual {
            width: 52,
            height: 52
        })
        // You can also convert the image to a web friendly format at compile time. This can make your images significantly smaller
        .with_format(ImageFormat::Avif)
);

fn EnumRouter() -> Element {
    rsx! {
        img { src: "{ENUM_ROUTER_IMG}" }
    }
}
````

## Including stylesheets

You can include stylesheets in your application using the `asset!` macro. Stylesheets will automatically be minified as they are bundled to speed up load times. For example, you can use the following code to include a stylesheet in your application:

````rs@assets.rs
// You can also bundle stylesheets with your application
// Any files that end with .css will be minified and bundled with your application even if you don't explicitly include them in your <head>
const _: Asset = asset!("/assets/tailwind.css");
````

 > 
 > The [tailwind guide](../../guides/utilities/tailwind.md) has more information on how to use tailwind with dioxus.

## SCSS Support

SCSS is also supported through the `asset!` macro. Include it the same way as a regular CSS file.

You can read more about assets and all the options available to optimize your assets in the [manganis documentation](https://docs.rs/manganis/latest/manganis).

## Including arbitrary files

In dioxus desktop, you may want to include a file with data for your application. If you don't set any options for your asset and the file extension is not recognized, the asset will be copied without any changes. For example, you can use the following code to include a binary file in your application:

````rs@assets.rs
// You can also collect arbitrary files. Relative paths are resolved relative to the package root
const PATH_TO_BUNDLED_CARGO_TOML: Asset = asset!("/Cargo.toml");
````

These files will be automatically included in the final build of your application, and you can use them in your application as you would any other file.

## Asset Hashes

The asset macro automatically attaches a hash to the name of the asset after it's bundled. This makes your app's bundled assets unique across time, allowing you to infinitely cache the asset in your webserver or on a [CDN](https://en.wikipedia.org/wiki/Content_delivery_network).

````rust
// prints "/assets/ferrous_wave-dxhx13xj2j.png"
println!("{}", asset!("/assets/static/ferrous_wave.png"))
````

Asset hashes are an extremely powerful feature of the asset system. Hashes integrate with CDNs and can greatly speedup your application's load performance and save you money in infrastructure costs.

However, you occasionally might want to disable them. We can customize the asset processing options with the `AssetOptions` builder:

````rust
let ferrous = asset!("/assets/static/ferrous_wave.png", AssetOptions::builder().with_hash_suffix(false));
````

## Linker-based Asset Bundling

Unlike Rust's `include_bytes!` macro, the `asset!` macro *does not* copy the contents of the asset into your final application binary. Instead, it adds the asset path and options into the final binary's metadata. When you run `dx serve` or `dx build`, we automatically read that metadata and process the asset.

![Asset Bundling](/assets/07/asset-pipeline-full.png)

The metadata for each asset is automatically embedded in the final executable by serializing its path and properties using the [const-serialize](https://crates.io/crates/const-serialize) crate. When DX builds the executable, it then searches the output binary for asset metadata. After the build is complete, DX computes asset hashes and writes them back into the binary.

````rust
#[link_section = "dx-assets"]
static SERIALIZED_ASSET_OPTIONS: &[u8] = r#"{"path": "/assets/main.css","minify":"true","hash":"dxh0000"}"#;
````

This means that assets are not permanently baked into your final executable. The final executable is smaller, loads faster, and asset loading is much more flexible. This is important on platforms like the browser where assets are fetched in parallel over the network.

To dynamically load the asset's contents, you can use the [dioxus-asset-resolver](https://crates.io/crates/dioxus-asset-resolver) crate which properly understands the app's bundle format and loads an asset given its `Display` impl.

````rust
let contents = dioxus_asset_resolver::serve_asset(&asset!("/assets/main.css").to_string());
````

## Assets Must Be Used, Assets in Libraries

Because Dioxus uses the program's linker to save asset metadata, the resulting asset must be used somewhere in your application. If you forget to use the returned Asset, the Rust compiler is free to optimize away the call, and the asset metadata won't end up in the final output:

````rust
let ferrous = asset!("/assets/static/ferrous_wave.png");
rsx! {
    // our ferrous png won't be included since we forgot to use it!
    img { src: "..." }
}
````

This is expected behavior. We designed the asset system to automatically prune unused assets, making it possible for 3rd party libraries to export their own assets as part of their public API. For example, we could write a library that includes multiple stylesheets:

````rust
// crate: cool_dioxus_library
pub static GREEN_STYLES: Asset = asset!("/assets/red.css");
pub static RED_STYLES: Asset = asset!("/assets/green.css");
````

When a user builds an application using our library, they just need to import the stylesheet they want to use:

````rust
fn main() {
    dioxus::launch(|| rsx!{
        link { href: cool_dioxus_library::GREEN_STYLES, rel: "stylesheet" }
    })
}
````

Because the `RED_STYLES` asset is never referenced by the user's application, it won't be bundled in the final output.

However, you might want to include an asset even if you never reference it directly. Rust's [`#[used]`](https://doc.rust-lang.org/reference/abi.html#the-used-attribute) attribute is useful here, annotating to the compiler that asset *is* used, even if we can't prove so at compile time.

````rust
#[used]
static CERTS: Asset = asset!("/assets/keys.cert");
````

## Including Folders

The asset macro also supports importing entire folders of content! The folder itself won't be copied into the final bundle. Instead, you join the name of the files in the folder against the folder's path. For example, you might need to include a folder of 3rd-party JavaScript into your app and don't want to use an `asset!` call for every file in the folder.

````rust
let logging_js_path = format!("{}/logging.js", asset!("/assets/posthog-js"));
````

Note that we need to format the `Asset` returned by the `asset!()` macro here because the actual folder name will receive an asset hash.

## Reading Assets

When you use an asset in an element like the `img` tag, the browser automatically fetches the asset for you. However, sometimes you might want to read the contents of an asset directly in your application code. For example, you might want to read a JSON file and parse it into a data structure.

To read assets at runtime, you can use the [`read_asset_bytes`](https://docs.rs/dioxus-asset-resolver/latest/dioxus_asset_resolver/fn.read_asset_bytes.html) from the [`asset_resolver`](https://docs.rs/dioxus-asset-resolver/latest/dioxus_asset_resolver/) module. This will either fetch the asset from the network (for the web target) or read it from the bundle (for native targets):

````rs@assets.rs
use dioxus::prelude::*;

// Bundle the static JSON asset into the application
static JSON_ASSET: Asset = asset!("assets/data.json");

// Read the bytes of the JSON asset
let bytes = dioxus::asset_resolver::read_asset_bytes(&JSON_ASSET)
    .await
    .unwrap();

// Deserialize the JSON data
let json: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
assert_eq!(json["key"].as_str(), Some("value"));
````

If you are targeting a platform like windows or macos where assets are bundled alongside the executable in the filesystem, you can also get the path to the asset using the `asset_path` function. Keep in mind this will not work in the browser or in android bundles since assets are not stored in the filesystem:

````rs@assets.rs
use dioxus::prelude::*;

// Bundle the static JSON asset into the application
static JSON_ASSET: Asset = asset!("assets/data.json");

// Resolve the path of the asset. This will not work in web or Android bundles
let path = dioxus::asset_resolver::asset_path(&JSON_ASSET).unwrap();

println!("Asset path: {:?}", path);

// Read the bytes of the JSON asset
let bytes = std::fs::read(path).unwrap();

// Deserialize the JSON data
let json: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
assert_eq!(json["key"].as_str(), Some("value"));
````

## The Public folder

If you're deploying your app to the web, then DX will automatically copy any files from your app's `/public` directory into the output `/public` directory.

This can be useful to copy files like `robots.txt` into the output directory since they're not referenced by any code in your app.

````
â”œâ”€â”€ assets
â”œâ”€â”€ src
â””â”€â”€ public
    â””â”€â”€ robots.txt
````

Note that this `/public` directory is *merged* into the output, allowing you to manually insert files into the output `/public/assets` directory.
# Styling your app

Dioxus uses standard HTML and CSS for styling, making it easy to leverage existing CSS frameworks, libraries, and knowledge. This chapter covers the various approaches to styling your Dioxus applications, from inline styles to CSS frameworks like TailwindCSS.

## Dioxus uses CSS for Styling

Unlike many other UI frameworks that introduce their own styling systems, Dioxus embraces the web's native styling approach: **HTML and CSS**. This means you can use all the CSS knowledge, tools, and frameworks you already know and love.

CSS is by-far the most popular styling system and is extremely capable. For example, here's a screenshot of [ebou](https://github.com/terhechte/Ebou), a very beautiful Mastodon client built with Dioxus.

![Ebou](/assets/06_docs/ebou-following.png)

All 1st-party Dioxus renderers leverage CSS, but other renderers like [Freya](http://freyaui.dev) might use their own style system. Dioxus automatically converts your CSS to the appropriate native widget properties when applicable, though in some cases you might need to write platform-specific code to achieve your ideal native look and feel.

## Inline CSS

The simplest way to add styles to your elements is through inline CSS using the [HTML `style` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/style). Simply write your CSS styles in an inline string:

````rust
use dioxus::prelude::*;

fn App() -> Element {
    rsx! {
        div {
            style: "background-color: blue; color: white; padding: 20px; border-radius: 8px;",
            "This is a styled div!"
        }
    }
}
````

For better ergonomics, Dioxus also allows you to set individual CSS properties directly as attributes. CSS property names are referenced via their snake_case variant:

````rust
fn App() -> Element {
    rsx! {
        div {
            background_color: "blue",
            color: "white",
            padding: "20px",
            border_radius: "8px",
            "This is a styled div!"
        }
    }
}
````

Because CSS properties are attributes, you can make them dynamic by using Rust expressions:

````rust
fn App() -> Element {
    let mut is_dark = use_signal(|| false);

    rsx! {
        div {
            background_color: if is_dark() { "black" } else { "white" },
            color: if is_dark() { "white" } else { "black" },
            padding: "20px",
            onclick: move |_| is_dark.toggle(),
            "Click to toggle theme"
        }
    }
}
````

## Stylesheets

For larger applications, it's better to organize your styles in separate CSS files. Dioxus provides excellent support for CSS stylesheets through the `asset!()` macro.

### Including CSS Files

Create a CSS file in your `assets` directory and include it using the `asset!()` macro. Dioxus provides two "document" elements - `document::Link` and `document::Stylesheet`:

````rust
use dioxus::prelude::*;

// Define the CSS asset
static MAIN_CSS: Asset = asset!("/assets/main.css");

fn App() -> Element {
    rsx! {
        // Include the stylesheet in the document head
        document::Stylesheet { href: MAIN_CSS }

        div {
            class: "my-component",
            "Hello, styled world!"
        }
    }
}
````

Note that a regular `<link>` element will work, though it won't be marked as pre-loadable when used with server-side-rendering:

````rust
rsx! {
    link { href: asset!("/assets/main.css") }
}
````

Your `assets/main.css` file might look like:

````css
.my-component {
    background-color: #f0f9ff;
    border: 2px solid #0ea5e9;
    border-radius: 8px;
    padding: 16px;
    font-family: system-ui, sans-serif;
}

.my-component:hover {
    background-color: #e0f2fe;
    transform: translateY(-2px);
    transition: all 0.2s ease;
}
````

### CSS Selectors

To use the style declarations from our stylesheet, we can use [class selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors) and [ID selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors):

````css
.my-component {
    background-color: #f0f9ff;
}
#root-component {
    font-weight: 500;
}
````

````rust
rsx! {
    div {
        id: "root-component",
        class: "my-component"
    }
}
````

CSS provides several selectors that you can leverage in your stylesheets:

* [**Element selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors) (`div`, `p`, `h1`): Target HTML elements by their tag name
* [**Class selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors) (`.my-class`): Target elements with a specific class attribute
* [**ID selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors) (`#my-id`): Target a single element with a specific ID attribute
* [**Attribute selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) (`[type="text"]`): Target elements based on their attributes
* [**Descendant selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator) (`div p`): Target elements that are descendants of another element
* [**Child selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Child_combinator) (`div > p`): Target direct children of an element
* [**Adjacent sibling selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Next-sibling_combinator) (`h1 + p`): Target elements immediately following another
* [**General sibling selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Subsequent-sibling_combinator) (`h1 ~ p`): Target elements that are siblings of another
* [**Pseudo-class selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes) (`:hover`, `:focus`, `:nth-child()`): Target elements in specific states
* [**Pseudo-element selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements) (`::before`, `::after`): Target virtual elements or parts of elements
* [**Universal selector**](https://developer.mozilla.org/en-US/docs/Web/CSS/Universal_selectors) (`*`): Target all elements
* [**Grouping selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Selector_list) (`h1, h2, h3`): Apply styles to multiple selectors at once

### Conditional Styles with Classes

The [HTML `class` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/class) supports conditional styling and can be defined multiple times on the same element:

````rust
fn App() -> Element {
    let mut is_active = use_signal(|| false);
    let mut is_large = use_signal(|| false);

    rsx! {
        button {
            class: "btn",
            class: if is_active() { "btn-active" },
            class: if is_large() { "btn-large" },
            onclick: move |_| is_active.toggle(),
            "Toggle me!"
        }
    }
}
````

In HTML, the `class` attribute specifies a list of CSS classes a particular element has. A corresponding CSS stylesheet might include several classes that your elements use:

````css
/* The base `btn` class the button uses */
.btn {
    background-color: #f3f4f6;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    padding: 8px 16px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

/* The "active" class, added when `is_active()` is true */
.btn-active {
    background-color: #3b82f6;
    color: white;
    border-color: #2563eb;
}

/* The "large" class, added when `is_large()` is true */
.btn-large {
    padding: 12px 24px;
    font-size: 16px;
}
````

### CSS Custom Properties for Theming

You can use CSS custom properties (variables) for consistent theming. This is generally preferred over using Rust variables since dynamic string formatting can be less efficient and harder to optimize.

````css
:root {
    --color-primary: #3b82f6;
    --color-primary-hover: #2563eb;
    --color-text: #1f2937;
    --color-background: #ffffff;
    --border-radius: 6px;
    --spacing-xs: 4px;
    --spacing-sm: 8px;
    --spacing-md: 16px;
    --spacing-lg: 24px;
}

.button {
    background: var(--color-primary);
    color: var(--color-background);
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--border-radius);
    border: none;
    cursor: pointer;
}

.button:hover {
    background: var(--color-primary-hover);
}
````

## SCSS

Dioxus supports SCSS (Sass) files out of the box. Simply use the `asset!()` macro with `.scss` files:

````rust
static STYLES: Asset = asset!("/assets/styles.scss");
````

Your `assets/styles.scss` file can use all SCSS features:

````css
$primary-color: #3b82f6;
$secondary-color: #64748b;
$border-radius: 8px;

.card {
    background: white;
    border-radius: $border-radius;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);

    &:hover {
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .header {
        background: $primary-color;
        color: white;
        padding: 16px;
        border-radius: $border-radius $border-radius 0 0;
    }

    .content {
        padding: 16px;
        color: $secondary-color;
    }
}
````

## Tailwind

[Tailwind CSS](https://tailwindcss.com/) is a popular utility-first CSS framework that works excellently with Dioxus. It allows you to style elements using pre-defined utility classes. This very documentation site uses Tailwind! We can simply use tailwind classes in Dioxus:

````rust
rsx! {
    div { class: "flex flex-col items-center p-7 rounded-2xl",
        img { class: "size-48 shadow-xl rounded-md", src: "/img/cover.png" }
        div { class: "flex",
            span { "Class Warfare" }
            span { "The Anti-Patterns" }
            span { class: "flex",
                span { "No. 4" }
                span { "Â·" }
                span { "2025" }
            }
        }
    }
}
````

As of Dioxus 0.7, DX automatically downloads and starts the TailwindCSS watcher for you. Whenever you build your project with DX, the Tailwind CLI collects your classes and generates an output file in `assets/tailwind.css`.

![Tailwind Hotreload](/assets/07/tailwind-inline.mp4)

DX automatically detects if your project is using TailwindCSS if it finds a file called "tailwind.css" at the root of your project. In this file, you declare the basic Tailwind import and an extra line to ensure the watcher searches Rust files:

````css
@import "tailwindcss";
@source "./src/**/*.{rs,html,css}";
````

Note that we need to add the generated stylesheet to our app:

````rust
fn app() -> Element {
    rsx! {
        document::Stylesheet { href: asset!("/assets/tailwind.css") }
    }
}
````

Tailwind provides many [theme variables to configure](https://tailwindcss.com/docs/theme), which we can do by updating our `tailwind.css` file. For example, we can customize our document's font or define a custom color palette.

````css
@theme {
    --color-dxblue: #00A8D6;
    --color-ghmetal: #24292f;
    --color-ghdarkmetal: #161b22;
    --color-ideblack: #0e1116;
    --font-sans: "Inter var", sans-serif;
}
````

Tailwind works with Dioxus's multiple class attribute support:

````rust
fn Card() -> Element {
    let mut is_hovered = use_signal(|| false);

    rsx! {
        div {
            class: "bg-white rounded-lg shadow-md p-6 m-4",
            class: if is_hovered() { "shadow-xl transform -translate-y-1" },
            class: "transition-all duration-200",

            onmouseenter: move |_| is_hovered.set(true),
            onmouseleave: move |_| is_hovered.set(false),

            h2 {
                class: "text-xl font-bold text-gray-800 mb-2",
                "Card Title"
            }
            p {
                class: "text-gray-600",
                "This is a beautiful card component styled with Tailwind CSS."
            }
        }
    }
}
````

### VSCode Integration

For better Tailwind development experience, install the Tailwind CSS IntelliSense extension and add this to your VSCode settings:

````json
{
    "tailwindCSS.experimental.classRegex": ["class: \"(.*)\""],
    "tailwindCSS.includeLanguages": {
        "rust": "html"
    }
}
````

## Laying out Elements

If you're familiar with HTML and CSS, then you likely already know how to arrange the HTML elements to craft your desired UI. However, if HTML and CSS are new to you, then it's worth understanding the many ways you can lay out elements on the page. CSS supports several layout systems simultaneously:

* **Normal Flow**: The default layout where elements stack vertically (block elements) or flow horizontally (inline elements)
* **Flexbox**: One-dimensional layout system for arranging items in rows or columns with flexible sizing and alignment
* **CSS Grid**: Two-dimensional layout system for creating complex grid-based layouts with rows and columns
* **Float**: Legacy layout method that moves elements to the left or right, allowing text to wrap around them
* **Positioning**: Allows precise control over element placement using `static`, `relative`, `absolute`, `fixed`, or `sticky` positioning
* **Table Layout**: Displays elements as table cells, rows, and columns (can be used with non-table elements via `display: table`)
* **Multi-column**: Splits content into multiple columns, similar to newspaper layouts

Generally, you'll use either Flexbox or CSS Grid.

### Flexbox Layout

Flexbox is incredibly handy for building responsive user interfaces. As you adjust the document viewport, elements will automatically adjust their size and placement to fit their flex constraints. The [CSS-Tricks guide](https://css-tricks.com/snippets/css/a-guide-to-flexbox/) provides a very helpful tutorial on all the flex constraints you can use.

![Flexbox Guide](/assets/07/flexbox-diagram.webp)

### CSS Grid

CSS Grid is another powerful layout system. You can leverage CSS stylesheets to declare named regions of your document, dividing them along fixed or flexible grid lines. Several online tools exist that provide a [graphical interface](https://grid.layoutit.com) for building grid layouts.

### Fixed Position Layout

![CSS Grid Guide](/assets/07/css-grid.svg)

Occasionally you'll need to reach for [fixed-position layouts](https://developer.mozilla.org/en-US/docs/Web/CSS/position). These tend to be less flexible than CSS Grid and Flexbox, but make it possible to implement features like sticky headers and dynamically-positioned content.

## Icons and SVG

Dioxus supports several approaches for including icons and SVG graphics in your applications.

### Inline SVG

You can include SVG directly in your RSX:

````rust
fn IconButton() -> Element {
    rsx! {
        button {
            class: "flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded",

            // Inline SVG icon
            svg {
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "currentColor",
                path {
                    d: "M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"
                }
            }

            "Star"
        }
    }
}
````

### SVG Assets

For larger or reusable SVG files, you can store them in a separate file and import them with the `asset!()` macro.

````rust
fn Icon() -> Element {
    rsx! {
        img {
            src: asset!("/assets/logo.svg"),
            alt: "Logo",
            class: "h-8 w-8"
        }
    }
}
````

### Icon Libraries

You can also use Rust crates that provide icon collections. Several libraries exist:

* [Dioxus Free Icons](https://crates.io/crates/dioxus-free-icons) - The FreeIcons library for Dioxus
* [Dioxus Material Icons](https://crates.io/crates/dioxus-material-icons) - Google's Material Icons library for Dioxus
* [Dioxus Hero Icons](https://crates.io/crates/dioxus-heroicons) - The HeroIcons library for Dioxus

````rust
use dioxus_free_icons::{Icon, icons::fa_solid_icons};

fn App() -> Element {
    rsx! {
        Icon {
            width: 30,
            height: 30,
            fill: "blue",
            icon: fa_solid_icons::FaHeart
        }
    }
}
````

### Using `dangerous_inner_html`

If you want to include icons from their raw HTML representation, you can use `dangerous_inner_html` which sets the content from a Rust string:

````rust
rsx! {
    svg { dangerous_inner_html: r#"<path d="M256 352 128 160h256z" />"# }
}
````
# Dioxus Hot-Reloading Reference

The Dioxus Hot-Reload engine is incredibly powerful. When used properly, it provides the fastest development experience for building apps with Rust.

 > 
 > Dioxus 0.5 featured a limited form of hot-reloading, while Dioxus 0.6 drastically improved it.
 > 
 > **Dioxus 0.7 introduces experimental Rust hot-reloading**, making it the first Rust framework to support hot-reloading of actual Rust code. ðŸŽ‰ðŸŽ‰

Dioxus provides three forms of hotreloading.

*Element hot-reloading:*

![Element Hot-reloading](/assets/07/dog_app_hotreload.mp4)

*Asset hot-reloading:*

![Element Hot-reloading](/assets/07/css-hotreload.mp4)

*Rust hot-reloading:*

![Element Hot-reloading](/assets/07/subsecond-tui.mp4)

We provide this text guide as a resource for the details of hot-reloading. This guide has an accompanying video as well:

<iframe style="width: 100%" height="500px" class="centered-overflow" src="https://www.youtube.com/embed/Q4Xzz8OJEoc" title="Dioxus 0.6" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## RSX Hot-Reload

RSX hot-reloading is fundamental to the Dioxus development experience. It allows you to modify the structure, styling, and content of your user interface without recompiling your entire application.

RSX hot-reload enables you to instantly add, remove, or modify an elements in an `rsx!` block. The RSX parser works both at compile time, and in our devtools, letting DX sidestep recompiling your Rust code entirely.

````rust
fn App() -> Element {
    rsx! {
        // You can add, remove, or modify any elements
        div { class: "container" }
        h1 { "My App" }
        button { "Click me" }
    }
}
````

All string-based attributes support instant hot-reloading:

````rust
fn Button() -> Element {
    rsx! {
        button {
            // All of these can be hot-reloaded instantly
            class: "btn btn-primary",
            id: "my-button",
            title: "Click this button",
            style: "background: blue; color: white;",

            "Submit"
        }
    }
}
````

Hot-reload supports modifying complex formatted strings anywhere in your RSX. While you cannot instantly hot-reload the interior Rust expressions, you *can* move existing expressions between formatted strings.

````rust
fn Counter() -> Element {
    let count = use_signal(|| 0);

    rsx! {
        div {
            // We can move this `count` variable from here
            "Count: {count}"

            button {
                // ... to here, without a recompile!
                "Increment ({count})"
            }
        }
    }
}
````

You can hot-reload simple Rust expressions passed as component props. If the attribute value is a [Rust "literal"](https://doc.rust-lang.org/reference/expressions/literal-expr.html) - a single "token" like a number, boolean, or string - DX will hot-reload it by re-parsing the new attribute and modifying the component's props in place.

````rust
fn App() -> Element {
    rsx! {
        MyButton {
            text: "Click me", // try changing the text
            enabled: true, // try changing true to false!
            count: 123, // or changing the number value!
        }
    }
}

#[component]
fn MyButton(text: String, enabled: bool, count: i32, color: String) -> Element {
    rsx! {
        button { disabled: !enabled, "{text} - {count}" }
    }
}
````

Hot-reloading works inside conditional blocks, loops, and component children. Note that the interior *expressions* don't support instant RSX hot-reload, but the interior *elements* and *markup* do.

````rust
fn TodoList() -> Element {
    let todos = use_signal(|| vec!["Learn Dioxus", "Build an app"]);

    rsx! {
        ul {
            // We can modify the *body*
            for (i, todo) in todos().iter().enumerate() {
                li {
                    key: "{i}",
                    class: "todo-item",
                    "{todo}"
                }
            }
        }

        // Conditional blocks bodies are hot-reloadable too
        if todos().len() > 5 {
            div { class: "warning", "You have many todos!" }
        }
    }
}
````

## What Requires a Full Rebuild (or a hot-patch!)

While RSX hot-reloading is very capable, some changes still require a full application rebuild:

* **New variables or expressions** not present in the last compilation.
* **Logic changes** outside of RSX (function bodies, hooks, etc.).
* **Component signatures** (adding/removing props).
* **Import statements** and module structure.
* **Complex Rust expressions** in attributes that involve function calls.

When Rust hotpatching is enabled with the `--hotpatch` flag, DX will modify your app's assembly *in place* and not require a full rebuild. With hotpatching enabled, DX rarely issues full rebuilds. You can manually force a full rebuild of your app at any time by pressing the `r` key with the DX TUI open.

## Experimental: Rust Hot-patching

**New in Dioxus 0.7**, you can enable experimental Rust code hot-reloading using the `--hotpatch` flag. This feature is revolutionary - allowing you to modify Rust logic and see changes without rebuilding.

To use Rust hot-reloading, run `dx serve --hotpatch`. The extra flag is required while hot-patching is still experimental, though we plan to make it default in the future.

````bash
dx serve --hotpatch
````

This system, named **Subsecond**, can reload most changes to Rust code. However, there are a few limitations:

* You may add new globals at runtime, but their destructors will never be called.
* Globals are tracked across patches, but will renames are observed as introducing a new global.
* Changes to static initializers will not be observed.

Also, most importantly, Rust hot-patching currently only tracks the "tip" crate in your project. If you edit code in any of your dependencies - which might be *your* crate in a workspace - DX does *not* register that change. While RSX hot-reloading works across a workspace, Subsecond currently does not.

Subsecond also works outside Dioxus. Many projects have already adopted the Subsecond library for Rust hot-reloading. For example, Bevy and Iced already have Subsecond integrations:

![Bevy Hot-patching](/assets/07/bevy-hotpatch.mp4)

## Asset Hot-Reload

Asset hot-reloading allows you to modify CSS, images, and other static files without rebuilding your application. This works seamlessly with the `asset!()` macro system.

### CSS Hot-Reloading

CSS files are automatically watched and hot-reloaded when changed:

````rust
fn App() -> Element {
    rsx! {
        // Editing this stylesheet will cause instant updates in the running app
        Stylesheet { href: asset!("/assets/main.css") }
        div { class: "my-component", "Hello World!" }
    }
}
````

````css
/* In assets/main.css - changes here are instantly applied */
.my-component {
    background: blue;
    color: white;
    padding: 20px;
    /* Change this to red and see instant updates! */
}
````

SCSS files are automatically re-compiled on changes and the generated CSS will be hot-reloaded.

### Image and Static Asset Hot-Reloading

Static assets like images also support hot-reloading:

````rust
fn Header() -> Element {
    rsx! {
        img { src: asset!("/assets/logo.png") }
    }
}
````

When you edit `/assets/logo.png`, the change appears instantly in your running application.

### Tailwind CSS Integration

When you `serve` your app, DX automatically downloads and starts the Tailwind CLI in the background. If a `tailwind.css` file is detected in the project root, the Tailwind watcher will watch your Rust code for changes and then recompile the output `/assets/tailwind.css` file.

![Inline Tailwind](/assets/07/tailwind-inline.mp4)

You can manually customize the Tailwind input and output file locations using the `tailwind_input` and `tailwind_output` configuration fields in your project's Dioxus.toml.
# Escaping RSX

While RSX is extremely capable, *some* changes to the UI require low-level access to system widgets or an imperative programming approach. Dioxus provides a number of "escape hatches," letting you use alternative UI techniques that don't fit into the declarative RSX paradigm. Also, Dioxus is relatively young and might not expose support for *every* feature the platform-specific renderer has.

## Custom Element Attributes

Under the hood, Dioxus declares every element attribute as a set of constants that describe the attribute's static properties. The definition is roughly equivalent to this pseudocode:

````rust
struct video;
impl video {
    const src: AttributeDefinition = AttributeDefinition {
        name: "src",
        namespace: None,
        type: String
    };
    const autoplay: AttributeDefinition = AttributeDefinition {
        name: "controls",
        namespace: None,
        type: Boolean
    };
}

//
rsx! {
    video { src: "...", autoplay: true }
}
````

In some cases, an attribute declaration might be missing, or you need to use a custom name. RSX enables this with quote-wrapped attribute names. Simply wrap the name of the custom attribute with quotes and pass in any expression that evaluates to `IntoAttributeValue`:

````rust
rsx! {
    div {
        "data-my-button-id": 123
    }
}
````

Custom attributes can be extremely handy when using data attributes and custom CSS selectors.

## Dangerous Inner HTML

If you're working with pre-rendered assets, output from templates, or output from a JS library, then you might want to pass HTML directly instead of going through Dioxus. In these instances, reach for `dangerous_inner_html`. This attribute sets the HTML `textContent` field of the element to the provided value. This will overwrite any other attributes or children of the element.

For example, shipping a markdown-to-Dioxus converter might significantly bloat your final application size. Instead, you'll want to pre-render your markdown to HTML and then include the HTML directly in your output. We use this approach for the [Dioxus homepage](https://dioxuslabs.com):

````rs@dangerous_inner_html.rs
// this should come from a trusted source
let contents = "live <b>dangerously</b>";

rsx! {
    div { dangerous_inner_html: "{contents}" }
}
````

````inject-dioxus
DemoFrame {
	dangerous_inner_html::App {}
}
````

 > 
 > Note! This attribute is called "dangerous_inner_html" because it is **dangerous** to pass it data you don't trust. If you're not careful, you can easily expose [cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks to your users.
 > 
 > If you're handling untrusted input, make sure to sanitize your HTML before passing it into `dangerous_inner_html` â€“ or just pass it to a Text Element to escape any HTML tags.

## Web Components

While we generally suggest creating new components directly in Dioxus, a 3rd-party component might be distributed as a [*Web Component*](https://www.webcomponents.org). Web components provide a framework-agnostic way of building and distributing custom HTML elements.

Any element with a dash in the name is a web component. Web components are rendered directly in dioxus without type checking. Generally, you'll be importing a web component *into* Dioxus. We therefore recommend wrapping web components in a type safe component to make them easier to use.

````rs@building_uis_with_rsx.rs
rsx! {
    my-web-component {}
}
````

Because web components are untyped, they have no default attributes. Each attribute name must be wrapped in quotes, hence why we suggest wrapping the web component in a Dioxus component:

````rust
// our dioxus component provides a strongly-typed wrapper around our stringly-typed web component
#[component]
fn MyWebComponent(name: String, age: i32) -> Element {
    rsx! {
        my-web-component {
            "name": "hello, {name}",
            "age": age + 10
        }
    }
}
````

## Direct DOM Access

As mentioned earlier, RSX is *declarative.* You compose your elements in an `rsx! {}` block and Dioxus does the rendering. Sometimes, you'll need lower-level access to DOM elements to build deeply interactive UI. This might involve rendering into a canvas element or performing a synchronous modification to an element's properties.

To get direct access to the underlying [HTML DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction), Dioxus provides a few built-in mechanisms:

* Running JavaScript through `eval`
* Using [`web-sys`](https://docs.rs/web-sys/latest/web_sys/) to get element by ID
* Using the `onmounted` event handler
* Using the `onresize` and `onvisible` events

### Eval

Dioxus exposes an `eval` function that allows you to evaluate arbitrary JavaScript in the platform renderer. On the web, this uses [`web-sys`](https://docs.rs/web-sys/latest/web_sys/), and for the webview renderer, this uses the webview's native `eval` method.

You can eval any valid JavaScript. Dioxus transforms the input source code into a `Function` declaration and then allows you to capture its result. To send custom data into JavaScript, we simply format the source code. To return data from JavaScript, we use `dioxus.send()` and the eval's `.recv()` method:

````rust
use dioxus::prelude::*;

fn app() -> Element {
    rsx! {
        button {
            onclick: move |_| async move {
                // You can send values from rust to the JavaScript code by using the `send` method on the object returned by `eval`.
                let mut eval = document::eval(
                    r#"for(let i = 0; i < 10; i++) {
                        // You can send values asynchronously with the `dioxus.send()` method.
                        dioxus.send(i);
                    }"#
                );

                // You can receive values from the JavaScript code with the `recv` method on the object returned by `eval`.
                for _ in 0..10 {
                    let value: i32 = eval.recv().await.unwrap();
                    println!("Received {}", value);
                }
            },
            "Log Count"
        }
    }
}
````

### Using `web-sys` and Event Downcasting

On the web, it's possible to use the [`web-sys`](https://docs.rs/web-sys/latest/web_sys/) crate to directly call JavaScript methods from Rust. This uses foreign-function-interfaces to bridge the gap between Rust and JavaScript. We don't necessarily suggest using web-sys in *all* cases since web-sys is currently not portable to the Dioxus Desktop and Mobile renderers.

With web-sys, we can call most JavaScript methods with a strongly-typed Rust interface:

````rust
rsx! {
    let alert_it = move |_| {
        let window = web_sys::window().unwrap();
        window.alert_with_message("Hello from Rust!");
    };
    button { onclick: alert_it, "Click to alert" }
}
````

If you *need* to use web-sys on desktop and mobile, you might want to use [Dioxus with Tauri](#using-dioxus-in-tauri) instead.

### Using `getElementById`

When using either eval or web_sys, it can be useful to get a direct handle to an HTML Dom Node. Generally, we suggest creating an ID for a given element, and then using `getElementById` to reference that node later.

````rust
// Set a unique ID for the div
let id = use_hook(|| Uuid::new_v4());

// Reference it in our eval logic
let set_div_contents = move |_| async move {
    dioxus::document::eval(format!(r#" document.getElementById("{{div-{id}}}").innerText = "one-two-three" "#)).await;
};

rsx! {
    // And then assign it on the element itself
    div { id: "div-{id}" }
    button { onclick:  set_div_contents, "Set Div Directly" }
}
````

## Child Windows and Overlays

Some apps require low-level access to the HTML [`canvas`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/canvas) element. For example, computer-aided-design (CAD) apps, video games, photo editors, video editors, or anything relying on lots of multimedia might want to render GUI textures manually.

When using the webview renderer, you can overlay your Dioxus HTML content *on top* of a native texture. This is an advanced escape hatch that unlocks the entire rendering pipeline - extremely powerful but also quite complex.

![wgpu-windows.mp4](/assets/06assets/wgpu-windows.mp4)

For more information, see the [accompanying example](https://github.com/DioxusLabs/dioxus/blob/main/examples/wgpu_child_window.rs).

## Using Dioxus in Tauri

If you *need* to use the `web-sys` crate on desktop and mobile platforms, then [Tauri](https://tauri.app) might be useful for you. Tauri is a framework that lets you combine a custom frontend across an IPC boundary with Rust code running natively. This is somewhat similar to Dioxus, but instead of your UI code running natively, it instead runs as WebAssembly *inside* the webview. This can be slower and harder to setup, but does enable direct DOM access across all platforms.

Dioxus-Web is supported as a frontend option when creating a new Tauri app, so make sure to check out [their docs](https://tauri.app/start/).

## Native Widgets

The first-party Dioxus renderers currently only render HTML and CSS. This is either done via `HTMLDomElement` with `web-sys` or through a eval for the webview renderers. Sometimes, you want to render a platform-native widget. Internally, Dioxus uses this to open file dialogs, color pickers, and provide functionality where platform-consistency matters.

![File Upload Dialog](/assets/07/file-upload.png)

This is somewhat advanced and requires using FFI into Objective-C and Kotlin to use system libraries. See the [dioxus-desktop docs](https://crates.io/crates/dioxus-desktop) for more info.

## Dioxus Native

For *complete* control over the DOM, we've built the *Dioxus Native* renderer. This renderer combines platform-native widgets along with a stripped-down HTML/CSS renderer to paint the Dioxus widget tree directly to the screen. Currently, Dioxus Native supports a variety of backends based on the [Vello](https://github.com/linebender/vello) crate.

Dioxus Native is nascent. We specifically built Dioxus Native to paint arbitrary GPU textures into canvas elements. Instead of using child windows and overlays, you can directly pump WGPU textures in HTML elements. Likewise, you can embed Dioxus into any existing WGPU application, like a Bevy game.

![WGPU Native](/assets/07/wgpu-native-overlay.mp4)

See the [dioxus-native crate](https://crates.io/crates/dioxus-native) for more information.
# The Basics of State

Now that you know how to create user interfaces in Dioxus, it's time to learn about creating and update your app's state.

**Managaing state is, by far, the hardest part of building an app.**

This guide will walk you through the core principles of state management in Dioxus with an early emphasis on theory and then a shift into application.

## The Theory of State Management

Ultimately, "state management" refers to the act of:

1. Initializing data for the UI
1. Handling events from the user
1. Updating the data and re-rendering the UI

Managing this cycle is easy at first, but can become more challenging as apps grow in size, add more asynchronous work, and interact with external resources.

## For Experienced Web Developers

If you're coming to Dioxus as an experienced web developer, we hope you'll feel comfortable rather quickly. State management in Dioxus was heavily inspired by projects like React, Preact, SolidJS, and Svelte.

Dioxus uses signal-based reactivity. Unlike SolidJS, *reads* and *writes* of value are **explicit**. Rust does not have an equivalent to JavaScript's Proxy, so reactivity is traced by calls to `.read()` and `.write()`.

````rust
let mut count = use_signal(|| 0);

rsx! {
    button {
        onclick: move |_| *count.write() += 1,
        "Increment"
    }
    {count.read().to_string()}
}
````

In many cases, `.read()` is subtle, like using the value inside a string format:

````rust
rsx! { "Count: {count}" }
````

Unlike Svelte, Dioxus does not do compile-time transformation of your state. Unlike SolidJS, Dioxus components run multiple times. You can think of state management in Dioxus as a hybrid of React and SolidJS, where reactivity is automatically tracked, but components are free to run multiple times throughout their lifetime.

Dioxus also employs "common sense" optimizations like automatic property memoization and automatic reactivity tracking - two huge improvements over React. Dioxus also allows you to early return, optionally with a Suspended future, giving you an `async/await`-like model for data loading in components.

## For Experienced Rustaceans

If you're coming to Dioxus as an experienced Rustacean, you might be intimidated by our use of "unusual" primitives like `use_signal`, `use_memo`, `use_resource`, etc. Dioxus uses stateful "hooks" - a paradigm that has its origins in web development (in particular, React).

If you don't want to write React-like code in Dioxus, you can opt to using structs to store state and handle updates to the UI imperatively. You can store your state in a struct:

````rust
struct EditorState {
    text: String
}

impl EditorState {
    fn handle_input(&mut self, event: FormEvent) {
        self.text = event.value();
    }
}
````

And then use that state in a component with a single `use_signal`:

````rust
/// Define a component
#[component]
fn TextEditor() -> Element {
    // Use a single "state" object, wrapped in a `Signal`
    let mut state = use_signal(EditorState::new);

    rsx! {
        input {
            // In event handlers, call `.write()` to get `&mut self` on the "state" object
            oninput: move |event| state.write().handle_input(event)
        }
    }
}
````

Rust's borrow checker adds complexity to holding values across async tasks and callbacks. Using our built-in primitives solves a number of issues:

* Ability to reference data in `'static` tasks and callbacks
* Calls to `.write()` automatically queue a component to re-render
* Values are never "stale", even in async contexts.

Dioxus exposes its core runtime functions like `spawn` and `needs_update` - an approach Rustaceans might be more familiar with. The built-in reactive primitives leverage these functions intelligently, and thus will likely be more efficient than the simplistic state approach, but do come with a learning curve.
# Intro to Reactivity

So far, we've covered how to declare static user interfaces with RSX. Now, it's time to make our UI interactive. When the user clicks a button, moves their cursor, or inputs text, we want to update our UI in response.

The act of reacting to a state changes is called *reactivity*. Reactivity sits at the very heart of Dioxus. Everything from data fetching to routing is centered around reacting to state changes.

Similar to libraries like ReactJS, Dioxus provides a built-in reactivity system, saving you from manually queuing re-renders of components. If you're coming from web development, this should feel familiar. If you're mostly experienced with immediate-mode GUIs, this might seem foreign.

Reactivity systems enable larger, more modular, complex GUIs than is typically achievable with other approaches. To build UIs that effectively leverage reactivity, we follow three main pillars:

* **Data Flows Down**: Our apps maintain a one-way flow of data from parents to children
* **Data is Tracked**: Modifications to data is observed by reactive scopes and side-effects
* **Data is Derived**: Our UI and state is a pure function of our data sources

## Pillar 1: Data Flows Down

The first fundamental pillar of reactivity: data flows down. As our apps grow in size, so do their complexity. In apps with dozens of screens and hundreds of components, it can become difficult to reason about relationships between parent and child elements. By enforcing a unidirectional flow of data through our app, we can be sure that a child component renders *purely* as a function of its inputs.

To make our apps interactive, we follow a similar pattern. Components provide two items: *values* and *functions* to modify those values. These items are passed *down* the tree as properties. Dioxus does not provide a way for child components to "reach up" and modify the state of a parent.

The functions we pass down the tree are free to mutate state in the *current* component. However, a child component cannot *directly* modify its parent's state. This ensures all mutations to state are defined in the **same scope as the state itself**, making it easier to reason about our app's state at scale.

![Reactivity Tree](/assets/07/reactivity-tree.png)

## Pillar 2: Data is Tracked

The second fundamental pillar of reactivity: data is tracked. When you use various state primitives in Dioxus, the Dioxus runtime *tracks* changes to the underlying value. Whenever you call `.set()` or `.write()` on a *Reactive Value*, that operation is *observed* and *effects* are run.

The core Reactive Value in Dioxus is the Signal. When Signals are used in *reactive contexts*, their associated *reads* and *writes* are tracked. Every component is a reactive context. Whenever a Signal's value is modified, a *side-effect* is queued that re-reruns any reactive contexts that read the signal's value.

````rust
#[component]
fn Filter() -> Element {
    let mut selection = use_signal(|| "none");

    rsx! {
        // reading the *selection* value has a side-effect of re-rendering this component
        div { "{selection}" }

        // Calling `.set()` runs side-effects
        button { onclick: move |_| selection.set("dogs"), "Set Filter" }
    }
}
````

Many hooks utilize reactive contexts to attach their own side-effects.

## Pillar 3: Data is Derived

The third pillar of reactivity: values are *derived*. After any state in our app changes, we want the UI to match what we declared in our RSX. In this case, the UI is *derived* from our app state. Similarly, in reactive programming, all data is either a source, or *derived* from a source.

When rendering components, we therefore prefer to perform any transformations of the data while rendering or in a memo. We *do not* modify the data while rendering.

````rust
// âœ… *num_names* is derived from "names"
let names = use_signal(|| vec!["Jane", "Jack", "Jill"]);
let num_names = names.read().len();

// âŒ we do not store num_names in a signal
let names = use_signal(|| vec!["Jane", "Jack", "Jill"]);
let mut num_names = use_signal(|| 0);
num_names.set(names.len());
````

Hopefully, the fact that data should be *derived* is apparent. If we were to modify component state while rendering, we would inadvertently queue re-render side-effects, potentially leading to infinite loops.
# Hooks

In Dioxus, state that is local to a component is stored in *hooks*.

Dioxus hooks work similarly to React's hooks. If you haven't done much web development, hooks might seem particularly unusual. Hooks provide a way of storing state, and attaching effects composability in components. Even better - they're less verbose than declaring structs and implementing "render" traits!

## The `use_hook` primitive

All hooks in Dioxus are built on the `use_hook` primitive. While you might never directly use this primitive, it's good to know where all state eventually resides. The `use_hook` primitive is a function that takes an initializer and returns a `.clone()` of the value.

````rust
fn Simple() -> Element {
    let count = use_hook(|| 123);
    rsx! { "{count}" }
}
````

Whenever `use_hook` is called, one of two things happens:

* if this `use_hook` has never been called before, the initializer is ran and a new slot is created
* otherwise, `use_hook` returns a clone of the current value in the slot.

Internally, the "hook index" is incremented by 1 on every call to `use_hook` and reset to 0 before the component re-renders.

![Hook List](/assets/07/hook-list.png)

## Rules of Hooks

In Dioxus, we are transparent with the inner workings of the framework. Because hooks are implemented by walking an internal "hook list," they have certain rules that would cause walking the list to fail and your app to panic. It's important to note that these rules are not arbitrary - they are the intended result of how hooks are implemented.

Hooks use their call order to keep track of what state belongs to which hook. You must call hooks in the same order every time the component is run. To make sure the order is always the same, **you should only call hooks at the top level of a component or another hook**.

These rules mean that there are certain things you can't do with hooks:

### No Hooks in Conditionals

You should not call a hook function conditionally. When the component re-renders, this might lead to the hook list skipping an entry, causing the next hook to retrieve the wrong value.

````rs@hooks_bad.rs
// âŒ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy && you_know_it {
    let something = use_signal(|| "hands");
    println!("clap your {something}")
}

// âœ… instead, *always* call use_signal
// You can put other stuff in the conditional though
let something = use_signal(|| "hands");
if you_are_happy && you_know_it {
    println!("clap your {something}")
}
````

### No Hooks in Closures

Similar to conditionals, closures provide a way for hook functions to be called in an inconsistent order between renders. Instead of placing the hook in a closure, prefer to only use the result of the hook function in a closure.

````rs@hooks_bad.rs
// âŒ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
    let b = use_signal(|| 0);
    b()
};

// âœ… instead, move hook `b` outside
let b = use_signal(|| 0);
let _a = || b();
````

### No Hooks in Loops

Just like conditionals and closures, calling hook functions in loops can lead to inconsistent retrieval of hook values between renders, causing hooks to return the wrong value.

````rs@hooks_bad.rs
// `names` is a Vec<&str>

// âŒ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &names {
    let is_selected = use_signal(|| false);
    println!("selected: {is_selected}");
}

// âœ… Instead, use a hashmap with use_signal
let selection_map = use_signal(HashMap::<&str, bool>::new);

for name in &names {
    let is_selected = selection_map.read()[name];
    println!("selected: {is_selected}");
}
````

### Early Returns

Unlike in React, in Dioxus, you *can* early return between hook calls. However, we generally discourage this pattern since it can lead to similar consistency issues as conditionals. Dioxus supports early returns because error boundaries and suspense boundaries use the question-mark syntax for ergonomics.

````rust
let name = use_signal(|| "bob".to_string());

// âŒ dont early return between hooks!
if name() == "jack" {
    return Err("wrong name".into())
}

let age = use_signal(|| 123);

rsx! { "{name}, {age}" }


// âœ… instead, prefer to early return *after* all hook functions are run
let name = use_signal(|| "bob".to_string());
let age = use_signal(|| 123);

if name() == "jack" {
    return Err("wrong name".into())
}

rsx! { "{name}, {age}" }
````

### Prefix hook names with "`use_`"

By convention, hooks are Rust functions that have the `use_` prefix. When you see a function with the `use_` prefix, you should be aware that it internally walks the component's hook list and therefore must follow the Rules of Hooks.

## Why Hooks?

You might be wondering - why use hooks? Aren't structs and traits enough?

Hooks are useful because they compose exceptionally well. We can combine hook primitives to build complex yet modular interactions with a consistent interface. With a single function, we can encapsulate both state *and* effects.

````rust
// This hook is *derived* from an initializer
fn use_document_title(initial: impl FnOnce() -> String) -> Signal<String> {
    let mut title = use_signal(initial);

    // Whenever the title signal changes, we queue a side-effect to modify the window state
    use_effect(move || {
        window().document().set_title(title());
    });

    // We return the reactive String
    title
}
````

Another perk of hooks: we don't need to declare the boilerplate that a struct-based approach might require. A simple component that stores user name and email is simple with hooks:

````rust
#[component]
fn Card(default_name: String) -> Element {
    let mut name = use_signal(|| default_name);
    let mut email = use_signal(|| "".to_string());
    rsx! {
        span { "default: {default_name}" }
        input { oninput: move |e| name.set(e.value()), }
        input { oninput: move |e| email.set(e.value()), }
    }
}
````

whereas struct components might be quite verbose:

````rust
struct Card {
    default_name: String
    name: Signal<String>,
    email: Signal<String>
}

#[derive(PartialEq, Clone)]
struct CardProps {
    default_name: String
}
impl Component for Card {
    type Props = CardProps;
    fn new(props: Self::Props) -> Self {
        Self {
            name: Signal::new(props.default_name)
            email: Signal::new("".to_string())
        }
    }

    fn change(&mut self, props: Self::Props) {
        self.default_name = props.default_name;
    }

    fn render(mut state: Handle<Self>) -> Element {
        rsx! {
            span { "default: {self.default_name}" }
            input { oninput: move |e| state.name.set(e.value()) }
            input { oninput: move |e| state.email.set(e.value()) }
        }
    }
}
````

With a single function, we are able to express a value initializer, establish automatic value tracking, and handle changes to component properties. We can easily encapsulate shared behavior, queue side-effects, and compose modular primitives.
# Reactive Signals

In Dioxus, your app's UI is defined as a function of its current state. As the state changes, the components and effects that depend on that state will automatically re-run. Reactivity automatically *tracks* state and *derives* new state, making it easy to build large applications that are efficient and simple to reason about.

Dioxus provides a single source of mutable state: the **Signal**.

## State with Signals

In Dioxus, mutable state is stored in Signals. Signals are *tracked* values that automatically update *reactive contexts* that watch them. They are the source of state from which all other state is derived from. Signals are modified directly by event handlers in response to user input or asynchronously in futures.

You can create a signal with the `use_signal` hook:

````rust
let mut signal = use_signal(|| 0);
````

Once you have your signal, you can gain a reference to the signal's inner value by calling the `.read()`:

````rust
let mut signal = use_signal(|| 0);

// use `.read()` to access the inner value
let inner = signal.read();
````

For Signals whose inner can be cheaply cloneable, you can also use "function" syntax to get a direct `Clone` of the value.

````rust
let name = use_signal(|| "Bob".to_string());

// Call the signal like a function
let inner = name();

// Or use `.cloned()`
let inner = name.cloned();
````

Finally, you can set the value of the signal with the `.set()` method or get a mutable reference to the inner value with the `.write()` method:

````rs@reactivity.rs
// Set the value from the signal
signal.set(1);

// get a mutable reference to the inner value with the .write() method
let mut value: &mut i32 = &mut signal.write();
*value += 1;
````

A simple component that uses `.read()` and `.write()` to update its own state with signals may look like:

````rust
fn Demo() -> Element {
    let mut count = use_signal(|| 0);

    // read the current value
    let current = count.read().clone();

    rsx! {
        button {
            onclick: move |_| *count.write() = current,
            "Increment ({current})"
        }
    }
}
````

When assigning values to a `.write()` call, note that we use the [*dereference operator*](https://doc.rust-lang.org/std/ops/trait.DerefMut.html) which lets us write a value directly into the mutable reference.

## Ergonomic Methods on Signals

In some cases, wrapping your data in Signals can make accessing the inner state awkward. Mutable Signals implement two fundamental traits: `Readable` and `Writable`. These traits provide a number of automatic ergonomic improvements.

* `Signal<T>` implements `Display` if `T` implements `Display`
* `Signal<bool>` implements `fn toggle()`
* `Signal<i32>` and other numbers implement math operators (+, -, /, etc)
* `Signal<T>` where `T` implements `IntoIterator` implements `.iter()`
* and many more!

The `Display` extension enables using signals in formatting expressions:

````rust
let mut count = use_signal(|| 0);
rsx! { "Count is: {count}" }
````

The toggle extension makes toggling boolean values simpler:

````rust
let mut enabled = use_signal(|| true);
rsx! {
    button {
        onclick: move |_| enabled.toggle(),
        if enabled() { "disable" } else { "enable" }
    }
}
````

Math operators simplify arithmetic operations:

````rust
fn app() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    }
}
````

The iterator extension makes iterating through collections easier:

````rust
fn app() -> Element {
    let names = use_signal(|| vec!["bob", "bill", "jane", "doe"]);

    rsx! {
        ul {
            for name in names.iter() {
                li { "hello {name}" }
            }
        }
    }
}
````

You'll generally want to use the extension methods unless the inner state does *not* implement the required traits. There are several methods available not listed here, so peruse the docs reference for more information.

## ReadSignal and WriteSignal

Dioxus provides two variations of the base Signal type: `ReadSignal` and `WriteSignal`.

* **`ReadSignal`**: a read-only version of the base Signal type
* **`WriteSignal`**: a read-write version of the base Signal type, equivalent to `Signal` itself

`ReadSignals` are reactive values that implement the `Readable` trait. `WriteSignals` are reactive values that implement the `Writable` trait.

These two variations are useful when writing components that need to be generic over their input types. If a component only needs the `.read()` method and its extensions, then it can specify a `ReadSignal` as an argument.

````rust
fn app() -> Element {
    let mut name: Signal<String> = use_signal(|| "abc".to_string());

    rsx! {
        // The rsx macro automatically converts the Signal into a ReadSignal
        Name { name }
    }
}

// We can accept anything that implements `Into<ReadSignal>`
#[component]
fn Name(name: ReadSignal<String>) {
    rsx! { "{name}" }
}
````

In Dioxus, `Signal` is not the only reactive type. The entire ecosystem is full of custom reactive types. Dioxus itself also provides additional reactive types like `Memo` and `Resource`. To integrate well with the broader ecosystem, it's best to prefer using `ReadSignal` and `WriteSignal` in your interfaces rather than specific reactive types.

This ensures we can pass both `Signal` and `Memo` to the same function:

````rust
let name: Signal<String> = use_signal(|| "abc".to_string());
let uppercase: Memo<String> = use_memo(move || name.to_uppercase());

rsx! {
    // The rsx macro automatically converts the Signal into ReadSignal
    Name { name, uppercase }
    // The rsx macro automatically converts the Memo into ReadSignal
    Name { uppercase }
}

#[component]
fn Name(name: ReadSignal<String>) {
    rsx! { "{name}" }
}
````

## Reactive Scopes

A **Reactive Scope** is a block of Rust code that observes reads and writes of reactive values. Whenever `.write()` or `.set()` is called on a Signal, any active reactive scopes tracking that Signal run a callback as a side-effect.

The simplest reactive scope is a component. During a component render, components automatically subscribe to signals where `.read()` is called. The `.read()` method can be called *implicitly* in many circumstances - notably, the extension methods provided by `Readable` use the underlying `.read()` method and thus *also* contribute to the current reactive scope. When a signal's value changes, components queue a side-effect to re-render the component using `dioxus::core::needs_update`.

````rust
let mut name = use_signal(|| "abc".to_string());

rsx! {
    // An explicit call to `.read()`
    {name.read().to_string()}

    // An implicit call via `Display`
    "{name}"
}
````

If a component does not call `.read()` on a Signal while rendering, it does not subscribe to that signal's value. This provides us "zero cost reactivity" where we can freely modify signal values without worrying about unnecessary re-renders. If a value is not observed, it won't cause unnecessary re-renders.

````rust
let mut loading = use_signal(|| false);

rsx! {
    button {
        // Because we don't use "loading" in our markup, the component won't re-render!
        onclick: move |_| async move {
            if loading() {
                return;
            }
            loading.set(true);
            // .. do async work
            loading.set(false);
        }
    }
}
````

Calls to `.read()` access the current reactive scope, adding this scope to the list of subscribers to the Signal with a side effect that runs when that signal is changed. For components, the logic causes the component to queue a re-render side effect.

![Component effects](/assets/07/component-effect.png)

There are other uses of reactive scopes beyond component re-renders. Hooks like `use_effect`, `use_memo`, and `use_resource` all implement functionality by leveraging a reactive scope that exists *outside* the rendering lifecycle.

## Automatic Batching

All built in hooks batch updates if possible. Instead of running effects immediately, `.write()` calls queue an effect before the next "step" of your app. The runtime will try to wait until all writes in the current step are complete before running any effects. This provides automatic batching of `.write()` calls which is important both for performance and consistency in the UI.

By batching `.write()` calls, Dioxus ensures that our example UI always displays one of two states:

* **"loading?: false -> Complete"**
* **"loading?: true -> Loading"**

````rust
let mut loading = use_signal(|| false);
let mut text = use_signal(|| "Complete!");

rsx! {
    button {
        onclick: move |_| async move {
            // these writes are batched and side-effects are de-duplicated
            text.set("Loading");
            loading.set(true);

            // awaiting a future allows the runtime to continue
            do_async_work().await

            // these writes are also batched - only one re-render is queued
            text.set("Complete!");
            loading.set(false);
        },
        "loading?: {loading:?} -> {text}"
    }
}
````

Dioxus uses `await` boundaries as barriers between steps. If state is modified during a step, Dioxus prefers to paint the new UI first before polling additional futures. This ensures changes are flushed as fast as possible and pending states aren't missed.

While dioxus tries to batch writes, it prefers consistent state over batching when the two are in conflict. If you read the result of a memo directly after writing to a signal it depends on, the memo will be re-evaluated immediately to ensure you get the most up-to-date value. This ensures the memo is always equivalent to running the memo's function directly.

````rust
let mut count = use_signal(|| 0);
let double = use_memo(|| *count() * 2);

rsx! {
    button {
        onclick: move |_| async move {
            // This queues a rerun of the memo and marks it as dirty
            count += 1;
            // This forces the memo to re-evaluate immediately
            println!("double is now: {}", double());
        },
        "doubled: {double}"
    }
}
````

## Signals are Borrowed at Runtime

In Rust, the `&T` and `&mut T` reference types statically assert that the underlying value is either immutable or mutable *at compile time*. This assertion brings a number of guarantees, enabling Rust to generate fast and correct code.

Unfortunately, these static assertions do not mix well with asynchronous background tasks. If our `onclick` handler spawns a long-running Future that captures an `&mut T`, we can not safely handle any *other* events until that Future completes:

![Mutability Over Time](/assets/07/mutable-diagram.png)

At times, our UIs can be very concurrent. There *are* ways to re-orient how we concurrently access state that are compatible with Rust's static mutability assertions - unfortunately, they are not easy to program.

Instead, Signals provide a `.write()` method that checks *at runtime* if the value is safe to access. If you're not careful, you can combine a `.read()` and a `.write()` in the same scope, leading to a runtime borrow failure (panic).

This is most frequently encountered when holding `.read()` or `.write()` refs across await points:

````rust
let mut state = use_signal(|| 0);

rsx! {
    button {
        // Clicking this button quickly will cause multiple `.write()` calls to be active
        onclick: move |_| async move {
            let mut writer = state.write();
            sleep(Duration::from_millis(1000)).await;
            *writer = 10;
        }
    }
}
````

Fortunately, this code fails `cargo clippy` because the `writer` type should not be held across an await point.

Thankfully, Signals guard against the "trivial" case because the `.write()` method takes an `&mut Signal`. While the `.write()` guard is active in a scope (block), no other `.read()` or `.write()` guards can be held:

````rust, no_run
let mut state = use_signal(|| 0);

rsx! {
    button {
        // rust prevents this code from compiling since `.write()` takes `&mut T`
        onclick: move |_| {
            let cur = state.read();
            *state.write() = *cur + 1;
        }
    }
}
````

We get a very nice error from the Rust compiler explaining why this code does not compile:

````text
error[E0502]: cannot borrow `state` as mutable because it is also borrowed as immutable
  --> examples/readme.rs:22:18
   |
21 |                 let cur = state.read();
   |                           ----- immutable borrow occurs here
22 |                 *state.write() = *cur + 1;
   |                  ^^^^^^^^^^^^^ mutable borrow occurs here
23 |             }
   |             - immutable borrow might be used here, when `cur` is dropped and runs the destructor for type `GenerationalRef<Ref<'_, i32>>`
````

If we *do* want to read and write in the same scope, we need to stage our operations in the correct order such that the `.read()` and `.write()` guards do not overlap. Usually, this is done by deriving an owned value from the `.read()` operation to be used in the `.write()` operation.

````rust
let cur = state.read().clone(); // calling `.clone()` releases the `.read()` guard immediately.
*state.write() = *cur + 1;
````

Note that Rust automatically drops items *at the end* of a scope, unless they are manually dropped sooner. We can use the `.read()` guard provided it's dropped before `.write()` is called.

This is done either by creating a new, shorter scope to access the `.read()` guard -

````rust
// The .read() guard is only alive for a shorter scope
let next = {
    let cur = state.read();
    println!("{cur}");
    cur.clone() + 1
};

// we can assign `state` to `next` since `next` is not referencing `.read()`.
*state.write() = next;
````

or, simply by calling `drop()` on the guard

````rust
let cur1 = state.read();
let cur2 = *cur1 + 1;
drop(cur1); // dropping early asserts we can `.write()` the signal safely
*state.write() = cur2 + 1;
````

In very advanced use cases, you can make a copy of the signal or use the `read_unchecked` method to relax the borrowing rules:

````rust
match result.read_unchecked().as_ref() {
    Ok(resp) => rsx! { "success! {resp}" }
    Err(err) => rsx! { "err: {err:?}" },
}
````

 > 
 > Rust 2021 had issues with `.read()` in match statements, whereas Rust 2024 fixes this issue, meaning you no longer need to use `read_unchecked`

While this might seem scary or error prone, you will *very rarely* run into these issues when building apps. The `.read()` and `.write()` guards respect Rust's ownership rules within a given scope and concurrent scopes are protected by the [Clippy `await_holding_refcell_ref` lint](https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_refcell_ref).

## Signals implement `Copy`

If you've used Rust to build other projects - like a webserver or a command line tool - you might have encountered situations with closures, threads, and async tasks that required an `Arc` or `Rc` to satisfy the borrow checker.

![Concurrent Access](/assets/07/concurrent-arc.png)

If our data is used across several parallel threads, or even just held in a callback, we might need to wrap it in an `Arc` or `Rc` smart pointer and `.clone()` it. This can lead to cumbersome code where we constantly call `.clone()` to share data into callbacks and async tasks.

````rust
let state = Arc::new(123);

// thread 1
std::thread::spawn({
    let state = state.clone();
    move |_| println!("{state:?}"),
})

// thread 2
std::thread::spawn({
    let state = state.clone();
    move |_| println!("{state:?}"),
})
````

Unfortunately, UI code constantly encounters this problem - **this is why Rust does not have a great reputation for building GUI apps**!

To solve this, we built the [generational-box crate](https://crates.io/crates/generational-box) that provides a `GenerationalBox` type that implements [Rust's `Copy` trait](https://doc.rust-lang.org/std/marker/trait.Copy.html). The `Copy` trait is very important: Rust automatically copies `Copy` types (when needed) on boundaries of scopes.

````rust
let state = GenerationalBox::new(123);

// the `move` keyword automatically copies the GenerationalBox!
std::thread::spawn(move |_| println!("{state:?}"));

// we can easily share across threads with no `.clone()` noise
std::thread::spawn(move |_| println!("{state:?}"));
````

Instead of copying the underlying value, the `GenerationalBox` simply copies a *handle* to the value. This handle is essentially a runtime-verified smart pointer. Accessing the contents of a signal is not as efficient as reading a pointer directly - there is an extra pointer indirection and lock - but we expect most code to not be bottlenecked by reading the contents of a `GenerationalBox`.

Dioxus Signals are built directly on top of `GenerationalBox`. They share the same `Copy` semantics and ergonomics, but with the same tradeoffs.

## Signals are Disposed

Signals implementing `Copy` is a huge win for ergonomics. However, there is a tradeoff. The `GenerationalBox` type does not have automatic [RAII](https://doc.rust-lang.org/rust-by-example/scope/raii.html) support. This means when a `GenerationalBox` is dropped, its resources are **not immediately cleaned up**. It can be tricky to correctly use `GenerationalBox` directly. Dioxus manages the *resource* lifecycle by cleaning up resources using the *component* lifecycle.

The Signal type is built on `GenerationalBox`. Whenever you call `use_signal`, we automatically:

* Call `Signal::new()`
* Register `signal.dispose()` on the component's `on_drop`

Whenever a component is unmounted, its hooks are dropped. When you create Signals in a component, each Signal is registered with a Signal "owner" on that component. When the component is unmounted, the owner drops, and in its `Drop` implementation, it calls `.dispose()` on all Signals that were created in its scope.

Effectively, we connected the `.dispose()` method of the Signals to the unmount of the component.

Because the Signal is disposed when the component unmounts, reading it after will cause a runtime panic. This very rarely happens in practice, but *is* possible if you "save" the signal in a component higher up the tree. Doing so would violate the one-way-data flow pillar of reactivity, but is technically possible.

![Concurrent Access](/assets/07/use-after-free.png)

Reading a Signal after it's been disposed is similar to the "use-after-free" bug with pointers, but reading a Signal *is not* undefined behavior. In debug mode, the Signal will be hoisted to its reader and you'll receive a warning in the logs that a Signal is being read after it's been disposed.

A similar issue can arise when you call `Signal::new()` directly. Dioxus creates an implicit Signal owner that is owned by the current component. The contents of this Signal will only be dropped when the current component is unmounted. Calling `Signal::new()` can lead to unbounded memory usage until the component is dropped. It's rare to do this in normal application code but can crop up in library development.

````rust
let mut users = use_signal(|| vec![]);

rsx! {
    button {
        // the underlying strings won't be dropped until the component is unmounted, or you call `.dispose()` manually
        onclick: move |_| {
            users.write().push(Signal::new("bob".to_string()));
        },
        "Add a new user"
    }
}
````

When mapping Signals or creating them on-the-fly, it's best to prefer the built-in methods and reactive collections.

## Effects, Memos, and More

Signals are just one piece of the Dioxus reactivity system. Hooks like `use_effect` and `use_memo` are able to isolate their reactive scopes to just callbacks and futures. This means `.read()` and `.write()` in these scopes won't queue re-render side-effects in their containing component.

We cover these hooks in more depth in a [later chapter](./effects.md).
# Handling User Input

It's time to make our app interactive! In Dioxus, user input is handled by attaching event listeners to elements. When an event listener is triggered, Dioxus runs the provided closure. In the closure, you can write to signals, log messages, make network requests, or take any action that makes the UI feel *alive*.

````rust
fn app() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    }
}
````

````inject-dioxus
DemoFrame {
    readme::App {}
}
````

## Event Handlers

Event handlers are callbacks used to respond to user actions. Event handlers can capture dozens of different interactions: button clicks, page scrolls, mouse movements, text input, and more.

Adding an event handler to an element is similar to adding an attribute with the `key: value` syntax. The handler name usually starts with `on` - and accepts a closure as the value. For example, to handle clicks on a button, we can add an `onclick` handler:

````rs@event_click.rs
rsx! {
    button { width: "100%", height: "100%",
        // This event handler will be called when the button is clicked
        onclick: move |event| log!("Clicked! Event: {event:#?}"),
        "click me!"
    }
}
````

````inject-dioxus
DemoFrame {
    event_click::AppDemo {}
}
````

There are many different event handlers available:

* **Mouse Events**: `onclick`, `onmouseover`, `onmousedown`, `onmousemove`, etc.
* **Keyboard Events**: `onkeydown`, `onkeyup`, `onkeypress`
* **Form Events**: `onsubmit`, `oninput`, `onchange`, etc.
* **Focus Events**: `onfocus`, `onblur`
* **Drag-and-Drop Events**: `ondrag`, `ondrop`, `ondragover`, etc.
* **UI Events**: `onscroll`, `onload`, `onscroll`, `onresize`

The full list of event listeners is available in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Events).

## The Event Object

Event handlers receive an [`Event`](https://docs.rs/dioxus-core/latest/dioxus_core/struct.Event.html) object containing information about the event. Different types of events contain different types of data. For example, mouse-related events contain [`MouseData`](https://docs.rs/dioxus/latest/dioxus/events/struct.MouseData.html), which provides details like the mouse position and which mouse buttons were pressed.

The event object is the first argument in the event handler callback:

````rust
rsx! {
    button {
        onclick: move |event| {   // <-- our `Event` object
            //
        }
    }
}
````

In the example above, this event data was logged to the terminal:

````
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
````

 > 
 > To learn what the different event types for HTML provide, read the [events module docs](https://docs.rs/dioxus-html/latest/dioxus_html/events/index.html).

## Handling Common Events

The most common action you'll take in an event handler is modifying the application's state. This might involve updating a filter, toggling a switch, or presenting feedback to text input.

For components like toggles, we might use a boolean signal and a checkbox:

````rust
let mut upload_enabled = use_signal(|| true);
rsx! {
    input {
        type: "checkbox",

        // set the upload_enabled signal
        oninput: move |evt| upload_enabled.set(evt.checked()),
    }
}
````

For components like filters, we might use the HTML `select` element:

````rust
let mut option = use_signal(|| None);
rsx! {
    select {
        // set the signal to the select's `value`
        oninput: move |evt| option.set(Some(evt.value())),

        option { label: "Sedan", value: "sedan" }
        option { label: "Suv", value: "suv" }
        option { label: "Truck", value: "truck" }
    }
}
````

For text, we might use the `input` element:

````rust
let mut first_name = use_signal(|| "".to_string());
rsx! {
    input {
        type: "text",
        placeholder: "First Nameâ€¦",

        // Update the first_name signal on text input
        oninput: move |e| first_name.set(e.value()),
    }
}
````

For forms, we might use a HashMap to hold the key-value pairs:

````rust
let mut values = use_signal(HashMap::new);

rsx! {
    form {
        onsubmit: move |evt| {
            // Prevent the default form submission navigation
            evt.prevent_default();
            values.set(evt.values());
        },

        label { for: "username", "Username" }
        input { type: "text", name: "username" }
    }
}
````

Dioxus bridges the Rust-JavaScript boundary by adding ergonomic accessor methods on the `Event` object to make reading values from the DOM easier. These include:

* A `.value()` method for input events to read the input contents
* A `.values()` method for form events to read all the form values
* A `.checked()` method on checkbox input events to read the `.checked` state
* A `.files()` event to read any uploaded files
* A `.key()` event to convert keydown events into a Rust `Key` enum
* and many more methods!

 > 
 > We provide a large number of examples in the [Dioxus GitHub repository](https://github.com/DioxusLabs/dioxus/tree/main/examples). Be sure to also read the docs on [handling events in HTML](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Events).

## Controlled vs Uncontrolled Inputs

Dioxus provides two ways of handling the state of input elements:

* **Uncontrolled mode**: the default where the input element handles its own state
* **Controlled mode**: an alternative mode where you control the input element's state manually

Controlled mode is useful if you plan to transform or programmatically modify the user's input.

### Uncontrolled Inputs

*Uncontrolled mode* is the default mode for input elements. In this mode, the input element itself manages its own state like the input value, cursor position, and focusing. We simply attach an event listener to the input and react to changes in the value:

````rs@input_uncontrolled.rs
pub fn App() -> Element {
    rsx! {
        form { onsubmit: move |event| { tracing::info!("Submitted! {event:?}") },
            input { name: "name" }
            input { name: "age" }
            input { name: "date" }
            input { r#type: "submit" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    input_uncontrolled::App {}
}
````

````
Submitted! UiEvent { data: FormData { value: "", values: {"age": "very old", "date": "1966", "name": "Fred"} } }
````

In this mode, we have no control over the actual value of the input. The user may enter any value and our code updates state in response.

### Controlled Inputs

*Controlled mode* as an alternative mode for input elements where you directly control the state of the input. If the user types invalid text in the input, you can reject it or overwrite it.

To put an input element in controlled mode, we drive its `value` attribute directly:

````rs@input_controlled.rs
pub fn App() -> Element {
    let mut name = use_signal(|| "bob".to_string());

    rsx! {
        input {
            // we tell the component what to render
            value: "{name().to_ascii_uppercase()}",
            // and what to do when the value changes
            oninput: move |event| name.set(event.value())
        }
    }
}
````

````inject-dioxus
DemoFrame {
    input_controlled::App {}
}
````

Controlled inputs enable more control over the input element behavior. You can:

* Transform the input as it's modified (e.g. to make sure it is upper case)
* Validate the input, rejecting invalid inputs
* Programmatically change the value (e.g. a "randomize" button that fills the input with nonsense)

## Event Propagation

When the user interacts with our app, their interactions might trigger multiple event listeners at once. In the simplest case, a `div` may contain a `button` - both with their own `onclick` listeners:

![Multiple Listeners](/assets/07/multiple-listeners.png)

In what order will the listeners fire? Event handling comes in two phases:

* **Event Capturing**: Listeners are triggered as the event "descends" to the target.
* **Event Bubbling**: Listeners are triggered as the event "bubbles" to the root.

By default, Dioxus only captures the "bubbling" phase of the event, so the inner `button` will receive the `onclick` event before the `div`.

![Bubbling Diagram](/assets/07/event-capturing.png)

As the event bubbles to the root element (in this case, the document root), you have an opportunity to prevent any further listeners from being triggered. To stop the event from propagating upwards, you can call the `stop_propagation()` method on the event:

````rs@event_nested.rs
rsx! {
    div { onclick: move |_event| {},
        "outer"
        button {
            onclick: move |event| {
                event.stop_propagation();
            },
            "inner"
        }
    }
}
````

This ensures *only* the inner `button` will run its `onclick` handler - the `div` handler will not be triggered. This behavior can be useful when building advanced UI like drag-and-drop interactions and custom menus.

 > 
 > For more information about event propagation see [the MDN docs on event bubbling](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling)

## Prevent Default

Some events have a default behavior. For keyboard events, this might be entering the typed character. For mouse events, this might be selecting some text. For forms, this might be submitting the form and navigating the page.

You can call the `prevent_default()` method on the event to stop this default behavior.

````rs@event_prevent_default.rs
rsx! {
    a {
        href: "https://example.com",
        onclick: |evt| {
            evt.prevent_default();
            log!("link clicked")
        },
        "example.com"
    }
}
````

````inject-dioxus
DemoFrame {
    event_prevent_default::AppDemo {}
}
````

Event handlers will still be called, but the "default" behavior of the interaction will be cancelled. The `prevent_default()` method is frequently used in interactions like:

* Capturing file drops
* Preventing form navigations
* Overriding the `a` link element behavior
* Disallowing certain text input
* Enabling drag-and-drop behavior for arbitrary elements

 > 
 > For more information about default behaviors, see the [MDN docs on preventDefault()](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)

## Downcasting to Native Events

In some cases, the Dioxus `Event` type does not bridge enough of the Event's data. In these cases, we can directly access the platform-specific event type. Dioxus does not do this automatically since not all platforms share a consistent event interface with some platforms providing richer detail than others.

To downcast the event, we can use `event.downcast::<T>()` where `T` is the type we are trying to downcast to. You'll mostly use this extension when building web applications to downcast into the underlying `web_sys` event:

````rust
rsx! {
    button {
        onclick: move |evt| {
            let web_evt = evt.downcast::<web_sys::Event>().unwrap();
            let target = web_evt.target().unwrap();
            log!("target: {:?}", target);
        },
        "Click me!"
    }
}
````

## Asynchronous Handlers

Event Handlers can either be synchronous or asynchronous. Dioxus automatically calls `spawn()` on the Futures produced by asynchronous event handlers:

````rust
rsx! {
    button {
        onclick: move |evt| async move {
            let res = reqwest::get("https://dog.ceo/api/breeds/image/random/")
                .await
                .unwrap()
                .json::<DogApi>()
                .await;
            log!("res: {:?}", res);
        },
        "Fetch a dog!"
    }
}
````

Dioxus won't cancel previous Tasks spawned by the onclick handler, so multiple rapid button clicks will start multiple concurrent fetches. Be careful to not mutate state in asynchronous handlers without synchronization first.

## Handling files

You can insert a file picker by using an input element of type `file`. This element supports the `multiple` attribute, to let you pick more files at the same time. You can select a folder by adding the `directory` attribute: Dioxus will map this attribute to browser specific attributes, because there is no standardized way to allow a directory to be selected.

Extracting the selected files is a bit different from what you may typically use in Javascript.

The `FormData` event contains a `files` field with data about the uploaded files. This field contains a `FileEngine` struct which lets you fetch the filenames selected by the user. This example saves the filenames of the selected files to a `Vec`:

````rs@input_fileengine.rs
pub fn App() -> Element {
    let mut filenames: Signal<Vec<String>> = use_signal(Vec::new);
    rsx! {
        input {
            // tell the input to pick a file
            type: "file",
            // list the accepted extensions
            accept: ".txt,.rs",
            // pick multiple files
            multiple: true,
            onchange: move |evt| {
                for file in evt.files() {
                    filenames.write().push(file.name());
                }
            }
        }
    }
}
````

If you're planning to read the file content, you need to do it asynchronously, to keep the rest of the UI interactive. This example event handler loads the content of the selected files in an async closure:

````rs@input_fileengine_async.rs
onchange: move |evt| {
    async move {
        for file in evt.files() {
            if let Ok(file) = file.read_string().await {
                files_uploaded.write().push(file);
            }
        }
    }
}
````

Lastly, this example shows you how to select a folder, by setting the `directory` attribute to `true`.

````rs@input_fileengine_folder.rs
input {
    type: "file",
    // Select a folder by setting the directory attribute
    directory: true,
    onchange: move |evt| {
        for file in evt.files() {
            println!("{}", file.name());
        }
    }
}
````

## Handler Props

Sometimes, you might want to make a component that accepts an event handler. A simple example would be a `FancyButton` component, which accepts an `onclick` handler with the `EventHandler` type:

````rs@event_handler_prop.rs
#[derive(PartialEq, Clone, Props)]
pub struct FancyButtonProps {
    onclick: EventHandler<MouseEvent>,
}

pub fn FancyButton(props: FancyButtonProps) -> Element {
    rsx! {
        button {
            class: "fancy-button",
            onclick: move |evt| props.onclick.call(evt),
            "Click me!"
        }
    }
}
````

To actually call the event handler, you call it with the `.call()` method:

````rs@event_handler_prop.rs
onclick: move |evt| props.onclick.call(evt),
````

 > 
 > Note: just like any other attribute, you can name the handlers anything you want! Any closure you pass in will automatically be turned into an `EventHandler`.

## Custom Data

Event Handlers are generic over the closure's first argument, so you can pass in any data, e.g:

````rs@event_handler_prop.rs
struct ComplexData(i32);

#[derive(PartialEq, Clone, Props)]
pub struct CustomFancyButtonProps {
    onclick: EventHandler<ComplexData>,
}

pub fn CustomFancyButton(props: CustomFancyButtonProps) -> Element {
    rsx! {
        button {
            class: "fancy-button",
            onclick: move |_| props.onclick.call(ComplexData(0)),
            "click me pls."
        }
    }
}
````

The `EventHandler<T>` type is a subset of the base `Callback<Args, Ret>` type that allows you to return a value from the closure.

## Returning a Value From an Event Handler

If you want to accept a closure that returns a value, you can use the `Callback` type. The callback type accepts two generic arguments, `I`, the input type, and `O`, the output type. Just like `EventHandler`, `Callback` is automatically converted in props and can be easily copied anywhere in your component:

````rs@event_handler_prop.rs
#[derive(PartialEq, Clone, Props)]
pub struct CounterProps {
    modify: Callback<u32, u32>,
}

pub fn Counter(props: CounterProps) -> Element {
    let mut count = use_signal(|| 1);

    rsx! {
        button {
            onclick: move |_| count.set(props.modify.call(count())),
            "double"
        }
        div { "count: {count}" }
    }
}
````

## Callbacks Carry the Runtime

Many Dioxus runtime functions are "free functions" - you can freely call them without needing an explicit handle to the Dioxus runtime. This works by implicitly setting a thread-local called "current runtime", roughly equivalent to this pseudocode:

````rust
thread_local! {
    static CURRENT_RUNTIME: Cell<Option<Runtime>> = Cell::new(None);
}

fn render_users_component(app: &Application) {
    CURRENT_RUNTIME.set(app.runtime());
    app.run_component();
    CURRENT_RUNTIME.set(None);
}
````

Whenever *your* code runs from within Dioxus, the runtime will always be set. However, plain closures do not automatically set the current runtime. Trying to call closures outside the app that reference state from within the app might cause a panic.

Fortunately, the `EventHandler` and `Callback` types carry a handle to the Dioxus runtime, ensuring runtime methods succeed. When the callback is called, the closure sets the `CURRENT_RUNTIME` variable. This means you can pass the `EventHandler` and `Callback` types to APIs like file-system watchers and system IO where the Dioxus runtime is not usually active.
# Async and Futures

Not all actions complete immediately. Some actions, like a network request, require waiting for system input/output (IO). While waiting for network response, we want to provide status updates, add a loading spinner, and most importantly: avoid blocking the UI thread. Code that blocks the UI thread will prevent further user input, making the UI feel janky and unintuitive.

Rust provides a built-in way of handling asynchronous work with its built-in async/await system. Dioxus provides a first-class integration with Rust's async/await system.

## Future: Rust's Async Primitive

The `Future` trait is the core of async Rust. A future represents a value that may not yet be ready. In other languages, this is sometimes called a *Promise* or *Task*. You can read more about Futures in the [Rust book](https://doc.rust-lang.org/book/ch17-00-async-await.html).

We won't cover all the details of futures here, but there are a few important things to know before using them in Dioxus:

* **Futures are lazy**: They do not do anything until you `await` them or `spawn` them.
* **Futures are concurrent but not always parallel**: In Dioxus, all futures run on the main thread.
* **Futures pause at await points**: You should not hold any locks across those await points.
* **Futures can be cancelled before they complete**: Your futures need to be "cancel safe."

Futures should be able to handle stopping at any time without panicking or leaving the application in an inconsistent state. They should also be careful not to run blocking operations that lock the main thread.

The lifecycle of a future follows a consistent structure:

* A callback calls an `async fn` or an async closure
* The async function returns a Future
* A `dioxus::spawn()` call submits the future to the Dioxus runtime, returning a `Task`
* The Future is polled in the background until it returns a `Ready` value
* If the Future is cancelled, Rust calls its `Drop` implementation

![Future Diagram](/assets/07/future-diagram.png)

## Lazy futures

Unlike JavaScript's Promises, Rust futures are *lazy*. This means that they do not start executing until you call `.await` or start them in the background with `spawn`.

This Future will never log "Ran" because it is never awaited:

````rs@async_crash_course.rs
let future = async {
    println!("Ran");
};
````

To run this Future, you can either await it in another Future or spawn it:

````rs@async_crash_course.rs
let future = async {
    println!("Ran");
};
let other_future = async {
    future.await;
    println!("Ran Other");
};
spawn(other_future);
````

You can stop polling a Future any time or customize how a Future is polled using the [futures](https://crates.io/crates/futures) crate.

## Running Futures with `spawn`

The Dioxus [`spawn`](https://docs.rs/dioxus/0.7/dioxus/prelude/fn.spawn.html) function starts running a Future in the background and returns a `Task` that you can use to control the Future. It is the basis of all other async hooks in dioxus. You can use spawn to execute one-off tasks in event handlers, hooks or other Futures:

````rs@asynchronous.rs
let mut response = use_signal(|| "Click to start a request".to_string());

rsx! {
    button {
        onclick: move |_| {
            response.set("...".into());
            // Spawn will start a task running in the background
            spawn(async move {
                let resp = reqwest::Client::new()
                    .get("https://dioxuslabs.com")
                    .send()
                    .await;

                if resp.is_ok() {
                    response.set("dioxuslabs.com responded!".into());
                } else  {
                    response.set("failed to fetch response!".into());
                }
            });
        },
        "{response}"
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::SpawnButton {}
}
````

Since spawning in event handlers is very common, Dioxus provides a more concise syntax. If you return a Future from an event handler, Dioxus will automatically `spawn` it:

````rs@asynchronous.rs
let mut response = use_signal(|| "Click to start a request".to_string());

rsx! {
    button {
        // Async closures passed to event handlers are automatically spawned
        onclick: move |_| async move {
            response.set("...".into());
            let resp = reqwest::Client::new()
                .get("https://dioxuslabs.com")
                .send()
                .await;

            if resp.is_ok() {
                response.set("dioxuslabs.com responded!".into());
            } else  {
                response.set("failed to fetch response!".into());
            }
        },
        "{response}"
    }
}
````

## Running Futures with `use_action`

You'll frequently want to spawn an action in response to some user input and store the result. For rapid user input, you'll also want to cancel previous actions to prevent race conditions. Dioxus provides a built-in hook that simplifies this pattern with a function called `use_action`.

The `use_action` hook combines signals and tasks into a single unified interface. Simply call `use_action` with a callback that returns a `Result<T>`:

````rust
// Whenever this action is called, it will re-run the future and return the result.
let mut breed = use_action(move |breed| async move {
    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    struct DogApi {
        message: String,
    }

    reqwest::get(format!("https://dog.ceo/api/breed/{breed}/images/random"))
        .await
        .unwrap()
        .json::<DogApi>()
        .await
});
````

You can call the action with `.call()`:

````rust
rsx! {
    button {
        onclick: move |_| {
            breed.call(cur_breed.clone());
        },
        "{cur_breed}"
    }
}
````

And then, elsewhere in your component, you can read the result with `.value()`:

````rust
match breed.value() {
    Some(Ok(res)) => rsx! {
        img { src: "{res.read().message}" }
    },
    Some(Err(_e)) => rsx! {
        div { "Failed to fetch a dog, please try again." }
    },
    None => rsx! {
        div { "Click the button to fetch a dog!" }
    },
}
````

If an action is pending, calling `.call()` will cancel the current action's `Task`, replacing it with the new task.

## Automatic Cancellation

The Future you pass to the `spawn` will automatically be cancelled when the component is unmounted. If you need to keep the Future running until it is finished, you can use [`spawn_forever`](https://docs.rs/dioxus/0.7/dioxus/prelude/fn.spawn_forever.html) instead:

````rs@asynchronous.rs
// Spawn will start a task running in the background which will not be
// cancelled when the component is unmounted
dioxus::dioxus_core::spawn_forever(async move {
   let resp = reqwest::Client::new()
       .get("https://dioxuslabs.com")
       .send()
       .await;

   if resp.is_ok() {
       response.set("dioxuslabs.com responded!".into());
   } else  {
       response.set("failed to fetch response!".into());
   }
});
````

## Manual Cancellation

If you want to cancel your future manually, you can call the `cancel` method on the `Task` returned by `spawn` or `spawn_forever`. This will stop the future from running and drop it.

````rs@asynchronous.rs
let mut response = use_signal(|| "Click to start a request".to_string());
let mut task = use_signal(|| None);

rsx! {
    button {
        onclick: move |_| {
            response.set("...".into());
            // Spawn will start a task running in the background
            let new_task = spawn(async move {
                let resp = reqwest::Client::new()
                    .get("https://httpbin.org/delay/1")
                    .send()
                    .await;

                if resp.is_ok() {
                    response.set("httpbin.org responded!".into());
                } else  {
                    response.set("failed to fetch response!".into());
                }
            });
            task.set(Some(new_task));
        },
        "{response}"
    }
    button {
        onclick: move |_| {
            // If the task is running, cancel it
            if let Some(t) = task.take() {
                t.cancel();
                response.set("Request cancelled".into());
            } else {
                response.set("No request to cancel".into());
            }
        },
        "Cancel Request"
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::CancelButton {}
}
````

## Cancel Safety

Async tasks can be cancelled at any time. The futures you spawn in dioxus may be canceled:

1. When the component they were spawned in is unmounted.
1. When the task is cancelled manually using the `cancel` method on the `Task` returned by `spawn` or `spawn_forever`.
1. When a resource restarts

This means that your futures need to be cancel safe. A cancel-safe future is one that can be stopped at any await point without causing issues. For example, if you are using a global state, you need to ensure that the state is restored when the future is dropped:

````rs@asynchronous.rs
static RESOURCES_RUNNING: GlobalSignal<HashSet<String>> = Signal::global(|| HashSet::new());
let mut breed = use_signal(|| "hound".to_string());
let dogs = use_resource(move || async move {
    // Modify some global state
    RESOURCES_RUNNING.write().insert(breed());

    // Wait for a future to finish. The resource may cancel
    // without warning if breed is changed while the future is running. If
    // it does, then the breed pushed to RESOURCES_RUNNING will never be popped
    let response = reqwest::Client::new()
        .get(format!("https://dog.ceo/api/breed/{breed}/images"))
        .send()
        .await?
        .json::<BreedResponse>()
        .await;

    // Restore some global state
    RESOURCES_RUNNING.write().remove(&breed());

    response
});
````

````inject-dioxus
DemoFrame {
    asynchronous::NotCancelSafe {}
}
````

You can mitigate issues with cancellation by cleaning up resources manually. For example, by making sure global state is restored when the future is dropped:

````rs@asynchronous.rs
static RESOURCES_RUNNING: GlobalSignal<HashSet<String>> = Signal::global(|| HashSet::new());
let mut breed = use_signal(|| "hound".to_string());
let dogs = use_resource(move || async move {
    // Modify some global state
    RESOURCES_RUNNING.write().insert(breed());

    // Automatically restore the global state when the future is dropped, even if
    // isn't finished
    struct DropGuard(String);
    impl Drop for DropGuard {
        fn drop(&mut self) {
            RESOURCES_RUNNING.write().remove(&self.0);
        }
    }
    let _guard = DropGuard(breed());

    // Wait for a future to finish. The resource may cancel
    // without warning if breed is changed while the future is running. If
    // it does, then it will be dropped and the breed will be popped
    reqwest::Client::new()
        .get(format!("https://dog.ceo/api/breed/{breed}/images"))
        .send()
        .await?
        .json::<BreedResponse>()
        .await
});
````

````inject-dioxus
DemoFrame {
    asynchronous::CancelSafe {}
}
````

Async methods will often mention if they are cancel safe in their documentation. Generally, most futures you'll encounter when building Dioxus apps *are* cancel safe.

## Concurrency vs Parallelism

Concurrency and parallelism are often confused, but the difference has important implications for how you write your applications. Multiple concurrent tasks may be in progress at the same time, but they don't necessarily run at the same time. In Rust, futures are concurrent. They can yield control to other tasks at await points, allowing other tasks to run while they wait for a value to become ready.

![concurrent](/assets/07/async_concurrent.png)

In contrast, multiple parallel tasks can run at exactly the same time on different threads. In Rust, you can spawn parallel tasks using the `std::thread` module or libraries like `rayon`.

![parallel](/assets/07/async_parallel.png)

Rust has multiple different async runtimes like `tokio` or `wasm-bindgen-futures`. Dioxus provides its own async runtime built on top of a platform specific runtime for each renderer. On desktop and mobile, we use Tokio to progress futures.

The Dioxus runtime is single threaded which means futures can use `!Send` types, but they need to be careful to never block the thread.

````rs@async_crash_course.rs
spawn(async {
    // This will block the main thread and make the UI unresponsive.
    // Do not do this!
    solve_for_the_answer_to_life_and_everything();
    println!("Ran");
});
````

If you have an expensive task you need to run, you should spawn it on a separate thread using [`std::thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html) on desktop/mobile or use a [web worker](https://docs.rs/gloo-worker/latest/gloo_worker/) on the web. This will allow the main thread to continue running and keep the UI responsive.

````rs@async_crash_course.rs
std::thread::spawn(|| {
    // This will run on a separate thread and not block the main thread.
    solve_for_the_answer_to_life_and_everything();
    println!("Ran");
});
````

## Handling locks

Futures will pause execution at `.await` points, allowing other tasks to run until the future is ready to continue. You should never hold `read`/`write` locks across `.await` points because another async task could try to use the value while the future is paused and the lock is still open. Instead, you need to ensure that locks are only held for the duration of the critical section and released before awaiting.

![async locks](/assets/07/async_lock_await.png)

## Long-lived Futures

In some apps, you might want to include long-lived tasks that exist for the lifetime of the app. This might be a background sync engine or a thread listening to some system IO. For these use cases, we provide the `spawn_forever` function. This works exactly the same as `spawn`, but instead of spawning the future under the *current* component, the future is attached to the *root* component. Because the root component is never unmounted, the task continues until the app is closed.

````rust
use_hook(|| spawn_forever(async move {
    println!("Starting a background task!");
}));
````

This function does have its drawbacks and is meant for advanced use cases. If any resources like a Signal are used in this future, they must *also* be valid for the lifetime of the app. Using Signals after they have been dropped will lead to a panic and crash your app!
# Data Fetching

One of the most common asynchronous operations in applications is making network requests. This guide will cover how to fetch data in Dioxus, how to avoid waterfalls, and using libraries to manage caching and invalidating requests.

The hooks and techniques we cover here are built on top of the Future and Signal primitives.

## Library Dependencies

While Dioxus does not provide a built-in HTTP client, you can use the popular [reqwest](https://docs.rs/reqwest/latest/reqwest/) library to make asynchronous network requests. We will be using the reqwest library throughout the examples in this page. Before we start, make sure to add the `reqwest` and `serde` libraries to your `Cargo.toml`:

````sh
cargo add reqwest --features json
cargo add serde --features derive
````

Your Cargo.toml should have the reqwest and serde libraries:

````toml
[dependencies]
# ... dioxus and other dependencies
reqwest = { version = "*", features = ["json"] }
serde = { version = "1", features = ["derive"] }
````

We are planning on eventually integrating a library like [dioxus-query](https://crates.io/crates/dioxus-query) directly into Dioxus for better integration with the app router.

## Requests from Event Handlers

The simplest way to request data is simply by attaching an async closure to an EventHandler.

````rust
#[derive(serde::Deserialize)]
struct DogApi {
    message: String,
}

let mut img_src = use_signal(|| "image.png".to_string());

let fetch_new = move |_| async move {
    let response = reqwest::get("https://dog.ceo/api/breeds/image/random")
        .await
        .unwrap()
        .json::<DogApi>()
        .await
        .unwrap();

    img_src.set(response.message);
};

rsx! {
    img { src: img_src }
    button { onclick: fetch_new, "Fetch a new dog!" }
}
````

Whenever the user clicks the button, the `fetch_new` closure is fired, a new Future is spawned, and the network request is made. When the response is complete, we set `img_src` to the return value.

Unfortunately, data fetching is not always quite this simple. If the user rapidly presses the fetch button, multiple requests will be made simultaneously, and the image source will overwritten multiple times. To mitigate this, we can add a "loading" Signal to prevent multiple requests:

````rust
let mut img_src = use_signal(|| "image.png".to_string());
let mut loading = use_signal(|| false);

let fetch_new = move |_| async move {
    if loading() {
        return;
    }

    loading.set(true);
    let response = reqwest::get("https://dog.ceo/api/breeds/image/random")
        .await
        .unwrap()
        .json::<DogApi>()
        .await
        .unwrap();

    img_src.set(response.message);
    loading.set(false);
};

// ...
````

Manually handling edge cases of data loading can be tedious, so we've built a more general solution for futures with `use_resource`.

## Asynchronous State with `use_resource`

The [`use_resource`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_resource.html) hook can be used to *derive* asynchronous state. This function accepts an async closure that returns a Future. As the future is polled, `use_resource` tracks `.read()` calls of any contained Signals. If another action calls `.write()` on the tracked signals, the `use_resource` immediately restarts.

````rs@asynchronous.rs
let mut breed = use_signal(|| "hound".to_string());
let dogs = use_resource(move || async move {
    reqwest::Client::new()
        // Since breed is read inside the async closure, the resource will subscribe to the signal
        // and rerun when the breed is written to
        .get(format!("https://dog.ceo/api/breed/{breed}/images"))
        .send()
        .await?
        .json::<BreedResponse>()
        .await
});

rsx! {
    input {
        value: "{breed}",
        // When the input is changed and the breed is set, the resource will rerun
        oninput: move |evt| breed.set(evt.value()),
    }

    div {
        display: "flex",
        flex_direction: "row",
        // You can read resource just like a signal. If the resource is still
        // running, it will return None
        if let Some(response) = &*dogs.read() {
            match response {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        } else {
            "Loading..."
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::UseResource {}
}
````

The `use_resource` hook might look similar to the `use_memo` hook. Unlike `use_memo`, the resource's output is not memoized with `PartialEq`. That means any components/reactive hooks that read the output will rerun if the future reruns even if the value it returns is the same:

````rs@asynchronous.rs
let mut number = use_signal(|| 0);

// Resources rerun any time their dependencies change. They will
// rerun any reactive scopes that read the resource when they finish
// even if the value hasn't changed
let halved_resource = use_resource(move || async move { number() / 2 });

log!("Component reran");

rsx! {
    button {
        onclick: move |_| number += 1,
        "Increment"
    }
    p {
        if let Some(halved) = halved_resource() {
            "Halved: {halved}"
        } else {
            "Loading..."
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::UseResourceDemo {}
}
````

 > 
 > Note: The future you pass to `use_resource` must be cancel safe. Cancel safe futures are futures that can be stopped at any await point without causing causing issues. For example, this task is not cancel safe:
 > 
 > ````rs@asynchronous.rs
 > static RESOURCES_RUNNING: GlobalSignal<HashSet<String>> = Signal::global(|| HashSet::new());
 > let mut breed = use_signal(|| "hound".to_string());
 > let dogs = use_resource(move || async move {
 >     // Modify some global state
 >     RESOURCES_RUNNING.write().insert(breed());
 > 
 >     // Wait for a future to finish. The resource may cancel
 >     // without warning if breed is changed while the future is running. If
 >     // it does, then the breed pushed to RESOURCES_RUNNING will never be popped
 >     let response = reqwest::Client::new()
 >         .get(format!("https://dog.ceo/api/breed/{breed}/images"))
 >         .send()
 >         .await?
 >         .json::<BreedResponse>()
 >         .await;
 > 
 >     // Restore some global state
 >     RESOURCES_RUNNING.write().remove(&breed());
 > 
 >     response
 > });
 > ````
 > 
 > ````inject-dioxus
 > DemoFrame {
 >     asynchronous::NotCancelSafe {}
 > }
 > ````
 > 
 > It can be fixed by making sure the global state is restored when the future is dropped:
 > 
 > ````rs@asynchronous.rs
 > static RESOURCES_RUNNING: GlobalSignal<HashSet<String>> = Signal::global(|| HashSet::new());
 > let mut breed = use_signal(|| "hound".to_string());
 > let dogs = use_resource(move || async move {
 >     // Modify some global state
 >     RESOURCES_RUNNING.write().insert(breed());
 > 
 >     // Automatically restore the global state when the future is dropped, even if
 >     // isn't finished
 >     struct DropGuard(String);
 >     impl Drop for DropGuard {
 >         fn drop(&mut self) {
 >             RESOURCES_RUNNING.write().remove(&self.0);
 >         }
 >     }
 >     let _guard = DropGuard(breed());
 > 
 >     // Wait for a future to finish. The resource may cancel
 >     // without warning if breed is changed while the future is running. If
 >     // it does, then it will be dropped and the breed will be popped
 >     reqwest::Client::new()
 >         .get(format!("https://dog.ceo/api/breed/{breed}/images"))
 >         .send()
 >         .await?
 >         .json::<BreedResponse>()
 >         .await
 > });
 > ````
 > 
 > ````inject-dioxus
 > DemoFrame {
 >     asynchronous::CancelSafe {}
 > }
 > ````
 > 
 > Async methods will often mention if they are cancel safe in their documentation.

## Asynchronous State with `use_loader`

The `use_resource` hook is great for loading arbitrary values. However, working with resources that return results can be a little cumbersome. In some cases, the `use_loader` hook is a better choice.

The `use_loader` hook is designed to work with reactive futures that return `Result<T, E>`. Instead of returning a `Resource<T>`, like `use_resource`, the `use_loader` hook *actually* returns a `Result<Loader<T>, Loading>`. The `Loading` return type tightly integrates with Error Boundaries and Suspense - both of which are very useful in server-side-rendering (SSR).

Because `use_loader` returns a Result, you can use the `?` syntax to early return if the resource is pending or errored:

````rust
// Fetch the list of breeds from the Dog API, using the `?` syntax to suspend or throw errors
let breed_list = use_loader(move || async move {
    reqwest::get("https://dog.ceo/api/breeds/list/all")
        .await?
        .json::<ListBreeds>()
        .await
})?;
````

Generally, we recommend using `use_resource` when doing client-side fetching and `use_loader` when doing hybrid client/server fetching.

## Avoiding Waterfalls

One common issue when fetching data is the "waterfall" effect, where requests run sequentially. This can lead to slow loading times and a poor user experience. To avoid waterfalls, you can hoist your data loading logic to a higher level in your component tree and avoid returning early before unrelated requests.

Lets look at at an app that causes a waterfall effect:

````rs@data_fetching.rs
fn fetch_dog_image(
    breed: impl Display,
) -> impl Future<Output = dioxus::Result<String, CapturedError>> {
    async move {
        let response = reqwest::get(format!("https://dog.ceo/api/breed/{breed}/images/random"))
            .await?
            .json::<DogApi>()
            .await?;
        Ok(response.message)
    }
}

#[component]
fn DogView() -> Element {
    let poodle_img = use_resource(|| fetch_dog_image("poodle"));

    let poodle_img = match poodle_img() {
        Some(Ok(src)) => src,
        _ => {
            return rsx! {
                p { "Loading or error..." }
            };
        }
    };

    let golden_retriever_img = use_resource(|| fetch_dog_image("golden retriever"));

    let golden_retriever_img = match golden_retriever_img() {
        Some(Ok(src)) => src,
        _ => {
            return rsx! {
                p { "Loading or error..." }
            };
        }
    };

    let pug_img = use_resource(|| fetch_dog_image("pug"));

    let pug_img = match pug_img() {
        Some(Ok(src)) => src,
        _ => {
            return rsx! {
                p { "Loading or error..." }
            };
        }
    };

    rsx! {
        div {
            h1 { "Dog Images" }
            img { src: "{poodle_img}" }
            img { src: "{golden_retriever_img}" }
            img { src: "{pug_img}" }
        }
    }
}
````

In this example, we return early from the component when any of the requests are still loading. The request for the golden retriever and pug images will not start until the poodle image is loaded, causing a waterfall effect.

![waterfall effect](/assets/07/waterfall_effect.png)

We can avoid this issue by moving all of the early returns after the data fetching for all three images has started. This way, all requests will start at the same time which means they can execute in parallel:

````rs@data_fetching.rs
let poodle_img = use_resource(|| fetch_dog_image("poodle"));
let golden_retriever_img = use_resource(|| fetch_dog_image("golden retriever"));
let pug_img = use_resource(|| fetch_dog_image("pug"));

let poodle_img = match poodle_img() {
    Some(Ok(src)) => src,
    _ => {
        return rsx! {
            p { "Loading or error..." }
        };
    }
};
let golden_retriever_img = match golden_retriever_img() {
    Some(Ok(src)) => src,
    _ => {
        return rsx! {
            p { "Loading or error..." }
        };
    }
};
let pug_img = match pug_img() {
    Some(Ok(src)) => src,
    _ => {
        return rsx! {
            p { "Loading or error..." }
        };
    }
};

rsx! {
    div {
        h1 { "Dog Images" }
        img { src: "{poodle_img}" }
        img { src: "{golden_retriever_img}" }
        img { src: "{pug_img}" }
    }
}
````

![no waterfall effect](/assets/07/no_waterfall_effect.png)

## Organizing Data Fetching

While it might be tempting to place `use_resource` calls *everywhere* in your app, we strongly recommend limiting yourself to just a few sources of data fetching. It is generally easier to reason about centralized loading states rather than many fragmented sources.

As we add more sources of data fetching, we also add a larger combination of loading states. If possible, it's better to load a users's "name" and "id" in *one* request, rather than two.

## Libraries for Data Fetching

`use_resource` is a great way to fetch data in dioxus, but it can be cumbersome to manage complex data fetching scenarios. Libraries like [Dioxus query](https://docs.rs/dioxus-query/latest/dioxus_query/) provide more advanced features for data fetching, such as caching, invalidation, and polling. We won't cover the api of these libraries in detail here, but you can check out the [dioxus awesome](https://dioxuslabs.com/awesome/) list for more libraries that can help you with data fetching.
# Effects and Memos

Signals provide a foundation for mutable state in Dioxus apps. Calls to `.read()` subscribe reactive scopes and calls to `.write()` queue side-effects.

However, sometimes we want to run *our own* side-effects when a Signal's value changes. Other times, we want to isolate reactive scopes such that changes to a signal do not automatically queue a component to be re-rendered. In these cases, we reach for Memos with `use_memo` and Effects with `use_effect`.

## Multiple Reactive Scopes

To understand Effects and Memos, we need to first understand that a single Signal (or other reactive value) can be read in multiple reactive scopes simultaneously. For instance, a signal may be shared among several components via props. Each component that calls `.read()` on the signal value is automatically subscribed to any changes of the signal's value. When the signal value changes, it runs the re-render side-effect.

Effects and Memos allow us to observe changes in reactive values without re-rendering components. We can isolate smaller units of reactivity with memos and then queue our own side-effects with effects.

![Multiple Readers](/assets/07/multiple-scopes.png)

Memos implement the `Readable` trait (but not the Writable trait!) and thus implement the same ergonomic extensions as signals. Both Memos and Effects are `Copy` and have the same lifecycle and Drop semantics as signals.

## Derived State with Memo

`use_memo` is a reactive primitive that lets you derive state from any tracked value. It takes a closure that computes the new state and returns a tracked value that contains the current state of the memo. When a dependency of the memo changes, the memo will rerun, and a new value will be calculated.

The value returned from the closure will only cause the memo's value to update - and thus any side-effects - when they are not equal, determined by the `PartialEq` between the old and new value.

````rs@reactivity.rs
fn Memo() -> Element {
    let mut count = use_signal(|| 0);

    // use_memo creates a tracked value that is derived from count
    // Since we read count inside the closure, it becomes a dependency of the memo
    // Whenever count changes, the memo will rerun
    let half_count = use_memo(move || count() / 2);

    use_effect(move || {
        // half_count is itself a tracked value
        // When we read half_count, it becomes a dependency of the effect
        // and the effect will rerun when half_count changes
        log!("{half_count}");
    });

    rsx! {
        button { onclick: move |_| count += 1, "Increment" }

        div { "Count is {count}" }
        div { "Half count is {half_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::MemoDemo {}
}
````

Memos can be useful to perform expensive computations outside the component's reactive scope, preventing re-renders when the inputs change. In this example, by performing our computation *inside* the memo, we prevent the component from re-rendering when either `loading` or `loading_text` changes. Instead, the component will only re-render when the computed memo value changes.

````rust
let mut loading = use_signal(|| false);
let mut loading_text = use_signal(|| "loading".to_string());

let subheading = use_memo(move || {
    if loading() && loading_text() == "loading" {
        return "The state is loading";
    }

    "The state is not loading"
});

rsx! {
    h1 { "{subheading}" }
}
````

## Derived Elements

The `use_memo` hook is particularly powerful. In addition to primitive values, it can even memoize `Element` objects! We can break up large components into a series of smaller memos for a performance boost.

In practice, you won't need to frequently use Element memoization, but it can be useful. Most commonly, we can transform the result of some expensive computation directly into an Element without needing to store the intermediate value:

````rust
let mut loading_text = use_signal(|| "loading".to_string());

let loading_ui = use_memo(move || {
    let num_chars = loading_text.read().chars().count();
    rsx! { "there are {num_chars} characters!" }
});

rsx! {
    h1 { "Demo" }
    {loading_ui}
}
````

Astute readers will recognize that memoized UI and components are essentially the same concept - components are simply functions of memoized state that return an Element.

## Running Side-Effects

By default, whenever a Tracked value changes, any reactive scopes observing the value with `.read()` will run side-effects. The classic example is a component: when a signal value changes, the component queues a side-effect that re-renders the component.

![Component renders are effects](/assets/07/component-effect.png)

We can attach our own side-effects to Signals and Memos using the `use_effect` hook. It creates a closure that is run any time a tracked value that is run inside the closure changes.

Any value you read inside the closure will become a dependency of the effect. If the value changes, the effect will rerun.

````rs@reactivity.rs
fn Effect() -> Element {
    // use_signal creates a tracked value called count
    let mut count = use_signal(|| 0);

    use_effect(move || {
        // When we read count, it becomes a dependency of the effect
        let current_count = count();
        // Whenever count changes, the effect will rerun
        log!("{current_count}");
    });

    rsx! {
        button { onclick: move |_| count += 1, "Increment" }

        div { "Count is {count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::EffectDemo {}
}
````

## Prefer Actions over Side-Effects

You might be wondering: "why should I ever run side-effects?" And, indeed, they should not be a frequently used tool in your toolbox. Side-effects can be difficult to reason about and are frequently misused when an action should be preferred.

The classic example of a side-effect is to synchronize UI state with some external state. For example, we might have a `Title {}` component that sets the window's title whenever the title changes:

````rust
fn Title() -> Element {
    let mut text = use_signal(|| "");

    // attach an effect to modify the document title whenever title changes
    use_effect(move || {
        window().document().set_title(text());
    });

    rsx! {
        input {
            oninput: move |e| text.set(e.value()),
            placeholder: "Set the document title"
        }
    }
}
````

This is a valid use case for side-effects. Dioxus guarantees side-effects will be run *after* the UI has been painted to the screen. If we instead set the document title from the oninput handler, another change in state during the same step might cause the `Title {}` component to be unmounted. In this case, the document title will have been set even though the `Title {}` component is no longer present.

However, some actions should *not* be effects. Effects are widely over-used in React and the source of many state headaches. If you can be reasonably sure that the `Title {}` component won't be unmounted, then it is better to set the document title directly in the handler:

````rust
fn Title() -> Element {
    rsx! {
        input {
            oninput: move |e| {
                window().document().set_title(e.value())
            },
            placeholder: "Set the document title"
        }
    }
}
````

## Opting Out of Subscriptions

In some situations, you may need to read a reactive value without subscribing to it. You can use the `peek` method to get a reference to the inner value without registering the value as a dependency of the current reactive context:

````rs@reactivity.rs
fn Peek() -> Element {
    let mut count = use_signal(|| 0);

    // The toggle signal is a tracked value
    let mut toggle = use_signal(|| false);

    use_effect(move || {
        // When we read count, it becomes a dependency of the effect
        let current_count = count();
        log!("current_count is {current_count}");

        if current_count % 4 == 0 {
            // We peek at the value of toggle instead of reading it,
            // so it does not become a dependency
            let current_toggle = *toggle.peek();
            // We didn't subscribe to toggle, so this will not cause
            // the effect to rerun forever
            toggle.set(!current_toggle);
            log!("flipped toggle to {toggle}");
        }
    });

    rsx! {
        button { onclick: move |_| count += 1, "Change Signal" }

        div { "Count is {count}" }
        div { "Toggle is {toggle}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::PeekDemo {}
}
````

## Working with Untracked State

Most of the state in your app will be tracked values. All built in hooks return tracked values, and we encourage custom hooks to do the same. However, there are times when you need to work with untracked state. For example, you may receive a raw untracked value in props. When you read an untracked value inside a reactive context, it will not subscribe to the value:

````rs@reactivity.rs
fn Component() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        button { onclick: move |_| count += 1, "Change Signal" }

        Count { count: count() }
    }
}

// The count reruns the component when it changes, but it is not a tracked value
#[component]
fn Count(count: i32) -> Element {
    // When you read count inside the memo, it does not subscribe to the count signal
    // because the value is not reactive
    let double_count = use_memo(move || count * 2);

    rsx! {
        div { "Double count: {double_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::NonReactiveDemo {}
}
````

You can start tracking raw state with the `use_reactive` hook. This hook takes a tuple of dependencies and returns a reactive closure. When the closure is called in a reactive context, it will track subscribe to the dependencies and rerun the closure when the dependencies change.

````rs@reactivity.rs
#[component]
fn Count(count: i32) -> Element {
    // You can manually track a non-reactive value with the use_reactive hook
    let double_count = use_memo(
        // Use reactive takes a tuple of dependencies and returns a reactive closure
        use_reactive!(|(count,)| count * 2),
    );

    rsx! {
        div { "Double count: {double_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::UseReactiveDemo {}
}
````

## Making Props Reactive

To avoid losing reactivity with props, we recommend you wrap any props you want to track in a `ReadSignal`. Dioxus will automatically convert `T` into `ReadSignal<T>` when you pass props to the component. This will ensure your props are tracked and rerun any state you derive in the component:

````rs@reactivity.rs
// You can track props by wrapping the type in a ReadOnlySignal
// Dioxus will automatically convert T into ReadOnlySignal<T> when you pass
// props to the component
#[component]
fn Count(count: ReadOnlySignal<i32>) -> Element {
    // Then when you read count inside the memo, it subscribes to the count signal
    let double_count = use_memo(move || count() * 2);

    rsx! {
        div { "Double count: {double_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::MakingPropsReactiveDemo {}
}
````
# Hoisting State

You now have enough Dioxus knowledge to build large and complex apps! As your apps scale in size, you might want to refactor large components into a collection of smaller components. Alternatively, you might add a new component that needs to access state from a sibling component.

In these cases, we need to "lift" up shared state to the nearest common ancestor. This technique of lifting common state up the tree is called *hoisting*.

![Hoisting State](/assets/07/hoisting-state.png)

## Hoisting Signals

The most common items to hoist are signals and local state. As your apps grow in size, we split larger components into smaller components. However, your smaller child components still need to access the same state. In these cases, we pass state down the tree.

We might start with a larger component that combines multiple sources of state - in this case, a user's name, email, and some validation in a Memo:

````rust
#[component]
fn EmailAndName() -> Element {
    let mut name = use_signal(|| "name".to_string());
    let mut email = use_signal(|| "email".to_string());
    let is_valid = use_memo(move || validate_name_and_email(name, email))
    rsx! {
        if !is_valid() { "Invalid name or email" }
        input { oninput: move |e| name.set(e.value()) }
        input { oninput: move |e| email.set(e.value()) }
    }
}
````

We might want to split out the validation UI into its own component. In this case, we can move the `Validator` markup into its own child component:

````rust
#[component]
fn EmailAndName() -> Element {
    let mut name = use_signal(|| "name".to_string());
    let mut email = use_signal(|| "email".to_string());
    rsx! {
        Validator { name, email }
        input { oninput: move |e| name.set(e.value()) }
        input { oninput: move |e| email.set(e.value()) }
    }
}

#[component]
fn Validator(name: Signal<String>, email: Signal<String>) -> Element {
    let is_valid = use_memo(move || validate_name_and_email(name, email));

    rsx! {
        if !is_valid() { "Invalid name or email" }
    }
}
````

As our app continues to grow in complexity, we might want to use the `is_valid` memo in other components. For example, we might want to style the input box differently if the input is invalid. In this case, need to *hoist* the `is_valid` memo out of the `Validator` component back into the `EmailAndName` component:

````rust
#[component]
fn EmailAndName() -> Element {
    let mut name = use_signal(|| "name".to_string());
    let mut email = use_signal(|| "email".to_string());
    let is_valid = use_memo(move || validate_name_and_email(name, email));

    rsx! {
        Validator { is_valid }
        div { class: if !is_valid() { "border-red" },
            input { oninput: move |e| name.set(e.value()) }
            input { oninput: move |e| email.set(e.value()) }
        }
    }
}

#[component]
fn Validator(is_valid: Memo<bool>) -> Element {
    rsx! {
        if !is_valid() { "Invalid name or email" }
    }
}
````

Now, our Validator component only depends on the memo of `name` and `email`, and not their contents. Notice how we started by splitting our UI *first* and *then* state. It's generally better to centralize our state primitives and pass down derived values where possible.

## Decaying Readable Types to ReadSignal

If you look closely at the `Validator` component, you might notice it currently takes a `Memo` type for an argument. Of course, that's the type `use_memo` returns! However, requiring the `Memo` type limits how we can use this component. Practically speaking, we don't *need* a Memo. Our `Validator` just wants a `bool`. And indeed, we can simply accept a bool:

````rust
#[component]
fn Validator(is_valid: bool) -> Element {
    rsx! {
        if !is_valid { "Invalid name or email" }
    }
}
````

Unfortunately, Rust primitives are *not* reactive types. When you read or write to a primitive - or any other types that aren't reactive - reactive contexts can't subscribe to their changes. Only reactive types like Signal, Memo, Resource, and ReadSignal will participate in the Dioxus reactivity system.

For example, an effect that logs whenever the validation state changes *won't fire* with the plain `is_valid` boolean as an argument.

````rust
// âŒ is_valid is untracked, and our effect won't work properly
#[component]
fn Validator(is_valid: bool) -> Element {
    use_effect(move || log!("validity change: {is_valid}"));
    rsx! {
        if !is_valid { "Invalid name or email" }
    }
}
````

How should you define your component's props such that it accepts *any* reactive value?

To solve this, Dioxus implements `Into<ReadSignal>` for all Readable reactive types. If a type allows you to `.read()` it, it will also automatically convert to a read-only handle of the inner value.

To fix our `Validator` component, we simply wrap `is_valid` in a `ReadSignal`:

````rust
// âœ… is_valid is reactive!
#[component]
fn Validator(is_valid: ReadSignal<bool>) -> Element {
    use_effect(move || log!("validity change: {is_valid}"));
    rsx! {
        if !is_valid { "Invalid name or email" }
    }
}
````

Now, parent components that use this child component can use any Readable reactive primitive as the value, allowing our original example to work properly.

````rust
// âœ… is_valid can be passed from a memo or a signal
#[component]
fn EmailAndName() -> Element {
    let mut name = use_signal(|| "name".to_string());
    let mut email = use_signal(|| "email".to_string());
    let is_valid = use_memo(move || validate_name_and_email(name, email));

    rsx! {
        Validator { is_valid }
        div { class: if !is_valid() { "border-red" },
            input { oninput: move |e| name.set(e.value()) }
            input { oninput: move |e| email.set(e.value()) }
        }
    }
}
````

We call this process of converting a read-write type into a read-only type "decaying". The read-only handle is arguably less useful than a full read-write handle, but has wider compatibility and is easier to reason about.

## Automatic Conversion to ReadSignal

For our `Validator` component above, we showed how any Readable reactive type like `Signal` and `Memo` automatically "decay" into `ReadSignal`. However, what if we wanted to pass just a plain boolean value?

````rust
#[component]
fn EmailAndName() -> Element {
    rsx! {
        Validator { is_valid: true }
    }
}
````

Again, `ReadSignal` saves the day! When using components, any untracked values passed as properties automatically implement `Into<ReadSignal>`. This is extremely powerful. We can upgrade plain primitive values into reactive values without boilerplate.

````rust
// âœ… this component accepts memos, signals, and even primitive values!
#[component]
fn Validator(is_valid: ReadSignal<bool>) -> Element {
    rsx! {
        if !is_valid { "Invalid name or email" }
    }
}
````

This super-power comes in most useful when doing computations in expressions at the callsite. For example, we might choose not to memoize the validator logic, and instead simply run it inline:

````rust
#[component]
fn EmailAndName() -> Element {
    let mut name = use_signal(|| "name".to_string());
    let mut email = use_signal(|| "email".to_string());

    rsx! {
        Validator { is_valid: validate_name_and_email(name, email) }
        input { oninput: move |e| name.set(e.value()) }
        input { oninput: move |e| email.set(e.value()) }
    }
}
````

As a general rule, it's best to wrap every readable component property in a `ReadSignal`. This ensures every prop is automatically reactive and is maximally compatible with the rest of the Dioxus ecosystem.

## Hoisting Callbacks

In Dioxus, the `Signal` object is both a reader *and* a writer. We designed signals to be ergonomic and conceptually straightforward: to read the value, you use `.read()`, and to write the value, you use `.write()`. This makes the basic `Signal` type extremely powerful.

If you're not careful with hoisting state, you might eventually try to build a component that takes a mutable signal as an argument:

````rust
// âŒ Mutable props are bad!
#[component]
fn Incrementer(mut sig: Signal<i32>) -> Element {
    rsx! {
        button {
            onclick: move |_| sig += 1,
            "Increment"
        }
    }
}
````

While this may compile (with warnings!), we actively discourage the usage of mutable data in component props since it breaks the foundation of one-way data-flow.

Instead, Dioxus gives you the ability to use callbacks instead, allowing the *caller* to handle updates to state, not the *callee*. Instead of mutating the count in the `Incrementer` component, you should expose an `onclick` callback and let the parent component handle updating state.

````rust
// âœ… Use callbacks instead!
#[component]
fn Parent() -> Element {
    let mut count = use_signal(|| 0);
    rsx! {
        Incrementer {
            onclick: move |_| count += 1,
        }
    }
}

#[component]
fn Incrementer(onclick: EventHandler<MouseEvent>) -> Element {
    rsx! {
        button {
            onclick: move |e| onclick.call(e),
            "Increment!"
        }
    }
}
````

To make hoisting callbacks even more ergonomic, Dioxus allows shorthand property declaration of element attributes and event listeners:

````rust
#[component]
fn Incrementer(onclick: EventHandler<MouseEvent>) -> Element {
    rsx! {
        button { onclick, "Increment!" }
    }
}
````

In the case where your hoisted callback needs to return a value, you can use the `Callback` type directly which accepts both arguments and return value as generics:

````rust
#[component]
fn CallbackChild(onclick: Callback<MouseEvent, String>) -> Element {
    let mut current = use_signal(|| "".to_string());
    rsx! {
        // onclick.call() accepts a MouseEvent and returns a String
        button {
            onclick: move |e| current.set(onclick.call(e)),
            "Set Value"
        }
    }
}
````

By hoisting mutation as callbacks, our child components are naturally more modular and simple to reason about.
# Global Context

By now, you have the requisite knowledge to build large Dioxus apps! When your component tree grows to several layers deep, passing state through component props can be become tedious and repetitive.

````rust
fn app() -> Element {
    let name = use_signal(|| "bob".to_string());
    rsx! { Container { name } }
}

#[name]
fn Container(name: Signal<String>) -> Element {
    rsx! { Content { name } }
}

#[name]
fn Content(name: Signal<String>) -> Element {
    rsx! { Title { name } }
}

#[name]
fn Title(name: Signal<String>) -> Element {
    rsx! { h1 { "{name}" } }
}
````

Passing state through several layers of component properties is called "prop drilling." Wouldn't it be great if we could pass the `name` signal from the app root *directly* to the Title component?

This is where *global context* becomes useful. Components can insert values into the global context, allowing and any child components to "reach up" and read those values.

![Context Tree](/assets/07/context-tree.png)

Note that context is only available by "reaching up" the tree. Recall a fundamental pillar of reactivity: data flows down. In the one-way data-flow model, child components can freely read the state of their parent components. You can think of context as an invisible extra argument passed through the properties of each component from the root to every child.

````rust
fn Child(context: Context, ..props) -> Element { /* */ }
````

Context is roughly defined as a recursive definition of itself:

````rust
struct Context {
    contexts: Vec<Rc<dyn Any>>
    parent: Option<Context>,
}
````

When we "reach up" through the tree, we first walk the current component's context list, and then check each parent recursively until the target context is found.

## Providing and Consuming Context

Before we can start reaching up the component tree, we first need to *provide* context to child components. Dioxus exposes the `provide_context` and `use_context_provider` functions. You typically place your state initializer in the `use_context_provider` hook like so:

````rust
fn app() -> Element {
    // use_context_provider takes an initializer closure
    use_context_provider(|| "Hello world!".to_string());

    rsx! { Child {} }
}
````

Now, to read the context, we pair the provider with a consumer. To do so, we call `use_context` and set the return type to be the same type as the context we provided. In the example above, we provided a `String` type object; therefore, we consume it with the `String` generic:

````rust
fn Child() -> Element {
    let title = use_context::<String>();
    rsx! { "{title}" }
}
````

The `::<String>` syntax declares the return type of this use of `use_context`. In Dioxus, context objects are indexed by their [TypeId](https://doc.rust-lang.org/std/any/struct.TypeId.html). A type's TypeId is a  compile-time hash that uniquely identifies every Rust type. No two types will share the same TypeId unless the refer to the same underlying type declaration - ie, [type aliases](https://doc.rust-lang.org/reference/items/type-aliases.html) will share the same TypeId.

When providing context objects, we should wrap the data we want to store in a custom type or [new type](https://doc.rust-lang.org/rust-by-example/generics/new_types.html). This ensures that we can store multiple `String` objects in the context tree and retrieve them by their wrapper type.

Declaring a new type requires a new struct declaration:

````rust
#[derive(Clone)]
struct Title(String);

#[derive(Clone)]
struct Subtitle(String);
````

Then, we can provide the context using our wrapper types:

````rust
use_context_provider(|| Title("Hello world!".to_string()));
use_context_provider(|| Subtitle("Hello world!".to_string()));
````

To consume the context, we pass in the appropriate struct type:

````rust
let title = use_context::<Title>();
let subtitle = use_context::<Subtitle>();
````

In practice, you don't need to wrap *every* field of your state in a newtype, usually just one struct to encapsulate a set of data is enough.

````rust
#[derive(Clone)]
struct HeaderContext {
    title: String,
    subtitle: String
}
````

## Context Provider Components

Sometimes you don't want context to apply to *every* component in your tree - just a subset is fine. If you want to provide state to a scoped portion of the elements in your `rsx!` macro, you can create a new component that provides context to its children called a **Context Provider**.

For example, we may write a `ThemeProvider` component that wraps its children and provides context:

````rust
#[component]
fn ThemeProvider(children: Element, color: ThemeColor) -> Element {
    use_context_provider(|| ThemeState::new(color));
    children
}
````

Then, we can use the context provider in our RSX multiple times, but with different parameters:

````rust
fn app() -> Element {
    rsx! {
        ThemeProvider {
            color: ThemeColor::Red,
            h1 { "Red theme!" }
        }
        ThemeProvider {
            color: ThemeColor::Blue,
            h1 { "Blue theme!" }
        }
    }
}
````

## Dynamically Providing and Consuming Context

Dioxus provides several different functions to provide and consume context. You do not necessarily need to use the `use_context` and `use_context_provider` hooks. Instead, you can dynamically provide and consume context *at runtime* with `provide_context` and `consume_context`.

Being able to dynamically consume context is powerful. We can directly access context in event handlers and async tasks without an additional hook.

````rust
fn ToggleTheme() -> Element {
    // no hooks required!
    rsx! {
        button {
            onclick: move |_| consume_context::<ThemeProvider>().set_theme(ThemeColor::Red),
            "Make Red"
        }
        button {
            onclick: move |_| consume_context::<ThemeProvider>().set_theme(ThemeColor::Blue),
            "Make Blue"
        }
    }
}
````

Because the Dioxus runtime always sets the theme context when running handlers and polling futures, this even works in async tasks:

````rust
rsx! {
    button {
        onclick: move |_| async move {
            let color = fetch_random_color().await;
            consume_context::<ThemeProvider>().set_theme(color);
        },
        "Make Random Color"
    }
}
````

Note that we can also dynamically provide context too, though this is less useful. Whenever we dynamically provide context, the current component's context entry is replaced (if it existed).

````rust
use_context_provider(|| ThemeProvider::new());
rsx! {
    button {
        onclick: move |_| dioxus::core::provide_context(ThemeProvider::reset()),
        "Reset Theme Provider"
    }
}
````

Replacing context is *not* a reactive operation which inherently limits its usefulness.

## Providing Signals

So far, we've only demonstrated how to provide simple values like Strings. As mentioned above, dynamically replacing context is not a reactive operation, so we shouldn't use it to update state in our application.

To make our context fully reactive, we should provide signals. Typically, you'll bundle a collection of signals together into a larger state object:

````rust
#[derive(Clone, Copy)]
struct HeaderContext {
    title: Signal<String>,
    subtitle: Signal<String>
}
````

Notice how our `HeaderContext` derives both `Clone` and `Copy`. For context to be shared throughout the component tree, each context entry must implement `Clone`. Dioxus signals are extremely ergonomic because they implement `Copy` too, which makes them easier to work with in async contexts. Similarly, our custom context structs can also implement `Copy` and gain the same ergonomic benefits.

To construct our HeaderContext, we use one of two approaches. The first is to build a Provider component:

````rust
#[component]
fn HeaderProvider(children: Element) -> Element {
    // create signals with `use_signal`
    let title = use_signal(|| "Title".to_string());
    let subtitle = use_signal(|| "Subtitle".to_string());

    // And then use them to build the HeaderContext directly
    use_context_provider(|| HeaderContext { title, subtitle });

    children
}
````

The second approach is to use `Signal::new()` directly, either in a `HeaderContext::new()` method or a `use_header_provider` function. The advantage here is that users can provide `HeaderContext` without needing to wrap their RSX elements.

````rust
fn app() -> Element {
    use_context_provider(|| HeaderContext::new());

    // ...
}

impl HeaderContext {
    fn new() -> HeaderContext {
        HeaderContext {
            title: Signal::new("Title")
            subtitle: Signal::new("Subtitle")
        }
    }
}
````

Using `new` methods is idiomatic Rust and lets us customize the initial parameters used to build the context.

When we bundle signals in a struct, we can make working with state a bit easier by adding accessor and mutation methods.

````rust
impl HeaderContext {
    pub fn reset(&mut self) {
        self.title.set("".to_string());
        self.subtitle.set("".to_string());
    }

    pub async fn fetch(&mut self) {
        let data = api::fetch_header_info().await;
        self.title.set(data.title);
        self.subtitle.set(data.subtitle);
    }

    pub fn uppercase_title(&self) -> String {
        self.title.cloned().to_ascii_uppercase()
    }
}
````

Now, when we want to interact with the header context, we use its methods:

````rust
let mut header = use_context::<HeaderContext>();

rsx! {
    h1 { "{header.uppercase_title()}" }
    button { onclick: move |_| header.reset(), "Reset" }
    button { onclick: move |_| header.fetch(), "Fetch New" }
}
````

With context and signals, you should have all the tools required to architect large reactive Dioxus apps. These simple primitives compose into a complete first-party state solution. You can say goodbye to libraries like [Redux](https://redux.js.org) and [Mobx](https://mobx.js.org/README.html)!

## Global Signals

We're not done with global state *just* yet! Dioxus provides an enhancement to the "signals in context" pattern with **global signals**. Global signals are signals available to *every* component in your application. Global signals are automatically mounted to the root component of your app.

Because the `GlobalSignalProvider` is automatically mounted to your app, you don't need to call `use_context_provider`. To create a new global signal, you use the `Signal::global` initializer in a `static`.

````rs@guide_state.rs
static SONG: GlobalSignal<String> = Signal::global(|| "Drift Away".to_string());
````

And then read and write to it from anywhere:

````rs@guide_state.rs
#[component]
fn Player() -> Element {
    rsx! {
        h3 { "Now playing {SONG}" }
        button {
            onclick: move |_| *SONG.write() = "Vienna".to_string(),
            "Shuffle"
        }
    }
}
````

GlobalSignals are only global to one app - not the entire program. This means that in "multitenant" environments like server-side-rendering and multi-window desktop, every app gets its own *independent* global signal value.

````rust
// every separate instance of the app receive its own "COUNT" GlobalSignal
static COUNT: GlobalSignal<i32> = Signal::global(|| 0);

fn app() -> Element {
    rsx! {
        div { "{COUNT}" }
        button { onclick: move |_| *COUNT.write() += 1 }
    }
}
````

While it may seem like `COUNT` is synchronized across *every* running app, it actually is just local to one app at a time. Global signals are roughly implemented as a HashMap of global signal key to value where the key is a unique compile-time identifier per instance.

In addition to global signals, you can also have global memos with GlobalMemo. These are similar to regular memos, allowing you to incrementally compute new values as the inner reactive values are updated.

````rust
static COUNT: GlobalSignal<i32> = Signal::global(|| 0);
static DOUBLE_COUNT: GlobalMemo<i32> = Memo::global(|| COUNT.cloned() * 2);

fn app() -> Element {
    rsx! {
        div { "count: {COUNT}" }
        div { "double: {DOUBLE_COUNT}" }
        button { onclick: move |_| *COUNT.write() += 1 }
    }
}
````

Note that the types for GlobalSignal and GlobalMemo are actually `Global<Signal<T>>` and `Global<Memo<T>>` - if you implemented the required traits, you can make any custom reactive type globally available!
# Reactive Stores and Collections

The `Signal` object is great for making your application state reactive. So far, we've demonstrated how signals can make any type reactive simply by wrapping its initializer in a `use_signal` hook:

````rust
let mut count: Signal<i32> = use_signal(|| 0);
````

Whenever we call `.read()` or `.write()` on the signal, we can easily access and modify the underlying value and queue components to be re-rendered.

As your data structures evolve, you might run into new challenges. Some questions you might ask:

* "How do I add reactivity to types I don't own?"
* "What exactly re-renders when I modify just *one* entry in a collection?"
* "What if I can't wrap every value in my app in a signal?"

As our apps become more interesting, we're more likely to pull in third-party libraries and organize our state into collections like HashMaps, BTrees, and Vectors. In these cases, we need to interact with data structures *we don't own.*

To make working with structs and collections easier, Dioxus provides the **Store**.

## Reactive Stores

In Dioxus, reactive stores are types that isolate reactivity to just a path in a data structure. Stores allow us to "zoom in" on a smaller portion of our data, ignoring all other reads and writes.

The simplest stores are structs that derive a `Store` trait:

````rust
#[derive(Store)]
struct HeaderState {
    title: String,
    subtitle: String
}
````

To use stores as state, we use the `use_store` hook:

````rust
let header = use_store(|| HeaderState {
    title: "Hello, ".to_string(),
    subtitle: "world!".to_string(),
});
````

The `Store` derive macro generates additional methods on `Store<HeaderState>` that allow us to "zoom in" to fields of the struct. We access the fields by calling the field name like a method:

````rust
fn app() -> Element {
    let header = use_store(|| HeaderState {
        title: "Hello, ".to_string(),
        subtitle: "world!".to_string(),
    });

    // we can "zoom in" with the generated `.title()` method.
    let title = header.title();

    rsx! { "{title}" }
}
````

The `.title()` method returns an object called a "lens". Lenses are not unique to Dioxus -  they are common throughout functional programming and web development.

### The `Store<Value, Lens>` type

When we use the `.title()` method, we're creating a new `Store` object, but with an additional generic parameter that specifies how the lens "zooms in" on our state. Lenses are zero-cost, meaning that the cost of using the `.title()` method is the same as indexing the struct directly with `.title`. One side-effect is that the generic type can't be explicitly "named" or specified:

````rust
// the second generic is the unique type of the lens
let title: Store<HeaderState, _> = header.title();
````

Notice how the default `Store` we get from `use_store` has an elided default generic argument:

````rust
let title: Store<HeaderState> = use_store(|| HeaderState::new());
````

Because the lens is "unnamable", we need to accept the lens as a generic in any functions that work with stores. If we only need to read the store, we can require the lens implements the `Readable` trait. If we need to write to the store, we can require the lens implements the `Writable` trait.

````rust
// This function works with any lens that can read the header state like ReadStore<HeaderState> or Store<HeaderState, _>
fn get_title(state: Store<HeaderState, impl Readable<Target = HeaderState>>) -> String {
    state.title().cloned()
}

// This function works with any lens that can write to the header state like Store<HeaderState> or Store<HeaderState, _>
fn clear_title(state: Store<HeaderState, impl Writable<Target = HeaderState>>) {
    state.title().take();
}
````

On the component boundary, Stores are automatically boxed and converted to `ReadSignal` or `ReadStore` as needed so you don't need to worry about the lens type:

````rust
fn app() -> Element {
    let header = use_store(|| HeaderState {
        title: "Hello, ".to_string(),
        subtitle: "world!".to_string(),
    });

    rsx! {
        // the lens returned by `.title()` decays into a `ReadSignal` automatically!
        Title { title: header.title() }
        // the lens returned by `.subtitle()` decays into a `ReadStore` automatically!
        Subtitle { subtitle: header.subtitle() }
    }
}

#[component]
fn Title(title: ReadSignal<String>) -> Element {
    // ..
}

#[component]
fn Subtitle(subtitle: ReadStore<String>) -> Element {
    // ..
}
````

### Stores are Readable and Writable

The `Store` type implements the same `Readable` and `Writable` traits that signals implement, allowing us to use stores and lenses just like signals:

````rust
// we can use `.read()`
let title = header.title().read();

// we can use `.write()`
*header.title().write() = "goodbye".to_string();

// we can use `.set()`
header.title().set("goodbye!".to_string());
````

Stores and lenses also implement the same `Readable` and `Writable` extension traits, allowing us to work with them like regular Rust values:

````rust
fn app() -> Element {
    let mut header = use_store(|| HeaderState {
        title: "Hello, ".to_string(),
        subtitle: "world!".to_string(),
    });

    rsx! {
        // Stores implement display
        h3 { "{header.title()}" }

        // They are `Copy`, making them easy to share between scopes
        button { onclick: move |_| header.title().write().clear() }
    }
}
````

### Nested Stores

Stores can also be nested, allowing lenses to "see through" multiple levels of datastructures:

````rust
#[derive(Store)]
struct HeaderState {
    title: String,
    subtitle: String,
    other: OtherHeaderState,
}

#[derive(Store)]
struct OtherHeaderState {
    title2: String,
    subtitle2: String,
}

// now we can "zoom in" to nested fields:
let title2 = header.other().title2();
````

The ability for a store to "zoom in" through nested datastructures is dependent on whether or not types also implement `Store`. If, for example, or nested structs *didn't* implement the `Store` trait, then we can't lens them:

````rust
#[derive(Store)]
struct HeaderState {
    title: String,
    subtitle: String,
    other: OtherHeaderState,
}

struct OtherHeaderState {
    title2: String,
    subtitle2: String,
}

// âŒ we *can't* lens the OtherHeaderState
let title2 = header.other().title2();
````

It's important to know that stores can't lens through types that don't implement `Store`. When working with 3rd-party APIs and datastructures, foreign structs typically don't implement the `Store` trait, meaning we can't make them entirely reactive.

### Result, Option, and enumerated Lenses

Some fields of our store may be an enumerated value, like a [Result](https://doc.rust-lang.org/std/result/) or an [Option](https://doc.rust-lang.org/std/option/). Stores provide a few helpful extension methods that make working with the enum easier and make the enum itself reactive.

We can update our header example to include both `Result` and `Option` types:

````rust
#[derive(Store)]
struct HeaderState {
    title: Result<String, String>,
    subtitle: Option<String>,
}
````

Just like regular `Result` and `Option`, store lenses also implement `.unwrap()` (and a number of utility methods).

````rust
let title = header.title().unwrap();
let subtitle = header.subtitle().unwrap();
````

To properly gain access to the underlying `Option<String>` we can use one of two approaches:

* The `.transpose()` method which converts `Store<Option<String>>` to `Option<Store<String>>`
* Using `.read().as_ref()`

The `.transpose()` approach is useful since we keep the lens, allowing us to "zoom in" to nested structs and collections.

````rust
let len = match header.subtitle().transpose() {
    Some(subtitle) => subtitle.read().len(),
    None => 0,
};
````

Alternatively, we can use `.as_ref()` the lens to gain access to the underlying value, but we lose the ability to reactively "zoom in" further:

````rust
let len = match header.subtitle().as_ref() {
    Some(subtitle) => subtitle.chars().count(),
    None => 0,
};
````

You can usually choose either approach - just know that using `.as_ref()` calls `.read()` internally, and the "reactivity zoom" might not be perfectly precise.

## Reactive Collections

You might be wondering: "what's the best way to handle HashMaps and Vectors in signals?" So far, we've only showcased simple state in signals, like strings and integers. Just like strings and integers, you can place collections directly into signals:

````rust
type UserId = i32;
struct UserData {
    name: String,
    email: String,
}

let mut users = use_signal(|| HashMap::<UserId, UserData>::new());

rsx! {
    ul {
        for (id, data) in users.read().iter() {
            li { key: "{id}", "{data.name}" }
        }
    }
}
````

For small apps, this is usually fine. However, we might eventually want to move the `li {}` element into its own component. Unfortunately, we'll immediately run into lifetime issues with the `GenerationalRef` guard returned by `.iter()`:

````rust
// âŒ This won't compile!
fn app() -> Element {
    let mut users = use_signal(|| HashMap::<UserId, UserData>::new());

    rsx! {
        // the lifetime here is is not `'static` won't pass to the ListItem component
        for (id, user) in users.read().iter() {
            ListItem { key: "{id}", user }
        }
    }
}

// `UserData` cannot be borrowed here
#[component]
fn ListItem(user: ReadSignal<UserData>) -> Element {
    rsx! {
        li { "{user.read().name}" }
    }
}
````

In these scenarios, we have a few options:

* Deeply clone the `UserData` object, detaching its lifetime from the `for` loop
* Clone individual fields of the `UserData` object
* Use Stores and pass a Lens

The first two options require us to perform potentially expensive clones when rendering our component. Instead, we can use stores and lenses to find a zero-cost solution, simply by converting our `use_signal` to a `use_store` call:

````rust
fn app() -> Element {
    // switch to using `use_store`
    let mut users = use_store(|| HashMap::<UserId, UserData>::new());

    rsx! {
        for (id, user) in users.iter() {
            ListItem { key: "{id}", user }
        }
    }
}

// And now we can accept a `ReadSignal<UserData>` as a prop
#[component]
fn ListItem(user: ReadSignal<UserData>) -> Element {
    rsx! {
        li { "{user.read().name}" }
    }
}
````

The `Store<HashMap<K, V>>` type is a special type that implements reactivity on a per-entry basis. When we insert or remove values from the `users` store, only *one* re-render is queued. If we edit an individual entry in the HashMap, only a single `ListItem` will re-render.

Alternatively, we could derive `Store` on our `UserData` type, and accept `ReadStore<UserData>` allowing us to further lens into specific fields of our UserData entry:

````rust
#[derive(Store)]
struct UserData {
    name: String,
    email: String,
}

fn app() -> Element {
    let users = use_store(|| HashMap::<UserId, UserData>::new());

    rsx! {
        for (id, user) in users.iter() {
            ListItem { key: "{id}", user }
        }
    }
}

#[component]
fn ListItem(user: ReadStore<UserData>) -> Element {
    rsx! {
        li { "{user.name()}" }
    }
}
````

## Extending Stores with Methods

You can extend your store types with methods with the `#[store]` attribute macro. Methods inside the macro are converted into an extension trait that is automatically implemented for `Store<T, Lens>`. The macro will automatically add bounds to the `Lens` generic based on the self parameter of the method. If the method takes `&self`, the `Lens` will be bound by `Readable`. If the method takes `&mut self`, the `Lens` will be bound by `Writable`.

````rust
type MappedUserDataStore<Lens> = Store<String, MappedMutSignal<String, Lens, fn(&UserData) -> &String, fn(&mut UserData) -> &mut String>>;

#[store]
impl<Lens> Store<UserData, Lens> {
    // This will automatically require `Readable` on the lens since it takes `&self`
    fn user_email(&self) -> String {
        self.email().cloned()
    }

    // This will automatically require `Writable` on the lens since it takes `&mut self`
    fn clear_name(&mut self) {
        self.name().take();
    }

    // This method does not require any bounds on the lens since it takes `self`
    fn into_parts(self) -> (MappedUserDataStore<Lens>, MappedUserDataStore<Lens>) where Self: Copy {
        (self.email(), self.name())
    }
}
````

## Making the Most of Stores

Hopefully, the examples here highlight when stores might be useful in your applications. It might be tempting to use stores *everywhere*, but in many cases, signals and structs are good enough. Most apps won't run into performance issues where precise control over the reactivity of struct fields makes a huge difference.

Stores are most useful when interfacing with foreign data types and optimizing huge collections - not something you need to do every day!
# Error handling

A major selling point of using Rust for web development its renowned reliability. A common sentiment by developers deploying Rust services:

 > 
 > "We deployed our Rust service and then forgot about it because it just kept running without any issues"

Rust provides developers powerful tools to track where errors occur and easy ways to handle them. Similarly, in Dioxus, we provide additional tools like early returns, a special RenderError type, and ErrorBoundaries to help you handle errors in a declarative way.

## Returning Errors from Components

Recall that Dioxus components are functions that take props and return an `Element`. Astute observers might recognize that the `Element` type is actually a type alias for `Result<VNode, RenderError>`!

The `RenderError` type can be created from an error type that implements `Error`. You can use `?` to bubble up any errors you encounter while rendering to the nearest error boundary:

````rs@error_handling.rs
#[component]
fn ThrowsError() -> Element {
    // You can return any type that implements `Error`
    let number: i32 = use_hook(|| "1.234").parse()?;

    todo!()
}
````

The [`RenderError`](https://docs.rs/anyhow/latest/anyhow/) is special error type that is an enum of either `Error(CapturedError)` or `Suspended(SuspendedFuture)`. A `RenderError` automatically implements `From<CapturedError>` which implements `From<anyhow::Error>`.

````rust
/// An error that can occur while rendering a component
#[derive(Debug, Clone, PartialEq)]
pub enum RenderError {
    /// The render function returned early due to an error.
    ///
    /// We captured the error, wrapped it in an Arc, and stored it here. You can no longer modify the error,
    /// but you can cheaply pass it around.
    Error(CapturedError),

    /// The component was suspended
    Suspended(SuspendedFuture),
}
````

Because `RenderError` can be automatically coerced from an `anyhow::Error`, we can use anyhow's `Context` trait to bubble up any error while rendering:

````rust
fn Counter() -> Element {
    let count = "123".parse::<i32>().context("Could not parse input")?;

    // ...
}
````

## CapturedError, RenderError, and anyhow::Error

Through the entire stack, Dioxus has many different error types. The large quantity can lead to some confusion.

### anyhow::Error

Unlike many other libraries, Dioxus uses the `anyhow::Error` as its core error type. In many APIs that take user code - like callbacks, actions, and loaders - you can cleanly use anyhow's Error type:

````rust
let mut breed = use_action(move |breed| async move {
    let res = reqwest::get(format!("https://dog.ceo/api/breed/{breed}/images/random"))
        .await
        .context("Failed to fetch")?
        .json::<DogApi>()
        .await
        .context("Failed to deserialize")?;

    anyhow::Ok(res)
});
````

Many APIs also either take or return an anyhow error. You can use `anyhow::Result` as the result type for a server function:

````rust
#[get("/dogs")]
async fn get_dogs() -> anyhow::Result<i32> {
    Ok(123)
}
````

The anyhow crate provides an ergonomic, dynamic error type that can ingest any errors that implement the `std::Error` trait. We chose to use anyhow's error type since it cleanly integrates with the broader Rust ecosystem. GUI apps can encounter many different types of errors along the way, and only a few are worth handling completely with a dedicated variant.

If you need to downcast the anyhow error to a specific error type, you can use `.downcast_ref::<T>()`. Other utilities like `.context()`, `anyhow!()`, and `bail!()` work seamlessly with the rest of Dioxus

### Captured Error

A `CapturedError` is a transparent wrapper type around anyhow's Error that makes it implement the `Clone` trait. The implementation is quite simple:

````rust
#[derive(Debug, Clone)]
pub struct CapturedError(pub Arc<anyhow::Error>);
````

The `CapturedError` type is useful when you need to call `.clone()` on the error, as is required by `use_resource`. The hook `use_resource` requires that the output by `Clone` - but the default `anyhow::Error` type is *not*.

In cases where you need a concrete error type, like in loaders and actions, consider using `dioxus::Ok()` which will return a `Result<T, CapturedError>`:

````rust
let value = use_resource(|| async move {
    let res = fetch("/dogs")?;
    dioxus::Ok(res)
});
````

## Capturing errors with ErrorBoundaries

In JavaScript, you might have used `try` and `catch` to throw and catch errors in your code:

````js
try {
    // Some code that might throw an error
    let result = riskyOperation();
    console.log(result);
} catch (error) {
    // Handle the error
    console.error("Something went wrong:", error.message);
}
````

In Dioxus, you can take a similar try/catch approach within the component tree with error boundaries. Error boundaries let you catch and handle errors produced while rendering our app.

[Error Boundaries](/assets/07/error-boundaries.png)

When you return an error from a component, it gets thrown to the nearest error boundary. That error boundary can then handle the error and render a fallback UI with the handle_error closure:

````rs@error_handling.rs
#[component]
fn Parent() -> Element {
    rsx! {
        ErrorBoundary {
            // The error boundary accepts a closure that will be rendered when an error is thrown in any
            // of the children
            handle_error: |_| {
                rsx! { "Oops, we encountered an error. Please report this to the developer of this application" }
            },
            ThrowsError {}
        }
    }
}
````

## Throwing Errors from Event Handlers

In addition to components, you can throw errors from event handlers. If you throw an error from an event handler, it will bubble up to the nearest error boundary just like a component:

````rs@error_handling.rs
#[component]
fn ThrowsError() -> Element {
    rsx! {
        button {
            onclick: move |_| {
                // Event handlers can return errors just like components
                let number: i32 = "1...234".parse()?;

                tracing::info!("Parsed number: {number}");

                Ok(())
            },
            "Throw error"
        }
    }
}
````

This is useful when handling async work or work that fails frequently.

## Adding context to errors

You can add additional context to your errors with anyhow's [`Context`](https://docs.rs/anyhow/latest/anyhow/trait.Context.html) trait. Calling `context` on a `Result` will add the context to the error variant of the `Result`:

````rs@error_handling.rs
#[component]
fn ThrowsError() -> Element {
    // You can call the context method on results to add more information to the error
    let number: i32 = use_hook(|| "1.234")
        .parse()
        .context("Failed to parse name")?;

    todo!()
}
````

If you need to show some specific UI for the error, we recommend wrapping the error in a custom type and then downcasting when it's caught.

## Downcasting Specific Errors

When handling errors in Error Boundaries, you can match on specific types of errors, optionally choosing to capture the error and prevent it from bubbling.

By default, errors are caught by the nearest Error Boundary. In some scenarios, we might not want to catch a specific type of error, like a NetworkError.

In our handler code, we can use with `.error()` to get the current error and then re-throw it if necessary:

````rust
rsx! {
    ErrorBoundary {
        handle_error: |error: ErrorContext| {
            // Network errors need to be handled by a different error boundary!
            if let Some(err) = error.error() {
                return Err(e.into())
            }

            // Otherwise, handle this error here
            rsx! {
                div { "Oops, we encountered an error" }
            }
        },
        // ...
    }
}
````

## Local Error Handling

If you need more fine-grained control over error states, you can store errors in reactive hooks and use them just like any other value. For example, if you need to show a phone number validation error, you can store the error in a memo and show it below the input field if it is invalid:

````rs@error_handling.rs
#[component]
pub fn PhoneNumberValidation() -> Element {
    let mut phone_number = use_signal(|| String::new());
    let parsed_phone_number = use_memo(move || phone_number().parse::<PhoneNumber>());

    rsx! {
        input {
            class: "border border-gray-300 rounded-md p-2 mb-4",
            placeholder: "Phone number",
            value: "{phone_number}",
            oninput: move |e| {
                phone_number.set(e.value());
            },
        }

        match parsed_phone_number() {
            Ok(phone_number) => rsx! {
                div {
                    "Parsed phone number: {phone_number}"
                }
            },
            Err(error) => rsx! {
                div {
                    "Phone number is invalid: {error}"
                }
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    error_handling::PhoneNumberValidation {}
}
````
# Suspense

[Resources](../basics/resources.md) let you load data asynchronously in Dioxus, but it can be cumbersome to handle the loading state of each resource individually. Dioxus provides a `SuspenseBoundary` component to group multiple asynchronous tasks and show a loading view while any of them are suspended.

You can create a `SuspenseBoundary` with a loading closure and children. Then you can call `.suspend()?` on any resource inside the children to pause rendering of that component until the future is finished. The suspense boundary will show the loading view while any of its children are suspended. Once that suspense is resolved, it will show the children again.

We can use a suspense boundary to show a grid of different breeds of dogs without handling each loading state individually:

````rs@asynchronous.rs
fn DogGrid() -> Element {
    rsx! {
        SuspenseBoundary {
            // When any child components (like BreedGallery) are suspended, this closure will
            // be called and the loading view will be rendered instead of the children
            fallback: |_| rsx! {
                div {
                    width: "100%",
                    height: "100%",
                    display: "flex",
                    align_items: "center",
                    justify_content: "center",
                    "Loading..."
                }
            },
            div {
                display: "flex",
                flex_direction: "column",
                BreedGallery {
                    breed: "hound"
                }
                BreedGallery {
                    breed: "poodle"
                }
                BreedGallery {
                    breed: "beagle"
                }
            }
        }
    }
}

#[component]
fn BreedGallery(breed: ReadSignal<String>) -> Element {
    let response = use_resource(move || async move {
        // Artificially slow down the request to make the loading indicator easier to seer
        gloo_timers::future::TimeoutFuture::new(1000).await;
        reqwest::Client::new()
            .get(format!("https://dog.ceo/api/breed/{breed}/images"))
            .send()
            .await?
            .json::<BreedResponse>()
            .await
    })
    // Calling .suspend()? will suspend the component and return early while the future is running
    .suspend()?;

    // Then you can just handle the happy path with the resolved future
    rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            match &*response.read() {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::DogGridView {}
}
````

## Customizing the loading view from children

If you need to change the loading view while a specific task is loading, you can provide a different loading view with the `with_loading_placeholder` method. The loading placeholder you return from the method will be passed to the suspense boundary and may choose to render it instead of the default loading view:

````rs@asynchronous.rs
fn DogGrid() -> Element {
    rsx! {
        SuspenseBoundary {
            // The fallback closure accepts a SuspenseContext which contains
            // information about the suspended component
            fallback: |suspense_context: SuspenseContext| {
                rsx! {
                    div {
                        width: "100%",
                        height: "100%",
                        display: "flex",
                        align_items: "center",
                        justify_content: "center",
                        "Loading..."
                    }
                }
            },
            div {
                display: "flex",
                flex_direction: "column",
                BreedGallery {
                    breed: "hound"
                }
                BreedGallery {
                    breed: "poodle"
                }
                BreedGallery {
                    breed: "beagle"
                }
            }
        }
    }
}

#[component]
fn BreedGallery(breed: ReadSignal<String>) -> Element {
    let response = use_resource(move || async move {
        gloo_timers::future::TimeoutFuture::new(breed().len() as u32 * 100).await;
        reqwest::Client::new()
            .get(format!("https://dog.ceo/api/breed/{breed}/images"))
            .send()
            .await?
            .json::<BreedResponse>()
            .await
    })
    .suspend()?;

    // Then you can just handle the happy path with the resolved future
    rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            match &*response.read() {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::DogGridViewWithLoadingPlaceholder {}
}
````

## Suspense with Fullstack

Dioxus fullstack will wait for suspended futures during server-side rendering. This means your async data loading starts sooner and search engines can see the resolved version of your page. However, using suspense in fullstack does require some changes for hydration compatibility.

To use suspense in your fullstack application, you need to switch every suspended resource to the `use_server_future` hook. `use_server_future` handles serializing the result of the future on the server and deserializing that result on the client. It will also suspend automatically, so you don't need to call `.suspend()` on the resource.

````rs@asynchronous.rs
#[component]
fn BreedGallery(breed: ReadOnlySignal<String>) -> Element {
    // use_server_future is very similar to use_resource, but the value returned from the future
    // must implement Serialize and Deserialize and it is automatically suspended
    let response = use_server_future(move || async move {
        // The future will run on the server during SSR and then get sent to the client
        reqwest::Client::new()
            .get(format!("https://dog.ceo/api/breed/{breed}/images"))
            .send()
            .await
            // reqwest::Result does not implement Serialize, so we need to map it to a string which
            // can be serialized
            .map_err(|err| err.to_string())?
            .json::<BreedResponse>()
            .await
            .map_err(|err| err.to_string())
        // use_server_future calls `suspend` internally, so you don't need to call it manually, but you
        // do need to bubble up the suspense variant with `?`
    })?;

    // If the future was still pending, it would have returned suspended with the `?` above
    // we can unwrap the None case here to get the inner result
    let response_read = response.read();
    let response = response_read.as_ref().unwrap();

    // Then you can just handle the happy path with the resolved future
    rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            match response {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::DogGridFullstack {}
}
````

Unlike `use_resource`, `use_server_future` is only reactive in the closure, not the future itself. If you need to subscribe to another reactive value, you need to read it in the closure before passing it to the future:

````rs@asynchronous.rs
let id = use_signal(|| 0);
// âŒ The future inside of use_server_future is not reactive
use_server_future(move || {
    async move {
        // But the future is not reactive which means that the future will not subscribe to any reads here
        println!("{id}");
    }
});
// âœ… The closure that creates the future for use_server_future is reactive
use_server_future(move || {
    // The closure itself is reactive which means the future will subscribe to any signals you read here
    let cloned_id = id();
    async move {
        // But the future is not reactive which means that the future will not subscribe to any reads here
        println!("{cloned_id}");
    }
});
````

### Streaming Suspense

The default behavior for server side rendering is to wait for all suspended futures then send the fully resolved page. If you [enable](https://docs.rs/dioxus/0.7/dioxus/prelude/struct.ServeConfigBuilder.html#method.enable_out_of_order_streaming) out of order streaming, dioxus will send the finished HTML chunks to the client one at a time as they are resolved. This lets you show the loading views in your suspense boundaries while you are still waiting for other futures to resolve on the server:

````rs@asynchronous.rs
fn main() {
    dioxus::LaunchBuilder::new()
        .with_context(server_only! {
            // Enable out of order streaming during SSR
            dioxus::server::ServeConfig::builder().enable_out_of_order_streaming()
        })
        .launch(DogGrid);
}
````

![Out of order streaming](/assets/06_docs/streaming_dogs.mp4)

For more information on streaming, see the [streaming documentation](../../essentials/fullstack/streaming.md).
# Dioxus Fullstack

Almost all apps need a remote server to store and update user data. Dioxus provides a number of fullstack utilities for building your app's server alongisde the client. With Dioxus Fullstack, you can build *both* your app's frontend and backend entirely in Rust!

Dioxus Fullstack deeply integrates with the popular [Axum](https://docs.rs/axum/latest/axum/) framework, making it easy to quickly add complex functionality to your app, including:

* **Server-Side-Rendering**: Render HTML on the server and hydrate it on the client
* **Server Functions**: Type-safe Axum HTTP endpoints directly callable from the client
* **Hot-Reload**: Rapid Rust hot-reload during development powered by [subsecond](https://crates.io/crates/subsecond)
* **Typed Routing**: Easily extract queries and paths from the URL
* **Multi-part Forms**: Capture multipart form data from the client into typed Rust structs
* **Binary Streams**: Easily add file upload/download backend capability
* **SSE and WebSockets**: Complex, stateful datatypes for server communication
* **Asset Management**: Automatically optimizes assets for deployment to CDNs
* **WASM Support**: Deploy to WASM-based providers like Cloudflare Workers
* **Bundle Splitting**: Split apart large WASM blobs on a per-route basis
* **Static Site Generation**: Generate HTML markup perfect for blogs and static sites

Currently, Dioxus Fullstack does not provide built-in utilities for things like Databases, Caches, Sessions, and Mailers. Our current focus is to finish polishing the fullstack integration before branching out into a more "complete" fullstack solution. You'll need to pull in 3rd-party crates like `Sqlx` and `tower-sessions` to use such features. To help, we provide a [few examples in the Dioxus GitHub repo](https://github.com/DioxusLabs/dioxus/tree/main/examples/07-fullstack) to get started.

## Hot-Reload

With Dioxus, our goal is to maximize your developer productivity. Dioxus Fullstack ships with full Rust hot-reload support built-in thanks to our hot-patch engine [subsecond](https://crates.io/crates/subsecond). Subsecond uses advanced assembly and linker techniques to allow modifying Rust functions at runtime. You can add new endpoints, pages, and logic to your app without manually rebuilding.

![Dual Serve Hot-Reload](/assets/07/dual-serve-hotreload.mp4)

Subsecond currently has a few limitations. For the best experience, we recommend only modifying code in the "tip" of your app. Note that code that runs only once will not be hot-reloadable and will require a restart of the app.

## Server functions

Dioxus Fullstack provides an easy way to communicate with the server from any client. Server functions let you define a function that always runs on the server. When you call that function from the client, Dioxus will automatically serialize the arguments, send them to the server, run the function on the server, serialize the return value, and send it back to the client.

````rust
// The body of the function will always run on the server so we can do server-side operations like database queries
#[get("/api/dog/{breed}")]
async fn fetch_dog(breed: String) -> Result<String> {
    DB.execute("SELECT url FROM dogs WHERE id = ?1", &breed)
}
````

We can use the results of server functions during server-side-rendering along with hydration:

````rust
let url = use_loader(|| fetch_dog("poodle".to_string()))?;

rsx! {
    img { src: "{url}", alt: "A cute dog" }
}
````

Server functions are described in more detail in the [server functions guide](./server_functions.md). In addition to this guide, you can find more examples of fullstack apps in the [examples directory](https://github.com/DioxusLabs/dioxus/tree/main/examples).

## Websockets and Streams

Dioxus Fullstack comes with full support for Axum, and with it, special client handlers for things like WebSockets and HTTP Streams. We provide a number of utilities like `use_websocket` to reactively manage these resources on the client.

![Fullstack websockets](/assets/07/fullstack-websockets.avif)

Our `Streaming<T>` wrapper allows you to easily send arbitrary bytes, text, JSON, and chunked file contents to and from the server. Easily roll your own hybrid client-server types by implementing `IntoRequest` and `FromResponse`!

## Server Side Rendering

Dioxus Fullstack allows you to render your app on the server, speeding up load times for your users and improving your site's discoverability for search engines like Google. Server-side-rendering (SSR) allows you to render your app's initial HTML on the server, sending a fully-formed HTML document to the client. The client can then "hydrate" the HTML into a fully-interactive app that can continue running on the client without requiring a persistant server connection.

## Assets

Because Dioxus Fullstack integrates with our build tool DX, your fullstack apps come pre-optimized for deploying onto infrastructure like content-distribution-networks (CDNs). CDNs reduce your bandwidth usage and speed up your app's time-to-first byte for maximum performance. Assets bundled with DX are hashed, letting the client infinitely cache their contents.
# Project Setup

Fullstack Dioxus apps are structured a bit differently than client-only apps. This distinction has implications on how we organize our apps, requiring more care when adding dependencies and including code.

In this chapter, we'll explore how to use feature flags and cargo targets to structure our apps for fullstack development.

 > 
 > Dioxus provides a number of templates with `dx new` to automatically bootstrap new fullstack projects.
 > 
 > If you want to get started quickly, we suggest using one of the built-in templates and then heading on to next chapter.

## The Server/Client split

A "fullstack" application is actually composed of at least two distinct binaries:

* The client binary that runs the web, desktop, or mobile application
* The server binary that renders the initial HTML and runs server functions

Because our client app and server app target different platforms, we need to include different code and different dependencies. You can conceptualize the "server" as just another platform for your app, just like you might target both iOS and Android. The server will have different dependencies than the client app, and thus you need to properly configure your app's `Cargo.toml` and build flags.

## How DX builds your app

Our build tool, DX, is capable of building both the client and server of your app simultaneously. If the `--hotpatch` flag is enabled, DX will also automatically hot-reload both the client and server code in tandem.

When developing your app, you'll generally use `dx serve`. This command accepts the usual arguments you might pass to `cargo run`:

````sh
# We can customize the build's features, profile, or release mode
dx serve --features "spicy" --release

# We can specify examples, packages, and binaries
dx serve --example dogs
````

Under the hood, DX automatically detects if the target app has a server variant by checking its `Cargo.toml` for a Cargo feature called "server". In this Cargo feature, you would enable the `server` feature on Dioxus:

````toml
[features]
server = ["dioxus/server"]
````

DX will also look for specific client features (`"web"` / `"desktop"` / `"mobile"`) and enable the relevant feature depending on the target platform. DX uses the concept of "platform" to distinguish types of builds from one another.

To set a build's platform, you can use `--web`, `--desktop`, `--ios`, etc. When you specify a platform, DX also enables a corresponding feature in your Cargo.toml:

````toml
# enabled with `--web`
web = ["dioxus/web"]

# enabled with `--desktop`
desktop = ["dioxus/desktop"]

# enabled with `--mobile`
mobile = ["dioxus/mobile"]
````

Running the command might look like:

````sh
# sets target=wasm32-unknown-unknown, features="web", profile="wasm-dev"
dx serve --web

# sets target=host, features="desktop", profile="desktop-dev"
dx serve --desktop

# sets target=aarch64-apple-ios-sim, features="mobile", profile="ios-dev"
dx serve --ios
````

If your `dioxus` dependency enables the `fullstack` feature, DX recognizes this app is a fullstack app and then creates two builds, each with a separate platform:

````toml
[dependencies]
dioxus = { version = "0.7", features = ["fullstack"] }

[features]
web = ["dioxus/web"]
server = ["dioxus/server"]
````

Internally, DX splits your input command into two separate `cargo build` commands, each with a different platform.

![Server Client Split](/assets/06_docs/server_split.png)

Feature flags like these for the client and server are automatically generated by the CLI when you run `dx new` with fullstack enabled. If you are creating a project from scratch, you will need to add the feature flags manually.

 > 
 > If you are not familiar with features in rust, you can read more about feature flags in the [cargo reference](https://doc.rust-lang.org/cargo/reference/features.html).

## Customizing the Builds

A fullstack app is comprised of two separate binaries, so DX provides a way to customize each. Usually, the default `dx serve` command is sufficient, but for complex app setups that need per-target customization, you can use the `@client` and `@server` modifiers to pass target-specific cargo args to each:

````sh
dx serve \
  @client --ios --features "optimizations" \
  @server --bin server
````

This syntax makes it possible to have two separate entrypoints for our app. This can be extremely useful if you have an existing backend and would like to launch that alongside your Dioxus frontend.

By default, DX isolates your server and client builds by levaraging Cargo Profiles. Cargo profiles let us specify certain build modifiers like opt-level, debug symbols, LTO, and other optimizations.

DX will use these profiles

* `web-dev` / `web-release`: targeting the web with `--web`
* `server-dev` / `server-release`: targeting the server (implicitly, or with `--server`)
* `desktop-dev` / `desktop-release`: targeting desktop apps with `--desktop`
* `ios-dev` / `ios-release`: targeting iOS apps with `--ios`
* `android-dev` / `android-release`: targeting Android apps with `--android`

These profiles correspond 1:1 with the "platforms" DX supports. Note that a `platform` is just a way of DX to isolate two builds from each other. You can completely customize the build, including:

* `--renderer`: swap between the various 1st-party renderers (ie `--renderer native`)
* `--bundle`: the bundle format of the build (`.app`, `.apk`, `.ipa`, etc.)
* all cargo options (`--features`, `--target`, `--profile`, `--bin`, etc.)

## Adding Server Only Dependencies

Many dependencies like [`tokio`](https://docs.rs/tokio/latest/tokio/index.html) cannot be compiled to WebAssembly, and thus should only be built for the server. If these dependencies are enabled when building a WASM bundle, you will receive cryptic compilation errors. As such, we need to take care not to accidentally add server-only dependencies to our client app.

For example, if we want to interact with the filesystem in a server function, we might want to add `tokio`. The `tokio` crate provides utilities for working with async IO with abstractions like [`tokio::fs::File`](https://docs.rs/tokio/latest/tokio/fs/struct.File.html). Unfortunately, if try to add `tokio` with its `full` feature set, we will receive a compilation error:

````toml
[dependencies]
# ...
# âŒ If tokio is added as a required dependency, it will be included in both the server
# and the web bundle. The web bundle will fail to build because tokio is not
# compatible with wasm
tokio = { version = "1", features = ["full"] }
````

````sh
error[E0432]: unresolved import `crate::sys::IoSourceState`
  --> /Users/user/.cargo/registry/src/index.crates.io-6f17d22bba15001f/mio-1.0.2/src   |source.rs:14:5
14 | use crate::sys::IoSourceState;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ no `IoSourceState` in `sys`
...
````

Since we added `tokio` as a dependency for both the server and the client binary, cargo tries to compile it for each target. This fails because `tokio` is not compatible with the `wasm32-unknown-unknown` target.

To fix the issue, we can **make the dependency optional and only enable it in the server feature**:

````toml
[dependencies]
# ...
# âœ… Since the tokio dependency is optional, it is not included in client bundle.
tokio = { version = "1", features = ["full"], optional = true }

[features]
# ...
# âœ… Since the tokio dependency is enabled in the server feature, it is included in
# the server binary.
server = ["dioxus/server", "dep:tokio"]
````

Now when we build with `dx serve`, the project compiles successfully!

## Adding Client Only Dependencies

Many dependencies like [`wasm-bindgen`](https://docs.rs/wasm-bindgen/latest/wasm_bindgen/index.html) and [`web-sys`](https://docs.rs/web-sys/latest/web_sys/index.html) are only compatible with the client. Unlike server-only dependencies, these dependencies can compile on native targets, but they will panic when used outside of the browser.

You can reduce build times for your server and native binaries by including web dependencies only in the browser client binary.

Instead of adding web only dependencies to every binary in your project like this:

````toml
[dependencies]
# ...
# âŒ If web-sys is added as a required dependency, it will be included in the server,
# native, and the web bundle which makes build times longer.
web-sys = { version = "0.3.60", features = ["console"] }
````

You can make the dependency optional and only enable it in the `web` feature in your `Cargo.toml`:

````toml
[dependencies]
# ...
# âœ… Since the web-sys dependency is optional, it is not included in the server and
# native bundles.
web-sys = { version = "0.3.60", features = ["console"], optional = true }

[features]
# ...
# âœ… Since the web-sys dependency is enabled in the web feature, it is included in
# the web bundle.
web = ["dioxus/web", "dep:web-sys"]
````

## Managing Binary Specific Imports

Once you have set up binary specific dependencies, you need to adjust any of your imports to only import the dependencies when building for the binary that includes those dependencies.

For example, if `tokio` is only enabled in the server feature, you will need to import it like this:

````rs@server_tokio_import.rs
// Since the tokio dependency is only enabled in the server feature,
// we need to only import it when the server feature is enabled.
#[cfg(feature = "server")]
use {tokio::fs::File, tokio::io::AsyncReadExt};
````

You also need to only compile any usage of the dependency when the feature is enabled:

````rs@server_tokio_import.rs
// Since the tokio dependency is only enabled in the server feature,
// we need to only compile any usage of the dependency when the server feature is enabled.
#[cfg(feature = "server")]
async fn read_file() -> Result<String, std::io::Error> {
    let mut file = File::open("path/to/file").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}

// The bodies of server functions automatically only compile when the server feature is enabled.
#[server]
async fn get_file_contents() -> Result<String> {
    let mut file = File::open("path/to/file").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}
````

It may be more convenient to group server or client specific code into a module that is only compiled when the feature is enabled:

````rs@server_tokio_import.rs
// Instead of configuring each item that is only used in the server, you can group
// them into a module that is only compiled when the server feature is enabled.
#[cfg(feature = "server")]
mod tokio_utilities {
    use std::path::PathBuf;
    use tokio::fs::File;
    use tokio::io::AsyncReadExt;

    pub async fn read_file(path: PathBuf) -> Result<String, std::io::Error> {
        let mut file = File::open(path).await?;
        let mut contents = String::new();
        file.read_to_string(&mut contents).await?;
        Ok(contents)
    }
}

// Then you can define your server functions using shared utilities you defined for
// server only code.
#[server]
async fn get_file_contents() -> Result<String> {
    let file = tokio_utilities::read_file(PathBuf::from("path/to/file")).await?;
    Ok(file)
}

#[server]
async fn get_other_file_contents() -> Result<String> {
    let file = tokio_utilities::read_file(PathBuf::from("path/to/other/file")).await?;
    Ok(file)
}
````

 > 
 > The [rust reference](https://doc.rust-lang.org/reference/conditional-compilation.html) has more information about conditional compilation in rust.

## Separate Frontend and Backend Crates

If you so choose, you can split your frontend and backend into separate crates. This can be useful for larger projects where you have separate complex entrypoints for web, desktop, and mobile.

Workspace setups bring extra complexity, but they can make it much easier to share data types and functions across several different projects. For instance, you might have a single API crate used by several different apps.

In these cases, we might organize our workspace like so:

````
â”œâ”€â”€ Cargo.toml
â””â”€â”€ packages/
    â”œâ”€â”€ cat-app/
    â”‚     ...
    â”œâ”€â”€ dog-app/
    â”‚     ...
    â””â”€â”€ pet-api/
          ...
````

If you're using Dioxus Fullstack, you can import your `pet-api`'s server functions to call from your UI. In the client app, you can then import the `pet-api` crate:

````toml
[dependencies]
pet-api = { workspace = true }
````

To launch the server, you can choose one of two options:

1. Start the pet-api server from the client project
1. Launch the pet-api crate's main binary

If your server is simple enough, then option 1 can be a decent option since it automatically integrates with `dx serve`.

However, if you choose to have a dedicated server binary, then you'll need to use the `@client` and `@server` modifiers to use a different binary:

````sh
dx serve @client --bin dog-app @server --bin pet-api
````

The built-in "Workspace" Dioxus Template can serve as a good starting point for workspace setups.
# Server Side Rendering

Dioxus Fullstack supports a powerful feature called "server side rendering" (SSR). SSR enables your apps to load data on the server *before* sending HTML to the client.

Server-side-rendering improve's your site's page load times and makes it easier for web crawlers like Google to index. Sites that are easier to index rank higher in web searches, improving your conversion rate and ultimately, your bottom line.

## SSR vs CSR

You might be intimidated by the various terms, tradeoffs, and details. Don't worry - these additional concepts are simply optimizations to make your site perform better in various ways. You can still build a beautiful, useful, accessible site without enhancements like server-side-rendering.

The terms SSR and CSR refer to two different approaches to rendering pages:

* **CSR**: *Client-side-rendering*, data is loaded by a "skeleton" page with `fetch()`
* **SSR**: *Server-side-rendering*, data is loaded on the server and serialized into HTML

SSR gives us the ability to send a more "complete" HTML document to the user when the visit the site, making the site immediately usable and improving its ranking in search results.

### CSR: The "App" Architecture

The architecture of web applications have shifted substantially over the years. Client-side-rendering is a somewhat "modern" architecture where the server responds to user requests with a "skeleton" HTML.

The skeleton HTML might be barebones - something like:

````html

<html>
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
        <script src="/index.js"> </script>
    </head>
    <body>
        <div id="main"></div>
    </body>
</html>
````

Note how there's no content *in the HTML document* when it loads. Once this barebones page is loaded by the browser, the `index.js` script executes, calling your app's `main` function. Data fetching is usually done as an *effect* after the initial `main` executes.

When using the CSR approach, there are *many* HTTP requests required to load the page:

* The initial GET to `index.html`
* The GET to `index.js`
* Multiple `GET` calls to backend endpoints to load data

Also note the numerous phases where the app *appears* to be in a loading state:

* The initial HTML is blank
* Once `main` executes, the page is blank, waiting for data to load
* Cascading fetches cause child components to be blank in a "waterfall"

This architecture is called client-side-rendering because the **client** is responsible for rendering the HTML on the page. This approach is well suited for interactive apps with little static content, like document editors, search tools, or anything that is well suited as an "app". This architecture is the primary architecture for desktop and mobile apps.

![CSR Diagram](/assets/07/csr-diagram.avif)

### SSR: The "Site" Architecture

In contrast to CSR, server-side-rendering is widely used for the classic "site" type application. Websites like e-commerce, portfolios, blogs, news, and other content-heavy applications prefer to render the initial HTML **on the server**.

Once the initial HTML reaches the client, extra supporting JavaScript (or WebAssembly) is executed, transforming the static page into an interactive one.

The HTML that reaches the client is usually "complete" with content:

````html
<html>
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
        <title> Our Site | Page XYZ </title>
        <meta name="description" content="Our really cool site - Page XYZ" />
        <link href="/main.css" />
        <link href="/page-xyz.css" />
        <script src="/index.js"/>
    </head>
    <body>
        <div id="main">
            <h1> This is a really cool site </h1>
            <h3> You are on page XYZ </h3>
            <p> Enjoy the content! </p>
        </div>
    </body>
</html>
````

Look closely to compare the two HTML bodies. The SSR HTML is full of content - the "main" div has headers and paragraphs, and the "head" of the app has page-specific attributes like its title, meta tags, and page-specific styling.

When using the SSR approach, there are *few* HTTP requests required to load the page:

* Initial GET to load `index.html`
* Follow-up GET requests to load assets

Also note the page only seems to be loading *once*:

* The user is waiting for the `index.html` to download.

Because the initial `GET` requests returns a complete picture of the site, crawlers like Google can easily read your site's contents, improving your ranking in search results.

![SSR Diagram](/assets/07/ssr-diagram.avif)

### Mixing CSR and SSR

Fortunately, these two architectures can be used *together* in a hybrid approach. This comes in two flavors:

* Default to SSR, add reactivity with "islands"
* Default to CSR, caching *some* data from the server

Dioxus employs the second approach. As a framework, we are focused on enabling great "app-like" experiences. Rust excels when building complex logic that is typically found in interaction-heavy applications.

There are *many* frameworks in the first category - projects like Ruby on Rails, NextJS, and Elixir Phoenix all serve primarily server-rendered content quite well. Dioxus easily handles SSR, but provides many tools and utilities that focus on client interaction.

## Do You Need SSR?

SSR is ideal for sites and pages that need to rank well in web searches like e-commerce stores, blogs, news, and other static content. In some instances, if your site is *entirely* static, you can even use static-site-generation to pre-render every page and deploy directly to a CDN.

However, adding SSR to your site is not always necessary, nor does it need to be enabled for every page. Dioxus SSR is *progressive*, meaning that by default, pages are rendered on the client, and you can *opt-in* to rendering components on the server. Any data not cached by the server will become a client-side fetch when the page finally loads.

## Hydration

In dioxus fullstack, the server renders the initial HTML for improved loading times. This initial version of the page is what most web crawlers and search engines see.

After the initial HTML is rendered, the client makes the page interactive through a process called **hydration**. Usually, hydration is purely an enhancement. You generally shouldn't need to think about hydration, but there are a few things you need to keep in mind to avoid [hydration errors](#hydration-errors).

To better understand hydration, let's walk through a simple example:

````rs@hydration.rs
fn Weather() -> Element {
    let mut weather = use_server_future(fetch_weather)?;

    rsx! {
        div {
            "{weather:?}"
        }
        button {
            onclick: move |_| weather.restart(),
            "Refetch"
        }
    }
}
````

## Rendering the initial HTML

When the server receives a request to render the `Weather` component, it renders the page to HTML and serializes some additional data the client needs to hydrate the page. It will follow these steps to render our component:

1. Run the component
1. Wait until all server futures are resolved
1. Serialize any non-deterministic data (like the `weather` future) for the client
1. Render the HTML

[![](https://mermaid.ink/img/pako:eNpdkDFTwzAMhf-KT3M70HbKwELhGMqSdAIziFhNfI2lnGzDQa__HZfk4Iq1-D1_ejr5BK04ggoOg3y0PWoy-61lE_Nbpzj2Jt68WGhI30lN4x2ZmtiReu4svBZwPs4rtckLm13958ZVaa4zmzsJozBxumqK6ynb4-C_yMxTHnLKSvGa3FyCfiabx_3Tbn4sxsTElVkub0vgLNeT3FieChYQSAN6V1Y9XSALqadAFqpydahHC5bPhcOcpPnkFqqkmRagkrseqgMOsag8Oky09Vh-J_y6I_KzSPhH3TufRGfz_A3Ce3PT?type=png)](https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNpdkDFTwzAMhf-KT3M70HbKwELhGMqSdAIziFhNfI2lnGzDQa__HZfk4Iq1-D1_ejr5BK04ggoOg3y0PWoy-61lE_Nbpzj2Jt68WGhI30lN4x2ZmtiReu4svBZwPs4rtckLm13958ZVaa4zmzsJozBxumqK6ynb4-C_yMxTHnLKSvGa3FyCfiabx_3Tbn4sxsTElVkub0vgLNeT3FieChYQSAN6V1Y9XSALqadAFqpydahHC5bPhcOcpPnkFqqkmRagkrseqgMOsag8Oky09Vh-J_y6I_KzSPhH3TufRGfz_A3Ce3PT)

Once the server finishes rendering, it will send this structure to the client as HTML:

[![](https://mermaid.ink/img/pako:eNqFUcFKAzEQ_ZUwh57agy22sAUFqaCgF1sQNCLTZLYbupss2VmLlv67s92luoo4uSRv3nvzhuzBBEuQQJqHnckwslottFdVvd5ELDNVjZ81LCk6zN0HWbVARg0vQpGyLpJhF7xaXbVIU_5MJCmxyV53hJxR7ATkbc96Irxb71i81c3q_u4_3ybKIOe5dW-DDc9P9GPzXJr7bl5yeeg3p51yXTOLa_Amd2b722QmvAdKI1XZH5mb3R57W7VVjb_dJ1_KY241Gl1IQjWQJB02bbGZ9u2BIRQUC3RWPmPfkDTIkII0JHK1GLcatD8ID2sOy3dvIOFY0xBiqDcZJCnmlbzq0iLTwqEELk5oif4phOIH69o6DrEDD5_uGqQ1?type=png)](https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNqFUcFKAzEQ_ZUwh57agy22sAUFqaCgF1sQNCLTZLYbupss2VmLlv67s92luoo4uSRv3nvzhuzBBEuQQJqHnckwslottFdVvd5ELDNVjZ81LCk6zN0HWbVARg0vQpGyLpJhF7xaXbVIU_5MJCmxyV53hJxR7ATkbc96Irxb71i81c3q_u4_3ybKIOe5dW-DDc9P9GPzXJr7bl5yeeg3p51yXTOLa_Amd2b722QmvAdKI1XZH5mb3R57W7VVjb_dJ1_KY241Gl1IQjWQJB02bbGZ9u2BIRQUC3RWPmPfkDTIkII0JHK1GLcatD8ID2sOy3dvIOFY0xBiqDcZJCnmlbzq0iLTwqEELk5oif4phOIH69o6DrEDD5_uGqQ1)

## Hydrating on the client

When the client receives the initial HTML, it hydrates the HTML by rerunning each component. As each component re-reruns, Dioxus loads cached data from the server, properly linking the HTML to each interactive DOM node.

Rerunning each component lets the client re-construct some non-serializable state like event handlers and kick off any client side logic like `use_effect` and `use_future`.

Hydration follows these steps:

1. Deserialize any data from the server (like the `weather` future)
1. Run the component with the deserialized data.
1. Hydrate the HTML sent from the server, adding event listeners and running effects.

[![](https://mermaid.ink/img/pako:eNpdkLFuAjEMhl_F8gxDgemGLlyrDnThmNp0SC-Gi7g4JydpRRHvXsOdkFpnif__s534jG10hBXu-_jddlYy7GrDkMrnQezQQXp4N7juPXGGxjuCl5MT63Nkgx8Kajgv1GYfGTbbUblGWmphTYnE297_EDQkXyTwXHIRSvfqG7tQdlsY1jEMkXXWX3ul9m1u1vm7183kErsRSkuYzx-1zZQuxnRleDw4w0ASrHf60_MVMpg7CmSw0quzcjRo-KKcLTk2J26xylJohhLLocNqb_ukWRmcvqH2VpcT7upg-S3G8I96crolmcTLL4RBdIg?type=png)](https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNpdkLFuAjEMhl_F8gxDgemGLlyrDnThmNp0SC-Gi7g4JydpRRHvXsOdkFpnif__s534jG10hBXu-_jddlYy7GrDkMrnQezQQXp4N7juPXGGxjuCl5MT63Nkgx8Kajgv1GYfGTbbUblGWmphTYnE297_EDQkXyTwXHIRSvfqG7tQdlsY1jEMkXXWX3ul9m1u1vm7183kErsRSkuYzx-1zZQuxnRleDw4w0ASrHf60_MVMpg7CmSw0quzcjRo-KKcLTk2J26xylJohhLLocNqb_ukWRmcvqH2VpcT7upg-S3G8I96crolmcTLL4RBdIg)

## Hydration Errors

For hydration to work, **the component must render exactly the same thing on the client and the server**. If it doesn't, you might see an error like this:

````
Uncaught TypeError: Cannot set properties of undefined (setting 'textContent')
at RawInterpreter.run (yourwasm-hash.js:1:12246)
````

Or this:

````
Error deserializing data:
Semantic(None, "invalid type: floating point `1.2`, expected integer")
This type was serialized on the server at src/main.rs:11:5 with the type name f64. The client failed to deserialize the type i32 at /path/to/server_future.rs
````

### Non-deterministic Data

Much of the logic in your components is "deterministic" - meaning that given the same inputs to a component, the component will render the same output. It's very important that the inputs to your component remain stable across the client and the server.

Some inputs are "non-deterministic". For example, an app like Instagram has a "feed" of content. Calling `GET /api/feed` might not return the same result every time. This type of data must be serialized *into the HTML* and then *deserialized on the client* to ensure the exact same data is used during hydration.

### Non-deterministic Data with Server Cached

You must put any non-deterministic data in `use_server_future`, `use_server_cached` or `use_effect` to avoid hydration errors. For example, if you need to render a random number on your page, you can use `use_server_cached` to cache the random number on the server and then use it on the client:

````rs@hydration.rs
// âŒ The random number will be different on the client and the server
let random: u8 = use_hook(|| rand::random());
// âœ… The same random number will be serialized on the server and deserialized on the client
let random: u8 = use_server_cached(|| rand::random());
````

### Async Loading with Server Futures

If you need render some data from a server future, you need to use `use_server_future` to serialize the data instead of waiting for the (non-deterministic) amount of time `use_resource(...).suspend()?` takes:

````rs@hydration.rs
// âŒ The server function result may be finished on the server, but pending on the client
let random: u8 = use_resource(|| random_server_function()).suspend()?().unwrap_or_default();
// âœ… Once the server function is resolved on the server, it will be sent to the client
let random: u8 = use_server_future(|| random_server_function())?()
    .unwrap()
    .unwrap_or_default();
````

### Async Loading with `use_loader`

New in Dioxus 0.7 is the `use_loader` hook - a hook dedicated for isomorphic data loading that excels in both CSR and SSR architectures.

The `use_loader` hook is very similar to `use_server_future`, but with a slightly different API. Unlike `use_server_future`, the `use_loader` hook will not re-suspend the page when the underlying future re-runs. Also, unlike `use_server_future`, the `use_loader` hook will re-throw any loading errors to the nearest suspense boundary:

````rust
fn app() -> Element {
    // Fetch the list of breeds from the Dog API, using the `?` syntax to suspend or throw errors
    let breed_list = use_loader(move || async move {
        reqwest::get("https://dog.ceo/api/breeds/list/all")
            .await?
            .json::<ListBreeds>()
            .await
    })?;

    rsx! {
        for cur_breed in breed_list.read().message.keys().take(20).cloned() {
            button {
                onclick: move |_| {
                    breed.call(cur_breed.clone());
                },
                "{cur_breed}"
            }
        }
    }
}
````

The `use_loader` hook takes a callback that returns a `Result<T, E>`. If that future returns a result, the error is automatically thrown. The `use_loader` hook excels when building sites that are both highly interactive and require SSR capabilities.

### Client Only Data with Effects

If you need to grab some data that is only available on the client, make sure you get it inside of a `use_effect` hook which runs after the component has been hydrated:

````rs@hydration.rs
// âŒ Using a different value client side before hydration will cause hydration issues
// because the server rendered the html with another value
let mut storage = use_signal(|| {
    #[cfg(feature = "server")]
    return None;
    let window = web_sys::window().unwrap();
    let local_storage = window.local_storage().unwrap().unwrap();
    local_storage.set_item("count", "1").unwrap();
    local_storage.get_item("count").unwrap()
});

// âœ… Changing the value inside of an effect is fine because effects run after hydration
let mut storage = use_signal(|| None);
use_effect(move || {
    let window = web_sys::window().unwrap();
    let local_storage = window.local_storage().unwrap().unwrap();
    local_storage.set_item("count", "1").unwrap();
    storage.set(local_storage.get_item("count").unwrap());
});
````

### Avoid Side Effects in Server Cached Hooks

The dioxus fullstack specific hooks `use_server_cached` and `use_server_future` don't run the same on the server and the client. The server will always run the closure, but the client may not run the closure if the server serialized the result. Because of this, the code you run inside these hooks **cannot have side effects**. If it does, the side effects will not be serialized and it can cause a hydration mismatch error:

````rs@hydration.rs
// âŒ The state of the signal cannot be serialized on the server
let mut storage = use_signal(|| None);
use_server_future(move || async move {
    storage.set(Some(server_future().await));
})?;

// âœ… The value returned from use_server_future will be serialized on the server and hydrated on the client
let storage = use_server_future(|| async move { server_future().await })?;
````
# Server Functions

Dioxus Fullstack provides an ergonomic solution for quickly building your backend API and calling those endpoints on the client called *Server Functions*. Server Functions are regular Rust functions that define an Axum-compatible endpoint:

````rust
#[get("/api/hello-world")]
async fn hello_world() -> Result<String> {
	Ok("Hello world!".to_string())
}
````

Server functions automatically generate an HTTP endpoint for your app. After launching your app, you can `curl` your endpoint directly:

````sh
# returns "Hello world!"
curl http://127.0.0.1:8080/api/hello-world
````

Server functions can be called directly from the client as a function:

````rust
let onclick = move |_| async move {
	let msg = hello_world().await;
	// ...
}
````

Server functions can take all sorts of modifiers like server-only extractors and custom axum payloads, making them even more powerful than a plain axum handler:

````rust
#[get("/api/users/{user_id}", db: SqlDb)]
async fn get_user(user_id: Uuid) -> Result<UserData> {
    db.get(user_id)
}
````

Ultimately, a server function is just an axum endpoint - you can cleanly use the entirety of the Axum ecosystem with server functions!

## Anatomy of a Server Function

A server function is an HTTP endpoint in the form of a Rust function. We can transform a regular function into a server function by annotating it with one of a few procedural macros:

* Explicitly using the `#[get]`, `#[post]`, `#[put]`, `#[delete]`, `#[patch]` macros
* Anonymously with the `#[server]` macro

To make a server function, simply add one of `#[get]`, `#[post]`, etc on top of your function. This function has a few restrictions - it must:

* Be an async function
* Return a `Result<T, E>`
* Take arguments that are either `Serialize + Deserialize` *or* `IntoRequest + FromRequest`
* Return a type that is either `Serialize + Deserialize` *or* `IntoResponse + FromResponse`

Dioxus uses some specialization "magic" to enable flexible input and output types, so the errors for types not satisfying these bounds might be rather unwieldy.

In essence, the non-URL inputs must either be a set of items that are obviously serializable (think strings, numbers, custom types):

````rust
// The function inputs create a single serializable object that looks like:
//
// ```
// #[derive(Serialize, Deserialize)]
// struct Body {
//     a: String,
//     b: i32,
//     c: serde_json::Value,
// }
// ```
#[get("/api/json-body")]
async fn json_body(a: String, b: i32, c: serde_json::Value) -> Result<()> {
	Ok(())
}
````

*or*, the inputs would be a single object that implements Axum's `FromRequest` trait and Dioxus' `IntoRequest` trait. Dioxus Fullstack provides a number of built-in types that implement these types and can be used across the client and the server:

````rust
// The `FileStream` type lets us stream file uploads from the client to the server
#[get("/api/upload")]
async fn upload(file: FileStream) -> Result<()> {
	// ....
}
````

Similarly, the output type can be either a serializable object (strings, numbers, custom structures)

````rust
// Our custom payload implements `Serialize + Deserialize`
#[derive(Serialize, Deserialize)]
struct Payload {
	a: i32,
	b: String
}

#[get("/api/json-out")]
async fn json_body() -> Result<Payload> {
	Ok(Payload {
		a: 123,
		b: "hello".to_string(),
	})
}
````

*or* an object that implements Axum's `IntoResponse` trait and Dioxus' `FromResponse` trait. Many built-in types implement these traits and can be returned to the client:

````rust
#[get("/api/stream")]
async fn stream() -> Result<Streaming<String>> {
	// ...
}
````

If you want to use a 3rd-party Axum response type but it doesn't implement `FromResponse`, then you need to call `.into_response()` and return an `axum::response::Response` type instead:

````rust
#[get("/api/video", range: RangeHeader)]
async fn video_endpoint() -> Result<axum::response::Response> {
	let chunk = get_chunk_from_range(range);
	Ok(chunk.into_response())
}
````

### Path and Query Extractors

We can combine custom payload bodies with query and path extractors, enabling us to build APIs that are suitable both for our Rust frontend and any other HTTP client. This can be particularly useful if your API is consumed both by your own app and external customers.

To add query and path extractors, we can use the Axum route syntax in the macro. The macro will parse the route and generate the associated axum extractors for you:

````rust
#[get("/api/products/{product}?color&quantity")]
async fn get_product_data(product: String, color: String, quantity: Option<i32>) -> Result<Vec<Product>> {
	// ...
}
````

Under the hood, we generate `axum::extract::Query<T>` and `axum::extract::Path<T>` objects, so you can use any valid types, like `Option<T>`. When extracting from the URL, values are URL-encoded and URL-decoded. Note that not all structures can be cleanly URL-encoded, so we recommend sticking with simple data types where possible.

We can combine path and query extractors with the body extractor. This is especially useful when sending additional data alongside custom payloads.

````rust
// we can pass along additional data to objects like streams!
#[post("/api/photos/upload?name&rating")]
async fn upload_photo(name: String, rating: i32, image: FileStream) -> Result<i32> {
	// ...
}
````

### Custom Inputs

We mentioned earlier that the non-query arguments of a server function must be one of two types:

* A group of serializable types (strings, ints, custom serializable structs)
* A single type that implements `FromRequest` and `IntoRequest`

The second type - `FromRequest + IntoRequest` - is extremely powerful. This lets us create new bodies that abstract over the client request with Rust methods, making things like the built-in `WebsocketOptions` and `Websocket` types possible.

````rust
#[get("/api/ws")]
async fn get_updates(options: WebsocketOptions) -> Result<Websocket> {
	Ok(options.on_upgrade(|mut socket| {
		// ...
	}))
}
````

The `WebsocketOptions` type implements the two key Rust traits mentioned above: `FromRequest` and `IntoRequest`.

The first trait, [`FromRequest`](https://docs.rs/axum/latest/axum/extract/trait.FromRequest.html), comes from Axum, the library that Dioxus fullstack is built on.

To implement the `FromRequest` trait, we need to define our new type and then implement the `from_request` method. If you aren't sure which `Rejection` type to use in the implementation, you can use the built-in `ServerFnError` type which integrates with the rest of Dioxus fullstack.

````rust
struct WebsocketOptions {}

impl<S: Send> FromRequest<S> for WebSocketOptions {
    type Rejection = axum::response::Response;

    fn from_request(
        request: Request,
        state: &S,
    ) -> impl Future<Output = Result<Self, Self::Rejection>> + Send {
		async move {
			// .. implementation for our type
		}
	}
}
````

Implementing `FromRequest` lets us use `WebsocketOptions` type as an Axum extractor. Now, we need to implement `IntoRequest` which lets create `WebsocketOptions` on the client before passing it off to the server.

The `IntoRequest` trait is generic over a hidden "state" type parameter. Generally, you'll implement the plain `IntoRequest` type, but for complex types like Websockets, we need a custom state object that the response (`Websocket`) will use to initialize with. In this case, we create a new state type called `UpgradingWebsocket` which will hold the state from the original request to properly upgrade the server's response into a `Websocket` handle.

````rust
struct UpgradingWebsocket {
	/// .. state for the connection
}

// IntoRequest is generic over `UpgradingWebsocket`
impl IntoRequest<UpgradingWebsocket> for WebSocketOptions {
    fn into_request(
        self,
        request: ClientRequest,
    ) -> impl Future<Output = std::result::Result<UpgradingWebsocket, RequestError>> + 'static {
		async move {
			let stream = send_request(request).await?;

			return Ok(UpgradingWebsocket {
				// ... pass along the stream
			})
		}
	}
}
````

For bodies that don't need custom state, you can just use the default `IntoRequest` type which is generic over the Dioxus Fullstack `ClientResponse` type

````rust
// the default state is `ClientResponse`:
pub trait IntoRequest<R = ClientResponse>: Sized {
    fn into_request(
        self,
        req: ClientRequest,
    ) -> impl Future<Output = Result<R, RequestError>> + 'static;
}
````

Now, when the client makes a request to our endpoint, the `WebsocketOptions` struct can be used to store state for the connection:

````rust
// We can now use `WebsocketOptions` as a custom body:
#[get("/api/ws/")]
async fn get_updates(options: WebsocketOptions) -> Result<()> {
	// ...
}

// Calling the endpoint is still quite simple:
_ = get_updates(WebsocketOptions::new()).await?;
````

### Custom Outputs

The `IntoRequest` and `FromRequest` traits allow us to send arbitrary data types to the Server, but sometimes we need to return arbitrary data types to the Client. In our example above, this would be the `Websocket` return type:

````rust
#[get("/api/ws")]
async fn get_updates(options: WebsocketOptions) -> Result<Websocket> {
	Ok(options.on_upgrade(|mut socket| {
		// ...
	}))
}
````

As mentioned above, the return type of a server function must be one of two types:

* An obviously serializable object (string, int, custom struct)
* A type that implements `IntoResponse` and `FromResponse`

The [`IntoResponse`](https://docs.rs/axum/latest/axum/response/trait.IntoResponse.html) trait comes from Axum and is quite simple to implement. To implement the `IntoResponse` trait, we just need to implement the `into_response` method for our custom type. The return type here is an Axum `Response` which is very simple to construct:

````rust
impl IntoResponse for Websocket {
	fn into_response(self) -> Response {
        Response::builder()
			.status(200)
			.header(/* */)
			.body(/* */)
			.unwrap()
	}
}
````

The Response here is directly passed along to the client. Dioxus Fullstack might attach some additional headers to the response, but the response body will remain untouched as its returned through the Axum router.

Now, to use our `Websocket` type on the client, we need to implement `FromResponse`. The `FromResponse` trait is an analog to the `IntoResponse` trait, with a similar definition:

````rust
pub trait FromResponse<R = ClientResponse>: Sized {
    fn from_response(res: R) -> impl Future<Output = Result<Self, ServerFnError>>;
}
````

Just like `IntoRequest`, the `FromResponse` trait is generic over a default state parameter (usually `ClientResponse`). For our `Websocket` type, we need to match the same state parameter as our `WebsocketOptions` type. Usually, we *aren't* generic over the state parameter since the `ClientResponse` type is quite useful on its own, but for `Websocket`, we want to make sure the input request has the required state at compile time.

To implement `FromResponse`, we need to create a new instance of our type from the stored state:

````rust
impl FromResponse<UpgradingWebsocket> for Websocket {
    fn from_response(res: UpgradingWebsocket) -> impl Future<Output = Result<Self, ServerFnError>> {
		async move {
			// ...
		}
	}
}
````

Note that the error type here is `ServerFnError`. This type ensures that the client code can properly downcast any errors that occur while making the request into a standard error type. The `ServerFnError` type includes a number of useful error variants, allowing us to express all sorts of failure modes, some with a standardized HTTP status code and details.

### Server Extractors

As you build increasingly complex backends, you might need more control over extracting data from the request. This could be handling things like auth tokens, cookies, range headers, or any number of tasks related to the request and its headers. Sometimes, these values cannot be sent directly from the client.

In the case of authentication, we might want to extract a stateful extension from the request or reader a specific header like the auth-bearer. In many cases, the client does not explicitly pass these types to the server as they are either extracted using server-only state or implicitly attached like cookies.

To extract arbitrary data from the request, we can "hoist" the function arguments into the macro. The types here must implement Axum's `FromRequestParts` trait - or `FromRequest` if there's no client-only body.

````rust
// Our `auth` argument is a function argument hoisted to the argument list in the proc macro
#[post("/api/user/login", auth: auth::Session)]
pub async fn login() -> Result<()> {
    auth.login_user(2);
    Ok(())
}
````

Because the types here must implement `FromRequestParts`, we can use a wide variety of built-in extractors. For example, we can extract the entire `HeaderMap` object from the request:

````rust
#[get("/api/headers", headers: dioxus::fullstack::HeaderMap)]
async fn get_headers() -> Result<String> {
    Ok(format!("{:#?}", headers))
}
````

We can stack as many of these extractors as we'd like:

````rust
#[post("/api/user/login", header: TypedHeader<Cookie>, auth: Session)]
pub async fn login() -> Result<()> {
    // ...
}
````

Server-only extractors make it easy to migrate existing axum handlers to Server Functions without too many code modifications.

## Handling Errors

### Acceptable Error Types

By default, Dioxus exports a custom `Result<T>` type in the prelude. Whenever you call `use dioxus::prelude::*`, you import this `Result<T>` type into the module's scope. This `Result<T>` type is actually a re-export of anyhow's `Result<T>` type.

Anyhow's Result type is a widely used "dynamic" error type used in Rust applications. It is extremely flexible, allowing you to use Rust's powerful question-mark (`?`) syntax with any error type that implements `std::Error`.

This means that the above examples are equivalent to using the anyhow error type directly:

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<(), anyhow::Error> {
    // ...
}
````

Unfortunately, when errors are created on the server, Dioxus Fullstack cannot preserve the error's type on the client. Therefore, all errors from endpoints that use the plain `Result<T>` will always downcast to the Dioxus Fullstack `ServerFnError` type:

````rust
// Make the request, assuming it always fails, unwrapping the error
let res = login().await.unwrap_err();

// We can only downcast this error to `ServerFnError`
let error = res.downcast_ref::<ServerFnError>().unwrap();
````

If you want more detail about the error type, you can use the `ServerFnError` type directly, or use `ServerFnResult`:

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<(), ServerFnError> {
    // ...
}
````

The `ServerFnError` type is a special error type that integrates cleanly with the rest of Dioxus. Its many variants represent various failure points of handling a given request. Its two most important variants are `ServerError` and `RequestError`.

````rust
pub enum ServerFnError {
    /// Occurs when there is an error while actually running the function on the server.
    #[error("error running server function: {message} (details: {details:#?})")]
    ServerError {
        /// A human-readable message describing the error.
        message: String,

        /// HTTP status code associated with the error.
        code: u16,

		/// Serialized custom error type
        details: Option<serde_json::Value>,
    },

    /// Occurs on the client if there is a network error while trying to run function on server.
    #[error("error reaching server to call server function: {0} ")]
    Request(RequestError),

	// ...
}
````

If an endpoint returns a `ServerFnError`, you can match the result on the client, providing more useful feedback to the user in the event of a failure:

````rust
match login().await {
	Err(ServerFnError::ServerError { code, .. }) => {
		if code == 404 {
			// .. handle not found
		}

		if code == 401 {
			// .. handle unauthorized
		}
	}
	_ => { /* */ }
}
````

Endpoints can accept a wide variety of error types, including:

* `anyhow::Error`: a simple, flexible error type to build quickly
* `ServerFnError`: a structured error for granularly handling types of errors
* `StatusCode`: a simple wrapper around the HTTP status code
* `HttpError`: the error type returned from the `OrHttpError` type
* Custom Errors: user-defined errors (see below)

### Custom Errors

In addition to `anyhow::Error`, `ServerFnError`, and `HttpError`, Server Functions can return custom, user-defined errors. These errors must implement `Serialize`, `Deserialize`, and an additional trait called `AsStatusCode`. `AsStatusCode` requires the error implement `From<ServerFnError>` and a method to get the actual status code from the error itself.

You can easily create new error types using the `thiserror` crate's `Error` macro. The `#[from]` attribute makes it possible to easily convert `ServerFnError` into the custom error type.

````rust
#[derive(thiserror::Error, Debug, Serialize, Deserialize)]
enum MyCustomError {
    #[error("bad request")]
    BadRequest { custom_name: String },

    #[error("not found")]
    NotFound,

    #[error("internal server error: {0}")]
    ServerFnError(#[from] ServerFnError),
}
````

We must then implement `AsStatusCode` so Dioxus Fullstack knows which status code to return to the client in the event of an error.

````rust
impl AsStatusCode for MyCustomError {
    fn as_status_code(&self) -> StatusCode {
        match self {
            MyCustomError::BadRequest { .. } => StatusCode::BAD_REQUEST,
            MyCustomError::NotFound => StatusCode::NOT_FOUND,
            MyCustomError::ServerFnError(e) => e.as_status_code(),
        }
    }
}
````

### Ergonomic Error Handling

Dioxus Fullstack provides a utility trait called `OrHttpError` to convert common failure cases into proper HTTP status codes and error messages. This trait makes it simpler to follow proper web semantics (like 404 for not-found, 401 for not-authorized, etc) while keeping inline with ergonomic Rust error handling.

You can use `OrHttpError` methods on any `Result<T>`, `Option<T>`, or `bool`, to return an `Err(HttpError)`.

For example, we might write an `authorize` method that throws an error if authorization fails. We can use the method `or_unauthorized()?` to convert the error into an appropriate status code.

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<(), ServerFnError> {
	authenticate_user()
		.or_unauthorized("You must be logged in to view this resource")?;
	// ..
}
````

To prevent polluting the global scope, only a few utility methods are available by default. You can use the `or_http_error` to return any status code:

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<(), ServerFnError> {
	authenticate_user()
		.or_http_error(StatusCode::UNAUTHORIZED, "Log in first!")?;
	// ..
}
````

Note that even when we use `anyhow::Error`, Dioxus will automatically extract the appropriate status code from the error:

````rust
// our `Result<T>` contains an `HttpError` object
#[post("/api/user/login")]
pub async fn login() -> Result<()> {
	authenticate_user()
		.or_http_error(StatusCode::UNAUTHORIZED, "Log in first!")?;
	// ..
}
````

This is true for `HttpError`, `StatusCode`, and `ServerFnError`, all of which are downcasted from the anyhow Error type.
# Fullstack Error Handling

Errors are unfortunately inevitable in software development. Even in Rust, apps might not behave as expected and user requests might be malformed.

In these cases, you might want to show an error page to the user while also returning an appropriate status code.

## Creating an Error

Recall in the [Server Functions](./server_functions.md) chapter, that all server functions must return a `Result<T>`:

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<()> {
    // ...
}
````

Because server functions are called from the client, they need some way of expressing *both* a request failure and a server failure. If the user is offline, we want to reliably return an offline error and status in the UI.

Also recall that server functions can return several different error types:

* `ServerFnError`: A broad error type encompassing request failures and server failures
* `anyhow::Error`: A general-purpose error type that downcasts its inner value
* `CapturedError`: A cheaply-cloneable `anyhow::Error` wrapper
* `StatusCode`: A specific HTTP status code
* `HttpError`: A specific HTTP status code and a message
* Custom Errors: User errors that implement `Serialize + Deserialize + AsStatusCode`

Dioxus will attempt to downcast server function errors and captured errors into status codes such that the returned page receives an appropriate HTTP status.

If an error does not downcast to a known status-code-like error type, then the request will default to a `500 INTERNAL SERVER ERROR`.

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<()> {
    // This will return a 500 status code
    return Err(anyhow::anyhow!("Bad request!").into());

    // ...
}
````

The `OrHttpError` error type makes emitting status codes quite simple with its extension methods on `Result<T>`, `Option<T>`, and `bool`.

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<()> {
	authenticate_user()
        // this method comes from `OrHttpError`
		.or_unauthorized("You must be logged in to view this resource")?;
	// ..
}
````

## Error Status Codes Bubble

In the event of an error, Dioxus extracts the status code for the response by downcasting errors that bubble to root component.

For example, this example app does not provide a root error boundary, and thus all errors will bubble up to the root:

````rust
fn app() -> Element {
    let post_data = use_loader(move || get_post())?;

    rsx! {
        p { "{post_data}" }
    }
}

// This endpoint always throws an error
#[get("/api/post/")]
async fn get_post() -> Result<String, HttpError> {
    HttpError::not_found("Post not found")
}
````

If you `curl` the app, you'll notice that it returns a `404` status code.

If we want to catch the error and provide a nice fallback UI, we can use an `ErrorBoundary`. Note that when we catch the error, we must explicitly set the HTTP status code on the outgoing response with `FullstackContext::commit_error_status`:

````rust
fn app() -> Element {
    rsx! {
        ErrorBoundary {
            handle_error: move |err| {
                // To ensure the HTTP status is still set properly, we need to call `commit_error_status`
                let http_error = FullstackContext::commit_error_status(err.error().unwrap());

                // and then we can render some pretty fallback UI
                rsx! { "An error occurred! {http_error:?}" }
            },
            Post {}
        }
    }
}

fn Post() -> Element {
    let post_data = use_loader(move || get_post())?;
    rsx! { p { "{post_data" } }
}
````

The `commit_error_status` function on `FullstackContext` extracts the HTTP status from a `CapturedError` and then modifies the outgoing response accordingly.

## Error Layout with Router

If you're using the Dioxus Router for your app's routing, then it might not be immediately clear how to integrate custom error pages into your app.

In these cases, we'd take a similar approach with an `ErrorBoundary`. We could either wrap our `Router {}` component in an error boundary, or add a layout to our app that renders the fallback UI.

````rust
// A router definition with `ErrorLayout` layout
#[derive(Routable, PartialEq, Clone, Debug)]
enum Route {
    #[layout(ErrorLayout)]
    #[route("/")]
    Home,

    #[route("/blog/:id")]
    Blog { id: u32 },
}

// And then our Outlet is wrapped in a fallback UI
#[component]
fn ErrorLayout() -> Element {
    rsx! {
        ErrorBoundary {
            handle_error: move |err: ErrorContext| {
                let http_error = FullstackContext::commit_error_status(err.error().unwrap());
                match http_error.status {
                    StatusCode::NOT_FOUND => rsx! { div { "404 - Page not found" } },
                    _ => rsx! { div { "An unknown error occurred" } },
                }
            },
            Outlet::<Route> {}
        }
    }
}
````

Using layouts for error pages is extremely powerful. You can isolate fallback UI to specific parts of the page while also properly setting the returned status code.

For example, the GitHub UI retains most of its UI while isolate the 404 message to just the source code viewer:

![Github Fallback UI](/assets/07/github-fallbackui.avif)

It's a better user experience to render a web page that is visually consistent while also still delivering the appropriate status code.
# Axum Router

Dioxus fullstack is built on the popular backend crate Axum. The default `dioxus::launch` function will initialize a default Axum server for your fullstack project. If you need more control, you can easily customize the router with `dioxus::serve`.

The `dioxus::serve` function is the primary entrypoint for Dioxus apps that run on the server, as is standard in fullstack applications. For fullstack apps, you'll typically use both `dioxus::launch` and `dioxus::serve`, enabling each entrypoint based on the `"server"` feature.

````rust
fn main() {
    // Run `serve()` on the server only
    #[cfg(feature = "server")]
    dioxus::serve(|| async move {
        // Create a new router for our app using the `router` function
        let mut router = dioxus::server::router(app);

        // .. customize the router, adding layers and new routes

        // And then return the router
        Ok(router)
    });

    // When not on the server, just run `launch()` like normal
    #[cfg(not(feature = "server"))]
    dioxus::launch(app);
}
````

Note how we use Rust's built-in `#[cfg]` macro to conditionally launch the app based on the `server` feature. When `server` feature is enabled, we enable `dioxus::serve`, and when it is disabled, we enable `dioxus::launch`.

The `dioxus::server::router` function creates a new axum router that sets up a few important pieces:

* Static Assets: automatically serve the `public` directory, index.html and assets
* SSR: automatically run the app, render it to HTML, and serialize data for hydration
* Server Functions: automatically initialize the API endpoints

Dioxus uses extension methods on the Axum router (given by `DioxusRouterExt`) that is equivalent to enabling each of these items manually:

````rust
axum::Router::new()
	.register_server_functions()
	.serve_static_assets()
	.fallback(
		get(render_handler).with_state(RenderHandleState::new(cfg, app)),
	)
````

## Registering Server Functions

When you use `dioxus::server::router` or `dioxus::launch` to start your fullstack server, Dioxus Fullstack registers all server functions for you automatically. This means you can quickly build your backend without needing to explicitly wire up endpoints to a central router.

If you need more control with a custom axum setup, you can manually iterate through the list of global server functions and register single endpoints, or create new routers with a subset of routes with `ServerFunction::collect()`:

````rust
// We can iterate through all server functions:
for func in ServerFunction::collect() {
	// Read their data
	tracing::info!(
		"Registering server function: {} {}",
		func.method(),
		func.path()
	);

	// And add them to our router
	router = func.register_server_fn_on_router(router);
}
````

## Adding New Routes

One common use-case of a custom axum router is to add new routes to the router that are *not* defined with server functions. We might want to include special endpoints that respond dynamically or that return non-HTML data types.

This example adds three new routes to our app:

````rust
dioxus::serve(|| async move {
    use dioxus::server::axum::routing::{get, post};

    let router = dioxus::server::router(app)
        .route("/submit", post(|| async { "Form submitted!" }))
        .route("/about", get(|| async { "About us" }))
        .route("/contact", get(|| async { "Contact us" }));

    Ok(router)
});
````

Note that the server-side-rendering handler is registered as a *fallback* handler. Any routes we manually register will take priority over the Dioxus app. Since these handlers are axum handlers, they can take the typical modifiers, like `.with_state()`, `.layer()`, etc.

````rust
let router = dioxus::server::router(app)
    .route(
        "/submit",
        post(
            |state: State<FormSubmitter>, ping: Extension<Broadcast>, cookie: TypedHeader<Cookie>| async {
                // ... endpoint logic
            },
        ),
    )
    .with_state(FormSubmitter::new())
    .layer(Extension(Broadcast::new()));
````

The [Axum documentation](https://docs.rs/axum/latest/axum/index.html) has more information on defining routes and handlers outside of server functions.

## Adding `Layers`

Axum allows you to to attach middleware to many parts of your router:

* To entire routers with [Router::layer](https://docs.rs/axum/latest/axum/struct.Router.html#method.layer) and [Router::route_layer](https://docs.rs/axum/latest/axum/struct.Router.html#method.route_layer).
* To method routers with [MethodRouter::layer](https://docs.rs/axum/latest/axum/routing/method_routing/struct.MethodRouter.html#method.layer) and [MethodRouter::route_layer](https://docs.rs/axum/latest/axum/routing/method_routing/struct.MethodRouter.html#method.route_layer).
* To individual handlers with [Handler::layer](https://docs.rs/axum/latest/axum/handler/trait.Handler.html#method.layer).

## Adding State with Extensions

As you build out your app, you might want to expose state to your endpoints and to your requests. Axum provides two ways of adding state to endpoints: `Extension` and `State<T>`. Extensions enable you to attach extra data to requests as they are handled by your router.

You can use extensions *either* as a form of global state *or* as a way of attaching state to requests. To share a given piece of data with all endpoints, you can attach the extension as a layer to the router in `dioxus::serve`:

````rust
dioxus::serve(|| async move {
    use dioxus::server::axum::Extension;
    use tokio::sync::broadcast;

    let router = dioxus::server::router(app)
        .layer(Extension(broadcast::channel::<String>(16).0));

    Ok(router)
});
````

Now, in our handlers, we can extract the extension from the request:

````rust
#[post("/api/broadcast", ext: Extension<broadcast::Sender<String>>)]
async fn broadcast_message() -> Result<()> {
    ext.send("New broadcast message".to_string())?;
    Ok(())
}
````

If we want to attach state to a single request - as in the case with a session middleware - we can attach a new middleware to the router that dynamically inserts a new extension into the request.

````rust
use axum::{extract::Request, middleware::Next, middleware};

let router = dioxus::server::router(app)
    .layer(middleware::from_fn(|req: Request, next: Next| async move {
        // Attach some extra state to the request
        req.extensions_mut().insert(Session::new());

        // And then return the response with `next.run()
        Ok::<_, Infallible>(next.run(req).await)
    }))
````

## Using `Lazy<T>` as Global State

As a simpler alternative to axum extensions and `State<T>`, you can also use the built-in `Lazy<T>` type to access server resources without needing to set up a dedicated `dioxus::serve` entrypoint. The `Lazy<T>` type is very similar to the standard library's `LazyLock<T>` type, making it possible to initialize asynchronous data like database connections.

Simply create a new `Lazy<T>` instance as a `static` variable:

````rust
static DATABASE: Lazy<sqlx::SqlitePool> = Lazy::new(|| async move {
    dioxus::Ok(
        SqlitePoolOptions::new()
            .max_connections(5)
            .connect_with("sqlite::memory:".parse().unwrap())
            .await?,
    )
});
````

Then when you access the `DATABASE` object in your code, Dioxus will ensure it's properly initialized, blocking the current thread until the initializer finishes. This lets you use asynchronous resources *synchronously* which makes them extremely ergonomic.

````rust
/// When using the `Lazy<T>` type, it implements `Deref<Target = T>`, so you can use it like a normal reference.
#[get("/api/users")]
async fn get_users() -> Result<Vec<String>> {
    let users = DATABASE
        .fetch_all(sqlx::query("SELECT name FROM users"))
        .await?
        .iter()
        .map(|row| row.get::<String, _>("name"))
        .collect::<Vec<_>>();

    Ok(users)
}
````

Typically, Rust discourages the use of global variables for managing state, but for apps like web-servers, it's generally okay to have a single shared object for the entire app.

Note that you can also use the built-in standard `LazyLock` type for simple synchronous data:

````rust
static MESSAGES: LazyLock<Mutex<Vec<String>>> = LazyLock::new(|| Mutex::new(Vec::new()));

#[post("/api/messages")]
async fn add_message() -> Result<()> {
    MESSAGES.lock().await.push("New message".to_string());
    Ok(())
}
````
# Middleware

Middleware allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.

Dioxus Fullstack provides two main ways of adding middleware to your app:

* Imperatively using Axum's APIs on your Router in `dioxus::serve`
* Declaratively by annotating individual endpoints with the `#[middleware]` attribute

## What is Middleware?

In web applications, middleware are functions that are called before and after the request is handled by your endpoint logic.

The underlying web framework that Dioxus Fullstack is built on - Axum - does not define its own bespoke middleware system. Instead, it leans on the broader ecosystem, integrating with the more fundamental [`tower`](https://github.com/tower-rs/tower) and [`hyper`](https://github.com/hyperium/hyper) crates.

Axum *does* provide a simple way of writing middleware with `middleware::from_fn`:

````rust
axum::middleware::from_fn(
    |request: Request, next: Next| async move {
        // Read and write the contents of the incoming request
        println!("Headers: {:?}", request.headers());

        // And then run the request, modifying and returning the response
        next.run(request).await
    },
)
````

Middleware give you both *read* and *write* access to both the *request* and the *response* of the handler. This is extremely powerful!

You can implements a wide range of functionality with middleware:

* Logging and telemetry
* Rate limiting
* Validation
* Compression
* CORS, CSRF
* Authentication and Authorization
* Caching

The broader Rust ecosystem has many different 3rd party crates for middleware.

The two main crates to look for middleware are:

* [Tower](https://docs.rs/tower/latest/tower/): The underlying library for networking
* [Tower-HTTP](https://github.com/tower-rs/tower-http): A dedicated HTTP-specific middleware library

## Middleware on the Router

Because Dioxus is built on Axum, you can use many Axum APIs directly. Dioxus Fullstack does not provide any bespoke wrappers around Axum middleware - you can simply attach them to your router in `dioxus::serve`:

````rust
dioxus::serve(|| async move {
    use axum::{extract::Request, middleware::Next};
    use dioxus::server::axum;

    Ok(dioxus::server::router(app)
        // we can apply a layer to the entire router using axum's `.layer` method
        .layer(axum::middleware::from_fn(
            |request: Request, next: Next| async move {
                // Read the incoming request
                println!("Request: {} {}", request.method(), request.uri().path());

                // Run the handler, returning the response
                let res = next.run(request).await;

                // Read/write the response
                println!("Response: {}", res.status());

                res
            },
        )))
});
````

The Tower-HTTP crate provides a number of useful middleware layers to add to your app. The `ServiceBuilder` object can be used to efficiently assemble a `Service` which handles a wide range of middleware actions:

````rust
// Use tower's `ServiceBuilder` API to build a stack of tower middleware
// wrapping our request handler.
let middleware = ServiceBuilder::new()
    // Mark the `Authorization` request header as sensitive so it doesn't show in logs
    .layer(SetSensitiveRequestHeadersLayer::new(once(AUTHORIZATION)))
    // High level logging of requests and responses
    .layer(TraceLayer::new_for_http())
    // Share an `Arc<State>` with all requests
    .layer(AddExtensionLayer::new(Arc::new(state)))
    // Compress responses
    .layer(CompressionLayer::new())
    // Propagate `X-Request-Id`s from requests to responses
    .layer(PropagateHeaderLayer::new(HeaderName::from_static("x-request-id")))
    // If the response has a known size set the `Content-Length` header
    .layer(SetResponseHeaderLayer::overriding(CONTENT_TYPE, content_length_from_response))
    // Authorize requests using a token
    .layer(ValidateRequestHeaderLayer::bearer("passwordlol"))
    // Accept only application/json, application/* and */* in a request's ACCEPT header
    .layer(ValidateRequestHeaderLayer::accept("application/json"))
    // Wrap a `Service` in our middleware stack
    .service_fn(handler);
````

You can then attach this service as a layer to your router:

````rust
dioxus::serve(|| async move {
    use axum::{extract::Request, middleware::Next};
    use dioxus::server::axum;

    // Assemble a middleware object from the ServiceBuilder
    let middleware = ServiceBuilder::new()
        .layer(/* */)
        .layer(/* */)
        .layer(/* */);

    Ok(dioxus::server::router(app).layer(middleware))
});
````

Axum recommend initializing multiple middleware on a `ServiceBuilder` object for maximum performance, but you can also attach layers directly onto the router:

````rust
dioxus::serve(|| async move {
    use axum::{extract::Request, middleware::Next};
    use dioxus::server::axum;

    Ok(
        dioxus::server::router(app)
            .layer(/* */)
            .layer(/* */)
            .layer(/* */)
    )
});
````

## Middleware on individual Routes

If you need to apply middleware to just a handful of specific routes, you can use the `#[middleware]` attribute. Unlike router-level middleware, route-level middleware will only be applied to a specific endpoint. Alternatively, you could register routes one-by-one on the axum router with dedicated calls `.layer()`.

For example, we might want to add a "timeout" middleware to a specific server function. This middleware will stop running the server function if it reaches a certain timeout:

````rs@server_function_middleware.rs
#[cfg(feature = "server")]
use {std::time::Duration, tower_http::timeout::TimeoutLayer};

// Add a timeout middleware to the server function that will return an error if the function takes longer than 1 second to execute
#[post("/api/timeout")]
#[middleware(TimeoutLayer::new(Duration::from_secs(1)))]
pub async fn timeout() -> Result<(), ServerFnError> {
    tokio::time::sleep(Duration::from_secs(2)).await;
    Ok(())
}
````

Under the hood, Dioxus Fullstack creates a `MethodRouter` object and then attaches these layers with calls to `.layer()` automatically.

## Caching and Middleware

In the chapter on server-side-rendering, we discussed at length about how Dioxus Fullstack is architected around client-side-rendering, with SSR being an additional enhancement. One enhancement is the ability to add a `Cache-Control` header to HTML responses, letting our CDN and Reverse Proxy decrease the load on our server. When the `Cache-Control` header is present, the proxy is able to cache responses.

 > 
 > It's very important to note that middleware can "bust" the cache - even accidentally!

If you're using middleware for session management or authentication, it can be easy to accidentally cache pages that shouldn't be cached. For example, a news site might want to cache its homepage:

````rust
dioxus::server::router(app)
    .layer(axum::middleware::from_fn(
        |request: Request, next: Next| async move {
            // If the route is `/home`, cache the page
            let is_home = request.uri() == "/home";

            let res = next.run(request).await;

            if is_home {
                res.headers_mut().insert("Cache-Control", "max-age=10800")
            }

            res
        }
    ))
````

Eventually, we might add a feature that lets users customize their homepage. We might add a session layer to our router:

````rust
dioxus::server::router(app)
    .layer(session_layer) // a new session layer
    .layer(caching_layer)
````

If we're not careful, we might accidentally cache a *logged-in user's* homepage! Caching is typically based on the request's URL, but middleware also operate on headers. If we show dynamic content based on headers (like auth or sessions), we need to take care to only cache certain responses.

Many reverse proxies have the ability to configure caching based on request headers. We suggest diving into our deploy platform's reverse proxy setup, or implementing a smarter caching middleware yourself.
# Websockets

Dioxus Fullstack provides built-in types for creating and managing websockets that work alongside server functions. Dioxus websockets are built on top of the underlying Axum websocket API, but with a few improvements tailored for fullstack apps:

* Shared server/client types
* Reactive wrappers for use in UI code
* Typed inputs, outputs, and customizable encoding

Websockets are an extremely powerful communication protocol that allows bidirectional message passing to and from the server. Websockets are more efficient than HTTP requests for large amounts of messages, provide better real-time support, and allow for *ordered* data transmission.

Note that websockets are *stateful*, meaning that a websocket connection ties a client and server together for a given session. If you plan to use websockets in a "serverless" environment with time limits of request handling, then you need some way to "store" the websocket session across multiple requests.

## Websocket and WebsocketOptions

To create a new server function that returns a websocket, simply use `WebsocketOptions` as your body type and `Websocket` as your response type.

````rust
#[get("/api/uppercase_ws")]
async fn uppercase_ws(options: WebSocketOptions) -> Result<Websocket> {
    Ok(options.on_upgrade(move |mut socket| async move {
        // send back a greeting message
        _ = socket
            .send("Hello!".to_string())
            .await;

        // Loop and echo back uppercase messages
        while let Ok(msg) = socket.recv().await {
            _ = socket.send(msg.to_ascii_uppercase()).await;
        }
    }))
}
````

The `Websocket` type is generic over three parameters - the input type, output type, and encoding:

````rust
pub struct Websocket<In = String, Out = String, E = JsonEncoding> {
    // ...
}
````

The input and output types are the types used when you call `.send()` and `.recv()` on the `socket` object provided after `on_upgrade`. By strongly typing the websocket, we guarantee that your client and server always use the right message format across the client and server.

The `on_upgrade` method is a wrapper over the underlying Axum `on_upgrade` API that returns an axum response, indicating to the client that the websocket upgrade process is successful. If the client agrees, then the server will run the `on_upgrade` callback, spawning the future. Note that this future is spawned on a tokio [LocalSet](https://docs.rs/tokio/latest/tokio/task/struct.LocalSet.html). This means the future does not need to be `Send`.

We can use our own message types for the input and output messages. Calls to `.send()` and `.recv()` will attempt to deserialize messages into the right type, returning an error if the deserialization fails.

````rust
// Events flowing *from* the client to the server
#[derive(Serialize, Deserialize, Debug)]
enum ClientEvent {
    TextInput(String),
}

// Events flowing *to* the client from the server
#[derive(Serialize, Deserialize, Debug)]
enum ServerEvent {
    Uppercase(String),
}

#[get("/api/uppercase_ws")]
async fn uppercase_ws(options: WebSocketOptions) -> Result<Websocket<ClientEvent, ServerEvent>> {
    // ...
}
````

We can also customize the encoding of the websocket with the third generic on `Websocket`. By default, messages are encoded using JSON with `JsonEncoding`, but you can opt for an alternative format like the binary Cbor format with `CborEncoding`:

````rust
#[get("/api/uppercase_ws")]
async fn uppercase_ws(options: WebSocketOptions) -> Result<Websocket<ClientEvent, ServerEvent, CborEncoding>> {
    // ...
}
````

Generally, if you're working with Rust-only clients, then Cbor or MsgPack are better options, but 3rd-party clients might be better suited with the standard JSON encoding.

If you need to send extra details to the server before establishing the websocket connection, you can use path and query parameters as well as header extraction like usual.

````rust
#[get("/api/uppercase_ws?name&age")]
async fn uppercase_ws(
    name: String,
    age: i32,
    options: WebSocketOptions,
) -> Result<Websocket<ClientEvent, ServerEvent, CborEncoding>> {
    // ...
}
````

## Connecting to a Websocket

On the client, to connect to a websocket, we'll simply call the server function and await the result. You might do this inside a `use_future` hook to connect to the websocket endpoint when the component is mounted:

````rust
// Calling `.recv()` automatically waits for the connection to be established and deserializes
// messages as they arrive.
use_future(move || async move {
    // Connect to the websocket
    let socket = uppercase_ws(WebSocketOptions::new()).await;

    // Wait for the next message with `.recv()`
    while let Ok(msg) = socket.recv().await {
        messages.push(msg);
    }
});
````

The `Websocket` object has a number of utility methods you can use to assess the state of the connection, send messages, and receive messages. We expose a number of lower-level APIs like `send_raw` that let you send raw websocket frames in case the typed API is too strict.

## The use_websocket hook

You might notice in the `use_future` example above, the websocket is only accessible to its containing scope. In a practical app, you'll want to send messages into the websocket and react to any changes in connection status.

The `use_websocket` hook wraps the `websocket` object with signal-based reactivity. We can use `.status()` to read the websocket connection state, and `.send()` to send messages to the server.

To connect to the websocket, we might use `use_websocket`:

````rust
// The `use_websocket` wraps the `WebSocket` connection and provides a reactive handle to easily
// send and receive messages and track the connection state.
//
// We can customize the websocket connection with the `WebSocketOptions` struct, allowing us to
// set things like custom headers, protocols, reconnection strategies, etc.
let mut socket = use_websocket(|| uppercase_ws("John Doe".into(), 30, WebSocketOptions::new()));
````

To listen for messages, we can use `.recv()` in a future:

````rust
// Calling `.recv()` automatically waits for the connection to be established and deserializes
// messages as they arrive.
use_future(move || async move {
    while let Ok(msg) = socket.recv().await {
        messages.push(msg);
    }
});
````

And then to send messages, we can use `.send()` on the handle:

````rust
rsx! {
    input {
        placeholder: "Type a message",
        oninput: move |e| async move {
            _ = socket.send(ClientEvent::TextInput(e.value())).await;
        },
    }
}
````

If the connection fails, you can restart it by manually calling `.set()` on the handle with a new websocket object.
# Streams and SSE

Dioxus Fullstack provides an easy way to send and receive streaming data from a server. This can be useful to
implement functionality like streaming LLM responses, file downloads, and server-sent-events (SSE).

Unlike websockets which allow two-way communication, streams are unidirectional. In browsers, it's usually impossible to have a streaming input *and* a streaming output, so you should stick to using streams for things like text/byte responses or file sending.

## Streaming Text

Dioxus Fullstack provides the `TextStream` type to easily send chunks of text between the client and the server. We can use this type as the input or output of a server function:

````rust
// The output is a `TextStream`
#[get("/api/test_stream?start")]
async fn text_stream(start: Option<i32>) -> Result<TextStream> {
    let mut count = start.unwrap_or(0);

    // We can create a new text stream with `spawn`
    Ok(TextStream::spawn(move |tx| async move {

        // Send a message with `unbounded_send`
        while tx.unbounded_send(format!("Hello, world! {}", count)).is_ok() {
            count += 1;

            // and then wait a bit
            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        }
    }))
}
````

You can create a new stream with `TextStream::spawn` which gives you an `UnboundedSender` object, or from `TextStream::new()` which takes an existing type that implements the `Stream` trait:

````rust
// the `rx` here implements `Stream` which can be used in `new()`
let (tx, rx) = futures::channel::mpsc::unbounded();

tokio::spawn(async move {
    let mut count = start.unwrap_or(0);
    loop {
        let message = format!("Hello, world! {}", count);
        if tx.unbounded_send(message).is_err() {
            break;
        }

        count += 1;
        tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
    }
});

Ok(Streaming::new(rx))
````

## Streaming Bytes

The `TextStream` type is a superset of the `ByteStream` type. To send raw bytes between the client and the server, simply use `ByteStream` in the same way as `TextStream`, but with the `Bytes` type as input:

````rust
#[post("/api/upload_as_bytestream")]
async fn upload_as_bytestream(mut stream: ByteStream) -> Result<()> {
    while let Some(chunk) = stream.next().await {
        // ... handle chunk
    }

    Ok(())
}
````

Note that in this example, we are *consuming* the byte stream using `.next()`. Streams in Dioxus implement the standard [`Stream`](https://docs.rs/futures/latest/futures/prelude/trait.Stream.html) trait, which has a number of [useful extensions](https://docs.rs/futures/latest/futures/stream/trait.StreamExt.html).

## The Generic `Streaming<T, E>` type

Both the `TextStream` and `ByteStream` types are implemented as specific variations of the generic `Streaming<T, E>` type. Under the hood, both stream types are simply streams of `Vec<u8>`. The `ByteStream` type wraps the incoming bytes in the `Bytes` type while `TextStream` ensures they're valid utf-8 text.

You can use any encoding provided it implements the `Encoding` trait.

````rust
pub trait Encoding {
    fn content_type() -> &'static str;
    fn stream_content_type() -> &'static str;
    fn to_bytes(data: impl Serialize) -> Option<Bytes>;
    fn from_bytes<O: DeserializeOwned>(bytes: Bytes) -> Option<O>;
}
````

Dioxus provides a number of built-in encodings:

* JsonEncoding: String-encoded JSON text
* CborEncoding: Binary-encoded data in the [CBOR](https://cbor.io) format
* PostcardEncoding: A binary encoding built on [Postcard](https://docs.rs/postcard/latest/postcard/) meant for use in no_std apps
* MsgPackEncoding: A compact binary encoding in a ["JSON but small" format](https://msgpack.org/index.html)

As each element in the stream arrives, it will be appropriately chunked and then deserialized using the encoding's `from_bytes` and `to_bytes` implementations.

This means we can stream arbitrary data - even custom structures!

````rust
#[derive(Serialize, Deserialize, Debug)]
struct Dog {
    name: String,
    age: u8,
}

/// A custom `Streaming<T, E>` endpoint that streams JSON-encoded `Dog` structs to the client.
///
/// Dioxus provides the `JsonEncoding` type which can be used to encode and decode JSON data.
#[get("/api/json_stream")]
async fn json_stream() -> Result<Streaming<Dog, JsonEncoding>> {
    Ok(Streaming::spawn(|tx| async move {
        for count in 0..10 {
            let dog = Dog {
                name: format!("Dog {}", count),
                age: (count % 10) as u8,
            };

            if tx.unbounded_send(dog).is_err() {
                break;
            }

            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        }
    }))
}
````

## File Streams

The final stream type, `FileStream`, is a special stream type *not* built on `Streaming<T, E>`. File streams use platform-native optimizations to efficiently stream files without buffering the entire file into memory.

We can create the `FileStream` object in a variety of ways. For example, we can use `from_path` to efficiently stream arbitrary files from the server's file system:

````rust
/// This endpoint uses `file!()` to return the current file's `PathBuf`
#[get("/api/download_as_filestream")]
async fn download_as_filestream() -> Result<FileStream> {
    Ok(FileStream::from_path(file!()).await?)
}
````

The `FileStream` type can be created from the `FileData` type from dioxus-html. This makes it easy to add streaming file uploads to your app from the HTML `<input />` and `<form />` elements:

````rust
// Our client component calls the endpoint with `file.into()`
fn app() -> Element {
    rsx! {
        h3 { "Upload as FileUpload" }
        div {
            ondragover: move |evt| evt.prevent_default(),
            ondrop: move |evt| async move {
                evt.prevent_default();
                for file in files {
                    _ = upload_file_as_filestream(file.into()).await;
                }
            },
            "Drop files here"
        }
    }
}

// Our server endpoint accepts `FileStream`
#[post("/api/upload_as_file_stream")]
async fn upload_file_as_filestream(mut upload: FileStream) -> Result<()> {
    // ...
}
````

The `FileStream` type also sets extra headers like `Content-Disposition` and `X-Content-Size` which give the server endpoint more information to efficiently handle the upload.
# Forms and Multipart

Dioxus natively supports HTML Forms and Multipart uploads.

* HTML forms are collections of input elements represented as a list of key-value pairs
* Multipart requests are requests that contain multiple bodies

Many forms you'll build will be rather simple. Uploading them will only require a single request body. In some cases, as with file-uploads, you'll need a multi-part form data.

## Forms

Dioxus Fullstack supports form uploads through Axum's typed `Form<T>` type. Simply wrap a struct that implements `Serialize + Deserialize` and pass it as an argument to a server function:

````rust
// Our form payload
#[derive(Deserialize, Serialize)]
pub struct LoginForm {
    username: String,
    password: String,
}

// Our form endpoint
#[post("/api/login")]
async fn login(form: Form<LoginForm>) -> Result<()> {
    // Verify the username and password.
    // In a real application, you'd check these against a database.
    if form.0.username == "admin" && form.0.password == "password" {
        // ..
    }
}
````

The values from the form can be created manually by constructing the form body, or automatically by calling `.parsed_values()` on the `FormEvent` type created by `onsubmit`.

````rust
rsx! {
    form {
        onsubmit: move |evt: FormEvent| async move {
            // Prevent the browser from navigating away.
            evt.prevent_default();

            // Extract the form values into our `LoginForm` struct. The `.parsed_values` method
            // is provided by Dioxus and works with any form element that has `name` attributes.
            let values: LoginForm = evt.parsed_values().unwrap();

            // Call the login endpoint
            login(Form(values)).await;
        },
        input { r#type: "text", id: "username", name: "username" }
        label { "Username" }
        input { r#type: "password", id: "password", name: "password" }
        label { "Password" }
        button { "Login" }
    }
}
````

Form elements must have a "name" attribute which will be used during the deserialization process to identify form fields.

Note that `GET` requests will encode the form values in the request URL. This might not work for complex data structures, so it's best practice to use `POST` endpoints for handling form data.

## Multipart

With some forms, you'll need to handle multiple request bodies in a single request. For example, if your form has file inputs, the browser will automatically create a multi-part request with the form values in one body and then file uploads in another.

Dioxus provides the `MultipartFormData` type which will automatically convert `FormEvent` objects into proper multi-part requests.

On the client, you can convert the `FormEvent` with `.into()`:

````
rsx! {
    form {
        display: "flex",
        flex_direction: "column",
        gap: "8px",
        onsubmit: move |evt| async move {
            evt.prevent_default();

            upload(evt.into()).await;
        },
        label { r#for: "headshot", "Photos" }
        input { r#type: "file", name: "headshot", multiple: true, accept: ".png,.jpg,.jpeg" }
        label { r#for: "resume", "Resume" }
        input { r#type: "file", name: "resume", multiple: false, accept: ".pdf" }
        label { r#for: "name", "Name" }
        input { r#type: "text", name: "name", placeholder: "Name" }
        label { r#for: "age", "Age" }
        input { r#type: "number", name: "age", placeholder: "Age" }
        input { r#type: "submit", name: "submit", value: "Submit your resume" }
    }
}
````

On the server, you can use an endpoint that takes `MultipartFormData` and then iterate through the fields using `next_field()`:

````rust
#[post("/api/upload-multipart")]
async fn upload(mut form: MultipartFormData) -> Result<()> {
    while let Ok(Some(field)) = form.next_field().await {
        let name = field.name().unwrap_or("<none>").to_string();
        let file_name = field.file_name().unwrap_or("<none>").to_string();
        let content_type = field.content_type().unwrap_or("<none>").to_string();
        let bytes = field.bytes().await;

        // ...
    }

    Ok(())
}
````

Currently Dioxus does not support typed `MultipartFormData` objects, but it *is* something we'd like to add in the future.
# Authentication

Most production-ready apps have some sort of authentication and authorization to restrict data and resources from being publicly accessible to all users.

Dioxus does *not* provide a built-in way of managing authentication. However, since auth is such a critical component of building fullstack apps, this chapter will help guide you through the process of implementing it for your app.

 > 
 > In the future, we'd like to integrate sessions and auth directly into Dioxus fullstack, but for now, you'll need to rely on 3rd-party libraries.

## What is Authentication?

Authentication is the process of verifying a user's identity, usually through the use of cookies or access tokens.

Your app should not blindly accept actions from untrusted users, so it's important to verify that a user who claims to be "Bob" *actually is* "Bob".

## What is Authorization?

Authorization is the *next step* after authentication. Once a user's identity is verified, you must then verify that they can actually take a given action.

You don't want one user to change another user's login credentials, so any action related to user data must be *authorized* first.

## Auth is Built on Sessions

Fundamentally, auth works by associating a users *connection* with some *session* in a database. As a user traverses our page and makes actions, we need some way of identifying their session on the server.

Usually, this is done via a middleware that automatically registers every connection with a row in your database. If the user is *unauthenticated*, you can either store their session as an anonymous user, or a ignore it completely.

A session is usually inserted with an axum-level middleware:

````rust
dioxus::server::router(app)
    .layer(axum::middleware::from_fn(
        |request: Request, next: Next| async move {
            // Get the auth token and then insert the session into the request's extensions
            //
            // We need to look up the auth token in our database to retrieve the session
            if let Some(token) = request.headers().get("Authorization") {
                if let Some(session) = DATABASE.get_session(token) {
                    request.extensions_mut().insert(session);
                }
            }

            // And then run the request
            next.run(request).await
        },
    ))
````

## Libraries for Authentication

You can implement session lookup and session creation system manually, or use a 3rd-party library like [`axum_session_auth`](https://crates.io/crates/axum_session_auth) to handle most of the complexity for you.

Generally, you'll add a 3rd-party library as a `.layer()` on your router, and it will add the `Session` extension to your requests automatically:

````rust
dioxus::serve(|| async move {
    // Create an axum router that dioxus will attach the app to
    Ok(dioxus::server::router(app)
        // Add the `AuthLayer`
        .layer(
            AuthLayer::new(Some(db.clone()))
                .with_config(AuthConfig::<i64>::default().with_anonymous_user_id(Some(1))),
        )
        // And add the `SessionLayer`
        .layer(SessionLayer::new(
            SessionStore::<SessionSqlitePool>::new(
                Some(db.into()),
                SessionConfig::default().with_table_name("test_table"),
            )
            .await?,
        )))
})
````

The `axum_session_auth` crate integrates with `sqlx` to automatically manage sessions using a row in your database.

## Auth as an Extractor

You can use extractors to integrate auth with your Fullstack application.

You can create a custom extractor to extract the auth session from the request. From that auth session, you can check if the user has the required privileges before returning the private data.

Because the sessions are inserted into every request, you can extract them with server-only extractors:

````rust
/// We use the `auth::Session` extractor to get access to the current user session.
/// This lets us modify the user session, log in/out, and access the current user.
#[post("/api/user/login", auth: auth::Session)]
pub async fn login() -> Result<()> {
    auth.login_user(2);
    Ok(())
}

/// Just like `login`, but this time we log out the user.
#[post("/api/user/logout", auth: auth::Session)]
pub async fn logout() -> Result<()> {
    auth.logout_user();
    Ok(())
}
````

A [full auth example](https://github.com/DioxusLabs/dioxus/blob/7102bc3b6a0ddea3a9e71423fc6d667df8d956f3/examples/07-fullstack/auth/src/main.rs) with the complete implementation is available in the fullstack examples.

## Auth as a 3rd-party service

Implementing auth can be somewhat tedious, so there are a number of 3rd party services that simplify the implementation for you. With these services, the session and auth data tends to not live in *your database*, but rather theirs.

We don't recommend any particular 3rd party service. However, there are some solutions like Supabase and Firebase where sessions are managed in your database, but with prebuilt infrastructure for you to integrate with.
# Native Clients

So far, we've focused on using fullstack alongside a web application. However, not all apps you'll build with Dioxus will be loaded in a web browser. Dioxus supports mobile apps and desktop apps as well.

On these platforms, fullstack works a bit differently. You can still use server functions, but things like server-side-rendering no-longer apply.

## Developing a Native Fullstack App

Developing a native fullstack app works just the same as developing a fullstack web app. Make sure your `Cargo.toml` has the appropriate features:

````toml
[dependencies]
dioxus = { version = "0.7", features = ["fullstack"] }

[features]
server = ["dioxus/server"]
desktop = ["dioxus/desktop"]
````

And then, to serve the app, use `dx serve --<platform>`:

````sh
dx serve --desktop
````

## Server Functions for Native App

When you build a native app that relies on server functions, you can freely call any server function just as you would with a web app.

This simple hello world app works the same on web, desktop, and mobile:

````rust
use dioxus::prelude::*;

fn main() {
    dioxus::launch(|| {
        let mut message = use_action(get_message);

        rsx! {
            h1 { "Server says: "}
            pre { "{message:?}"}
            button { onclick: move |_| message.call("world".into(), 30), "Click me!" }
        }
    });
}

#[get("/api/{name}/?age")]
async fn get_message(name: String, age: i32) -> Result<String> {
    Ok(format!("Hello {}, you are {} years old!", name, age))
}
````

Your native code can still make requests to your backend. However, when if you deployed your app to production, you might notice that the native app *does not know where to make requests*.

In the web, requests are always made to the current host origin. For example, requests to this endpoint are made to `/api/dogs`:

````rust
#[get("/api/dogs")]
async fn get_message() -> Result<()> {
    // ..
}
````

Desktop and mobiles are not served from a specific URL, and thus do not know which host to make a request to.

To set a specific server URL, you must call `set_server_url` before making any requests:

````rust
fn main() {
    #[cfg(not(feature = "server"))]
    dioxus::fullstack::set_server_url("https://hot-dog.fly.dev");

    dioxus::launch(app);
}
````

This ensures that requests are always properly joined with the correct host.

## Disabled Fullstack Features

When using fullstack with native apps, a number of features and optimizations are disabled. Native apps are usually meant to be used offline, so their rendering needs to happen entirely on the client. Architecturally, native apps are similar to single-page-applications (SPA) where the bundle loads and *then* HTTP requests are made to load content.

As such, a number of features are disabled:

* There is no hydration context, and thus no hydration data to hydrate the page
* The app is never rendered on the server, skipping `#[cfg(feature = "server")]` code
* There is no `FullstackContext` when rendering components
* HTML Streaming and SSG have no effect

Functionally, this won't change how you build your apps, but you should be aware that some code might never be executed.

## Prefer Known Endpoints

Dioxus supports two ways of annotating server functions:

* Explicitly with `#[get]`, `#[post]`, `#[delete]`, etc.
* Anonymously with `#[server]`

When you use the `#[server]` macro, the endpoint path is free to change as you update the endpoint's signature and body. If you re-redeploy your backend, URLs that worked previously are not guaranteed to exist in the future.

````rust
// âŒ this endpoint generates `/api/do_it12nldkj2378jnakls`
#[server]
async fn do_it() -> Result<()> {
    //
}
````

Because the endpoint receives a hash, its name is unique and might change as you update its code.

When using server functions with native clients, we strongly recommend using the `#[get]` / `#[post]` annotations since they guarantee a stable endpoint.

````rust
// âœ… This endpoint is stable
#[post("/api/do_it")]
async fn do_it() -> Result<()> {
    //
}
````

## Versioning

Because native clients are distributed as downloadable software, they might not always up to date as the latest version of your code. This can be particularly challenging when you want to update the signature of an endpoint.

````rust
// version 1
#[post("/api/do_it")]
async fn do_it() -> Result<()> { /* */ }

// version 2
// âŒ we are breaking old clients!
#[post("/api/do_it")]
async fn do_it(name: String) -> Result<()>  { /* */ }
````

We hope this problem is obvious to you - if you re-redploy your backend with breaking changes, previous clients will break!

To upgrade APIs, we recommend one of two options:

* Use `Option<T>` to add new fields
* Use `/api/v1`, `/api/v2/` versioning

For most API upgrades, you can simply add new fields by making new values optional with `Option<T>`:

````rust
// version 2
// âœ… Option<String> means `name` is not required
#[post("/api/do_it")]
async fn do_it(name: Option<String>) -> Result<()>  { /* */ }
````

For API changes that require much larger changes, we recommend using a versioning scheme to create different versions of the API accessible by the client:

````rust
// This is at /api/v1/
#[post("/api/v1/do_it")]
async fn do_it() -> Result<()> { /* */ }

// This is at api/v2
#[post("/api/v2/do_it")]
async fn do_it(name: String) -> Result<()> { /* */ }
````

Creating different API versions is common practice and helps prevent breaking old clients as you update your app.

## Deploying

You can deploy native fullstack apps just the same as you would deploy a regular web app. Server apps always generate a `server` binary and a `/public/` folder. Native apps will generate an app bundle (`.app`, `.ipa`, `.apk`, etc).

You can distribute the native app via an app store or by making the file downloadable to your users.

To distribute the server, simply upload it to a hosting provider of your choice. As long as you set the `server_url` in the native app, you should be able to access your backend from the native client.
# Streaming

For some sites, it is extremely important to optimize "time-to-first-byte". Users want to see results as soon as possible, even if not *all* results are ready immediately.

Dioxus supports this usecase with a technology called *"HTML Streaming"*. HTML streaming allows you to quickly send an initial skeleton of the page to the user and then fill in various components as their data loads.

## What is Streaming?

The default rendering mode in dioxus fullstack waits for all [suspense boundaries](../basics/suspense.md#suspense-with-fullstack) to resolve before sending the entire page as HTML to the client. If you have a page with multiple chunks of async data, the server will wait for all of them to complete before rendering the page.

When streaming is enabled, the server can send chunks of HTML to the client as soon as each suspense boundary resolves. You can start interacting with a page as soon as the first part of the HTML is sent, instead of waiting for the entire page to be ready. This can lead to a much faster initial load time.

Bellow is the same [hackernews example](https://github.com/DioxusLabs/dioxus/tree/main/examples/01-app-demos/hackernews) rendered with and without streaming enabled. While both pages take the same amount of time to load all the data, the page with streaming enabled on the left shows you the data as soon as it becomes available.

````inject-dioxus
DemoFrame {
    overflow: "hidden",
    FakePage {
        div {
            display: "flex",
            flex_direction: "row",
            justify_content: "space-around",
            align_items: "center",
            height: "100%",
            width: "100%",
            img {
                max_height: "100%",
                max_width: "50%",
                aria_label: "Hackernews with streaming enabled",
                src: asset!("/assets/static/streaming-enabled-hackernews"),
            }
            img {
                max_height: "100%",
                max_width: "50%",
                aria_label: "Hackernews with streaming disabled",
                src: asset!("/assets/static/streaming-disabled-hackernews"),
            }
        }
    }
}
````

## SEO and No JS

When streaming is enabled, all of the contents of the page are still rendered into the html document, so search engines can still crawl and index the full content of the page. However, the content will not be visible to users unless they have JavaScript enabled. If you want to support users without JavaScript, you will need to disable streaming and use the default rendering mode.

## Do You Need Streaming?

HTML streaming is best suited for apps like e-commerce sites where much of the data is quick to render (the product image, description, etc) but some data takes much longer to resolve. In these cases, you don't want to make the user wait too long for the page to load, so you send down what you have as soon as possible.

Streaming adds some slight overhead and complexity to your app, so it's disabled by default.

## Enabling Streaming

You can enable streaming in the ServeConfig builder with the `enable_out_of_order_streaming` method. If you are launching your application through the `dioxus::LaunchBuilder`, you can use the `with_cfg` method to pass in a configuration that enables streaming:

````rs@streaming.rs
pub fn main() {
    dioxus::LaunchBuilder::new()
        .with_cfg(server_only! {
            dioxus::server::ServeConfig::builder().enable_out_of_order_streaming()
        })
        .launch(app);
}
````

or if you are using a custom axum server, you can pass the config into `serve_dioxus_application` directly:

````rs@streaming.rs
#[cfg(feature = "server")]
#[tokio::main]
async fn main() {
    let addr = dioxus::cli_config::fullstack_address_or_localhost();
    let router = axum::Router::new()
        // Server side render the application, serve static assets, and register server functions
        .serve_dioxus_application(
            dioxus::server::ServeConfig::builder().enable_out_of_order_streaming(),
            app,
        )
        .into_make_service();
    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, router).await.unwrap();
}
````

## Head elements with streaming

Head elements can only be rendered in the initial HTML chunk that contains the `<head>` tag. You should include all of your `document::Link`, `document::Meta`, and `document::Title` elements in the first part of your page if possible. If you have any head elements that are not included in the first chunk, they will be rendered by the client after hydration instead, which will not be visible to any search engines or users without JavaScript enabled.

The initial chunk of HTML is send after [commit_initial_chunk](https://docs.rs/dioxus-fullstack/0.7.0-alpha.1/dioxus_fullstack/prelude/fn.commit_initial_chunk.html) is called for the first time. If you are using the router, this will happen automatically when all suspense boundaries above the router are resolved. If you are not using the router, you can call `commit_initial_chunk` manually after all of your blocking head elements have been rendered.

````rs@streaming.rs
/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route("/")]
    Home,
}

fn Home() -> Element {
    let title = use_server_future(get_title)?;
    let description = use_server_future(get_description)?;

    rsx! {
        // This will be rendered on the server because it is inside the same (root)
        // suspense boundary as the `Router` component.
        document::Title { {title} }
        SuspenseBoundary {
            fallback: |_| {
                rsx! { "Loading..." }
            },
            AsyncHead {}
        }
    }
}

fn AsyncHead() -> Element {
    let description = use_server_future(get_description)?;
    // The resource should always be resolved at this point because the `?` above bubbles
    // up the async case if it is pending
    let current_description = description.read_unchecked();
    let current_description = current_description.as_ref().unwrap();

    rsx! {
        // This will be rendered on the client because it is in a
        // suspense boundary below the `Router` component.
        document::Meta { name: "description", content: "{current_description}" }
    }
}
````

## Response Headers with Streaming

When rendering an app with streaming enabled, Dioxus will wait for the app to commit its initial skeleton before sending a response to the user's request. This is done with the `commit_initial_chunk()` method.

Once the initial chunk is committed, you can no longer change the headers of the response nor change the HTTP status.

For example, you might have a server function that throws a 404 status code:

````rust
#[get("/api/post/{id}")]
async fn get_post(id: u32) -> Result<String, HttpError> {
    match id {
        1 => Ok("first post".to_string()),
        _ => HttpError::not_found("Post not found")?,
    }
}
````

With streaming disabled, if this status code is bubbled to the root component as an error, the user will get a `404 NOT FOUND` status in the response.

````rust
#[component]
fn Post(id: ReadSignal<u32>) -> Element {
    // If `get_post` returns a 404, then the user will also get a 404
    let post_data = use_loader(move || get_post(id()))?;

    rsx! {
        h1 { "Post {id}" }
        p { "{post_data}" }
    }
}
````

However, when streaming is *enabled*, the status code from this server function will only be propagated to the user *before* the call to `commit_initial_chunk()`.

Normally, you won't call `commit_initial_chunk()` yourself since the `Router` component calls it for you once the root suspense boundary is resolved.

This means that, when suspense is enabled, server functions won't set the HTTP status code if they are called from within a dedicated suspense boundary:

````rust
fn Home() -> Element {
    rsx! {
        SuspenseBoundary {
            fallback: |_| rsx! { "loading..." },

            // Errors here won't propagate to the response headers
            Post { id: 123 }
        }
    }
}
````
# Static Site Generation

Static site generation (SSG) lets you pre-generate all static pages of your application at build time. Once you have the static HTML pages, you can deploy them to any static hosting provider like GitHub Pages.

SSG is extremely powerful since it lets you cache the rendering of your pages before deploying to production. This cuts down on bandwidth costs, lets you cache content on a CDN, and allows for deploying *without* a server. Many deploy providers let you deploy SSG sites for free!

## How Dioxus SSG works

Dioxus SSG works by running your app locally, querying the app for a sitemap, and then indexing your site using `curl` requests manually. If your site is configured to use SSG, then it will cache HTML for each page on the filesystem.

This approach to SSG is quite different than a traditional static-site-generator like Hugo, Jekyll, or Zola. Dioxus SSG is designed to let you write your entire site in Rust, load data however you want, and then deploy a hybrid SSG app that loads SPA content.

## You might not need SSG

Even if your app has a significant amount of static content, you might not actually need SSG. You should use SSG in a few cases:

* You have *lots* of static content that benefits from pre-rendering before deploy
* You don't need a backend for your site

Sites like docs and portfolios benefit from SSG while apps like photo editors will not. In many cases, you can simply set `Cache-Control` headers while rendering pages and let your CDN or reverse-proxy handle caching for you!

## Setting up the ServeConfig

SSG builds on top of the incremental rendering feature of Dioxus fullstack. We need to set up the `ServeConfig` to enable incremental rendering. The incremental config needs to render to the `public` directory where Dioxus places all other public files like the wasm binary and static assets. The `public` directory in the web folder will always be placed alongside the server binary.

````rs@static_site_generation.rs
fn main() {
    dioxus::LaunchBuilder::new()
        // Set the server config only if we are building the server target
        .with_cfg(server_only! {
            ServeConfig::builder()
                // Enable incremental rendering
                .incremental(
                    dioxus::server::IncrementalRendererConfig::new()
                        // Store static files in the public directory where other static assets like wasm are stored
                        .static_dir(
                            std::env::current_exe()
                                .unwrap()
                                .parent()
                                .unwrap()
                                .join("public")
                        )
                        // Don't clear the public folder on every build. The public folder has other files including the wasm
                        // binary and static assets required for the app to run
                        .clear_cache(false)
                )
                .enable_out_of_order_streaming()
        })
        .launch(app);
}
````

## Configuring static routes

Once you have incremental rendering enabled, you need to tell the CLI about the static routes in your app. The CLI looks for a server function at the endpoint `"static_routes"` that returns a list of all static urls. It will call this server function at build time and pre-render all of the routes in the list.

````rs@static_site_generation.rs
#[derive(Routable, Clone, PartialEq)]
pub enum Route {
    // Any routes with no dynamic segments in your router will be included in the static routes list
    #[route("/")]
    Index {},

    #[route("/other")]
    Other {},
}

// The server function at the endpoint "static_routes" will be called by the CLI to generate the list of static
// routes. You must explicitly set the endpoint to `"static_routes"` in the server function attribute instead of
// the default randomly generated endpoint.
#[server(endpoint = "static_routes", output = server_fn::codec::Json)]
async fn static_routes() -> Result<Vec<String>, ServerFnError> {
    // The `Routable` trait has a `static_routes` method that returns all static routes in the enum
    Ok(Route::static_routes()
        .iter()
        .map(ToString::to_string)
        .collect())
}
````

## Publishing static sites

Finally, you can bundle your site with `dx bundle --web --ssg`. Once the CLI finishes bundling, you should see a `public` folder in the dx folder of your project:

![Dioxus SSG](/assets/06_docs/ssg_folder.png)

The folder contains all of the static assets that you need to serve your site. You can copy the public folder into any static hosting provider like GitHub Pages.
# Introduction

As your app grows, it can be helpful to organize your app into multiple pages or views you can switch between. In web application, each view has an associated url that can be saved and shared. The Dioxus router helps you manage the URL state of your application. It provides a type safe interface that checks all routes at compile time to prevent runtime errors.

## Installing the router

To get started, you can add the `router` feature to your `dioxus` dependency in your `Cargo.toml`:

````toml
[dependencies]
dioxus = { version = "0.7", features = ["router"] }
````

## Creating a Routable enum

The core of the router is your `Routable` enum. You will use this enum throughout your application to navigate to different pages. Each variant of the enum is a single view page in your app handles:

1. Parsing your route from a URL
1. Displaying your route as a URL
1. Rendering your route as a component

To create a `Routable` enum, you will need to derive the `Routable` with a `#[route(..)]` attribute on each variant which describes the format of the route. You must have a component in scope that matches the name of each variant to render the route:

````rs@router_introduction.rs
use dioxus::prelude::*;

#[derive(Clone, Debug, PartialEq, Routable)]
enum Route {
    #[route("/")]
    Home,

    #[route("/about")]
    About,

    #[route("/user/:id")]
    User { id: u32 },
}

#[component]
fn Home() -> Element {
    rsx! { "Welcome to the home page!" }
}

#[component]
fn About() -> Element {
    rsx! { "This is the about page." }
}

#[component]
fn User(id: u32) -> Element {
    rsx! { "User page for user with id: {id}" }
}
````

## Rendering the router

Now that you have defined your routes, you can use the `Router` component to render them. The `Router` component takes your `Routable` enum as a generic argument to define handle parsing, and rendering routes.

````rs@router_introduction.rs
fn main() {
    dioxus::launch(|| rsx! { Router::<Route> {} });
}
````

## Linking to your first route

To navigate between routes, you can use the `Link` component provided by the router. The `Link` component takes a `to` prop which can be either a unchecked string route or a variant of your `Routable` enum:

````rust@router_introduction.rs
// ...

#[component]
fn Home() -> Element {
    rsx! {
        div {
            "Welcome to the home page!"
            Link { to: Route::About, "Go to About Page" }
        }
    }
}
````
# Defining Routes

When creating a `Routable` enum, we can define routes for our application using the `route("path")` attribute.

## Route Segments

Each route is made up of segments. Most segments are separated by `/` characters in the path.

There are five fundamental types of segments:

1. [Static segments](#static-segments) are fixed strings that must be present in the path.
1. [Dynamic segments](#dynamic-segments) are types that can be parsed from a segment.
1. [Catch-all segments](#catch-all-segments) are types that can be parsed from multiple segments.
1. [Query segments](#query-segments) are types that can be parsed from the query string.
1. [Hash fragments](#hash-segments) are types that can be parsed from the hash fragment.

Routes are matched:

* First, from most specific to least specific (Static then Dynamic then Catch All) (Query and hash are always matched)
* Then, if multiple routes match the same path, the order in which they are defined in the enum is followed.

## Static segments

Fixed routes match a specific path. For example, the route `#[route("/about")]` will match the path `/about`.

````rs@static_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // Routes always start with a slash
    #[route("/")]
    Home {},
    // You can have multiple segments in a route
    #[route("/hello/world")]
    HelloWorld {},
}

#[component]
fn Home() -> Element {
    todo!()
}

#[component]
fn HelloWorld() -> Element {
    todo!()
}
````

## Dynamic Segments

Dynamic segments are in the form of `:name` where `name` is
the name of the field in the route variant. If the segment is parsed
successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromStr`.

````rs@dynamic_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with : are dynamic segments
    #[route("/post/:name")]
    BlogPost {
        // You must include dynamic segments in child variants
        name: String,
    },

    #[route("/document/:id")]
    Document {
        // You can use any type that implements FromStr
        // If the segment can't be parsed, the route will not match
        id: usize,
    },
}

// Components must contain the same dynamic segments as their corresponding variant
#[component]
fn BlogPost(name: String) -> Element {
    todo!()
}

#[component]
fn Document(id: usize) -> Element {
    todo!()
}
````

## Catch All Segments

Catch All segments are in the form of `:..name` where `name` is the name of the field in the route variant. If the segments are parsed successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromSegments`. (`Vec<String>` implements this by default)

Catch All segments must be the *last route segment* in the path (query segments are not counted) and cannot be included in nests.

````rs@catch_all_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with :.. are catch all segments
    #[route("/blog/:..segments")]
    BlogPost {
        // You must include catch all segment in child variants
        segments: Vec<String>,
    },
}

// Components must contain the same catch all segments as their corresponding variant
#[component]
fn BlogPost(segments: Vec<String>) -> Element {
    todo!()
}
````

## Query Segments

Query segments are in the form of `?:name&:othername` where `name` and `othername` are the names of fields in the route variant.

Unlike [Dynamic Segments](#dynamic-segments) and [Catch All Segments](#catch-all-segments), parsing a Query segment must not fail.

The segment can be of any type that implements `FromQueryArgument`.

Query segments must be the *after all route segments* and cannot be included in nests.

````rs@query_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with ?: are query segments
    #[route("/blog?:name&:surname")]
    BlogPost {
        // You must include query segments in child variants
        name: String,
        surname: String,
    },
}

#[component]
fn BlogPost(name: String, surname: String) -> Element {
    rsx! {
        div { "This is your blogpost with a query segment:" }
        div { "Name: {name}" }
        div { "Surname: {surname}" }
    }
}
````

## Hash Segments

Hash segments are in the form of `#:field` where `field` is a field in the route variant.

Just like [Query Segments](#query-segments), parsing a Hash segment must not fail.

The segment can be of any type that implements `FromHashFragment`.

Hash fragments must be the *after all route segments and any query segments* and cannot be included in nests.

````rs@hash_fragments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with #: are hash segments
    #[route("/blog#:name")]
    BlogPost {
        // You must include hash segments in child variants
        name: String,
    },
}

#[component]
fn BlogPost(name: String) -> Element {
    rsx! {
        div { "This is your blogpost with a query segment:" }
        div { "Name: {name}" }
    }
}
````

## Nested Routes

When developing bigger applications we often want to nest routes within each
other. As an example, we might want to organize a settings menu using this
pattern:

````plain
â”” Settings
  â”œ General Settings (displayed when opening the settings)
  â”œ Change Password
  â”” Privacy Settings
````

We might want to map this structure to these paths and components:

````plain
/settings		  -> Settings { GeneralSettings }
/settings/password -> Settings { PWSettings }
/settings/privacy  -> Settings { PrivacySettings }
````

Nested routes allow us to do this without repeating /settings in every route.

### Nesting

To nest routes, we use the `#[nest("path")]` and `#[end_nest]` attributes.

The path in nest must not:

1. Contain a [Catch All Segment](routes.md#catch-all-segments)
1. Contain a [Query Segment](routes.md#query-segments)

If you define a dynamic segment in a nest, it will be available to all child routes and layouts.

To finish a nest, we use the `#[end_nest]` attribute or the end of the enum.

````rs@nest.rs
#[derive(Routable, Clone)]
// Skipping formatting allows you to indent nests
#[rustfmt::skip]
enum Route {
    // Start the /blog nest
    #[nest("/blog")]
        // You can nest as many times as you want
        #[nest("/:id")]
            #[route("/post")]
            PostId {
                // You must include parent dynamic segments in child variants
                id: usize,
            },
        // End nests manually with #[end_nest]
        #[end_nest]
        #[route("/:id")]
        // The absolute route of BlogPost is /blog/:name
        BlogPost {
            id: usize,
        },
    // Or nests are ended automatically at the end of the enum
}

#[component]
fn BlogPost(id: usize) -> Element {
    todo!()
}

#[component]
fn PostId(id: usize) -> Element {
    todo!()
}
````
# Links & Navigation

When we split our app into pages, we need to provide our users with a way to
navigate between them. On regular web pages, we'd use an anchor element for that,
like this:

````html
<a href="/other">Link to an other page</a>
````

However, we cannot do that when using the router for three reasons:

1. Anchor tags make the browser load a new page from the server. This takes a
   lot of time, and it is much faster to let the router handle the navigation
   client-side.
1. Navigation using anchor tags only works when the app is running inside a
   browser. This means we cannot use them inside apps using Dioxus Desktop.
1. Anchor tags cannot check if the target page exists. This means we cannot
   prevent accidentally linking to non-existent pages.

To solve these problems, the router provides us with a [`Link`] component we can
use like this:

````rs@links.rs
#[component]
fn NavBar() -> Element {
    rsx! {
        nav {
            Link { to: Route::Home {}, "Home" }
        }
        Outlet::<Route> {}
    }
}
````

The `target` in the example above is similar to the `href` of a regular anchor
element. However, it tells the router more about what kind of navigation it
should perform. It accepts something that can be converted into a
[`NavigationTarget`]:

* The example uses a Internal route. This is the most common type of navigation.
  It tells the router to navigate to a page within our app by passing a variant of a \[`Routable`\] enum. This type of navigation can never fail if the link component is used inside a router component.
* \[`External`\] allows us to navigate to URLs outside of our app. This is useful
  for links to external websites. NavigationTarget::External accepts an URL to navigate to. This type of navigation can fail if the URL is invalid.

 > 
 > The [`Link`] accepts several props that modify its behavior. See the API docs
 > for more details.

# Programmatic Navigation

Sometimes we want our application to navigate to another page without having the
user click on a link. This is called programmatic navigation.

## Using a Navigator

We can get a navigator with the [`navigator`] function which returns a [`Navigator`].

We can use the [`Navigator`] to trigger four different kinds of navigation:

* `push` will navigate to the target. It works like a regular anchor tag.
* `replace` works like `push`, except that it replaces the current history entry
  instead of adding a new one. This means the prior page cannot be restored with the browser's back button.
* `Go back` works like the browser's back button.
* `Go forward` works like the browser's forward button.

````rs@navigator.rs
#[component]
fn Home() -> Element {
    let nav = navigator();

    // push
    nav.push(Route::PageNotFound { route: vec![] });

    // replace
    nav.replace(Route::Home {});

    // go back
    nav.go_back();

    // go forward
    nav.go_forward();

    rsx! { h1 { "Welcome to the Dioxus Blog!" } }
}
````

You might have noticed that, like [`Link`], the [`Navigator`]s `push` and
`replace` functions take a [`NavigationTarget`]. This means we can use either
`Internal`, or `External` targets.

## External Navigation Targets

Unlike a [`Link`], the [`Navigator`] cannot rely on the browser (or webview) to
handle navigation to external targets via a generated anchor element.

This means, that under certain conditions, navigation to external targets can
fail.

# History Providers

\[`HistoryProvider`\]s are used by the router to keep track of the navigation history
and update any external state (e.g. the browser's URL).

The router provides two \[`HistoryProvider`\]s, but you can also create your own.
The two default implementations are:

* The \[`MemoryHistory`\] is a custom implementation that works in memory.
* The \[`LiveviewHistory`\] is a custom implementation that works with the liveview renderer.
* The \[`WebHistory`\] integrates with the browser's URL.

By default, the router uses the \[`MemoryHistory`\]. It might be changed to use
\[`WebHistory`\] when the `web` feature is active, but that is not guaranteed.

You can override the default history:

````rs@history_provider.rs
#[component]
fn App() -> Element {
    rsx! {
        Router::<Route> { config: || RouterConfig::default() }
    }
}
````

# Routing Update Callback

In some cases, we might want to run custom code when the current route changes. For this reason, the [`RouterConfig`] exposes an `on_update` field.

## How does the callback behave?

The `on_update` is called whenever the current routing information changes. It is called after the router updated its internal state, but before dependent components and hooks are updated.

If the callback returns a [`NavigationTarget`], the router will replace the current location with the specified target. It will not call the `on_update` again.

If at any point the router encounters a navigation failure, it will go to the appropriate state without calling the `on_update`. It doesn't matter if the invalid target initiated the navigation, was found as a redirect target, or was returned by the `on_update` itself.

## Code Example

````rs@routing_update.rs
#[derive(Routable, Clone, PartialEq)]
enum Route {
    #[route("/")]
    Index {},
    #[route("/home")]
    Home {},
}

#[component]
fn Home() -> Element {
    rsx! {
        p { "Home" }
    }
}

#[component]
fn Index() -> Element {
    rsx! {
        p { "Index" }
    }
}

fn app() -> Element {
    rsx! {
        Router::<Route> {
            config: || {
                RouterConfig::default()
                    .on_update(|state| {
                        (state.current() == Route::Index {})
                            .then_some(NavigationTarget::Internal(Route::Home {}))
                    })
            },
        }
    }
}
````

# History Buttons

Some platforms, like web browsers, provide users with an easy way to navigate
through an app's history. They have UI elements or integrate with the OS.

However, native platforms usually don't provide such amenities, which means that
apps wanting users to have access to them, need to implement them. For this
reason, the router comes with two components, which emulate a browser's back and
forward buttons:

* [`GoBackButton`]
* [`GoForwardButton`]

````rs@history_buttons.rs
fn HistoryNavigation() -> Element {
    rsx! {
        GoBackButton { "Back to the Past" }
        GoForwardButton { "Back to the Future" }
    }
}
````

As you might know, browsers usually disable the back and forward buttons if
there is no history to navigate to. The router's history buttons try to do that
too, but depending on the \[history provider\] that might not be possible.

Importantly, neither `WebHistory` supports that feature.
This is due to limitations of the browser History API.

However, in both cases, the router will just ignore button presses, if there is
no history to navigate to.

Also, when using `WebHistory`, the history buttons might
navigate a user to a history entry outside your app.
# Layouts

Layouts allow you to wrap all child routes in a component. This can be useful when creating something like a header that will be used in many different routes.

[`Outlet`] tells the router where to render content in layouts. In the following example,
the Index will be rendered within the [`Outlet`].

Here is a more complete example of a layout wrapping the body of a page.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/")]
        Index {},
}

#[component]
fn Wrapper() -> Element {
    rsx! {
        header { "header" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index() -> Element {
    rsx! { h1 { "Index" } }
}
````

The example above will output the following HTML (line breaks added for
readability):

````html
<header>header</header>
<h1>Index</h1>
<footer>footer</footer>
````

## Layouts with dynamic segments

You can combine layouts with nested routes to create dynamic layouts with content that changes based on the current route.

Just like routes, layouts components must accept a prop for each dynamic segment in the route. For example, if you have a route with a dynamic segment like `/:name`, your layout component must accept a `name` prop:

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[nest("/:name")]
        #[layout(Wrapper)]
            #[route("/")]
            Index {
                name: String,
            },
}

#[component]
fn Wrapper(name: String) -> Element {
    rsx! {
        header { "Welcome {name}!" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index(name: String) -> Element {
    rsx! { h1 { "This is a homepage for {name}" } }
}
````

Or to get the full route, you can use the `use_route` hook.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/:name")]
        Index {
            name: String,
        },
}

#[component]
fn Wrapper() -> Element {
    let full_route = use_route::<Route>();
    rsx! {
        header { "Welcome to {full_route}!" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index(name: String) -> Element {
    rsx! { h1 { "This is a homepage for {name}" } }
}
````
# Advanced Topics

This section covers a variety of advanced topics you may find useful as your dioxus app grows. It covers topic from organizing your app with custom hooks to breaking out of dioxus with effects.

## Table of Contents

* [Custom hooks](./custom_hooks.md) In addition to the built-in hooks, Dioxus lets you create your own custom hooks to encapsulate logic you can use throughout your components.
* [Component Lifecycle](./lifecycle.md) Every component in dioxus follows the same, mount, diff and drop lifecycle. This section covers how to hook into that lifecycle.
* [Breaking Out](./breaking_out.md) Sometimes the apis provided by dioxus aren't enough. This section covers how to break out of dioxus and use your own apis to manipulate the DOM or call JS functions.
# Custom Hooks

Hooks are a great way to encapsulate business logic. If none of the existing hooks work for your problem, you can write your own.

When writing your hook, you can make a function that starts with `use_` and takes any arguments you need. You can then use the `use_hook` method to create a hook that will be called the first time the component is rendered.

## Composing Hooks

To avoid repetition, you can encapsulate business logic based on existing hooks to create a new hook.

For example, if many components need to access an `AppSettings` struct, you can create a "shortcut" hook:

````rs@hooks_composed.rs
fn use_settings() -> Signal<AppSettings> {
    consume_context()
}
````

Or if you want to wrap a hook that persists reloads with the storage API, you can build on top of the use_signal hook to work with mutable state:

````rs@hooks_composed.rs
use gloo_storage::{LocalStorage, Storage};
use serde::{de::DeserializeOwned, Serialize};

/// A persistent storage hook that can be used to store data across application reloads.
#[allow(clippy::needless_return)]
pub fn use_persistent<T: Serialize + DeserializeOwned + Default + 'static>(
    // A unique key for the storage entry
    key: impl ToString,
    // A function that returns the initial value if the storage entry is empty
    init: impl FnOnce() -> T,
) -> UsePersistent<T> {
    // Use the use_signal hook to create a mutable state for the storage entry
    let state = use_signal(move || {
        // This closure will run when the hook is created
        let key = key.to_string();
        let value = LocalStorage::get(key.as_str()).ok().unwrap_or_else(init);
        StorageEntry { key, value }
    });

    // Wrap the state in a new struct with a custom API
    UsePersistent { inner: state }
}

struct StorageEntry<T> {
    key: String,
    value: T,
}

/// Storage that persists across application reloads
pub struct UsePersistent<T: 'static> {
    inner: Signal<StorageEntry<T>>,
}

impl<T> Clone for UsePersistent<T> {
    fn clone(&self) -> Self {
        *self
    }
}

impl<T> Copy for UsePersistent<T> {}

impl<T: Serialize + DeserializeOwned + Clone + 'static> UsePersistent<T> {
    /// Returns a reference to the value
    pub fn get(&self) -> T {
        self.inner.read().value.clone()
    }

    /// Sets the value
    pub fn set(&mut self, value: T) {
        let mut inner = self.inner.write();
        // Write the new value to local storage
        LocalStorage::set(inner.key.as_str(), &value);
        inner.value = value;
    }
}
````

## Custom Hook Logic

You can use [`use_hook`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_hook.html) to build your own hooks. In fact, this is what all the standard hooks are built on!

`use_hook` accepts a single closure for initializing the hook. It will be only run the first time the component is rendered. The return value of that closure will be used as the value of the hook â€“ Dioxus will take it, and store it for as long as the component is alive. On every render (not just the first one!), you will get a reference to this value.

 > 
 > Note: You can use the `use_on_destroy` hook to clean up any resources the hook uses when the component is destroyed.

Inside the initialization closure, you will typically make calls to other dioxus runtime methods. For example:

* The `use_signal` hook tracks state in the hook value, and uses [`ReactiveContext`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ReactiveContext.html) to make Dioxus re-render any component that has observed it whenever the signal's value changes.

Here is a simplified implementation of the `use_signal` hook:

````rs@hooks_custom_logic.rs
use std::cell::RefCell;
use std::collections::HashSet;
use std::rc::Rc;
use std::sync::{Arc, Mutex};

struct Signal<T> {
    value: Rc<RefCell<T>>,
    subscribers: Arc<Mutex<HashSet<ReactiveContext>>>,
}

impl<T> Clone for Signal<T> {
    fn clone(&self) -> Self {
        Self {
            value: self.value.clone(),
            subscribers: self.subscribers.clone(),
        }
    }
}

fn my_use_signal<T: 'static>(init: impl FnOnce() -> T) -> Signal<T> {
    use_hook(|| {
        // A set of subscribers to notify about changes to this signals value
        let subscribers = Default::default();
        // Create the initial state
        let value = Rc::new(RefCell::new(init()));

        Signal { value, subscribers }
    })
}

impl<T: Clone> Signal<T> {
    fn get(&self) -> T {
        // Subscribe the context observing the signal (if any) to updates of its value.
        if let Some(reactive_context) = ReactiveContext::current() {
            reactive_context.subscribe(self.subscribers.clone());
        }

        self.value.borrow().clone()
    }

    fn set(&self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render of the components that observed the signal's previous value
        let mut subscribers = std::mem::take(&mut *self.subscribers.lock().unwrap());
        subscribers.retain(|reactive_context| reactive_context.mark_dirty());
        // Extend the subscribers list instead of overwriting it in case a subscriber is added while reactive contexts are marked dirty
        self.subscribers.lock().unwrap().extend(subscribers);
    }
}
````

* The `use_context` hook calls [`consume_context`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.consume_context.html) (which would be expensive to call on every render) to get some context from the component

Here is an implementation of the `use_context` and `use_context_provider` hooks:

````rs@hooks_custom_logic.rs
pub fn use_context<T: 'static + Clone>() -> T {
    use_hook(|| consume_context())
}

pub fn use_context_provider<T: 'static + Clone>(f: impl FnOnce() -> T) -> T {
    use_hook(|| {
        let val = f();
        // Provide the context state to the component
        provide_context(val.clone());
        val
    })
}

````

## Building Reactive Hooks

The `use_hook` primitive only provides a way to *store* a value. It does not directly integrate with the Dioxus runtime to allow *modifying* state or queueing effects.

To queue a component to re-render, you can use the `dioxus::core::needs_update` primitive. This sends a message to the internal Dioxus scheduler to queue the current component to be re-rendered.

````rust
log!("Re-rendering!");

rsx! {
    // Clicking this button will force a re-render
    button {
        onclick: move |_| dioxus::core::needs_update(),
        "Queue for re-rendering"
    }
}
````

We can combine `needs_update`, `use_hook`, and [interior mutability](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html) to build hooks that work with the Dioxus reactivity system.

````rust
// We declare a new "ReactiveString" type that calls `needs_update` when modified
#[derive(Default)]
struct ReactiveString { inner: Rc<RefCell<String>> }
impl ReactiveString {
    fn get(&self) -> String {
        self.inner.borrow().to_string()
    }
    fn set(&mut self, new: String) {
        *self.inner.write() = new;
        dioxus::core::needs_update();
    }
}

// We store the ReactiveString in a hook
fn use_reactive_string(init: impl FnOnce() -> String) -> ReactiveString {
    let inner = use_hook(|| Rc::new(RefCell::new(init())));
    ReactiveString { inner }
}

// And then when can use it in our component
let mut name = use_reactive_string(|| "Jane".to_string());

rsx! {
    // Clicking the button will cause `needs_update` to be queue a re-render
    button {
        onclick: move |_| name.set("Bob".to_string()),
        "Name: {name.get()}"
    }
}
````

In practice, you should never need to build state management primitives yourself. We provide these examples to help you understand how they work.
# Component Lifecycle

## Initializing State with `use_hook`

`use_hook` lets you create new state for your component. The closure you pass to `use_hook` will be called once the first time the component is rendered. Every time the component is re-rendered, the value that was created the first run will be re-used.

````rs@component_lifecycle.rs
fn UseHook() -> Element {
    // The closure that is passed to use_hook will be called once the first time the component is rendered
    let random_number = use_hook(|| {
        let new_random_number = random_number();

        log!("{new_random_number}");

        new_random_number
    });

    rsx! {
        div { "Random {random_number}" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::UseHookDemo {}
}
````

## Rerendering

You can use tracked values to re-render your component whenever a value changes.

````rs@component_lifecycle.rs
fn Rerenders() -> Element {
    let mut count = use_signal(|| 0);

    log!("Rerendering parent component with {}", *count.peek());

    rsx! {
        button { onclick: move |_| count += 1, "Increment" }
        // Since we read count here, the component will rerender when count changes
        Count { current_count: count() }
    }
}

// If the count prop changes, the component will rerender
#[component]
fn Count(current_count: i32) -> Element {
    log!("Rerendering child component with {current_count}");

    rsx! {
        div { "The count is {current_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::RerenderDemo {}
}
````

### âš ï¸ Don't mutate state in the body of a component

You should avoid changing state in the body of a component. If you read and write to state in the body of a component, you can cause an infinite loop as the component tries to rerender because of the change which triggers another state change.

````rs@component_lifecycle.rs
fn Bad() -> Element {
    let mut count = use_signal(|| 0);

    // âŒ Don't mutate state in the body of the component.
    // It can easily cause an infinite loop!
    count += 1;

    rsx! { "{count}" }
}
````

Instead, derive state with `use_memo`, `use_resource`, or mutate state in a effect.

## Using Effects

You can use effects to run code whenever a component is rendered.

````rs@component_lifecycle.rs
fn Effect() -> Element {
    // Effects run after the component is rendered
    // You can use them to read or modify the rendered component
    use_effect(|| {
        log!("Effect ran");
        document::eval(&format!(
            "document.getElementById('effect-output').innerText = 'Effect ran'"
        ));
    });

    rsx! {
        div { id: "effect-output", "This will be changed by the effect" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::EffectDemo {}
}
````

## Cleaning Up Components with Drop

Before a component is dropped, it will drop all of its hooks. You can use this drop behavior to clean up any resources that your component is using. If you just need the drop effect, you can use the [`use_drop`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_drop.html) hook.

````rs@component_lifecycle.rs
fn TogglesChild() -> Element {
    let mut show = use_signal(|| true);

    rsx! {
        button { onclick: move |_| show.toggle(), "Toggle" }
        if show() {
            Child {}
        }
    }
}

fn Child() -> Element {
    // You can use the use_drop hook to clean up any resources
    dioxus::core::use_drop(|| {
        log!("Child dropped");
    });

    rsx! {
        div { "Child" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::DropDemo {}
}
````
# Breaking Out of Dioxus

Dioxus makes it easy to build reactive user interfaces. However, there are some cases where you may need to break out of the reactive paradigm to interact with the DOM directly.

## Interacting with JavaScript with `eval` and `web-sys`

Dioxus exposes a limited number of [web apis](https://developer.mozilla.org/en-US/docs/Web/API) with a nicer interface. If you need access to more APIs, you can use the `eval` function to run JavaScript in the browser.

For example, you can use the eval function to read the domain of the current page:

````rs@breaking_out.rs
pub fn Eval() -> Element {
    let mut domain = use_signal(String::new);
    rsx! {
        button {
            // When you click the button, some javascript will run in the browser
            // to read the domain and set the signal
            onclick: move |_| async move {
                domain.set(document::eval("return document.domain").await.unwrap().to_string());
            },
            "Read Domain"
        }
        "Current domain: {domain}"
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::Eval {}
}
````

If you are only targeting web, you can also use the [`web-sys`](https://crates.io/crates/web-sys) crate for typed access to the web APIs. Here is what reading the domain looks like with web-sys:

````rs@breaking_out.rs
use ::web_sys::window;
use wasm_bindgen::JsCast;
pub fn WebSys() -> Element {
    let mut domain = use_signal(String::new);
    rsx! {
        button {
            // When you click the button, we use web-sys to read the domain and a signal
            onclick: move |_| {
                domain
                    .set(
                        window()
                            .unwrap()
                            .document()
                            .unwrap()
                            .dyn_into::<::web_sys::HtmlDocument>()
                            .unwrap()
                            .domain(),
                    );
            },
            "Read Domain"
        }
        "Current domain: {domain}"
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::WebSys {}
}
````

## Synchronizing DOM updates with `use_effect`

If you do need to interact with the DOM directly, you should do so in a `use_effect` hook. This hook will run after the component is rendered and all of the Dioxus UI has been rendered. You can read or modify the DOM in this hook.

For example, you can use the `use_effect` hook to write to a canvas element after it is created:

````rs@breaking_out.rs
pub fn Canvas() -> Element {
    let mut count = use_signal(|| 0);

    use_effect(move || {
        // Effects are reactive like memos, and resources. If you read a value inside the effect, the effect will rerun when that value changes
        let count = count.read();

        // You can use the count value to update the DOM manually
        document::eval(&format!(
            r#"var c = document.getElementById("dioxus-canvas");
var ctx = c.getContext("2d");
ctx.clearRect(0, 0, c.width, c.height);
ctx.font = "30px Arial";
ctx.fillText("{count}", 10, 50);"#
        ));
    });

    rsx! {
        button {
            // When you click the button, count will be incremented and the effect will rerun
            onclick: move |_| count += 1,
            "Increment"
        }
        canvas { id: "dioxus-canvas" }
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::Canvas {}
}
````

## Getting access to elements with `onmounted`

If you need a handle to an element that is rendered by dioxus, you can use the `onmounted` event. This event will fire after the element is first mounted to the DOM. It returns a live reference to the element with some methods to interact with it.

You can use the onmounted event to do things like focus or scroll to an element after it is rendered:

````rs@breaking_out.rs
pub fn OnMounted() -> Element {
    let mut input_element = use_signal(|| None);

    rsx! {
        div { height: "100px",
            button {
                class: "focus:outline-2 focus:outline-blue-600 focus:outline-dashed",
                // The onmounted event will run the first time the button element is mounted
                onmounted: move |element| input_element.set(Some(element.data())),
                "First button"
            }

            button {
                // When you click the button, if the button element has been mounted, we focus to that element
                onclick: move |_| async move {
                    if let Some(header) = input_element() {
                        let _ = header.set_focus(true).await;
                    }
                },
                "Focus first button"
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::OnMounted {}
}
````

## Down casting web sys events

Dioxus provides platform agnostic wrappers over each event type. These wrappers are often nicer to interact with than the raw event types, but they can be more limited. If you are targeting web, you can downcast the event with the `as_web_event` method to get the underlying web-sys event:

````rs@breaking_out.rs
pub fn Downcast() -> Element {
    let mut event_text = use_signal(|| 0);

    rsx! {
        div {
            onmousemove: move |event| {
                #[cfg(feature = "web")]
                {
                    use dioxus::web::WebEventExt;
                    event_text.set(event.as_web_event().movement_x());
                }
            },
            "movement_x was {event_text}"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::Downcast {}
}
````
# Dioxus Guides

These guides build on topics covered in the [core concepts](../essentials/index.md) chapter to provide more detailed explanations and examples. While we recommend everyone read either the entire [tutorial](../tutorial/index.md) or [core concepts](../essentials/index.md) chapters as you learn dioxus, these guides are intended for users who want to dive deeper into specific topics as needed.

## Tools

Dioxus provides a set of tools to make building cross platform applications easier. The [`dioxus-cli`](https://crates.io/crates/dioxus-cli) is the core tool for building, running, and managing dioxus applications. The [`tools`](./tools/index.md) guide provides more information on the various tools available in the dioxus ecosystem.

## Platforms

When you build an app with dioxus, most of your application code can be platform agnostic. When you do need to interact with platform specific features, dioxus provides a variety of platform backends to help you do so. The [platforms](./platforms/index.md) guide provides more information on the various platforms supported by dioxus.

## Publishing

Once you finish building your application, the [publishing guide](./deploy/index.md) provides an overview of how to package and distribute your application. It also includes information about what configuration options are available for bundling.

## Custom Renderer

If you are ready to dive into building your own renderer for dioxus, the [custom renderer guide](./depth/custom_renderer.md) provides an overview of how to get started.

## Migration

If you are updating from an older version of dioxus, the [migration guides](../migration/index.md) provide information about breaking changes and how to update your code to work with the latest version of dioxus.
# Tools

Dioxus has an ecosystem of tools to help you develop and deploy your applications. This guide will help you set up, configure and use these tools.

## Installing the CLI

The CLI bundles together many different tools for dioxus development. Dioxus provides prebuilt binaries for Windows, macOS, and Linux you can download with [cargo-binstall](https://github.com/cargo-bins/cargo-binstall):

````bash
cargo binstall dioxus-cli
````

### Manual installation

If you don't have cargo-binstall installed or we don't have a prebuilt binary for your platform, you can install the CLI with cargo install:

````bash
cargo install dioxus-cli
````

## Commands

To verify your installation and get an overview of all the commands available, run:

````sh
dx --help
````

You should see something like this:

````sh
Dioxus: build web, desktop, and mobile apps with a single codebase

Usage: dx [OPTIONS] <COMMAND>

Commands:
  new          Create a new Dioxus project
  serve        Build, watch, and serve the project
  bundle       Bundle the Dioxus app into a shippable object
  build        Build the Dioxus project and all of its assets
  run          Run the project without any hotreloading
  init         Init a new project for Dioxus in the current directory (by default). Will attempt to keep your project in a good state
  doctor       Diagnose installed tools and system configuration
  print        Print project information in a structured format, like cargo args, linker args, and other flags DX sets that might be useful in third-party tools
  translate    Translate a source file into Dioxus code
  fmt          Automatically format RSX
  check        Check the project for any issues
  config       Dioxus config file controls
  self-update  Update the Dioxus CLI to the latest version
  tools        Run a dioxus build tool. IE `build-assets`, `hotpatch`, etc
  components   Manage components from the `dioxus-component` registry
  help         Print this message or the help of the given subcommand(s)

Options:
      --verbose      Use verbose output [default: false]
      --trace        Use trace output [default: false]
      --json-output  Output logs in JSON format
  -h, --help         Print help
  -V, --version      Print version

Logging Options:
      --log-to-file <LOG_TO_FILE>  Write *all* logs to a file

Manifest Options:
      --locked   Assert that `Cargo.lock` will remain unchanged
      --offline  Run without accessing the network
      --frozen   Equivalent to specifying both --locked and --offline
````

## Table of Contents

Many chapters in this guide cover different commands in the CLI:

* [Create a project](./creating.md) provides an overview of the `dx new` and `dx init` commands to scaffold your dioxus project
* [Translate HTML](./translate.md) provides an overview of the `dx translate` command to convert HTML into rsx.

Other chapters explore different aspects of using the CLI and other tools:

* [Configure Project](./configure.md) explores how you can configure your project with the `Dioxus.toml` file the CLI reads
# Create a Project

Once you have the Dioxus CLI installed, you can use it to create your own project!

## Initializing a project

First, run the `dx new` command to create a new project.

 > 
 > It clones this [template](https://github.com/DioxusLabs/dioxus-template), which is used to create dioxus apps.
 > 
 > You can create your project from a different template by passing the `template` argument:
 > 
 > ````
 > dx new --template gh:dioxuslabs/dioxus-template
 > ````

Next, navigate into your new project using `cd project-name`, or simply opening it in an IDE.

 > 
 > Make sure the WASM target is installed before running the projects.
 > You can install the WASM target for rust using rustup:
 > 
 > ````
 > rustup target add wasm32-unknown-unknown
 > ````

Finally, serve your project with `dx serve`! The CLI will tell you the address it is serving on, along with additional
info such as code warnings.
# Configure Project

This chapter will teach you how to configure the CLI with the `Dioxus.toml` file. There's an [example](#config-example) which has comments to describe individual keys. You can copy that or view this documentation for a more complete learning experience.

"ðŸ”’" indicates a mandatory item. Some headers are mandatory, but none of the keys inside them are. In that case, you only need to include the header, but no keys. It might look weird, but it's normal.

## Structure

Each header has its TOML form directly under it.

### Application ðŸ”’

````toml
[application]
````

Application-wide configuration. Applies to both web and desktop.

* **asset_dir** - The directory with your static assets. The CLI will automatically copy these assets into the **out_dir** after a build/serve.
  ````toml
  asset_dir = "public"
  ````

* **sub_package** - The sub package in the workspace to build by default.
  ````toml
  sub_package = "my-crate"
  ````

### Web.App ðŸ”’

````toml
[web.app]
````

Web-specific configuration.

* **title** - The title of the web page.
  ````toml
  # HTML title tag content
  title = "project_name"
  ````

* **base_path** - The base path to build the application for serving at. This can be useful when serving your application in a subdirectory under a domain. For example, when building a site to be served on GitHub Pages.
  ````toml
  # The application will be served at domain.com/my_application/, so we need to modify the base_path to the path where the application will be served
  base_path = "my_application"
  ````

### Web.Watcher ðŸ”’

````toml
[web.watcher]
````

Development server configuration.

* **reload_html** - If this is true, the cli will rebuild the index.html file every time the application is rebuilt
  
  ````toml
  reload_html = true
  ````

* **watch_path** - The files & directories to monitor for changes
  
  ````toml
  watch_path = ["src", "public"]
  ````

* **index_on_404** - If enabled, Dioxus will serve the root page when a route is not found.
  *This is needed when serving an application that uses the router*. However, when serving your app using something else than Dioxus (e.g. GitHub Pages), you will have to check how to configure it on that platform. In GitHub Pages, you can make a copy of `index.html` named `404.html` in the same directory.
  
  ````toml
  index_on_404 = true
  ````

### Web.Resource ðŸ”’

````toml
[web.resource]
````

Static resource configuration.

* **style** - CSS files to include in your application.
  
  ````toml
  style = [
     # Include from public_dir.
     "./assets/style.css",
     # Or some asset from online cdn.
     "https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.css"
  ]
  ````

* **script** - JavaScript files to include in your application.
  
  ````toml
  script = [
      # Include from asset_dir.
      "./public/index.js",
      # Or from an online CDN.
      "https://cdn.jsdelivr.net/npm/bootstrap/dist/js/bootstrap.js"
  ]
  ````

### Web.Resource.Dev ðŸ”’

````toml
[web.resource.dev]
````

This is the same as [`[web.resource]`](#webresource-), but it only works in development servers. For example, if you want to include a file in a `dx serve` server, but not a `dx serve --release` server, put it here.

### Web.Proxy

````toml
[[web.proxy]]
````

Configuration related to any proxies your application requires during development. Proxies will forward requests to a new service.

* **backend** - The URL to the server to proxy. The CLI will forward any requests under the backend relative route to the backend instead of returning 404
  ````toml
  backend = "http://localhost:8000/api/"
  ````
  
  This will cause any requests made to the dev server with prefix /api/ to be redirected to the backend server at http://localhost:8000. The path and query parameters will be passed on as-is (path rewriting is currently not supported).

### Web.https

````toml
[[web.https]]
````

Controls the https config for the CLI.

* **enabled** enables or disables https in the CLI
  ````toml
  enabled = true
  ````

* **mkcert** enables or disables generating certs with the mkcert CLI
  ````toml
  mkcert = true
  ````

* **key_path** sets the path to use for the https key
  ````toml
  key_path = "/path/to/key"
  ````

* **cert_path** sets the path to use for the https cert
  ````toml
  cert_path = "/path/to/cert"
  ````

### Web.pre_compress

If this setting is enabled, the CLI will pre-compress the built assets in release mode with brotli. This setting is enabled by default.

````toml
[web]
pre_compress = true
````

### Web.wasm_opt

Controls the wasm-opt config for the CLI.

* **level** sets the level of optimization to use for wasm-opt in release builds.
  * z: optimize aggressively for size
  * s: optimize for size
  * 1: optimize for speed
  * 2: optimize for more for speed
  * 3: optimize for even more for speed
  * 4: optimize aggressively for speed (default)
  ````toml
  level = "z"
  ````

* **debug** keep debug symbols in the wasm file even in release builds
  ````toml
  debug = true
  ````

### Bundle

````toml
[bundle]
````

Controls the bundling process for your application. Dioxus uses tauri-bundler under the hood. This section only includes a subset of the options available in tauri-bundler. More options can be found in the tauri-bundler [documentation](https://v1.tauri.app/v1/guides/building/#configuration-options).

* **identifier** - A unique identifier for your application (e.g., `com.dioxuslabs`).
  ````toml
  identifier = "com.dioxuslabs"
  ````

* **publisher** - The name of the entity publishing the application.
  ````toml
  publisher = "DioxusLabs"
  ````

* **icon** - Paths to icon files to be used in the bundle. Icon files must be square and 16, 24, 32, 64, or 256 pixels in size. PNG icons must have a 32 bit depth in the RGBA format. If you use a `.icns` file is must fit [this](https://github.com/tauri-apps/tauri/blob/d8db5042a28635259f646c329c3ec5ccf23eac9e/tooling/cli/src/helpers/icns.json) format. The icons must include a `.icns` icon for macOS, `.ico` for Windows and `.png` for Linux.
  ````toml
  icon = [
     "icons/32x32.png",
     "icons/128x128.png",
     "icons/128x128@2x.png",
     "icons/icon.icns",
     "icons/icon.ico"
  ]
  ````

* **resources** - Additional files to include in the bundle. Each asset is copied from the path and is accessible from the bundle at the same path. Any [assets](../../essentials/ui/assets.md) are automatically bundled with the installer.
  ````toml
  resources = ["path/to/resource"]
  ````

* **copyright** - Copyright information for the application.
  ````toml
  copyright = "Copyright 2023 DioxusLabs"
  ````

* **category** - The category of the application. Must be one of `Business`, `DeveloperTool`, `Education`, `Entertainment`, `Finance`, `Game`, `ActionGame`, `AdventureGame`, `ArcadeGame`, `BoardGame`, `CardGame`, `CasinoGame`, `DiceGame`, `EducationalGame`, `FamilyGame`, `KidsGame`, `MusicGame`, `PuzzleGame`, `RacingGame`, `RolePlayingGame`, `SimulationGame`, `SportsGame`, `StrategyGame`, `TriviaGame`, `WordGame`, `GraphicsAndDesign`, `HealthcareAndFitness`, `Lifestyle`, `Medical`, `Music`, `News`, `Photography`, `Productivity`, `Reference`, `SocialNetworking`, `Sports`, `Travel`, `Utility`, `Video`, or `Weather`
  ````toml
  category = "Utility"
  ````

* **short_description** - A brief description of the application.
  ````toml
  short_description = "A utility application built with Dioxus"
  ````

* **long_description** - A detailed description of the application.
  ````toml
  long_description = "This application provides various utility functions..."
  ````

* **external_bin** - Paths to external sidecar binaries to include in the bundle. These bundles may be accessed at runtime with the name of the binary (not the absolute path). **the target triple will be automatically added to the binary name before it is added to the bundle.**
  ````toml
  external_bin = ["path/to/external_binary"] # On macos, the binary at path/to/external_binary-aarch64-apple-darwin will be included in the bundle. It can be accessed at runtime with the name external_binary
  ````

### Bundle.macos

````toml
[bundle.macos]
````

Configuration options for macOS bundles.

* **frameworks** - List of frameworks to include in the bundle.
  ````toml
  frameworks = ["CoreML"]
  ````

* **minimum_system_version** - Minimum macOS version required. (default: `10.13`)
  ````toml
  minimum_system_version = "10.13"
  ````

* **license** - Path to the license file.
  ````toml
  license = "LICENSE.txt"
  ````

* **exception_domain** - Domain for exception handling. The domain must be lowercase without a port or protocol.
  ````toml
  exception_domain = "mysite.com"
  ````

* **signing_identity** - macOS signing identity.
  ````toml
  signing_identity = "SIGNING IDENTITY KEYCHAIN ENTRY NAME"
  ````

* **provider_short_name** - Provider short name for the bundle.
  ````toml
  provider_short_name = "DioxusLabs"
  ````

* **entitlements** - Path to the entitlements file.
  ````toml
  entitlements = "entitlements.plist"
  ````

* **hardened_runtime** - Whether to enable the [hardened runtime](https://developer.apple.com/documentation/security/hardened-runtime) in the bundle.
  ````toml
  hardened_runtime = true
  ````

### Bundle.windows

````toml
[bundle.windows]
````

Configuration options for Windows bundles.

* **digest_algorithm** - Sets the file digest algorithm used for signing.
  ````toml
  digest_algorithm = "sha-256"
  ````

* **certificate_thumbprint** - SHA1 hash of the signing certificate.
  ````toml
  certificate_thumbprint = "A1B2C3D4E5F6..."
  ````

* **timestamp_url** - Sets the server to used for timestamping the signature.
  ````toml
  timestamp_url = "http://timestamp.digicert.com"
  ````

* **tsp** - Whether to use the time stamping protocol.
  ````toml
  tsp = true
  ````

* **icon_path** - Path to the icon for the system tray icon. (defaults to `./icons/icon.ico`)
  ````toml
  icon_path = "assets/icon.ico"
  ````

* **webview_install_mode** - Installation mode for WebView2.
  EmbedBootstrapper: embed the WebView2 bootstrapper into the installer
  ````toml
  [webview_install_mode.EmbedBootstrapper]
  silent = true
  ````
  
  DownloadBootstrapper: download the WebView2 bootstrapper in the installer at runtime
  ````toml
  [webview_install_mode.DownloadBootstrapper]
  silent = true
  ````
  
  OfflineInstaller: Embed the WebView2 installer into the main installer
  ````toml
  [webview_install_mode.OfflineInstaller]
  silent = true
  ````
  
  FixedRuntime: Use a fixed path to the WebView2 runtime
  ````toml
  [webview_install_mode.FixedRuntime]
  path = "path/to/runtime"
  ````
  
  Skip: Does not install WebView2 as part of the installer. This will cause the application to fail if webview was not already installed
  ````toml
  webview_install_mode = "Skip"
  ````

## Config example

This includes all fields, mandatory or not.

````toml
[application]

# App name
name = "project_name"

# `build` & `serve` output path
out_dir = "dist"

# The static resource path
asset_dir = "public"

[web.app]

# HTML title tag content
title = "project_name"

[web.watcher]

# When watcher is triggered, regenerate the `index.html`
reload_html = true

# Which files or dirs will be monitored
watch_path = ["src", "public"]

# Include style or script assets
[web.resource]

# CSS style file
style = []

# Javascript code file
script = []

[web.resource.dev]

# Same as [web.resource], but for development servers

# CSS style file
style = []

# JavaScript files
script = []

[[web.proxy]]
backend = "http://localhost:8000/api/"

[bundle]
identifier = "com.dioxuslabs"
publisher = "DioxusLabs"
icon = "assets/icon.png"
````
# Translating existing HTML

Dioxus uses a custom format called RSX to represent the HTML because it is more concise and looks more like Rust code. However, it can be a pain to convert existing HTML to RSX. That's why Dioxus comes with a tool called `dx translate` that can automatically convert HTML to RSX!

Dx translate can make converting large chunks of HTML to RSX much easier! Lets try translating some of the HTML from the Dioxus homepage:

````sh
dx translate --raw  "<div class=\"relative w-full mx-4 sm:mx-auto text-gray-600\"><div class=\"text-[3em] md:text-[5em] font-semibold dark:text-white text-ghdarkmetal font-sans py-12 flex flex-col\"><span>Fullstack, crossplatform,</span><span>lightning fast, fully typed.</span></div><h3 class=\"text-[2em] dark:text-white font-extralight text-ghdarkmetal pt-4 max-w-screen-md mx-auto\">Dioxus is a Rust library for building apps that run on desktop, web, mobile, and more.</h3><div class=\"pt-12 text-white text-[1.2em] font-sans font-bold flex flex-row justify-center space-x-4\"><a href=\"/learn/0.7/getting_started\" dioxus-prevent-default=\"onclick\" class=\"bg-red-600 py-2 px-8 hover:-translate-y-2 transition-transform duration-300\" data-dioxus-id=\"216\">Quickstart</a><a href=\"/learn/0.7/reference\" dioxus-prevent-default=\"onclick\" class=\"bg-blue-500 py-2 px-8 hover:-translate-y-2 transition-transform duration-300\" data-dioxus-id=\"214\">Read the docs</a></div><div class=\"max-w-screen-2xl mx-auto pt-36\"><h1 class=\"text-md\">Trusted by top companies</h1><div class=\"pt-4 flex flex-row flex-wrap justify-center\"><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/futurewei_bw.png\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/airbuslogo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/ESA_logo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/yclogo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/satellite.webp\"></div></div></div></div>"
````

We get the following RSX you can easily copy and paste into your code:

````rs
div { class: "relative w-full mx-4 sm:mx-auto text-gray-600",
   div { class: "text-[3em] md:text-[5em] font-semibold dark:text-white text-ghdarkmetal font-sans py-12 flex flex-col",
      span { "Fullstack, crossplatform," }
      span { "lightning fast, fully typed." }
   }
   h3 { class: "text-[2em] dark:text-white font-extralight text-ghdarkmetal pt-4 max-w-screen-md mx-auto",
      "Dioxus is a Rust library for building apps that run on desktop, web, mobile, and more."
   }
   div { class: "pt-12 text-white text-[1.2em] font-sans font-bold flex flex-row justify-center space-x-4",
      a {
         href: "/learn/0.7/getting_started",
         data_dioxus_id: "216",
         dioxus_prevent_default: "onclick",
         class: "bg-red-600 py-2 px-8 hover:-translate-y-2 transition-transform duration-300",
         "Quickstart"
      }
      a {
         dioxus_prevent_default: "onclick",
         href: "/learn/0.7/reference",
         data_dioxus_id: "214",
         class: "bg-blue-500 py-2 px-8 hover:-translate-y-2 transition-transform duration-300",
         "Read the docs"
      }
   }
   div { class: "max-w-screen-2xl mx-auto pt-36",
      h1 { class: "text-md", "Trusted by top companies" }
      div { class: "pt-4 flex flex-row flex-wrap justify-center",
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "/assets/static/futurewei_bw.png" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "/assets/static/airbuslogo.svg" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "/assets/static/ESA_logo.svg" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "/assets/static/yclogo.svg" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "/assets/static/satellite.webp" }
         }
      }
   }
}
````

## Usage

The `dx translate` command has several flags you can use to control your html input and rsx output.

You can use the `--file` flag to translate an HTML file to RSX:

````sh
dx translate --file index.html
````

Or you can use the `--raw` flag to translate a string of HTML to RSX:

````sh
dx translate --raw "<div>Hello world</div>"
````

Both of those commands will output the following RSX:

````rs
div { "Hello world" }
````

The `dx translate` command will output the RSX to stdout. You can use the `--output` flag to write the RSX to a file instead.

````sh
dx translate --raw "<div>Hello world</div>" --output index.rs
````

You can automatically create a component with the `--component` flag.

````sh
dx translate --raw "<div>Hello world</div>" --component
````

This will output the following component:

````rs
fn component() -> Element {
   rsx! {
      div { "Hello world" }
   }
}
````

To learn more about the different flags `dx translate` supports, run `dx translate --help`.
# Platform Support

Most of your code in dioxus will work across all platforms. However, each platform has its own set of features and limitations. For example, the web platform supports calling JavaScript through wasm-bindgen, while the desktop platform supports customizing the appearance of the window around the application.

## Platform specific code

Before diving into platform-specific code, it's important to have a good understanding of features in rust. Features let you add code that will only be included in the build if a certain feature is enabled.

Dioxus uses a different feature for each platform. For example, the web platform enables the `dioxus/web` feature, while the desktop platform enables the `dioxus/desktop` feature.

In your `Cargo.toml` file, you should set up a feature for each platform you want to support. For example:

````toml
[features]
default = []
web = ["dioxus/web"] # This feature is enabled during web builds
desktop = ["dioxus/desktop"] # This feature is enabled during desktop builds
````

Once you have your features set up, you can wrap your code in `#[cfg(feature = "web")]` or `#[cfg(feature = "desktop")]` to conditionally include code for each platform.

````rust
#[cfg(feature = "web")]
fn web_specific_code() {
    // Code specific to the web platform
}

#[cfg(feature = "desktop")]
fn desktop_specific_code() {
    // Code specific to the desktop platform
}
````

## Platform-specific dependancies

In addition to platform specific code, you may need to set up dependencies that are only included on specific platforms. For example, if you're building a web application, you may want to include a dependency on the `wasm-bindgen` crate to call JavaScript functions from Rust.

You can add platform specific dependencies as optional in your `Cargo.toml` and enable them using the `features` table. For example:

````toml
# Since this dependency is optional, it isn't included in the build automatically
wasm-bindgen = { version = "*", optional = true }

[features]
default = []
# adding dep:wasm-bindgen enables the wasm-bindgen dependency only
# in web builds
web = ["dioxus/web", "dep:wasm-bindgen"]
desktop = ["dioxus/desktop"]
````

## Table of Contents

Each chapter in this guide covers a different platform:

* [Web](web.md) The web platform lets you compile to wasm and render to the DOM in the browser
* [Desktop](desktop.md) The desktop platform runs your code natively and renders using webview
* [Mobile](mobile.md) The mobile platform has the same rendering engine as desktop, but requires additional setup for mobile devices/emulators
# Web

To run on the Web, your app must be compiled to WebAssembly and depend on the `dioxus` and `dioxus-web` crates.

A build of Dioxus for the web will be roughly equivalent to the size of a React build (70kb vs 65kb) but it will load significantly faster because [WebAssembly can be compiled as it is streamed](https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/).

Examples:

* [TodoMVC](https://github.com/DioxusLabs/dioxus/blob/main/examples/todomvc.rs)
* [Tailwind App](https://github.com/DioxusLabs/dioxus/tree/main/examples/tailwind)

[![TodoMVC example](https://github.com/DioxusLabs/example-projects/raw/master/todomvc/example.png)](https://github.com/DioxusLabs/dioxus/blob/main/examples/todomvc.rs)

 > 
 > Note: Because of the limitations of Wasm, [not every crate will work](https://rustwasm.github.io/docs/book/reference/which-crates-work-with-wasm.html) with your web apps, so you'll need to make sure that your crates work without native system calls (timers, IO, etc).

## Support

The Web is the best-supported target platform for Dioxus.

* Because your app will be compiled to WASM you have access to browser APIs through [wasm-bindgen](https://rustwasm.github.io/docs/wasm-bindgen/introduction.html).
* Dioxus provides hydration to resume apps that are rendered on the server. See the [fullstack](../../essentials/fullstack/index.md) reference for more information.

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus web exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    let future = use_resource(move || async move {
        // You can create as many eval instances as you want
        let mut eval = document::eval(
            r#"
            // You can send messages from JavaScript to Rust with the dioxus.send function
            dioxus.send("Hi from JS!");
            // You can receive messages from Rust to JavaScript with the dioxus.recv function
            let msg = await dioxus.recv();
            console.log(msg);
            "#,
        );

        // You can send messages to JavaScript with the send method
        eval.send("Hi from Rust!").unwrap();

        // You can receive any message from JavaScript with the recv method
        eval.recv::<String>().await.unwrap()
    });

    match future.read_unchecked().as_ref() {
        Some(v) => rsx! {
            p { "{v}" }
        },
        _ => rsx! {
            p { "hello" }
        },
    }
}

````

If you are targeting web, but don't plan on targeting any other Dioxus renderer you can also use the generated wrappers in the [web-sys](https://rustwasm.github.io/wasm-bindgen/web-sys/index.html) and [gloo](https://gloo-rs.web.app/) crates.

## Customizing Index Template

Dioxus supports providing custom index.html templates. The index.html must include a `div` with the id `main` to be used. Hot Reload is still supported. An example
is provided in the [PWA-Example](https://github.com/DioxusLabs/dioxus/blob/main/examples/10-integrations/pwa/index.html).
# Desktop

This guide will cover concepts specific to the Dioxus desktop renderer.

Apps built with Dioxus desktop use the system WebView to render the page. This makes the final size of application much smaller than other WebView renderers (typically under 5MB).

Although desktop apps are rendered in a WebView, your Rust code runs natively. This means that browser APIs are *not* available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs *are* accessible, so streaming, WebSockets, the filesystem, etc are all easily accessible though system APIs.

Dioxus desktop is built on top of [wry](https://github.com/tauri-apps/wry), a Rust library for creating desktop applications with a WebView.

 > 
 > In the future, we plan to move to a custom web renderer-based DOM renderer with WGPU integrations ([Blitz](https://github.com/DioxusLabs/blitz)).

## Examples

* [File Explorer](https://github.com/DioxusLabs/dioxus/tree/main/examples/01-app-demos/file-explorer)
* [Tailwind App](https://github.com/DioxusLabs/dioxus/tree/main/examples/tailwind)

[![Tailwind App screenshot](/assets/static/tailwind_desktop_app.png)](https://github.com/DioxusLabs/dioxus/tree/main/examples/tailwind)

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus desktop exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    let future = use_resource(move || async move {
        // You can create as many eval instances as you want
        let mut eval = document::eval(
            r#"
            // You can send messages from JavaScript to Rust with the dioxus.send function
            dioxus.send("Hi from JS!");
            // You can receive messages from Rust to JavaScript with the dioxus.recv function
            let msg = await dioxus.recv();
            console.log(msg);
            "#,
        );

        // You can send messages to JavaScript with the send method
        eval.send("Hi from Rust!").unwrap();

        // You can receive any message from JavaScript with the recv method
        eval.recv::<String>().await.unwrap()
    });

    match future.read_unchecked().as_ref() {
        Some(v) => rsx! {
            p { "{v}" }
        },
        _ => rsx! {
            p { "hello" }
        },
    }
}

````

## Custom Assets

You can link to local assets in dioxus desktop instead of using a url:

````rs@custom_assets.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    rsx! {
        div {
            img { src: asset!("/assets/static/scanner.png") }
        }
    }
}

````

## Integrating with Wry

In cases where you need more low level control over your window, you can use wry APIs exposed through the [Desktop Config](https://docs.rs/dioxus-desktop/latest/dioxus_desktop/struct.Config.html) and the [use_window hook](https://docs.rs/dioxus-desktop/latest/dioxus_desktop/fn.use_window.html)
# Mobile App

Build a mobile app with Dioxus!

## Support

The Rust ecosystem for mobile continues to mature, with Dioxus offering strong support for mobile applications. Mobile is a first-class target for Dioxus apps, with a robust WebView implementation that supports CSS animations and transparency effects.

Mobile apps are rendered with either the platform's WebView or experimentally with WGPU. While native Android animations and widgets aren't currently supported, CSS-based animations and styling provide a powerful alternative.

Mobile support is well-suited for most application types, from business tools to consumer apps, making it an excellent choice for teams looking to build cross-platform applications with a single codebase.

## Getting Set up

## Android

Android devices run a different executable architecture than desktop and web. We need to install these toolchains to build Dioxus apps for Android.

First, install the Rust Android targets:

````sh
rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android
````

To develop on Android, you will need to [install Android Studio](https://developer.android.com/studio).

Once you have installed Android Studio, you will need to install the Android SDK and NDK:

1. Create a blank Android project
1. Select `Tools > SDK manager`
1. Navigate to the `SDK tools` window:

![NDK install window](/assets/static/android_ndk_install.png)

Then select:

* The SDK
* The SDK Command line tools
* The NDK (side by side)
* CMAKE

4. Select `apply` and follow the prompts

 > 
 > More details that could be useful for debugging any errors you encounter are available [in the official android docs](https://developer.android.com/studio/intro/update#sdk-manager)

Next set the Java, Android, NDK, and PATH variables:

Mac:

````sh
export JAVA_HOME="/Applications/Android Studio.app/Contents/jbr/Contents/Home"
export ANDROID_HOME="$HOME/Library/Android/sdk"
export NDK_HOME="$ANDROID_HOME/ndk/25.2.9519653"
export PATH="$PATH:$ANDROID_HOME/emulator:$ANDROID_HOME/platform-tools"
````

Windows:

````powershell
[System.Environment]::SetEnvironmentVariable("JAVA_HOME", "C:\Program Files\Android\Android Studio\jbr", "User")
[System.Environment]::SetEnvironmentVariable("ANDROID_HOME", "$env:LocalAppData\Android\Sdk", "User")
[System.Environment]::SetEnvironmentVariable("NDK_HOME", "$env:LocalAppData\Android\Sdk\ndk\25.2.9519653", "User")
````

 > 
 > The NDK version in the paths should match the version you installed in the last step

We manually set the PATH variable to include the Android emulator since some distributions of Android Studio include the emulator in the wrong location.

## IOS

To develop on IOS, you will need to [install XCode](https://apps.apple.com/us/app/xcode/id497799835). Also make sure to install the iOS targets

````sh
rustup target add aarch64-apple-ios aarch64-apple-ios-sim
````

 > 
 > If you are using M1, you will have to run `cargo build --target x86_64-apple-ios` instead of `cargo apple build` if you want to run in simulator.

You will also need to install the iOS SDK and the Xcode command line tools.

## Running your app

Starting with Dioxus 0.6, `dx` ships with built-in support for mobile.

Simply create a new Dioxus project:

````sh
dx new my-app
````

Make sure to launch the relevant mobile simulator. For Android, you can use the Android Studio emulator, or the Android Emulator in the terminal. Make sure to adjust the device name depending on which emulator you installed.

````sh
emulator -avd Pixel_6_API_34  -netdelay none -netspeed full
````

For iOS, you can use the iOS simulator. You can launch it with:

````sh
open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app
xcrun simctl boot "iPhone 15 Pro Max"
````

And then run the app with:

````sh
cd my-app
dx serve
````

This will start the app in development mode.
# Publishing

After you have built your application, you will need to publish it somewhere. This reference will outline different methods of publishing your desktop or web application.

## Web: Publishing with GitHub Pages

Edit your `Dioxus.toml` to point your `out_dir` to the `docs` folder and the `base_path` to the name of your repo:

````toml
[application]
# ...
[web.app]
base_path = "your_repo"
````

Then build your app and publish it to Github:

* Make sure GitHub Pages is set up for your repo to publish any static files in the docs directory
* Build your app into the `docs` directory with:

````sh
dx bundle --out-dir docs
````

* Move the static content from `docs/public` to `docs`

````sh
mv docs/public/* docs
````

* Make a copy of your `docs/index.html` file and rename the copy to `docs/404.html` so that your app will work with client-side routing:

````sh
cp docs/index.html docs/404.html
````

* Add and commit with git
* Push to GitHub

## Desktop: Creating an installer

Dioxus desktop app uses your operating system's WebView library, so it's portable to be distributed for other platforms.

In this section, we'll cover how to bundle your app for macOS, Windows, and Linux.

## Preparing your application for bundling

Depending on your platform, you may need to add some additional code to your `main.rs` file to make sure your app is ready for bundling. On Windows, you'll need to add the `#![windows_subsystem = "windows"]` attribute to your `main.rs` file to hide the terminal window that pops up when you run your app. **If you're developing on Windows, only use this when bundling.** It will disable the terminal, so you will not get logs of any kind. You can gate it behind a feature, like so:

````toml
# Cargo.toml
[features]
bundle = []
````

And then your `main.rs`:

````rust
#![cfg_attr(feature = "bundle", windows_subsystem = "windows")]
````

## Adding assets to your application

If you want to bundle assets with your application, you can either use them with the `manganis` crate (covered more in the [assets](../../essentials/ui/assets.md) page), or you can include them in your `Dioxus.toml` file:

````toml
[bundle]
# The list of files to include in the bundle. These can contain globs.
resources = ["main.css", "header.svg", "**/*.png"]
````

## Install `dioxus CLI`

The first thing we'll do is install the [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli). This extension to cargo will make it very easy to package our app for the various platforms.

To install, simply run

`cargo install dioxus-cli`

## Building

To bundle your application you can simply run `dx bundle --release` (also add `--features bundle` if you're using that, see the [this](#preparing-your-application-for-bundling) for more) to produce a final app with all the optimizations and assets builtin.

Once you've ran the command, your app should be accessible in `dist/bundle/`.

For example, a macOS app would look like this:

![Published App](/assets/static/publish.png)

Nice! And it's only 4.8 Mb â€“ extremely lean!! Because Dioxus leverages your platform's native WebView, Dioxus apps are extremely memory efficient and won't waste your battery.

 > 
 > Note: not all CSS works the same on all platforms. Make sure to view your app's CSS on each platform â€“ or web browser (Firefox, Chrome, Safari) before publishing.
### Bundling config

The `[bundle]` section of our Dioxus.toml can take a variety of options.

Here are the options, in the form of Rust structs.

````rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct BundleConfig {
    /// eg. com.dioxuslabs
    pub(crate) identifier: Option<String>,
    /// eg. DioxusLabs
    pub(crate) publisher: Option<String>,
    /// eg. assets/icon.png
    pub(crate) icon: Option<Vec<String>>,
    /// eg. Extra assets like "img.png"
    pub(crate) resources: Option<Vec<String>>,
    /// eg. DioxusLabs
    pub(crate) copyright: Option<String>,
    /// eg. "Social Media"
    pub(crate) category: Option<String>,
    /// eg. "A great social media app"
    pub(crate) short_description: Option<String>,
    /// eg. "A social media app that makes people love app development"
    pub(crate) long_description: Option<String>,
    /// eg. extra binaries (like tools) to include in the final app
    pub(crate) external_bin: Option<Vec<String>>,
    /// Additional debian-only settings (see below)
    pub(crate) deb: Option<DebianSettings>,
    /// Additional macos settings (see below)
    pub(crate) macos: Option<MacOsSettings>,
    /// Additional windows settings (see below)
    pub(crate) windows: Option<WindowsSettings>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct DebianSettings {
    // OS-specific settings:
    /// the list of debian dependencies.
    pub depends: Option<Vec<String>>,
    /// the list of dependencies the package provides.
    pub provides: Option<Vec<String>>,
    /// the list of package conflicts.
    pub conflicts: Option<Vec<String>>,
    /// the list of package replaces.
    pub replaces: Option<Vec<String>>,
    /// List of custom files to add to the deb package.
    /// Maps the path on the debian package to the path of the file to include (relative to the current working directory).
    pub files: HashMap<PathBuf, PathBuf>,
    /// Path to a custom desktop file Handlebars template.
    ///
    /// Available variables: `categories`, `comment` (optional), `exec`, `icon` and `name`.
    pub desktop_template: Option<PathBuf>,
    /// Define the section in Debian Control file. See : <https://www.debian.org/doc/debian-policy/ch-archive.html#s-subsections>
    pub section: Option<String>,
    /// Change the priority of the Debian Package. By default, it is set to `optional`.
    /// Recognized Priorities as of now are :  `required`, `important`, `standard`, `optional`, `extra`
    pub priority: Option<String>,
    /// Path of the uncompressed Changelog file, to be stored at /usr/share/doc/package-name/changelog.gz. See
    /// <https://www.debian.org/doc/debian-policy/ch-docs.html#changelog-files-and-release-notes>
    pub changelog: Option<PathBuf>,
    /// Path to script that will be executed before the package is unpacked. See
    /// <https://www.debian.org/doc/debian-policy/ch-maintainerscripts.html>
    pub pre_install_script: Option<PathBuf>,
    /// Path to script that will be executed after the package is unpacked. See
    /// <https://www.debian.org/doc/debian-policy/ch-maintainerscripts.html>
    pub post_install_script: Option<PathBuf>,
    /// Path to script that will be executed before the package is removed. See
    /// <https://www.debian.org/doc/debian-policy/ch-maintainerscripts.html>
    pub pre_remove_script: Option<PathBuf>,
    /// Path to script that will be executed after the package is removed. See
    /// <https://www.debian.org/doc/debian-policy/ch-maintainerscripts.html>
    pub post_remove_script: Option<PathBuf>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct WixSettings {
    pub(crate) language: Vec<(String, Option<PathBuf>)>,
    pub(crate) template: Option<PathBuf>,
    pub(crate) fragment_paths: Vec<PathBuf>,
    pub(crate) component_group_refs: Vec<String>,
    pub(crate) component_refs: Vec<String>,
    pub(crate) feature_group_refs: Vec<String>,
    pub(crate) feature_refs: Vec<String>,
    pub(crate) merge_refs: Vec<String>,
    pub(crate) skip_webview_install: bool,
    pub(crate) license: Option<PathBuf>,
    pub(crate) enable_elevated_update_task: bool,
    pub(crate) banner_path: Option<PathBuf>,
    pub(crate) dialog_image_path: Option<PathBuf>,
    pub(crate) fips_compliant: bool,
    /// MSI installer version in the format `major.minor.patch.build` (build is optional).
    ///
    /// Because a valid version is required for MSI installer, it will be derived from [`PackageSettings::version`] if this field is not set.
    ///
    /// The first field is the major version and has a maximum value of 255. The second field is the minor version and has a maximum value of 255.
    /// The third and fourth fields have a maximum value of 65,535.
    ///
    /// See <https://learn.microsoft.com/en-us/windows/win32/msi/productversion> for more info.
    pub version: Option<String>,
    /// A GUID upgrade code for MSI installer. This code **_must stay the same across all of your updates_**,
    /// otherwise, Windows will treat your update as a different app and your users will have duplicate versions of your app.
    ///
    /// By default, tauri generates this code by generating a Uuid v5 using the string `<productName>.exe.app.x64` in the DNS namespace.
    /// You can use Tauri's CLI to generate and print this code for you by running `tauri inspect wix-upgrade-code`.
    ///
    /// It is recommended that you set this value in your tauri config file to avoid accidental changes in your upgrade code
    /// whenever you want to change your product name.
    pub upgrade_code: Option<uuid::Uuid>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct MacOsSettings {
    pub(crate) frameworks: Option<Vec<String>>,
    pub(crate) minimum_system_version: Option<String>,
    pub(crate) license: Option<String>,
    pub(crate) exception_domain: Option<String>,
    pub(crate) signing_identity: Option<String>,
    pub(crate) provider_short_name: Option<String>,
    pub(crate) entitlements: Option<String>,
    pub(crate) info_plist_path: Option<PathBuf>,
    /// List of custom files to add to the application bundle.
    /// Maps the path in the Contents directory in the app to the path of the file to include (relative to the current working directory).
    pub files: HashMap<PathBuf, PathBuf>,
    /// Preserve the hardened runtime version flag, see <https://developer.apple.com/documentation/security/hardened_runtime>
    ///
    /// Settings this to `false` is useful when using an ad-hoc signature, making it less strict.
    pub hardened_runtime: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct WindowsSettings {
    pub(crate) digest_algorithm: Option<String>,
    pub(crate) certificate_thumbprint: Option<String>,
    pub(crate) timestamp_url: Option<String>,
    pub(crate) tsp: bool,
    pub(crate) wix: Option<WixSettings>,
    pub(crate) icon_path: Option<PathBuf>,
    pub(crate) webview_install_mode: WebviewInstallMode,
    pub(crate) webview_fixed_runtime_path: Option<PathBuf>,
    pub(crate) allow_downgrades: bool,
    pub(crate) nsis: Option<NsisSettings>,
    /// Specify a custom command to sign the binaries.
    /// This command needs to have a `%1` in it which is just a placeholder for the binary path,
    /// which we will detect and replace before calling the command.
    ///
    /// Example:
    /// ```text
    /// sign-cli --arg1 --arg2 %1
    /// ```
    ///
    /// By Default we use `signtool.exe` which can be found only on Windows so
    /// if you are on another platform and want to cross-compile and sign you will
    /// need to use another tool like `osslsigncode`.
    pub sign_command: Option<CustomSignCommandSettings>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct NsisSettings {
    pub(crate) template: Option<PathBuf>,
    pub(crate) license: Option<PathBuf>,
    pub(crate) header_image: Option<PathBuf>,
    pub(crate) sidebar_image: Option<PathBuf>,
    pub(crate) installer_icon: Option<PathBuf>,
    pub(crate) install_mode: NSISInstallerMode,
    pub(crate) languages: Option<Vec<String>>,
    pub(crate) custom_language_files: Option<HashMap<String, PathBuf>>,
    pub(crate) display_language_selector: bool,
    pub(crate) start_menu_folder: Option<String>,
    pub(crate) installer_hooks: Option<PathBuf>,
    /// Try to ensure that the WebView2 version is equal to or newer than this version,
    /// if the user's WebView2 is older than this version,
    /// the installer will try to trigger a WebView2 update.
    pub minimum_webview2_version: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) enum NSISInstallerMode {
    CurrentUser,
    PerMachine,
    Both,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) enum WebviewInstallMode {
    Skip,
    DownloadBootstrapper { silent: bool },
    EmbedBootstrapper { silent: bool },
    OfflineInstaller { silent: bool },
    FixedRuntime { path: PathBuf },
}


#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustomSignCommandSettings {
    /// The command to run to sign the binary.
    pub cmd: String,
    /// The arguments to pass to the command.
    ///
    /// "%1" will be replaced with the path to the binary to be signed.
    pub args: Vec<String>,
}

#[derive(Clone, Copy, Debug)]
pub(crate) enum PackageType {
    /// "macos"
    MacOsBundle,
    /// "ios"
    IosBundle,
    /// "msi"
    WindowsMsi,
    /// "nsis"
    Nsis,
    /// "deb"
    Deb,
    /// "rpm"
    Rpm,
    /// "appimage"
    AppImage,
    /// "dmg"
    Dmg,
    /// "updater"
    Updater,
}
````
# Testing and Debugging

Testing and debugging are essential parts of the development process. This guide covers the basics of testing dioxus applications and debugging issues.

## Testing

Testing can be broken down into several categories:

* **Unit Testing**: Testing individual components or functions in isolation.
* **End-to-End Testing**: Testing the entire application from start to finish.

### Unit Testing

Unit testing involves testing individual components or functions in isolation. Rust has built in support for testing using `cargo test`. You can annotate any function with the `#[test]` attribute to mark it as a test function. Here's an example of how to write a unit test for a simple function:

````rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[test]
fn test_add() {
    assert_eq!(add(2, 3), 5);
}
````

### End-to-End Testing

End-to-end testing involves testing the entire application from start to finish. For dioxus applications, playwright can be used to automate the browser and test different aspects of your application. The [Web Testing](./web.md) guide provides more information on how to setup and use playwright with dioxus.

## Avoiding Common Pitfalls

While it is important to understand how to debug issues when they come up, avoiding issues altogether is even better. The [anti-patterns](../tips/antipatterns.md) guide walks through a couple of common pitfalls and how to avoid them.

## Optimizing Builds

Once you have ironed out all of the bugs in your application and are ready to deploy, its worth taking some time to get your application ready for production. The [Optimizing](../tips/optimizing.md) guide covers optimizing your build settings for production.
# Testing

When building application or libraries with Dioxus, you may want to include some tests to check the behavior of parts of your application. This guide will teach you how to test different parts of your Dioxus application.

## Component Testing

You can use a combination of [pretty-assertions](https://docs.rs/pretty_assertions/latest/pretty_assertions/) and [dioxus-ssr](http://crates.io/crates/dioxus-ssr) to check that two snippets of rsx are equal:

````rs@component_test.rs
use futures::FutureExt;
use std::{cell::RefCell, sync::Arc};

use dioxus::prelude::*;

#[test]
fn test() {
    assert_rsx_eq(
        rsx! {
            div { "Hello world" }
            div { "Hello world" }
        },
        rsx! {
            for _ in 0..2 {
                div { "Hello world" }
            }
        },
    )
}

fn assert_rsx_eq(first: Element, second: Element) {
    let first = dioxus_ssr::render_element(first);
    let second = dioxus_ssr::render_element(second);
    pretty_assertions::assert_str_eq!(first, second);
}

````

## Hook Testing

When creating libraries around Dioxus, it can be helpful to make tests for your [custom hooks](../../essentials/advanced/custom_hooks.md).

Dioxus does not currently have a full hook testing library, but you can build a bespoke testing framework by manually driving the virtual dom.

````rs@hook_test.rs
use futures::FutureExt;
use std::{cell::RefCell, rc::Rc, sync::Arc, thread::Scope};

use dioxus::{dioxus_core::NoOpMutations, prelude::*};

#[test]
fn test() {
    test_hook(
        || use_signal(|| 0),
        |mut value, mut proxy| match proxy.generation {
            0 => {
                value.set(1);
            }
            1 => {
                assert_eq!(*value.read(), 1);
                value.set(2);
            }
            2 => {
                proxy.rerun();
            }
            3 => {}
            _ => todo!(),
        },
        |proxy| assert_eq!(proxy.generation, 4),
    );
}

fn test_hook<V: 'static>(
    initialize: impl FnMut() -> V + 'static,
    check: impl FnMut(V, MockProxy) + 'static,
    mut final_check: impl FnMut(MockProxy) + 'static,
) {
    #[derive(Props)]
    struct MockAppComponent<I: 'static, C: 'static> {
        hook: Rc<RefCell<I>>,
        check: Rc<RefCell<C>>,
    }

    impl<I, C> PartialEq for MockAppComponent<I, C> {
        fn eq(&self, _: &Self) -> bool {
            true
        }
    }

    impl<I, C> Clone for MockAppComponent<I, C> {
        fn clone(&self) -> Self {
            Self {
                hook: self.hook.clone(),
                check: self.check.clone(),
            }
        }
    }

    fn mock_app<I: FnMut() -> V, C: FnMut(V, MockProxy), V>(
        props: MockAppComponent<I, C>,
    ) -> Element {
        let value = props.hook.borrow_mut()();

        props.check.borrow_mut()(value, MockProxy::new());

        rsx! {
            div {}
        }
    }

    let mut vdom = VirtualDom::new_with_props(
        mock_app,
        MockAppComponent {
            hook: Rc::new(RefCell::new(initialize)),
            check: Rc::new(RefCell::new(check)),
        },
    );

    vdom.rebuild_in_place();

    while vdom.wait_for_work().now_or_never().is_some() {
        vdom.render_immediate(&mut NoOpMutations);
    }

    vdom.in_scope(ScopeId::ROOT, || {
        final_check(MockProxy::new());
    })
}

struct MockProxy {
    rerender: Arc<dyn Fn()>,
    pub generation: usize,
}

impl MockProxy {
    fn new() -> Self {
        let generation = dioxus::core::generation();
        let rerender = dioxus::core::schedule_update();

        Self {
            rerender,
            generation,
        }
    }

    pub fn rerun(&mut self) {
        (self.rerender)();
    }
}

````

## End to End Testing

You can use [Playwright](https://playwright.dev/) to create end to end tests for your dioxus application.

In your `playwright.config.js`, you will need to run cargo run or dx serve instead of the default build command. Here is a snippet from the end to end web example:

````js
//...
webServer: [
    {
        cwd: path.join(process.cwd(), 'playwright-tests', 'web'),
        command: 'dx serve',
        port: 8080,
        timeout: 10 * 60 * 1000,
        reuseExistingServer: !process.env.CI,
        stdout: "pipe",
    },
],
````

* [Web example](https://github.com/DioxusLabs/dioxus/tree/main/packages/playwright-tests/web)
* [Liveview example](https://github.com/DioxusLabs/dioxus/tree/main/packages/playwright-tests/liveview)
* [Fullstack example](https://github.com/DioxusLabs/dioxus/tree/main/packages/playwright-tests/fullstack)
# Optimizing

*Note: This is written primarily for the web, but the main optimizations will work on other platforms too.*

You might have noticed that Dioxus binaries are pretty big.
The WASM binary of a [TodoMVC app](https://github.com/tigerros/dioxus-todo-app) weighs in at 2.36mb!
Don't worry; we can get it down to a much more manageable 234kb.
This will get obviously lower over time.
With nightly features, you can even reduce the binary size of a hello world app to less than 100kb!

We will also discuss ways to optimize your app for increased speed.

However, certain optimizations will sacrifice speed for decreased binary size or the other way around.
That's what you need to figure out yourself. Does your app perform performance-intensive tasks, such as graphical processing or tons of DOM manipulations?
You could go for increased speed. In most cases, though, decreased binary size is the better choice, especially because Dioxus WASM binaries are quite large.

To test binary sizes, we will use [this](https://github.com/tigerros/dioxus-todo-app) repository as a sample app.
The `no-optimizations` package will serve as the base, which weighs 2.36mb as of right now.

Additional resources:

* [WASM book - Shrinking `.wasm` code size](https://rustwasm.github.io/docs/book/reference/code-size.html)
* [min-sized-rust](https://github.com/johnthagen/min-sized-rust)

## Building in release mode

This is the best way to optimize. In fact, the 2.36mb figure at the start of the guide is with release mode.
In debug mode, it's actually a whopping 32mb! It also increases the speed of your app.

We can use the `--release` flag to create an optimized build of our application which will be both faster and smaller:

`dx build --release`

## UPX

If you're not targeting web, you can use the [UPX](https://github.com/upx/upx) CLI tool to compress your executables.

Setup:

* Download a [release](https://github.com/upx/upx/releases) and extract the directory inside to a sensible location.
* Add the executable located in the directory to your path variable.

You can run `upx --help` to get the CLI options, but you should also view `upx-doc.html` for more detailed information.
It's included in the extracted directory.

An example command might be: `upx --best -o target/release/compressed.exe target/release/your-executable.exe`.

## Build configuration

*Note: Settings defined in `.cargo/config.toml` will override settings in `Cargo.toml`.*

Other than the `--release` flag, this is the easiest way to optimize your projects, and also the most effective way,
at least in terms of reducing binary size.

### Stable

This configuration is 100% stable and decreases the binary size from 2.36mb to 310kb.
Add this to your `.cargo/config.toml`:

````toml
[profile.release]
opt-level = "z"
debug = false
lto = true
codegen-units = 1
panic = "abort"
incremental = false
````

Links to the documentation of each value:

* [`opt-level`](https://doc.rust-lang.org/rustc/codegen-options/index.html#opt-level)
* [`debug`](https://doc.rust-lang.org/rustc/codegen-options/index.html#debuginfo)
* [`lto`](https://doc.rust-lang.org/rustc/codegen-options/index.html#lto)
* [`codegen-units`](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units)
* [`panic`](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic)
* [`strip`](https://doc.rust-lang.org/rustc/codegen-options/index.html#strip)
* [`incremental`](https://doc.rust-lang.org/rustc/codegen-options/index.html#incremental)

### Unstable

This configuration contains some unstable features, but it should work just fine.
It decreases the binary size from 310kb to 234kb.
Add this to your `.cargo/config.toml`:

````toml
[unstable]
build-std = ["std", "panic_abort", "core", "alloc"]
build-std-features = ["panic_immediate_abort"]

[build]
rustflags = [
    "-Clto",
    "-Zvirtual-function-elimination",
    "-Zlocation-detail=none"
]

# Same as in the Stable section
[profile.release]
opt-level = "z"
debug = false
lto = true
codegen-units = 1
panic = "abort"
strip = true
incremental = false
````

*Note: The omitted space in each flag (e.g., `-C<no space here>lto`) is intentional. It is not a typo.*

The values in `[profile.release]` are documented in the [Stable](#stable) section. Links to the documentation of each value:

* [`[build.rustflags]`](https://doc.rust-lang.org/cargo/reference/config.html#buildrustflags)
* [`-C lto`](https://doc.rust-lang.org/rustc/codegen-options/index.html#lto)
* [`-Z virtual-function-elimination`](https://doc.rust-lang.org/stable/unstable-book/compiler-flags/virtual-function-elimination.html)
* [`-Z location-detail`](https://doc.rust-lang.org/stable/unstable-book/compiler-flags/location-detail.html)

## wasm-opt

*Note: In the future, `wasm-opt` will be supported natively through the [Dioxus CLI](https://crates.io/crates/dioxus-cli).*

`wasm-opt` is a tool from the [binaryen](https://github.com/WebAssembly/binaryen) library that optimizes your WASM files.
To use it, install a [binaryen release](https://github.com/WebAssembly/binaryen/releases) and run this command from the package directory:

````
wasm-opt dist/assets/dioxus/APP_NAME_bg.wasm -o dist/assets/dioxus/APP_NAME_bg.wasm -Oz
````

The `-Oz` flag specifies that `wasm-opt` should optimize for size. For speed, use `-O4`.

## Improving Dioxus code

Let's talk about how you can improve your Dioxus code to be more performant.

It's important to minimize the number of dynamic parts in your `rsx`, like conditional rendering.
When Dioxus is rendering your component, it will skip parts that are the same as the last render.
That means that if you keep dynamic rendering to a minimum, your app will speed up, and quite a bit if it's not just hello world.

Also check out [Anti-patterns](antipatterns.md) for patterns that you should avoid.
Obviously, not all of them are just about performance, but some of them are.

## Optimizing the size of assets

Assets can be a significant part of your app's size. Dioxus includes alpha support for first party assets. Any assets you include with the `asset!` macro will be optimized for production in release builds.
# Antipatterns

This example shows what not to do and provides a reason why a given pattern is considered an "AntiPattern". Most anti-patterns are considered wrong for performance or code re-usability reasons.

## Incorrect Iterator Keys

As described in the [rsx chapter](../../essentials/ui/iteration.md), list items must have unique keys that are associated with the same items across renders. This helps Dioxus associate state with the contained components and ensures good diffing performance. Do not omit keys, unless you know that the list will never change.

````rs@anti_patterns.rs
let data: &HashMap<_, _> = &props.data;

// âŒ No keys
rsx! {
    ul {
        for value in data.values() {
            li { "List item: {value}" }
        }
    }
};

// âŒ Using index as keys
rsx! {
    ul {
        for (index , value) in data.values().enumerate() {
            li { key: "{index}", "List item: {value}" }
        }
    }
};

// âœ… Using unique IDs as keys:
rsx! {
    ul {
        for (key , value) in props.data.iter() {
            li { key: "{key}", "List item: {value}" }
        }
    }
}
````

## Avoid Interior Mutability in Props

While it is technically acceptable to have a `Mutex` or a `RwLock` in the props, they will be difficult to use.

Suppose you have a struct `User` containing the field `username: String`. If you pass a `Mutex<User>` prop to a `UserComponent` component, that component may wish to write to the `username` field. However, when it does, the parent component will not be aware of the change, and the component will not re-render which causes the UI to be out of sync with the state. Instead, consider passing down a reactive value like a `Signal` or immutable data.

````rs@anti_patterns.rs
// âŒ Mutex/RwLock/RefCell in props
#[derive(Props, Clone)]
struct AntipatternInteriorMutability {
    map: Rc<RefCell<HashMap<u32, String>>>,
}

impl PartialEq for AntipatternInteriorMutability {
    fn eq(&self, other: &Self) -> bool {
        std::rc::Rc::ptr_eq(&self.map, &other.map)
    }
}

fn AntipatternInteriorMutability(map: Rc<RefCell<HashMap<u32, String>>>) -> Element {
    rsx! {
        button {
            onclick: {
                let map = map.clone();
                move |_| {
                    // Writing to map will not rerun any components
                    map.borrow_mut().insert(0, "Hello".to_string());
                }
            },
            "Mutate map"
        }
        // Since writing to map will not rerun any components, this will get out of date
        "{map.borrow().get(&0).unwrap()}"
    }
}

// âœ… Use a signal to pass mutable state
#[component]
fn AntipatternInteriorMutabilitySignal(map: Signal<HashMap<u32, String>>) -> Element {
    rsx! {
        button {
            onclick: move |_| {
                // Writing to map will rerun any components that read the map
                map.write().insert(0, "Hello".to_string());
            },
            "Mutate map"
        }
        // Since writing to map will rerun subscribers, this will get updated
        "{map.read().get(&0).unwrap()}"
    }
}
````

## Avoid Updating State During Render

Every time you update the state, Dioxus needs to re-render the component â€“ this is inefficient! Consider refactoring your code to avoid this.

Also, if you unconditionally update the state during render, it will be re-rendered in an infinite loop.

````rs@anti_patterns.rs
// âŒ Updating state in render
let first_signal = use_signal(|| 0);
let mut second_signal = use_signal(|| 0);

// Updating the state during a render can easily lead to infinite loops
if first_signal() + 1 != second_signal() {
    second_signal.set(first_signal() + 1);
}

// âœ… Update state in an effect
let first_signal = use_signal(|| 0);
let mut second_signal = use_signal(|| 0);

// The closure you pass to use_effect will be rerun whenever any of the dependencies change without re-rendering the component
use_effect(move || {
    if first_signal() + 1 != second_signal() {
        second_signal.set(first_signal() + 1);
    }
});

// âœ… Deriving state with use_memo
let first_signal = use_signal(|| 0);
// Memos are specifically designed for derived state. If your state fits this pattern, use it.
let second_signal = use_memo(move || first_signal() + 1);
````

## Avoid Large Groups of State

It can be tempting to have a single large state struct that contains all of your application's state. However, this can lead to issues:

* It can be easy to accidentally mutate the state in a way that causes an infinite loop
* It can be difficult to reason about when and how the state is updated
* It can lead to performance issues because many components will need to re-render when the state changes

Instead, consider breaking your state into smaller, more manageable pieces. This will make it easier to reason about the state, avoid update loops, and improve performance.

````rs@anti_patterns.rs
fn app() -> Element {
    // âŒ Large state struct
    #[derive(Props, Clone, PartialEq)]
    struct LargeState {
        users: Vec<User>,
        logged_in: bool,
        warnings: Vec<String>,
    }

    #[derive(Props, Clone, PartialEq)]
    struct User {
        name: String,
        email: String,
    }

    let mut all_my_state = use_signal(|| LargeState {
        users: vec![User {
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        }],
        logged_in: true,
        warnings: vec![],
    });

    use_effect(move || {
        // It is very easy to accidentally read and write to the state object if it contains all your state
        let read = all_my_state.read();
        let logged_in = read.logged_in;
        if !logged_in {
            all_my_state
                .write_unchecked()
                .warnings
                .push("You are not logged in".to_string());
        }
    });

    // âœ… Use multiple signals to manage state
    let users = use_signal(|| {
        vec![User {
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        }]
    });
    let logged_in = use_signal(|| true);
    let mut warnings = use_signal(|| vec![]);

    use_effect(move || {
        // Now you can read and write to separate signals which will not cause issues
        if !logged_in() {
            warnings.write().push("You are not logged in".to_string());
        }
    });

    // âœ… Use memos to create derived state when larger states are unavoidable
    // Notice we didn't split everything into separate signals. Users still make sense as a vec of data
    let users = use_signal(|| {
        vec![User {
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        }]
    });
    let logged_in = use_signal(|| true);
    let warnings: Signal<Vec<String>> = use_signal(|| vec![]);

    // In child components, you can use the memo to create derived that will only update when a specific part of the state changes
    // This will help you avoid unnecessary re-renders and infinite loops
    #[component]
    fn FirstUser(users: Signal<Vec<User>>) -> Element {
        let first_user = use_memo(move || users.read().first().unwrap().clone());

        rsx! {
            div {
                "First user: {first_user().name}"
            }
        }
    }

    rsx! {
        FirstUser {
            users
        }
    }
}
````

## Running Non-Deterministic Code in the Body of a Component

If you have a component that contains non-deterministic code, that code should generally not be run in the body of the component. If it is put in the body of the component, it will be executed every time the component is re-rendered which can lead to performance issues.

Instead, consider moving the non-deterministic code into a hook that only runs when the component is first created or an effect that reruns when dependencies change.

````rs@anti_patterns.rs
// âŒ Non-deterministic code in the body of a component
#[component]
fn NonDeterministic(name: String) -> Element {
    let my_random_id = rand::random::<u64>();

    rsx! {
        div {
            // Id will change every single time the component is re-rendered
            id: "{my_random_id}",
            "Hello {name}"
        }
    }
}

// âœ… Use a hook to run non-deterministic code
fn NonDeterministicHook(name: String) -> Element {
    // If you store the result of the non-deterministic code in a hook, it will stay the same between renders
    let my_random_id = use_hook(|| rand::random::<u64>());

    rsx! {
        div {
            id: "{my_random_id}",
            "Hello {name}"
        }
    }
}
````

## Overly Permissive PartialEq for Props

You may have noticed that `Props` requires a `PartialEq` implementation. That `PartialEq` is very important for Dioxus to work correctly. It is used to determine if a component should re-render or not when the parent component re-renders.

If you cannot derive `PartialEq` for your `Props`, you will need to implement it yourself. If you do implement `PartialEq`, make sure to return `false` any time the props change in a way that would cause the UI in the child component to change.

In general, returning `false` from `PartialEq` if you aren't sure if the props have changed or not is better than returning `true`. This will help you avoid out of date UI in your child components.

````rs@anti_patterns.rs
// âŒ Permissive PartialEq for Props
#[derive(Props, Clone)]
struct PermissivePartialEqProps {
    name: String,
}

// This will cause the component to **never** re-render when the parent component re-renders
impl PartialEq for PermissivePartialEqProps {
    fn eq(&self, _: &Self) -> bool {
        true
    }
}

fn PermissivePartialEq(name: PermissivePartialEqProps) -> Element {
    rsx! {
        div {
            "Hello {name.name}"
        }
    }
}

#[component]
fn PermissivePartialEqParent() -> Element {
    let name = use_signal(|| "Alice".to_string());

    rsx! {
        PermissivePartialEq {
            // The PermissivePartialEq component will not get the updated value of name because the PartialEq implementation says that the props are the same
            name: name()
        }
    }
}

// âœ… Derive PartialEq for Props
#[derive(Props, Clone, PartialEq)]
struct DerivePartialEqProps {
    name: String,
}

fn DerivePartialEq(name: DerivePartialEqProps) -> Element {
    rsx! {
        div {
            "Hello {name.name}"
        }
    }
}

#[component]
fn DerivePartialEqParent() -> Element {
    let name = use_signal(|| "Alice".to_string());

    rsx! {
        DerivePartialEq {
            name: name()
        }
    }
}

// âœ… Return false from PartialEq if you are unsure if the props have changed
#[derive(Debug)]
struct NonPartialEq;

#[derive(Props, Clone)]
struct RcPartialEqProps {
    name: Rc<NonPartialEq>,
}

impl PartialEq for RcPartialEqProps {
    fn eq(&self, other: &Self) -> bool {
        // This will almost always return false because the Rc will likely point to a different value
        // Implementing PartialEq for NonPartialEq would be better, but if it is controlled by another library, it may not be possible
        // **Always** return false if you are unsure if the props have changed
        std::rc::Rc::ptr_eq(&self.name, &other.name)
    }
}

fn RcPartialEq(name: RcPartialEqProps) -> Element {
    rsx! {
        div {
            "Hello {name.name:?}"
        }
    }
}

fn RcPartialEqParent() -> Element {
    let name = use_signal(|| Rc::new(NonPartialEq));

    rsx! {
        RcPartialEq {
            // Generally, RcPartialEq will rerun even if the value of name hasn't actually changed because the Rc will point to a different value
            name: name()
        }
    }
}
````
# Utilities

The utilities section provides a collection of useful libraries that can be used alongside dioxus.

* [Logging](./logging.md) Covers how to use dioxus-logger to configure logging for your project.
* [Internationalization](./internationalization.md) Explains how to use dioxus-i8n to support multiple languages in your application.
* [Tailwind](./tailwind.md) Provides setup instructions for using dioxus with Tailwind CSS.
# Logging

Dioxus has a wide range of supported platforms, each with their own logging requirements. We'll discuss the different options available for your projects.

## Dioxus Logger

Dioxus provides a first-party logger as part of `launch`. This sets up a tracing subscriber that cleanly integrates with the Dioxus CLI and platforms like Web and Mobile. In development mode, the `Debug` tracing level is set, and in release only the `Info` level is set.

````rust
use dioxus::prelude::*;

fn main() {
    dioxus::launch(|| {
        // Will only log in "dev" mode
        tracing::debug!("Rendering app!");

        // Will log in dev and release
        tracing::info!("Rendering app!");

        rsx! {}
    })
}
````

To override the default or initialize the logger before `launch`, you can use the `init` function yourself:

To use Dioxus Logger, call the `init()` function:

````rs
use tracing::Level;

fn main() {
    // Init logger
    dioxus::logger::init(Level::INFO).expect("failed to init logger");

    // Dioxus launch code
    dioxus::launch(|| rsx! {})
}
````

## The Tracing Crate

The [Tracing](https://crates.io/crates/tracing) crate is the logging interface that the dioxus-logger uses. It is not required to use the Tracing crate, but you will not receive logs from the Dioxus library.

The Tracing crate provides a variety of simple `println`-like macros with varying levels of severity.
The available macros are as follows with the highest severity on the bottom:

````rs
fn main() {
    tracing::trace!("trace");
    tracing::debug!("debug");
    tracing::info!("info");
    tracing::warn!("warn");
    tracing::error!("error");
}
````

All the loggers provided on this page are, besides configuration and initialization, interfaced using these macros. Often you will also utilize the Tracing crate's `Level` enum. This enum usually represents the maximum log severity you want your application to emit and can be loaded from a variety of sources such as configuration file, environment variable, and more.

For more information, visit the Tracing crate's [docs](https://docs.rs/tracing/latest/tracing/).

## Platform Intricacies

On web, Dioxus Logger will use [tracing-wasm](https://crates.io/crates/tracing-wasm). On Desktop and server-based targets, Dioxus Logger will use [tracing-subscriber](https://crates.io/crates/tracing-subscriber)'s `FmtSubscriber`.

## Viewing Logs

Android logs are sent to logcat. To use logcat through the Android debugger, run:

````cmd
adb -d logcat
````

Your Android device will need developer options/usb debugging enabled.

For more information, visit android_logger's [docs](https://docs.rs/android_logger/latest/android_logger/).

iOS logs are sent to oslog.

For more information, visit [oslog](https://crates.io/crates/oslog).

#### Final Notes

Dioxus Logger is the preferred logger to use with Dioxus if it suites your needs. There are more features to come. If there are any feature suggestions or issues with Dioxus Logger, feel free to reach out on the [Dioxus Discord Server](https://discord.gg/XgGxMSkvUM)!

For more information, visit Dioxus Logger's [docs](https://docs.rs/dioxus-logger/latest/dioxus_logger/).
# Internationalization

If your application supports multiple languages, the [dioxus-i18n](https://github.com/dioxus-community/dioxus-i18n) crate contains helpers to make working with translations in your application easier.

You can find an example [here](https://github.com/dioxus-community/dioxus-i18n/blob/main/examples/dioxus-desktop.rs).
# Tailwind

You can style your Dioxus application with whatever CSS framework you choose, or just write vanilla CSS.

One popular option for styling your Dioxus application is [Tailwind](https://tailwindcss.com/). Tailwind allows you to style your elements with CSS utility classes. This guide will show you how to setup Tailwind CSS with your Dioxus application.

## Setup

1. Install the Dioxus CLI:

````bash
cargo install dioxus-cli
````

2. Install NPM: [https://docs.npmjs.com/downloading-and-installing-node-js-and-npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)

2. Install the Tailwind CSS CLI: [https://tailwindcss.com/docs/installation/tailwind-cli](https://tailwindcss.com/docs/installation/tailwind-cli)

2. Create a `input.css` file in the root of your project with the following content:

````css
@import "tailwindcss";
@source "./src/**/*.{rs,html,css}";
````

5. Create a link to the `tailwind.css` file using manganis somewhere in your rust code:

````rs@tailwind.rs
use dioxus::prelude::*;

#[component]
fn app() -> Element {
    rsx! {
        // The Stylesheet component inserts a style link into the head of the document
        document::Stylesheet {
            // Urls are relative to your Cargo.toml file
            href: asset!("/assets/tailwind.css")
        }
    }
}

````

### Bonus Steps

1. Install the Tailwind CSS VSCode extension
1. Go to the settings for the extension and find the experimental regex support section. Edit the setting.json file to look like this:

````json
"tailwindCSS.experimental.classRegex": ["class: \"(.*)\""],
"tailwindCSS.includeLanguages": {
    "rust": "html"
},
````

## Development

* Run the following command in the root of the project to start the Tailwind CSS compiler:

````bash
npx @tailwindcss/cli -i ./input.css -o ./assets/tailwind.css --watch
````

### Web

* Run the following command in the root of the project to start the Dioxus dev server:

````bash
dx serve
````

* Open the browser to [http://localhost:8080](http://localhost:8080).

### Desktop

* Launch the Dioxus desktop app:

````bash
dx serve --desktop
````

# Custom Renderer

Dioxus is an incredibly portable framework for UI development. The lessons, knowledge, hooks, and components you acquire over time can always be used for future projects. However, sometimes those projects cannot leverage a supported renderer or you need to implement your own better renderer.

Great news: the design of the renderer is entirely up to you! We provide suggestions and inspiration with the 1st party renderers, but only really require processing `Mutations` and sending `UserEvents`.

## The specifics:

Implementing the renderer is fairly straightforward. The renderer needs to:

1. Handle the stream of edits generated by updates to the virtual DOM
1. Register listeners and pass events into the virtual DOM's event system

Essentially, your renderer needs to process edits and generate events to update the VirtualDOM. From there, you'll have everything needed to render the VirtualDOM to the screen.

Internally, Dioxus handles the tree relationship, diffing, memory management, and the event system, leaving as little as possible required for renderers to implement themselves.

For reference, check out the [javascript interpreter](https://github.com/DioxusLabs/dioxus/tree/v0.5/packages/interpreter) or [tui renderer](https://github.com/DioxusLabs/blitz/tree/master/packages/dioxus-tui) as a starting point for your custom renderer.

## Templates

Dioxus is built around the concept of [Templates](https://docs.rs/dioxus-core/latest/dioxus_core/prelude/struct.Template.html). Templates describe a UI tree known at compile time with dynamic parts filled at runtime. This is useful internally to make skip diffing static nodes, but it is also useful for the renderer to reuse parts of the UI tree. This can be useful for things like a list of items. Each item could contain some static parts and some dynamic parts. The renderer can use the template to create a static part of the UI once, clone it for each element in the list, and then fill in the dynamic parts.

## Mutations

The `Mutation` type is a serialized enum that represents an operation that should be applied to update the UI. The variants roughly follow this set:

````rust
enum Mutation {
	AppendChildren,
	AssignId,
	CreatePlaceholder,
	CreateTextNode,
	HydrateText,
	LoadTemplate,
	ReplaceWith,
	ReplacePlaceholder,
	InsertAfter,
	InsertBefore,
	SetAttribute,
	SetText,
	NewEventListener,
	RemoveEventListener,
	Remove,
	PushRoot,
}
````

The Dioxus diffing mechanism operates as a [stack machine](https://en.wikipedia.org/wiki/Stack_machine) where the [LoadTemplate](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.LoadTemplate), [CreatePlaceholder](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.CreatePlaceholder), and [CreateTextNode](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.CreateTextNode) mutations pushes a new "real" DOM node onto the stack and [AppendChildren](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.AppendChildren), [InsertAfter](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.InsertAfter), [InsertBefore](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.InsertBefore), [ReplacePlaceholder](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.ReplacePlaceholder), and [ReplaceWith](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.ReplaceWith) all remove nodes from the stack.

## Node storage

Dioxus saves and loads elements with IDs. Inside the VirtualDOM, this is just tracked as as a u64.

Whenever a `CreateElement` edit is generated during diffing, Dioxus increments its node counter and assigns that new element its current NodeCount. The RealDom is responsible for remembering this ID and pushing the correct node when id is used in a mutation. Dioxus reclaims the IDs of elements when removed. To stay in sync with Dioxus you can use a sparse Vec (Vec\<Option<T>\>) with possibly unoccupied items. You can use the ids as indexes into the Vec for elements, and grow the Vec when an id does not exist.

### An Example

For the sake of understanding, let's consider this example â€“ a very simple UI declaration:

````rust
rsx! {
	h1 { "count: {x}" }
}
````

#### Building Templates

The above rsx will create a template that contains one static h1 tag and a placeholder for a dynamic text node. The template contains the static parts of the UI, and ids for the dynamic parts along with the paths to access them.

The template will look something like this:

````rust
Template {
	// Some id that is unique for the entire project
	name: "main.rs:1:1:0",
	// The root nodes of the template
	roots: &[
		TemplateNode::Element {
			tag: "h1",
			namespace: None,
			attrs: &[],
			children: &[
				TemplateNode::DynamicText {
					id: 0
				},
			],
		}
	],
	// the path to each of the dynamic nodes
	node_paths: &[
		// the path to dynamic node with a id of 0
		&[
			// on the first root node
			0,
			// the first child of the root node
			0,
		]
	],
	// the path to each of the dynamic attributes
	attr_paths: &'a [&'a [u8]],
}
````

 > 
 > For more detailed docs about the structure of templates see the [Template api docs](https://docs.rs/dioxus-core/latest/dioxus_core/prelude/struct.Template.html)

This template will be sent to the renderer in the [list of templates](https://docs.rs/dioxus-core/latest/dioxus_core/struct.Mutations.html#structfield.templates) supplied with the mutations the first time it is used. Any time the renderer encounters a [LoadTemplate](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.LoadTemplate) mutation after this, it should clone the template and store it in the given id.

For dynamic nodes and dynamic text nodes, a placeholder node should be created and inserted into the UI so that the node can be modified later.

In HTML renderers, this template could look like this:

````html
<h1>""</h1>
````

#### Applying Mutations

After the renderer has created all of the new templates, it can begin to process the mutations.

When the renderer starts, it should contain the Root node on the stack and store the Root node with an id of 0. The Root node is the top-level node of the UI. In HTML, this is the `<div id="main">` element.

````rust
instructions: []
stack: [
	RootNode,
]
nodes: [
	RootNode,
]
````

The first mutation is a `LoadTemplate` mutation. This tells the renderer to load a root from the template with the given id. The renderer will then push the root node of the template onto the stack and store it with an id for later. In this case, the root node is an h1 element.

````rust
instructions: [
	LoadTemplate {
		// the id of the template
		name: "main.rs:1:1:0",
		// the index of the root node in the template
		index: 0,
		// the id to store
		id: ElementId(1),
	}
]
stack: [
	RootNode,
	<h1>""</h1>,
]
nodes: [
	RootNode,
	<h1>""</h1>,
]
````

Next, Dioxus will create the dynamic text node. The diff algorithm decides that this node needs to be created, so Dioxus will generate the Mutation `HydrateText`. When the renderer receives this instruction, it will navigate to the placeholder text node in the template and replace it with the new text.

````rust
instructions: [
	LoadTemplate {
		name: "main.rs:1:1:0",
		index: 0,
		id: ElementId(1),
	},
	HydrateText {
		// the id to store the text node
		id: ElementId(2),
		// the text to set
		text: "count: 0",
	}
]
stack: [
	RootNode,
	<h1>"count: 0"</h1>,
]
nodes: [
	RootNode,
	<h1>"count: 0"</h1>,
	"count: 0",
]
````

Remember, the h1 node is not attached to anything (it is unmounted) so Dioxus needs to generate an Edit that connects the h1 node to the Root. It depends on the situation, but in this case, we use `AppendChildren`. This pops the text node off the stack, leaving the Root element as the next element on the stack.

````rust
instructions: [
	LoadTemplate {
		name: "main.rs:1:1:0",
		index: 0,
		id: ElementId(1),
	},
	HydrateText {
		id: ElementId(2),
		text: "count: 0",
	},
	AppendChildren {
		// the id of the parent node
		id: ElementId(0),
		// the number of nodes to pop off the stack and append
		m: 1
	}
]
stack: [
	RootNode,
]
nodes: [
	RootNode,
	<h1>"count: 0"</h1>,
	"count: 0",
]
````

Over time, our stack looked like this:

````rust
[Root]
[Root, <h1>""</h1>]
[Root, <h1>"count: 0"</h1>]
[Root]
````

Conveniently, this approach completely separates the Virtual DOM and the Real DOM. Additionally, these edits are serializable, meaning we can even manage UIs across a network connection. This little stack machine and serialized edits make Dioxus independent of platform specifics.

Dioxus is also really fast. Because Dioxus splits the diff and patch phase, it's able to make all the edits to the RealDOM in a very short amount of time (less than a single frame) making rendering very snappy. It also allows Dioxus to cancel large diffing operations if higher priority work comes in while it's diffing.

This little demo serves to show exactly how a Renderer would need to process a mutation stream to build UIs.

## Event loop

Like most GUIs, Dioxus relies on an event loop to progress the VirtualDOM. The VirtualDOM itself can produce events as well, so it's important for your custom renderer can handle those too.

The code for the WebSys implementation is straightforward, so we'll add it here to demonstrate how simple an event loop is:

````rust, ignore
pub async fn run(&mut self) -> dioxus_core::error::Result<()> {
	// Push the body element onto the WebsysDom's stack machine
	let mut websys_dom = crate::new::WebsysDom::new(prepare_websys_dom());
	websys_dom.stack.push(root_node);

	// Rebuild or hydrate the virtualdom
	let mutations = self.internal_dom.rebuild();
	websys_dom.apply_mutations(mutations);

	// Wait for updates from the real dom and progress the virtual dom
	loop {
		let user_input_future = websys_dom.wait_for_event();
		let internal_event_future = self.internal_dom.wait_for_work();

		match select(user_input_future, internal_event_future).await {
			Either::Left((_, _)) => {
				let mutations = self.internal_dom.work_with_deadline(|| false);
				websys_dom.apply_mutations(mutations);
			},
			Either::Right((event, _)) => websys_dom.handle_event(event),
		}

		// render
	}
}
````

It's important to decode what the real events are for your event system into Dioxus' synthetic event system (synthetic meaning abstracted). This simply means matching your event type and creating a Dioxus `UserEvent` type. Right now, the virtual event system is modeled almost entirely around the HTML spec, but we are interested in slimming it down.

````rust, ignore
fn virtual_event_from_websys_event(event: &web_sys::Event) -> VirtualEvent {
	match event.type_().as_str() {
		"keydown" => {
			let event: web_sys::KeyboardEvent = event.clone().dyn_into().unwrap();
			UserEvent::KeyboardEvent(UserEvent {
				scope_id: None,
				priority: EventPriority::Medium,
				name: "keydown",
				// This should be whatever element is focused
				element: Some(ElementId(0)),
				data: Arc::new(KeyboardData{
					char_code: event.char_code(),
					key: event.key(),
					key_code: event.key_code(),
					alt_key: event.alt_key(),
					ctrl_key: event.ctrl_key(),
					meta_key: event.meta_key(),
					shift_key: event.shift_key(),
					location: event.location(),
					repeat: event.repeat(),
					which: event.which(),
				})
			})
		}
		_ => todo!()
	}
}
````

## Custom raw elements

If you need to go as far as relying on custom elements/attributes for your renderer â€“ you totally can. This still enables you to use Dioxus' reactive nature, component system, shared state, and other features, but will ultimately generate different nodes. All attributes and listeners for the HTML and SVG namespace are shuttled through helper structs that essentially compile away. You can drop in your elements any time you want, with little hassle. However, you must be sure your renderer can handle the new namespace.

For more examples and information on how to create custom namespaces, see the [`dioxus_html` crate](https://github.com/DioxusLabs/dioxus/blob/main/packages/html/README.md#how-to-extend-it).

## Conclusion

That should be it! You should have nearly all the knowledge required on how to implement your renderer. We're super interested in seeing Dioxus apps brought to custom desktop renderers, mobile renderers, video game UI, and even augmented reality! If you're interested in contributing to any of these projects, don't be afraid to reach out or join the [community](https://discord.gg/XgGxMSkvUM).
# Migration Guides

Dioxus has evolved over its lifetime. We feel quite stable with the current API, but there might be changes in the future.

To help migrate between versions, we've assembled a set of migration guides:

* [v0.4 to v0.5](to_05/index.md)
* [v0.5 to v0.6](to_06.md)
* [v0.6 to v0.7](to_07.md)
# How to Upgrade to Dioxus 0.7

This guide will outline the API changes between the 0.6 and 0.7 releases. The 0.7 release contains breaking changes to:

* [`dioxusâ€‘lib`](#dioxuslib-removed)
* [Form submissions](#form-submission-behavior)
* [Asset Options](#asset-options)
* [Custom server function errors](#custom-server-function-error-type)
* [dioxus::prelude](#items-removed-from-the-prelude)
* [The default server function codec](#change-default-server-function-codec-to-json)
* [Transitive dependency updates](#transitive-dependency-updates)
* [Owned event listener type](#owned-event-listener-type-only-applies-to-custom-renderers)

## `dioxusâ€‘lib` removed

`dioxusâ€‘lib` crate was removed. You need to add dioxus as a dependency and adjust all references from `dioxus_lib` to use `dioxus` directly.

````toml
# Cargo.toml
[dependencies]
dioxus = { version = "0.7", default-features = false, features = ["lib"] }
````

````rust
// src/main.rs
use dioxus::prelude::*;
````

[PRÂ #4438](https://github.com/DioxusLabs/dioxus/pull/4438)

## Form submission behavior

Before dioxus 0.7 form submissions were prevented by default in all renderers because it broke the page on desktop. If you called `prevent_default` on a form submission, it would invert the default behavior and allow the form to submit.

In dioxus 0.7, the default behavior is to allow form submissions, and you need to call `prevent_default` to prevent them. The desktop renderer prevents all page navigation including form submissions separately.

Dioxus 0.6:

````rust
rsx!(
    form {
        onsubmit: |e| {}, // Forms used to automatically not submit and reload the page
        input { name: "username", type: "text" },
        button { type: "submit", "Submit" }
    }
)
````

Dioxus 0.7:

````rust
rsx!(
    form {
        onsubmit: |e| e.prevent_default(), // In dioxus 0.7 you need to call prevent_default to prevent form submission
        input { name: "username", type: "text" },
        button { type: "submit", "Submit" }
    }
)
````

[PRÂ #4422](https://github.com/DioxusLabs/dioxus/pull/4422)

## Asset Options

The asset options api for manganis was unified to use a single `AssetOptionsBuilder`. Instead of pulling in specific options like `ImageAssetOptions::new()`, you can now use `AssetOptions::image()` to create a builder for the asset variant you need.

Dioxus 0.6:

````rust
use manganis::{ImageFormat, ImageAssetOptions, Asset, asset, ImageSize};

pub const RESIZED_PNG_ASSET: Asset =
    asset!("/assets/image.png", ImageAssetOptions::new().with_size(ImageSize::Manual { width: 52, height: 52 }));
pub const AVIF_ASSET: Asset = asset!("/assets/image.png", ImageAssetOptions::new().with_format(ImageFormat::Avif));
````

Dioxus 0.7:

````rust
use manganis::{ImageFormat, ImageAssetOptions, Asset, asset, ImageSize};

pub const RESIZED_PNG_ASSET: Asset =
    asset!("/assets/image.png", AssetOptions::image().with_size(ImageSize::Manual { width: 52, height: 52 }));
pub const AVIF_ASSET: Asset = asset!("/assets/image.png", AssetOptions::image().with_format(ImageFormat::Avif));
````

[PRÂ #4312](https://github.com/DioxusLabs/dioxus/pull/4312)

### Custom server function error type

The `ServerFnError` type was changed from the generic server fn error type to a dioxus specific error type that can be easily converted into `dioxus::Error`. The type name is the same, but you may need to update your imports to use the dioxus type instead of the server fn type.

[PRÂ #4205](https://github.com/DioxusLabs/dioxus/pull/4205)

### Items removed from the prelude

Many items were removed from the prelude and now need to be imported explicitly. This includes:

* `use_drop`
* `Runtime`
* `queue_effect`
* `provide_root_context`

[PRÂ #4128](https://github.com/DioxusLabs/dioxus/pull/4128)

### Change default server function codec to JSON

Server functions used to encode arguments using URLâ€‘encoded form data. Url encoding did not allow empty data structures or nested structures. The default codec is now JSON which supports many more types. Thirdâ€‘party integrations that rely on the old form encoding format need to be updated to use the JSON codec or you need to explicitly set the protocol to `Http<PostUrl, Json>`.

Dioxus 0.6:

````rust
#[server]
async fn my_post_function(arg: MyStruct) -> ServerFnResult<MyResponse> {
    // ...
}

#[server(protocol = Http<Json, Json>)]
async fn my_json_function(arg: MyStruct) -> ServerFnResult<MyResponse> {
    // ...
}
````

Dioxus 0.7:

````rust
#[server(protocol = Http<GetUrl, Json>)]
async fn my_post_function(arg: MyStruct) -> ServerFnResult<MyResponse> {
    // ...
}
#[server]
async fn my_json_function(arg: MyStruct) -> ServerFnResult<MyResponse> {
    // ...
}
````

[PRÂ #3602](https://github.com/DioxusLabs/dioxus/pull/3602)

### Transitive dependency updates

Several crates dioxus exposes in public apis and re-exports were updated to the latest versions. If you rely on these crates, you may need to update your dependencies.

* Wry was updated to 0.52: [PRÂ #4255](https://github.com/DioxusLabs/dioxus/pull/4255)
* Axum was updated to 0.8: [PRÂ #3820](https://github.com/DioxusLabs/dioxus/pull/3820)
* Server fn was updated to 0.7: [PRÂ #3560](https://github.com/DioxusLabs/dioxus/pull/3560)

## Owned event listener type (only applies to custom renderers)

Dioxus html event handlers used to accept the same copy event handler that components use which complicates the drop logic in the VNode type. Event handlers now accept `impl ::dioxus_core::prelude::SuperInto<::dioxus_core::ListenerCallback<$data>, __Marker>` instead of `impl ::dioxus_core::prelude::SuperInto<::dioxus_core::prelude::EventHandler<::dioxus_core::Event<$data>>, __Marker>`. Custom renderers should be updated to accept the same type for consistency.

[PRÂ #4289](https://github.com/DioxusLabs/dioxus/pull/4289)
# How to Upgrade to Dioxus 0.6

This guide will outline the API changes between the `0.5` and `0.6` releases. The `0.6` release contains breaking changes to:

* The `Element` type
* Prevent default
* Assets with Manganis
* `dioxus_logger` integration with `dioxus`
* The `launch` function
* The `eval` function
* The `dioxus-fullstack` crate
* The router crate
* The `derive(Props)` macro
* The `dioxus-core` crate
* Custom renderer API
* Global state management

## Element

The element type has changed from `Option<VNode>` to `Result<VNode, RenderError>`. This makes it possible to bubble up errors while rendering with the `?` operator, but it does remove the ability to return `None` from a component. Instead of returning `None`, you can return `VNode::empty()` or an empty `rsx!` macro.

Dioxus 0.5:

````rust
use dioxus::prelude::*;

fn app() -> Element {
    let number = use_signal(|| -1);

    if number() < 0 {
        // âŒ In dioxus 0.6, the element type is a result, so None values cannot be returned directly
        return None;
    }

    rsx! {
        "Positive number: {number}"
    }
}
````

Dioxus 0.6:

````rs@migration.rs
use dioxus::prelude::*;

fn app() -> Element {
    let number = use_signal(|| -1);

    if number() < 0 {
        // âœ… You can return VNode::empty() instead
        return VNode::empty();
    }
    if number() < 0 {
        // âœ… Or an empty rsx! macro
        return rsx! {};
    }

    rsx! {
        "Positive number: {number}"
    }
}
````

## Prevent Default

Dioxus 0.1-0.5 used the `prevent_default` attribute to prevent default behavior of event handlers for every event. Dioxus 0.6 introduces more fine-grained control over preventing default behavior with the `prevent_default` function on the event type. Instead of setting the `prevent_default` attribute for all events you want to prevent, you can create event handlers that call `event.prevent_default()`.

Dioxus 0.5:

````rs@migration.rs
use dioxus::prelude::*;

fn app() -> Element {
    rsx! {
        a {
            href: "https://dioxuslabs.com",
            // âŒ The prevent default attribute is deprecated in dioxus 0.6
            prevent_default: "onclick",
            "Don't navigate to dioxuslabs.com"
        }
    }
}
````

Dioxus 0.6:

````rs@migration.rs
use dioxus::prelude::*;

fn app() -> Element {
    rsx! {
        a {
            href: "https://dioxuslabs.com",
            // âœ… Instead, you can call event.prevent_default() inside the event handler
            onclick: move |event| event.prevent_default(),
            "Don't navigate to dioxuslabs.com"
        }
    }
}
````

 > 
 > Note: Since event handlers run on the server in Liveview, events cannot be prevented quickly inside the event handler. Because of this, the new `prevent_default` method does not prevent default behavior in Liveview.
 > 
 > Instead you can use javascript inside the `onclick` handler to prevent default behavior.
 > 
 > ````rs@migration.rs
 > use dioxus::prelude::*;
 > 
 > fn app() -> Element {
 >     rsx! {
 >         a {
 >             href: "https://dioxuslabs.com",
 >             // âœ… In liveview, you can use javascript to prevent default behavior
 >             "onclick": "event.preventDefault()",
 >             "Don't navigate to dioxuslabs.com"
 >         }
 >     }
 > }
 > ````

## Assets

The syntax of the `asset!` macro has changed in Dioxus 0.6. Instead of accepting a single argument with both the path and the configuration for the asset, you can now pass in the path as the first argument and the configuration as a optional second argument.

The path the `asset!` macro accepts has also changed. Previously, the macro used to accept absolute and relative paths where relative paths were relative to the current crate directory. Now the macro only accepts absolute paths which are resolved relative to the root of the crate.

Dioxus 0.5:

````rust
use dioxus::prelude::*;

fn app() -> Element {
    rsx! {
        img {
            src: asset!(image("./assets/static/bundle.png").size(100, 100))
        }
    }
}
````

Dioxus 0.6:

````rs@migration.rs
use dioxus::prelude::*;

fn app() -> Element {
    rsx! {
        img {
            src: asset!("/assets/static/bundle.png", ImageAssetOptions::new().with_size(ImageSize::Manual { width: 100, height: 100 }))
        }
    }
}
````

## Logging

Dioxus 0.6 brings the `dioxus-logger` crate directly into dioxus itself.

Previously, you needed to add `dioxus-logger` to your Cargo.toml and then call its init function:

````rs
// cargo.toml:
// dioxus-logger = "0.5"

use dioxus::prelude::*;
use tracing::Level;

fn main() {
    // Init logger
    dioxus_logger::init(Level::INFO).expect("failed to init logger");

    // Dioxus launch code
    dioxus::launch(app)
}
````

Now, in Dioxus 0.6, the logger is implicit with `launch`. Simply call launch and the logger is initialized to a default log level. In development mode, the `Debug` tracing level is set, and in release only the `Info` level is set.

````rust
use dioxus::prelude::*;

fn main() {
    dioxus::launch(app);
}
````

If you still need to set the level manually or configure a custom subscriber, do that before `launch`. We expose the `initialize_default` function in case you need additional logging before your `launch` call:

````rust
use dioxus::prelude::*;

fn main() {
    dioxus::logger::initialize_default();

    tracing::info!("Logs received!");

    dioxus::launch(app);
}
````

## Launch

The `launch` function was removed from the prelude. You must now import the launch method from `dioxus` or use it by its full path:

````rust
use dioxus::prelude::*;

fn main() {
    // âŒ launch(app);
    dioxus::launch(app); // âœ…
}
````

See <https://github.com/DioxusLabs/dioxus/pull/2967> for more details.

## Eval

* `eval` was moved from the prelude to the `document` module. You must now call it with `document::eval` instead of `eval`:

````rust
use dioxus::prelude::*;

fn app() -> Element {
    // âŒ use_effect(|| eval("console.log(1)"));
    use_effect(|| document::eval("console.log(1)")); // âœ…

    rsx! {}
}
````

* The `eval` feature flag was removed from the `dioxus-html` crate and the functionality of `EvalProvider` was moved to the new `dioxus-document` crate. Custom renderers must now provide a `Rc<dyn Document>` context to the application to make `eval` and head elements work correctly. See <https://github.com/DioxusLabs/dioxus/pull/2635> for more details.
* `Eval::recv` and `Eval::join` now returns any value that implements `DeserializeOwned` instead of `serde_json::Value`. `Eval::send` now accepts any value that implements `Serialize`. See <https://github.com/DioxusLabs/dioxus/pull/3035> for more details

## Fullstack

* The feature `dioxus/axum` was renamed to `dioxus/server`

````toml
[features]
default = []
# âŒ server = ["dioxus/axum"]
server = ["dioxus/server"] # âœ…
web = ["dioxus/web"]
````

See <https://github.com/DioxusLabs/dioxus/pull/3186> for more details

* The `fullstack::Config` item was removed. You can now pass the platform configs into the `LaunchBuilder` directly. For example, if you want to set the rootname on each platform, you can set the root name in each config:

````rust
LaunchBuilder::new()
    // Only set the server config if the server feature is enabled
    .with_cfg(server_only! {
        ServeConfigBuilder::default().root_id("app")
    })
    // You also need to set the root id in your web config
    .with_cfg(web! {
        dioxus::web::Config::default().rootname("app")
    })
    // And desktop config
    .with_cfg(desktop! {
        dioxus::desktop::Config::default().with_root_name("app")
    })
    .launch(app);
````

See <https://github.com/DioxusLabs/dioxus/pull/2967> for more details.

* The dioxus-cli now proxies fullstack applications at a port behind a reverse proxy. If you have a custom axum server, you must serve your application at the port returned by `dioxus_cli_config::server_port` and the address returned by `dioxus_cli_config::server_ip` or the complete address returned by `dioxus_cli_config::fullstack_address_or_localhost` during development:

````rust
#[cfg(feature = "server")]
#[tokio::main]
async fn main() {
    // Get the address the server should run on. If the CLI is running, the CLI proxies fullstack into the main address
    // and we use the generated address the CLI gives us
    let address = dioxus_cli_config::fullstack_address_or_localhost();

    // Launch the fullstack application on the address the CLI is proxying
    let router = axum::Router::new()
        .serve_dioxus_application(ServeConfigBuilder::default(), App);

    let router = router.into_make_service();
    let listener = tokio::net::TcpListener::bind(address).await.unwrap();
    axum::serve(listener, router).await.unwrap();
}
````

See <https://github.com/DioxusLabs/dioxus/pull/2258> for more details.

* `serve_dioxus_application` was changed to accept a component directly instead of a virtual dom factory. See <https://github.com/DioxusLabs/dioxus/pull/2515> for more details.
* `register_server_fns` was renamed to `register_server_functions`. See <https://github.com/DioxusLabs/dioxus/pull/2515> for more details.
* `RenderHandleState::new` accepts a new `ServeConfig` argument. See <https://github.com/DioxusLabs/dioxus/pull/2862> for more details.
* `ServeConfigBuilder::build` returns a result. It may fail during desktop builds if no `index.html` file is found. This error is fine to ignore in desktop builds. You can pass the builder directly to `serve_dioxus_application` to only serve the index.html file if it exists. See <https://github.com/DioxusLabs/dioxus/pull/2862> for more details.
* `dioxus_fullstack::Config::addr` was removed. You can now export the `PORT` and `IP` environment variables to set the address the `launch` method uses for the server.

## Router

* The `Routable` derive macro no longer accepts fields that are not present in the `route("/route")` if the web feature is enabled. See <https://github.com/DioxusLabs/dioxus/pull/2159> for more details.
* The `ToRouteSegments` trait in the router was changed from accepting `self` to accepting `&self`. This means you can now implement it for `T` directly instead of `&T`. See <https://github.com/DioxusLabs/dioxus/pull/2283> for more details.

## derive(Props)

* `#[props(into)]` is ignore on any String props. String props already accept `impl ToString` which is implemented for many of the same types, but if you implement `Into<String>` for a specific type, your code may require some changes. See <https://github.com/DioxusLabs/dioxus/pull/2501> for more details
* Properties that start with an uppercase letter are no longer accepted. This allows us to autocomplete Components. See <https://github.com/DioxusLabs/dioxus/pull/2652> for more details.

## State Management

* `use_coroutine` now accepts `impl FnMut` instead of `impl FnOnce`. This was required to support restarting the coroutine without rerunning the component. See <https://github.com/DioxusLabs/dioxus/pull/3005> for more details.
* `Signal::global_memo` now requires `T: PartialEq` just like `use_memo`. See <https://github.com/DioxusLabs/dioxus/pull/2851> for more details.
* `GlobalMemo<T>` is now a trait alias for `Global<Memo<T>, T>` and `GlobalSignal<T>` is now a trait alias for `Global<Signal<T>, T>`. To get the underlying `Memo` or `Signal`, you can now use the `resolve` method instead of `signal` or `memo`. See <https://github.com/DioxusLabs/dioxus/pull/2851> for more details.
* The `Readable` trait in dioxus signals now requires a `try_peek_unchecked` method instead of `peek_unchecked`. See <https://github.com/DioxusLabs/dioxus/pull/2714> for more details.
* The `check_generation` feature flag was removed from the `generational-box` crate. See <https://github.com/DioxusLabs/dioxus/pull/2638> for more details.

## Core changes

* The `Template::name` field was removed. See <https://github.com/DioxusLabs/dioxus/pull/2799> for more details.
* `Properties::into_vcomponent` now accepts only the `render_fn` instead of the `render_fn` and `component_name`. This change fixes the name of re-exported components. Fixes <https://github.com/DioxusLabs/dioxus/pull/2744>
* The field `VNode::template` is now `Template` instead of `Cell<Template>`. See <https://github.com/DioxusLabs/dioxus/pull/2705> for more details
* `Mutations::sanitize` was renamed to `Mutations::sanitize`. See <https://github.com/DioxusLabs/dioxus/pull/2653> for more details.
* The variant `AttributeValue::Any` now contains `Rc<dyn AnyValue>` instead of `Box<dyn AnyValue>` to make `AttributeValue` `Clone`. See <https://github.com/DioxusLabs/dioxus/pull/2705> for more details

## Custom Renderers

If you are building a custom renderer, there were some breaking changes to hot reloading and rsx that you should be aware of:

* The CLI hot reloading format changed significantly. Custom renderers must switch from `dioxus-hot-reload` to `dioxus_devtools`. Renderers can connect to the hot reloading engine with the \[connect\](<https://docs.rs/dioxus>-devtools/0.6.0/dioxus_devtools/fn.connect.html) function. See <https://github.com/DioxusLabs/dioxus/pull/2258> for more details.
* The format of custom elements was changed to improve autocomplete. The `dioxus_elements` namespace must now contain each element as a module with a TAG_NAME and NAME_SPACE constant inside that module. Each attribute should be another constant in that module. The top-level `dioxus_elements` module should contain a `completions` module with a `CompleteWithBraces` enum that re-exports each element the namespace supports for braces autocomplete. See <https://github.com/DioxusLabs/dioxus/pull/2421> for more details.
* The format for custom event handlers changed include `eventname::call_with_explicit_closure` to provide better type inference for inline closures. See <https://github.com/DioxusLabs/dioxus/pull/2437> for more details

If you are also using dioxus-html, there are a few more breaking changes:

* A `file_size` method was added to the `FileEngine` trait. Any custom renderers must implement this method. See <https://github.com/DioxusLabs/dioxus/pull/2323/files> for more details.
* `HtmlEventConverter` has a new `convert_resize_data` method which must be implemented by any custom renderers that use dioxus-html. See <https://github.com/DioxusLabs/dioxus/pull/2479> for more details
* The web and native features were removed from the `dioxus-html` crate. See <https://github.com/DioxusLabs/dioxus/pull/3006> for more details.
* `dioxus_html::AttributeDescription ` was renamed to `dioxus_html::AttributeDescription`. See <https://github.com/DioxusLabs/dioxus/pull/2653> for more details.

## Minor Breaking Changes

There were several more minor breaking changes in Dioxus 0.6:

* Many implicit features from dioxus crates were removed. These features were automatically generated by cargo and generally not functional. See <https://github.com/DioxusLabs/dioxus/pull/2512> for more details.
* `dioxus_autofmt::write_block_out` accepts `&CallBody` instead of `CallBody`. See <https://github.com/DioxusLabs/dioxus/pull/2573> for more details.
* The `panic_hook` feature which provides a console panic message for wasm panics was moved from the `dioxus-web` crate to the `dioxus-logger` crate. The handler is still provided by default. See <https://github.com/DioxusLabs/dioxus/pull/3302> for more details.
# How to Upgrade to Dioxus 0.5

This guide will outline the API changes between the `0.4` and `0.5` releases.

`0.5` includes significant changes to hooks, props, and global state.

## Cheat Sheet

Here is a quick cheat sheet for the changes:

### Scope

Dioxus 0.4:

````rust
fn app(cx: Scope) -> Element {
    cx.use_hook(|| {
        /*...*/
    });
    cx.provide_context({
        /*...*/
    });
    cx.spawn(async move {
        /*...*/
    });
    cx.render(rsx! {
        /*...*/
    })
}
````

Dioxus 0.5:

````rs@migration.rs
use dioxus::prelude::*;

// In dioxus 0.5, the scope is no longer passed as an argument to the function
fn app() -> Element {
    // Hooks, context, and spawn are now called directly
    use_hook(|| { /*...*/ });
    provide_context({ /*...*/ });
    spawn(async move { /*...*/ });
    rsx! {
        /*...*/
    }
}
````

### Props

Dioxus 0.4:

````rust
#[component]
fn Comp(cx: Scope, name: String) -> Element {
    // You pass in an owned prop, but inside the component, it is borrowed (name is the type &String inside the function)
    let owned_name: String = name.clone();

    cx.render(rsx! {
        "Hello {owned_name}"
        BorrowedComp {
            "{name}"
        }
        ManualPropsComponent {
            name: name
        }
    })
}

#[component]
fn BorrowedComp<'a>(cx: Scope<'a>, name: &'a str) -> Element<'a> {
    cx.render(rsx! {
        "Hello {name}"
    })
}

#[derive(Props, PartialEq)]
struct ManualProps {
    name: String
}

fn ManualPropsComponent(cx: Scope<ManualProps>) -> Element {
    cx.render(rsx! {
        "Hello {cx.props.name}"
    })
}
````

Dioxus 0.5:

````rs@migration.rs
use dioxus::prelude::*;

// In dioxus 0.5, props are always owned. You pass in owned props and you get owned props in the body of the component
#[component]
fn Comp(name: String) -> Element {
    // Name is owned here already (name is the type String inside the function)
    let owned_name: String = name;

    rsx! {
        "Hello {owned_name}"
        BorrowedComp {
            name: "other name"
        }
        ManualPropsComponent {
            name: "other name 2"
        }
    }
}

// Borrowed props are removed in dioxus 0.5. Mapped signals can act similarly to borrowed props if your props are borrowed from state
// ReadOnlySignal is a copy wrapper over a state that will be automatically converted to
#[component]
fn BorrowedComp(name: ReadOnlySignal<String>) -> Element {
    rsx! {
        "Hello {name}"
    }
}

// In dioxus 0.5, props need to implement Props, Clone, and PartialEq
#[derive(Props, Clone, PartialEq)]
struct ManualProps {
    name: String,
}

// Functions accept the props directly instead of the scope
fn ManualPropsComponent(props: ManualProps) -> Element {
    rsx! {
        "Hello {props.name}"
    }
}
````

You can read more about the new props API in the [Props Migration](props.md) guide.

### Futures

Dioxus 0.4:

````rust
use_future((dependency1, dependency2,), move |(dependency1, dependency2,)| async move {
	/*use dependency1 and dependency2*/
});
````

Dioxus 0.5:

````rs@migration.rs
// dependency1 and dependency2 must be Signal-like types like Signal, ReadOnlySignal, GlobalSignal, or another Resource
use_resource(|| async move { /*use dependency1 and dependency2*/ });

let non_reactive_state = 0;
// You can also add non-reactive state to the resource hook with the use_reactive macro
use_resource(use_reactive!(|(non_reactive_state,)| async move {
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    non_reactive_state + 1
}));
````

Read more about the `use_resource` hook in the [Hook Migration](hooks.md) guide.

### State Hooks

Dioxus 0.4:

````rust
let copy_state = use_state(cx, || 0);
let clone_local_state = use_ref(cx, || String::from("Hello"));
use_shared_state_provider(cx, || String::from("Hello"));
let clone_shared_state = use_shared_state::<String>(cx);

let copy_state_value = **copy_state;
let clone_local_state_value = clone_local_state.read();
let clone_shared_state_value = clone_shared_state.read();

cx.render(rsx!{
	"{copy_state_value}"
	"{clone_shared_state_value}"
	"{clone_local_state_value}"
	button {
		onclick: move |_| {
			copy_state.set(1);
			*clone_local_state.write() = "World".to_string();
			*clone_shared_state.write() = "World".to_string();
		},
		"Set State"
	}
})
````

Dioxus 0.5:

````rs@migration.rs
// You can now use signals for local copy state, local clone state, and shared state with the same API
let mut copy_state = use_signal(|| 0);
let mut clone_shared_state = use_context_provider(|| Signal::new(String::from("Hello")));
let mut clone_local_state = use_signal(|| String::from("Hello"));

// Call the signal like a function to clone the current value
let copy_state_value = copy_state();
// Or use the read method to borrow the current value
let clone_local_state_value = clone_local_state.read();
let clone_shared_state_value = clone_shared_state.read();

rsx! {
    "{copy_state_value}"
    "{clone_shared_state_value}"
    "{clone_local_state_value}"
    button {
        onclick: move |_| {
            // All three states have the same API for updating the state
            copy_state.set(1);
            clone_shared_state.set("World".to_string());
            clone_local_state.set("World".to_string());
        },
        "Set State"
    }
}
````

Read more about the `use_signal` hook in the [State Migration](state.md) guide.

### Fermi

Dioxus 0.4:

````rust
use dioxus::prelude::*;
use fermi::*;

static NAME: Atom<String> = Atom(|_| "world".to_string());

fn app(cx: Scope) -> Element {
    use_init_atom_root(cx);
    let name = use_read(cx, &NAME);

    cx.render(rsx! {
        div { "hello {name}!" }
        Child {}
        ChildWithRef {}
    })
}

fn Child(cx: Scope) -> Element {
    let set_name = use_set(cx, &NAME);

    cx.render(rsx! {
        button {
            onclick: move |_| set_name("dioxus".to_string()),
            "reset name"
        }
    })
}

static NAMES: AtomRef<Vec<String>> = AtomRef(|_| vec!["world".to_string()]);

fn ChildWithRef(cx: Scope) -> Element {
    let names = use_atom_ref(cx, &NAMES);

    cx.render(rsx! {
        div {
            ul {
                names.read().iter().map(|f| rsx!{
                    li { "hello: {f}" }
                })
            }
            button {
                onclick: move |_| {
                    let names = names.clone();
                    cx.spawn(async move {
                        names.write().push("asd".to_string());
                    })
                },
                "Add name"
            }
        }
    })
}
````

Dioxus 0.5:

````rs@migration.rs
use dioxus::prelude::*;

// Atoms and AtomRefs have been replaced with GlobalSignals
static NAME: GlobalSignal<String> = Signal::global(|| "world".to_string());

fn app() -> Element {
    rsx! {
        // You can use global state directly without the use_read or use_set hooks
        div { "hello {NAME}!" }
        Child {}
        ChildWithRef {}
    }
}

fn Child() -> Element {
    rsx! {
        button {
            onclick: move |_| *NAME.write() = "dioxus".to_string(),
            "reset name"
        }
    }
}

// Atoms and AtomRefs have been replaced with GlobalSignals
static NAMES: GlobalSignal<Vec<String>> = Signal::global(|| vec!["world".to_string()]);

fn ChildWithRef() -> Element {
    rsx! {
        div {
            ul {
                for name in NAMES.read().iter() {
                    li { "hello: {name}" }
                }
            }
            button {
                onclick: move |_| {
                    // No need to clone the signal into futures, you can use it directly
                    async move {
                        NAMES.write().push("asd".to_string());
                    }
                },
                "Add name"
            }
        }
    }
}
````

You can read more about global signals in the [Fermi migration guide](fermi.md).
# Hooks

Dioxus now uses signals as the backing for its state management. Signals are a smarter, more flexible version of the `use_ref` hook. Signals now back many hooks in dioxus to provide a more consistent and flexible API.

### State Hooks

State hooks are now backed by signals. `use_state`, `use_ref`, and `use_shared_state` have been replaced with the `use_signal` hook. The `use_signal` hook is a more flexible and powerful version of the `use_ref` hook with smarter scopes that only subscribe to a signal if that signal is read within the scope. You can read more about the `use_signal` hook in the [State Migration](state.md) guide.

### Async Hooks

The `use_future` hook has been replaced with the `use_resource` hook. `use_resource` automatically subscribes to any signals that are read within the closure instead of using a tuple of dependencies.

Dioxus 0.4:

````rust
fn MyComponent(cx: Scope) -> Element {
	let state = use_state(cx, || 0);
	let my_resource = use_future(cx, (**state,), |(state,)| async move {
		// start a request that depends on the state
		println!("{state}");
	});
	render! {
		"{state}"
	}
}
````

Dioxus 0.5:

````rs@migration_hooks.rs
fn MyComponent() -> Element {
    let state = use_signal(|| 0);
    // No need to manually set the dependencies, the use_resource hook will automatically detect signal dependencies
    let my_resource = use_resource(move || async move {
        // start a request that depends on the state
        // Because we read from the state signal, this future will be re-run whenever the state changes
        println!("{state}");
    });
    rsx! {"{state}"}
}
````

### Dependencies

Some hooks including `use_effect` and `use_resource` now take a single closure with automatic subscriptions instead of a tuple of dependencies. You can read more about the `use_resource` hook in the [Hook Migration](hooks.md) guide.

Dioxus 0.4:

````rust
fn HasDependencies(cx: Scope) -> Element {
	let state = use_state(cx, || 0);
	let my_resource = use_resource(cx, (**state,), |(state,)| async move {
		println!("{state}");
	});
	let state_plus_one = use_memo(cx, (**state,), |(state,)| {
		state() + 1
	});
	render! {
		"{state_plus_one}"
	}
}
````

Dioxus 0.5:

````rs@migration_hooks.rs
fn HasDependencies() -> Element {
    let state = use_signal(|| 0);
    // No need to manually set the dependencies, the use_resource hook will automatically detect signal dependencies
    let my_resource = use_resource(move || async move {
        // Because we read from the state signal, this future will be re-run whenever the state changes
        println!("{state}");
    });
    let state_plus_one = use_memo(move || {
        // Because we read from the state signal, this future will be re-run whenever the state changes
        state() + 1
    });
    rsx! {"{state_plus_one}"}
}
````
# State Migration

The `use_state` and `use_ref` hooks have been replaced with the `use_signal` hook. The `use_signal` hook is a more flexible and powerful version of the `use_ref` hook with smarter scopes that only subscribe to a signal if that signal is read within the scope.

With `use_state`, if you had this code:

````rust
fn Parent(cx: Scope) -> Element {
	let state = use_state(cx, || 0);

	render! {
		Child {
			state: state.clone()
		}
	}
}

#[component]
fn Child(cx: Scope, state: UseState<i32>) -> Element {
	render! {
		"{state}"
	}
}
````

Parent would re-render every time the state changed even though only the child component was using the state. With the new `use_signal` hook, the parent would only re-render if the state was changed within the parent component:

````rs@migration_state.rs
fn Parent() -> Element {
    let state = use_signal(|| 0);

    rsx! { Child { state } }
}

#[component]
fn Child(state: Signal<i32>) -> Element {
    rsx! {"{state}"}
}
````

Only the child component will re-render when the state changes because only the child component is reading the state.

## Context Based State

The `use_shared_state_provider` and `use_shared_state` hooks have been replaced with using the `use_context_provider` and `use_context` hooks with a `Signal`:

````rs@migration_state.rs
fn Parent() -> Element {
    // Create a new signal and provide it to the context API
    let state = use_context_provider(|| Signal::new(0));

    rsx! { Child {} }
}

fn Child() -> Element {
    // Get the state from the context API
    let state = use_context::<Signal<i32>>();

    rsx! {"{state}"}
}
````

Signals are smart enough to handle subscribing to the right scopes without a special shared state hook.

## Opting Out of Subscriptions

Some state hooks including `use_shared_state` and `use_ref` hooks had a function called `write_silent` in `0.4`. This function allowed you to update the state without triggering a re-render any subscribers. This function has been removed in `0.5`.

Instead, you can use the `peek` function to read the current value of a signal without subscribing to it. This inverts the subscription model so that you can opt out of subscribing to a signal instead of opting all subscribers out of updates:

````rs@migration_state.rs
fn Parent() -> Element {
    let state = use_signal(|| 0);

    // Even though we are reading the state, we don't need to subscribe to it
    let read_without_subscribing = state.peek();
    println!("{}", state.peek());

    rsx! { Child { state } }
}

#[component]
fn Child(state: Signal<i32>) -> Element {
    rsx! {
        button { onclick: move |_| {
                state += 1;
            }, "count is {state}" }
    }
}
````

`peek` gives you more fine-grained control over when you want to subscribe to a signal. This can be useful for performance optimizations and for updating state without re-rendering components.

## Global State

In `0.4`, the fermi crate provided a separate global state API called atoms. In `0.5`, the `Signal` type has been extended to provide a global state API. You can use the `Signal::global` function to create a global signal:

````rs@migration_state.rs
static COUNT: GlobalSignal<i32> = Signal::global(|| 0);

fn Parent() -> Element {
    rsx! {
        div { "{COUNT}" }
        button {
            onclick: move |_| {
                *COUNT.write() += 1;
            },
            "Increment"
        }
    }
}
````

You can read more about global signals in the [Fermi migration guide](fermi.md).
# Fermi

In dioxus 0.5, fermi atoms have been replaced with global signals and included in the main dioxus library.

The new global signals can be used directly without hooks and include additional functionality like global memos.

Dioxus 0.4:

````rust
use dioxus::prelude::*;
use fermi::*;

static NAME: Atom<String> = Atom(|_| "world".to_string());
static NAMES: AtomRef<Vec<String>> = AtomRef(|_| vec!["world".to_string()]);

fn app(cx: Scope) -> Element {
    use_init_atom_root(cx);
    let set_name = use_set(cx, &NAME);
	let names = use_atom_ref(cx, &NAMES);

    cx.render(rsx! {
        button {
			onclick: move |_| set_name("dioxus".to_string()),
			"reset name"
		}
		"{names.read():?}"
    })
}
````

Dioxus 0.5:

````rs@migration_fermi.rs
use dioxus::prelude::*;

static NAME: GlobalSignal<String> = Signal::global(|| "world".to_string());
// Global signals work for copy and clone types in the same way
static NAMES: GlobalSignal<Vec<String>> = Signal::global(|| vec!["world".to_string()]);

fn app() -> Element {
    // No need to use use_init_atom_root, use_set, or use_atom_ref. Just use the global signal directly
    rsx! {
        button { onclick: move |_| *NAME.write() = "reset name".to_string(), "reset name" }
        "{NAMES:?}"
    }
}
````

## Memos

Dioxus 0.5 introduces global memos which can be used to store computed values globally.

````rs@migration_fermi.rs
static COUNT: GlobalSignal<u32> = Signal::global(|| 0);
static MEMO: GlobalMemo<u32> = Signal::global_memo(|| COUNT() + 1);

fn GlobalMemo() -> Element {
    rsx! {
        button { onclick: move |_| *COUNT.write() += 1, "increment" }
        // Global memos can be used like signals
        "{MEMO}"
    }
}
````
# Props Migration

In dioxus 0.4, props are passed into the component through the scope. In dioxus 0.5, props are passed into the component through the props struct directly.

## Owned Props

The props were borrowed with the lifetime from the scope. The props are cloned every render, and passed into the component as an owned value.

Dioxus 0.4:

````rust
#[component]
fn Comp(cx: Scope, name: String) -> Element {
    // You pass in an owned prop, but inside the component, it is borrowed (name is the type &String inside the function)
    let owned_name: String = name.clone();

    cx.render(rsx! {
        "Hello {owned_name}"
    })
}
````

Dioxus 0.5:

````rs@migration_props.rs
// In dioxus 0.5, props are always owned. You pass in owned props and you get owned props in the body of the component
#[component]
fn Comp(name: String) -> Element {
    // Name is owned here already (name is the type String inside the function)
    let owned_name: String = name;

    rsx! {"Hello {owned_name}"}
}
````

Because props are cloned every render, making props Copy is recommended. You can easily make a field Copy by accepting `ReadOnlySignal<T>` instead of `T` in the props struct:

````rs@migration_props.rs
// In dioxus 0.5, props are always owned. You pass in owned props and you get owned props in the body of the component
#[component]
fn CopyPropsComp(name: ReadOnlySignal<String>) -> Element {
    rsx! {
        button {
            // You can easily copy the value of a signal into a closure
            onclick: move |_| {
                println!("Hello {name}");
                async move {
                    println!("Hello {name}");
                }
            },
            "Click me"
        }
    }
}

fn CopyPropsCompParent() -> Element {
    rsx! { CopyPropsComp { name: "World" } }
}
````

## Borrowed Props

Borrowed props are removed in dioxus 0.5. Mapped signals can act similarly to borrowed props if your props are borrowed from state.

Dioxus 0.4:

````rust
fn Parent(cx: Scope) -> Element {
    let state = use_state(cx, || (1, "World".to_string()));
    rsx! {
        BorrowedComp {
            name: &state.get().1
        }
    }
}

#[component]
fn BorrowedComp<'a>(cx: Scope<'a>, name: &'a str) -> Element<'a> {
    rsx! {
        "Hello {name}"
    }
}
````

Dioxus 0.5:

````rs@migration_props.rs
fn Parent() -> Element {
    let state = use_signal(|| (1, "World".to_string()));

    rsx! { BorrowedComp { name: state.map(|s| &s.1) } }
}

#[component]
fn BorrowedComp(name: MappedSignal<String>) -> Element {
    rsx! {"Hello {name}"}
}
````

## Manual Props

Manual prop structs in dioxus 0.5 need to derive `Clone` in addition to `Props` and `PartialEq`:

Dioxus 0.4:

````rust
#[derive(Props, PartialEq)]
struct ManualProps {
    name: String,
}

// Functions accept the props directly instead of the scope
fn ManualPropsComponent(cx: Scope<ManualProps>) -> Element {
    render! {
        "Hello {cx.props.name}"
    }
}
````

Dioxus 0.5:

````rs@migration_props.rs
#[derive(Props, Clone, PartialEq)]
struct ManualProps {
    name: String,
}

// Functions accept the props directly instead of the component
fn ManualPropsComponent(props: ManualProps) -> Element {
    rsx! {"Hello {props.name}"}
}
````
# Beyond

This guide expands upon the basic of dioxus to dive into the internals of the framework. It covers:

* [Contributing to Dioxus](contributing.md)
* [The Project Structure of Dioxus](project_structure.md)

In addition to these chapters, it may also be helpful to read articles in the [Dioxus Blog](https://dioxuslabs.com/blog) that discuss interesting optimziations like [template diffing](https://dioxuslabs.com/blog/templates-diffing) dioxus uses internally
# Contributing

Development happens in the [Dioxus GitHub repository](https://github.com/DioxusLabs/dioxus). If you've found a bug or have an idea for a feature, please submit an issue (but first check if someone hasn't [done it already](https://github.com/DioxusLabs/dioxus/issues)).

[GitHub discussions](https://github.com/DioxusLabs/dioxus/discussions) can be used as a place to ask for help or talk about features. You can also join [our Discord channel](https://discord.gg/XgGxMSkvUM) where some development discussion happens.

## Improving Docs

If you'd like to improve the docs, PRs are welcome! The Rust docs ([source](https://github.com/DioxusLabs/dioxus/tree/main/packages)) and this guide ([source](https://github.com/DioxusLabs/docsite/tree/main/docs-src/0.7)) can be found in their respective GitHub repos.

## Working on the Ecosystem

Part of what makes React great is the rich ecosystem. We'd like the same for Dioxus! So if you have a library in mind that you'd like to write and many people would benefit from, it will be appreciated. You can [browse npm.js](https://www.npmjs.com/search?q=keywords:react-component) for inspiration. Once you are done, add your library to the [awesome dioxus](https://github.com/DioxusLabs/awesome-dioxus) list or share it in the `#I-made-a-thing` channel on [Discord](https://discord.gg/XgGxMSkvUM).

## Bugs & Features

If you've fixed [an open issue](https://github.com/DioxusLabs/dioxus/issues), feel free to submit a PR! Consider [reaching out](https://discord.gg/XgGxMSkvUM) to the team first to make sure everyone's on the same page, and you don't do useless work!

All pull requests (including those made by a team member) must be approved by at least one other team member.
Larger, more nuanced decisions about design, architecture, breaking changes, trade-offs, etc. are made by team consensus.

## Before you contribute

You might be surprised that a lot of checks fail when making your first PR.
That's why you should first run these commands before contributing to save time, because the
GitHub CI is much slower at executing all of these than your PC.

* Format code with [rustfmt](https://github.com/rust-lang/rustfmt):

````sh
cargo fmt -- packages/**/**.rs
````

* You might need to install some packages on Linux (Ubuntu/deb) before the following commands will complete successfully (there is also a Nix flake in the repo root):

````sh
sudo apt install libgdk3.0-cil libatk1.0-dev libcairo2-dev libpango1.0-dev libgdk-pixbuf2.0-dev libsoup-3.0-dev libjavascriptcoregtk-4.1-dev libwebkit2gtk-4.1-dev
````

* Check all code [cargo check](https://doc.rust-lang.org/cargo/commands/cargo-check.html):

````sh
cargo check --workspace --examples --tests
````

* Check if [Clippy](https://doc.rust-lang.org/clippy/) generates any warnings. Please fix these!

````sh
cargo clippy --workspace --examples --tests -- -D warnings
````

* Test all code with [cargo-test](https://doc.rust-lang.org/cargo/commands/cargo-test.html):

````sh
cargo test --all --tests
````

* Test with Playwright. This tests the UI itself, right in a browser. Here are all steps, including installation:
  **Disclaimer: This might inexplicably fail on your machine without it being your fault.** Make that PR anyway!

````sh
cd packages/playwright-tests
npm ci
npm install -D @playwright/test
npx playwright test
````

## How to test dioxus with local crate

If you are developing a feature, you should test it in your local setup before raising a PR. This process makes sure you are aware of your code functionality before being reviewed by peers.

* Fork the following github repo (DioxusLabs/dioxus):

`https://github.com/DioxusLabs/dioxus`

* Create a new or use an existing rust crate (ignore this step if you will use an existing rust crate):
  This is where we will be testing the features of the forked

````sh
cargo new --bin demo
````

* Add the dioxus dependency to your rust crate (new/existing) in Cargo.toml:

````toml
dioxus = { path = "<path to forked dioxus project>/dioxus/packages/dioxus", features = ["web", "router"] }
````

This above example is for dioxus-web, with dioxus-router. To know about the dependencies for different renderer visit [here](../getting_started/index.md).

* Run and test your feature

````sh
dx serve
````

If this is your first time with dioxus, please read [the tutorial](../tutorial/index.md) to get familiar with dioxus.
# Project Structure

There are many packages in the Dioxus organization. This document will help you understand the purpose of each package and how they fit together:

![Dioxus Dependency Graph](/assets/static/workspace-graph.png)

## Entry Points

* [dioxus](https://github.com/DioxusLabs/dioxus/tree/main/packages/dioxus): The main crate for Dioxus applications. The dioxus crate has different feature flags to enable a specific [renderer](#renderers) with the launch API and expose different features like the router and [fullstack](#fullstack). The [CLI](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli) uses the renderer feature flag that is enabled to determine what rust target to compile for.

## Renderers

Renderers are the entry point for Dioxus applications. They handle rendering the application, polling async tasks, and handling events. Each renderer depends on `dioxus-core` for the core virtual dom and implements both the history trait from `dioxus-history` and the event conversion trait from `dioxus-html`. Dioxus has four renderers in the main repository:

* [web](https://github.com/DioxusLabs/dioxus/tree/main/packages/web): Renders Dioxus applications in the browser by compiling to WASM and manipulating the DOM. The web renderer has a hydration feature to take over rendering from the server if [fullstack](#fullstack) is enabled
* [desktop](https://github.com/DioxusLabs/dioxus/tree/main/packages/desktop): A renderer that runs on desktop and mobile platforms. The Dioxus application code is compiled natively, and the UI is rendered using a system webview.
* [mobile](https://github.com/DioxusLabs/dioxus/tree/main/packages/mobile): A Render that Runs Dioxus applications natively, but renders them with the system webview. This is currently a thin wrapper on top of the desktop renderer since both renderers use the webview
* [native](https://github.com/DioxusLabs/dioxus/tree/main/packages/native): An (experimental) renderer that runs on desktop and mobile platforms. The Dioxus application is compiled natively and the UI is rendered using a custom WGPU HTML/CSS renderer ([blitz](https://github.com/DioxusLabs/blitz))
* [liveview](https://github.com/DioxusLabs/dioxus/tree/main/packages/liveview): A renderer that runs on the server, and renders using a websocket proxy in the browser. The liveview renderer is currently supported, but development has been deprioritized in favor of fullstack and it may be removed in the future

 > 
 > The [TUI](https://github.com/DioxusLabs/blitz/tree/legacy/packages/dioxus-tui) renderer has been deprecated but may be revisited in the future once  Blitz is more stable

## Native Rendering

In addition to the renderers listed above, Dioxus also has an experimental native renderer called Blitz that uses WebGPU to render HTML+CSS for dioxus applications:

* [taffy](https://github.com/DioxusLabs/taffy): Standalone CSS layout engine which powers Blitz (also used by Zed and Bevy UI)
* [blitz](https://github.com/DioxusLabs/blitz): An experimental custom WGPU-based HTML/CSS renderer which is the basis of Dioxus Native
* [native-dom](https://github.com/DioxusLabs/dioxus/tree/main/packages/native-dom): The core integration of `blitz` with `dioxus-core`. Useful for embedding Dioxus Native into an another application (e.g. a Bevy game) which already has it's own windowing and input handling.

## Fullstack

Fullstack can be layered on top of any renderer to add support for server functions and server-side rendering.

* [ssr](https://github.com/DioxusLabs/dioxus/tree/main/packages/ssr): dioxus-ssr handles rendering a dioxus virtual dom to a string for testing or on the server. SSR is used in the fullstack renderer to handle server side rendering and static generation.
* [isrg](https://github.com/DioxusLabs/dioxus/tree/main/packages/isrg): dioxus-isrg handles incremental static site generation for dioxus fullstack applications. It helps fullstack cache server side rendered routes in memory and on the file system.
* [fullstack](https://github.com/DioxusLabs/dioxus/tree/main/packages/fullstack): dioxus-fullstack package handles the integration between a [axum](https://github.com/tokio-rs/axum) server and a dioxus renderer. If the frontend renderer is targeting the web, the fullstack renderer will prepare html with embedded data so the client can take over rendering after the initial load (hydration)
* [server-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/server-macro): The server-macro crate defines the `server` macro used to define server functions in Dioxus applications. It integrates with the [server_fn](https://crates.io/crates/server_fn) to automatically register the server functions on the server and call them on the client.

## Core utilities

The core utilities contain the implementation of the virtual dom, and other macros used in all dioxus renderers. The core of dioxus doesn't assume it is running in a web context, so these utilities can be used by third party renderers like [Freya](https://github.com/marc2332/freya).

* [core](https://github.com/DioxusLabs/dioxus/tree/main/packages/core): The core virtual dom implementation every Dioxus application uses. The main entry point for core is the `VirtualDom`. The virtual dom diffing methods accept a cross platform `WriteMutations` trait that is called any time the renderer need to change what is rendered. The vdom also has methods for running futures, and inserting events. You can read more about the architecture of the core [in this blog post](https://dioxuslabs.com/blog/templates-diffing/)
* [core-types](https://github.com/DioxusLabs/dioxus/tree/main/packages/core-types): The core types crate contains some of the core functions used in both in dioxus core and the hot reloading engine.
* [core-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/core-macro): The core macro crate implement the `derive(Props)` and `#[component]` macros to derive builds for components. It also re-exports the rsx macro
* [rsx](https://github.com/DioxusLabs/dioxus/tree/main/packages/rsx): Implements parsing and expansion for the RSX macro. The parser is also used for hot reloading, and autoformatting in the CLI

## Web utilities

Every first party dioxus renderer targets html and css. With the exception of the blitz, all renderers run inside the browser context. Dioxus has a few utilities in the workspace with shared traits and javascript bindings to help interact with the browser:

* [interpreter](https://github.com/DioxusLabs/dioxus/tree/main/packages/interpreter): The interpreter implements the `WriteMutations` trait from dioxus core to modify the DOM with the diffs the virtual dom generates. The interpreter is used by the desktop, web and liveview renderers. It uses a combination of [`wasm-bindgen`](https://rustwasm.github.io/wasm-bindgen) and [`sledgehammer-bindgen`](https://github.com/ealmloff/sledgehammer_bindgen) to interact with the browser
* [html](https://github.com/DioxusLabs/dioxus/tree/main/packages/html): defines html specific elements, events, and attributes. The elements and attributes are used in the rsx macro and hot reloading engine to map the rust identifiers to the html names. The events defined in the html crate are traits defined for each platform.
* [html-internal-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/html-internal-macro): The html-internal-macro crate is used by the html crate to define the html elements and attributes.
* [lazy-js-bundle](https://github.com/DioxusLabs/dioxus/tree/main/packages/lazy-js-bundle): A library to bundle typescript files at build time with bun only if the contents change. Only compiling the typescript when the files change and committing the build output lets us not require a ts compiler to be installed when dioxus is added as a library.
* [history](https://github.com/DioxusLabs/dioxus/tree/main/packages/history): The dioxus-history crate defines the history trait backing each renderer must provide for use with the router. For web renderers, this should call the javascript history api. Native renderers maintain their own history stack in memory.
* [document](https://github.com/DioxusLabs/dioxus/tree/main/packages/document): The dioxus-document crate defines the document trait backing each renderer must provide for use with `eval` and the `document::*` components. `eval` runs javascript code from rust, and the `document::*` components create html elements in the head.

## State Management

* [generational-box](https://github.com/DioxusLabs/dioxus/tree/main/packages/generational-box): Generational Box is the core of all `Copy` state management in Dioxus. It allocates an arena of dynamically borrow checked values used throughout the dioxus ecosystem. The `GenerationalBox` type backs `Signal`, `Memo`, and `Resource` in dioxus signals. It is also used in `dioxus-core` to make the `Closure` and `EventHandler` types `Copy`.
* [signals](https://github.com/DioxusLabs/dioxus/tree/main/packages/signals): Signals are the main user facing state management crate for Dioxus. Signals track when they are read and written to and automatically re-run any `ReactiveContext`s that depends on the signal.
* [hooks](https://github.com/DioxusLabs/dioxus/tree/main/packages/hooks): Hooks are a collection of common hooks for Dioxus applications. Most hooks are a thin wrapper over the new methods in the `signals` crate to only create the object once when the component is created.

## Logging

* [logger](https://github.com/DioxusLabs/dioxus/tree/main/packages/logger): The logger crate provides a simple logging interface for Dioxus applications that works across native and wasm targets. It is automatically called in the launch function if the logging feature is enabled.

## Routing

* [router](https://github.com/DioxusLabs/dioxus/tree/main/packages/router): The router crate handles routing in Dioxus applications. It uses the history provider the renderer provides to get and modify the url. The route parsing logic is derived with the `derive(Routable)` macro defined in the dioxus-router-macro crate.
* [router-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/router-macro): The router-macro crate defines the `derive(Routable)` macro used to the route enum from a url and display it as a url.

## Assets

* [manganis](https://github.com/DioxusLabs/dioxus/tree/main/packages/manganis/manganis): Manganis is dioxus' asset system. It uses a macro to inject assets from rust code into the linker. Every asset gets a unique hash for cache busting. The CLI pulls the asset out of the linker and bundled them into the final application.
* [manganis-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/manganis/manganis-macro): Manganis-macro defines the `asset!()` macro used to include assets in Dioxus applications.
* [manganis-core](https://github.com/DioxusLabs/dioxus/tree/main/packages/manganis/manganis-core): Manganis-core contains the builders for all options passed into the `asset!()` macro and the link sections the asset macro and CLI use to bundle assets.
* [const-serialize](https://github.com/DioxusLabs/dioxus/tree/main/packages/const-serialize): Const Serialize defines a trait to serialize rust types to a cross platform format at compile time. This is used to serialize the options for assets at compile time in manganis.
* [const-serialize-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/const-serialize-macro): Const Serialize Macro defines a derive macro for types that can be serialized at compile time with the `const-serialize` crate.
* [cli-opt](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli-opt): The cli-opt optimizes the assets that manganis produces.

## Formatting

* [autofmt](https://github.com/DioxusLabs/dioxus/tree/main/packages/autofmt): The autofmt crate finds and formats all rsx macros in a rust project. It uses the `dioxus-rsx` crate to parse rsx.

## Linting

* [check](https://github.com/DioxusLabs/dioxus/tree/main/packages/check): The dioxus-check crate analyzes dioxus code to check for common errors like calling hooks in conditionals or loops.

## Translation

* [rsx-rosetta](https://github.com/DioxusLabs/dioxus/tree/main/packages/rsx-rosetta): The rsx-rosetta crate translates html to rsx. It uses the element definitions from `dioxus-html` to translate html elements and attributes to their rust names and the `rsx` crate to generate the rsx macro.

## Hot Reloading

* [rsx-hotreload](https://github.com/DioxusLabs/dioxus/tree/main/packages/rsx-hotreload): The rsx-hotreload crate handles diffing rsx macros between builds and creating the hot reload templates for the CLI.
* [devtools](https://github.com/DioxusLabs/dioxus/tree/main/packages/devtools): The devtools crate contains the frontend for hot reloading each renderer needs to integrate with. It receives hot reload messages from a websocket connection with the CLI
* [devtools-types](https://github.com/DioxusLabs/dioxus/tree/main/packages/devtools-types): The devtools-types crate contains the types used to communicate between the devtools frontend and the backend in the CLI.

## CLI

* [cli](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli): The cli crate contains the dioxus CLI. It integrates check, autofmt, cli-opt, and rsx-hotreload to build and serve Dioxus applications.
* [cli-config](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli-config): The cli-config crate has shared types that are provided at runtime from the CLI to crates the CLI are built with. It is used by `dioxus-desktop` to set the title from the `Dioxus.toml` file and by `dioxus-fullstack` to set the port the CLI proxies the server from.
* [dx-wire-format](https://github.com/DioxusLabs/dioxus/tree/main/packages/dx-wire-format): The dx-wire-format crate has the unstable types the CLI emits in json mode. This is used by the dioxus playground.

## Extension

* [extension](https://github.com/DioxusLabs/dioxus/tree/main/packages/extension): The extension folder contains the source code for the dioxus VSCode extension. It uses many of the same crates as the CLI, but packaged into a wasm+JS bundle for VSCode.

## Testing

* [playwright-tests](https://github.com/DioxusLabs/dioxus/tree/main/packages/playwright-tests): The playwright-tests folder contains end to end tests for dioxus-web, dioxus-liveview and fullstack. These crates are not published on crates.io
# Introduction

Welcome to the Dioxus documentation! Dioxus is a framework for building cross-platform apps with the Rust programming language. With one codebase, you can build apps that run on web, desktop, and mobile.

Dioxus is designed to be familiar for developers who already know tools like React and Flutter.

````rs@readme.rs
use dioxus::prelude::*;

pub fn App() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    }
}

````

````inject-dioxus
DemoFrame {
    readme::App {}
}
````

This guide is split into different sections:

* [Tutorial](guide/index.md) walks you through your first Dioxus app.
* [Core Concepts](essentials/index.md) provides detail on topics like managing state.
* [Guides](reference/index.md) provides references for things like assets, routing, testing, and more.

First, try walking through the [Tutorial](guide/index.md) to get familiar with Dioxus. Before embarking on a larger project, we strongly recommend reading the entire [Essential Concepts](essentials/index.md) and glancing through the [Guides Overview](guides/index.md).

 > 
 > This guide assumes you already know some [Rust](https://www.rust-lang.org/)! If not, we recommend reading [*the book*](https://doc.rust-lang.org/book/ch01-00-getting-started.html) to learn Rust first.

## What is Dioxus?

Dioxus is a developer-friendly framework that empowers developers to ship cross-platform apps with one codebase.

![Multi-platform app architecture diagram](/assets/static/dioxus-architecture-diagram.png)

In many ways, Dioxus is similar to Flutter: we integrate our own build tools, foster an ecosystem, and provide a markup language for declaring UI. In key areas, Dioxus takes a different approach:

* Apps are declared with HTML and CSS instead of custom styling solution
* Reactivity is inspired by web frameworks like React and SolidJS
* Dioxus code runs natively with no virtual machine and enables direct FFI with system APIs

Our goal is to provide a "better Flutter": faster, slimmer, and web-native. You can think of Dioxus as a hybrid of [Flutter](http://flutter.dev) and [NextJS](http://nextjs.org): cross-platform apps with stellar fullstack support. Today, Dioxus apps can only be written in Rust, but we plan to support more languages in the future.

## Why Dioxus?

We started Dioxus because we believe the current standard of building apps is too complex. Developers need to learn and install dozens of different tools just to get their app into the world.

![App stack](/assets/static/dioxus-app-stack.png)

Our vision for Dioxus is a framework that is fast, flexible, and has a minimal learning curve. We want developers to confidently ship their app from idea to production as fast as possible. We believe that fewer tools and a simpler architecture makes it easier to develop apps. Apps that are easier to build also ship faster and are more likely to succeed.

## Syntax and Ecosystem

The Dioxus syntax is similar to React's JSX markup, borrowing React's component and hooks approach. All components are Rust functions that take `Properties`, define state with hooks, and return an `Element`. We only support markup within the `rsx! {}` macro; this ensures your app is automatically optimized and has stellar devtools support like advanced hot-reloading.

````rust
#[component]
fn Component(name: String) -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        h1 { "Hello, {name}" }
        p { "Count: {count}" }
    }
}
````

Dioxus is designed to be easy to extend and fairly thin over system APIs. This means you can easily drop into system APIs when first-party APIs are lacking. When targeting the web, this might mean using [`web-sys`](http://crates.io/crates/web-sys/) and on Android using [`jni`](http://crates.io/crates/jni).

````rust
fn PromptModal() {
    #[cfg(web)]
    web_sys::call_web_function();

    #[cfg(android)]
    jni_sys::call_android_function();
}
````

The core Dioxus framework covers a number of utilities that are either challenging to design or integrate the `dx` tooling:

* [App Routing](router/index.md)
* [Backend integration via server functions](guides/fullstack/server_functions.md)
* [Including and optimizing](guides/assets.md) assets
* [State management](essentials/state/index.md) (signals-based reactivity)
* [SDK](http://github.com/dioxusLabs/sdk): 1st-party System integrations

## Stability

Dioxus has not reached a "1.0" release yet.

We are currently on version 0.6, which has stabilized a huge number of APIs and drastically improved the developer experience. In version 0.5 we overhauled the state management system and in 0.6 we overhauled tooling.

It's likely that the next few versions of Dioxus (0.7, 0.8) will bring breaking changes to your apps. Fortunately, these planned changes will only affect the syntax of specific APIs and not your apps at large. With every version update, we ship a rather comprehensive migration guide - eg [0.6](migration/index.md).

## Examples, projects, tutorials, and more

The Dioxus ecosystem is growing and so are the number of examples, projects, tutorials, books, and other learning resources.

We highly recommend a few first-party sources:

* The [official folder of small examples](https://github.com/DioxusLabs/dioxus/tree/main/examples)
* The [official repository of example projects](https://github.com/DioxusLabs/dioxus/tree/main/example-projects)
* The official [YouTube channel](https://www.youtube.com/@DioxusLabs)

## Who's funding Dioxus?

Dioxus is funded by a mix of corporate sponsorships, enterprise support contracts, [crowd-sourced funding](https://github.com/sponsors/DioxusLabs#sponsors), and [venture capital](http://ycombinator.com/companies/dioxus-labs). We strive to maintain a healthy mix of funding to balance the various competing visions of the future. We want to provide "Flutter but better" for everyone - not controlled by Apple, Meta, or Google - and we need to make sure Dioxus has a sustainable long-term financial future.

Ultimately, we'd like Dioxus to be self-sustaining. This means that you'll eventually have the option to deploy your production apps with [Dioxus Deploy](https://dioxuslabs.com/deploy). Revenue from *Dioxus Deploy* will in turn fund development on Dioxus itself.

We're committed to keeping Dioxus free and open source forever. You'll never need to pay us to build apps nor will we ever change the license of Dioxus.
# Getting Started

Getting started with Dioxus is quick and shouldn't take more than a minute or two.

## Pick an Editor

Pick your favorite editor!

We recommend using [VSCode](https://code.visualstudio.com) since Dioxus ships with its [own VSCode extension](https://marketplace.visualstudio.com/items?itemName=DioxusLabs.dioxus).

Our build tool `dx` is standalone and works with any editor.

## Install Rust-Analyzer

Dioxus integrates very well with the [Rust-Analyzer LSP plugin](https://rust-analyzer.github.io) which provides appropriate syntax highlighting, code navigation, folding, and more.

You can follow the [installation instructions](https://rust-analyzer.github.io/manual.html#installation) for your editor of choice.

* [VSCode](https://rust-analyzer.github.io/manual.html#vs-code)
* [Zed](https://rust-analyzer.github.io/manual.html#zed)
* [Emacs](https://rust-analyzer.github.io/manual.html#emacs)
* [Vim](https://rust-analyzer.github.io/manual.html#vimneovim)

## Install Rust

Head over to [https://rust-lang.org](http://rust-lang.org) and install the Rust compiler (preferably using `rustup`).

Once installed, make sure you add the `stable` toolchain and the `wasm32-unknown-unknown` target for web development:

````shell
rustup toolchain install stable
rustup target add wasm32-unknown-unknown
````

We strongly recommend going through the [official Rust book](https://doc.rust-lang.org/book/ch01-00-getting-started.html) *completely*. However, we hope that a Dioxus app can serve as a great first Rust project.

We've put a lot of care into making Dioxus syntax familiar and easy to understand, so you won't need deep knowledge of async, lifetimes, or smart pointers until you start building complex Dioxus apps.

## Install cargo-binstall

Dioxus ships prebuilt binaries for its CLI using [`cargo-binstall`](https://github.com/cargo-bins/cargo-binstall?tab=readme-ov-file#installation). This means you can install `dx` without needing to compile from source.

You can install `cargo-binstall` with the following command:

````shell
curl -L --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash
````

or alternatively:

````shell
# through brew
brew install cargo-binstall

# or from source
cargo install cargo-binstall
````

## Install the Dioxus CLI

Dioxus is comprised of two parts:

* The `dioxus` crate: the core Dioxus framework
* The `dx` tool: a CLI tool for building Dioxus apps

If you want to build web or mobile apps with Dioxus, or benefit from features like hot-reloading and bundling, you'll need to install the `dx` tool. You can download the prebuilt binary with the following command:

````
cargo binstall dioxus-cli
````

If you want to build the CLI from source, you can install it with the following command:

````rust
cargo install dioxus-cli
````

 > 
 > ðŸ“£ Installing from source will take several minutes. We strongly recommend using `cargo-binstall` for installation.

If you get an OpenSSL error on installation, ensure the dependencies listed [here](https://docs.rs/openssl/latest/openssl/#automatic) are installed.

## Platform-specific dependencies

Most platforms don't require any additional dependencies, but if you are targeting desktop, you can install the following dependencies.

### macOS

There are no extra dependencies for macOS! However, if you want to build iOS apps, read the [iOS section](#ios) below.

### Windows

Windows apps depend on WebView2 â€“ a library that should be installed in all modern Windows distributions.

If you have Edge installed, then Dioxus will work fine. If you *don't* have WebView2, then you can [install it through Microsoft](https://developer.microsoft.com/en-us/microsoft-edge/webview2/). Microsoft provides 3 options:

1. A tiny "evergreen" *bootstrapper* that fetches an installer from Microsoft's CDN.
1. A tiny *installer* that fetches WebView2 from Microsoft's CDN.
1. A statically linked version of WebView2 in your final binary for offline users.

We recommend using Option 1.

### Linux

WebView Linux apps require WebkitGtk and xdotool. When distributing, these should be part of your dependency tree in your `.rpm` or `.deb`.

If you run into issues, make sure you have all the basics installed.

For Ubuntu, make sure everything is installed:

````shell
sudo apt update
sudo apt install libwebkit2gtk-4.1-dev \
  build-essential \
  curl \
  wget \
  file \
  libxdo-dev \
  libssl-dev \
  libayatana-appindicator3-dev \
  librsvg2-dev
````

For arch:

````shell
sudo pacman -Syu
sudo pacman -S --needed \
  webkit2gtk-4.1 \
  base-devel \
  curl \
  wget \
  file \
  openssl \
  appmenu-gtk-module \
  libappindicator-gtk3 \
  librsvg \
  xdotool
````

For all other Linux targets, [check the Tauri docs which cover the same dependencies](https://tauri.app/start/prerequisites/#linux).

In addition to the Tauri docs, for Fedora:

````shell
sudo dnf install libxdo-devel
````

### WSL

While doable, it can be tricky to setup development in WSL for Dioxus desktop. Not everything has been figured out and some stuff may not work.

Here are the steps we used to get Dioxus running through WSL:

1. Update your kernel to the latest version and update WSL to version 2.
1. Add `export DISPLAY=:0` to `~/.zshrc`
1. Install Tauri's Linux dependencies found [here](https://beta.tauri.app/start/prerequisites/).
1. For file dialogs to work, you need to install a fallback like `zenity`

When running Dioxus desktop on WSL, you may get warnings from `libEGL`. There is currently no way to silence these, but the app should still render.

### iOS

Building iOS apps requires a device running macOS with XCode installed.

Download and install XCode from one of the following places:

* [Mac App Store](https://apps.apple.com/gb/app/xcode/id497799835?mt=12)
* [Apple Developer website](https://developer.apple.com/xcode/resources/)

You will need to download the iOS SDK and install some simulators.

For more details, we recommend reading the [dedicated guide for iOS development](../guides/mobile/index.md).

### Android

Android apps require the Android SDK and NDK to be installed. This can be a substantial amount of setup, so we recommend reading the [dedicated guide for Android development](../guides/mobile/index.md).
# Dioxus Tutorial

In this tutorial, we'll be building a small app called: *HotDog* - basically Tinder, but for dogs! This app will serve as a great way to learn about building UIs, adding state, and deploying.

By the end of this tutorial, you will launch your very own web, desktop, and mobile apps and a backend deployed to [Fly.io](http://fly.io).

![Photo of HotDog](/assets/06_docs/dog_app_styled.png)

We will primarily focus on the higher-level concepts of Dioxus without diving deep into the details of specific APIs. We recommend experimenting with the APIs yourself or reading the [Core Concepts](../essentials/index.md) and specific [Guides](../guides/index.md) for more information.

## What will we be learning?

This guide will cover the "core" Dioxus features including:

* [Tooling Setup](tooling.md)
* [Creating a new app](new_app.md)
* [How Components Work](component.md)
* [Creating UI with RSX](rsx.md)
* [Styling and Assets](assets.md)
* [Adding State](state.md)
* [Fetching Data](data_fetching.md)
* [Adding a Backend](backend.md)
* [Integrating a Database](databases.md)
* [App Routing](routing.md)
* [Bundling](bundle.md)
* [Deployment](deploy.md)
* [Next Steps](next_steps.md)

Dioxus is a very full-featured framework, so we encourage you to follow up this tutorial by building your own larger apps.

## What are we building?

The features of *HotDog* are fairly simple:

* Engage with a stream of cute dog photos
* Swipe right if we want to save the dog photo to our collection
* Swipe left if we don't want to save the dog photo
* View the dog photos we saved later

At the end of the tutorial, you'll have your very own *HotDog* app to remix and download to your device.
# Setting up Tooling

Before we get started, make sure you've followed the [Getting Started](../getting_started/index.md) page on installing the required dependencies.

We will be primarily developing *HotDog* as web application, but we still recommend setting up the relevant tooling for desktop and mobile development as well.

## Checklist

We covered the setup instructions in [Getting Started](../getting_started/index.md), but first you should verify everything is set up properly:

* Rust is installed
* You have a code editor installed
* The wasm32-unknown-unknown Rust target is installed
* The `dioxus-cli` is installed and up-to-date
* System-specific dependencies are installed

## Verify your setup

Before proceeding, make sure you have the `dioxus-cli` installed and up-to-date.

Verify the returned version matches this guide (eg 0.6) by running:

````sh
dx --version
````

## All the Commands

You can also run `dx help` which will give you a list of useful commands and some information on how to use `dx`.

````sh
Build, Bundle & Ship Dioxus Apps

Usage: dx [OPTIONS] <COMMAND>

Commands:
  build      Build the Dioxus project and all of its assets
  translate  Translate a source file into Dioxus code
  serve      Build, watch & serve the Dioxus project and all of its assets
  new        Create a new project for Dioxus
  init       Init a new project for Dioxus in the current directory (by default). Will attempt to keep your project in a good state
  clean      Clean output artifacts
  bundle     Bundle the Dioxus app into a shippable object
  fmt        Automatically format RSX
  check      Check the project for any issues
  run        Run the project without any hotreloading
  config     Dioxus config file controls
  help       Print this message or the help of the given subcommand(s)

Options:
      --verbose      Use verbose output [default: false]
      --trace        Use trace output [default: false]
      --json-output  Output logs in JSON format
  -h, --help         Print help
  -V, --version      Print version
````

If `dx` is installed properly, then you're ready to proceed!
## Create a new project

Let's get to work!

You can create a new Dioxus project by running the following command and following the prompts:

````sh
dx new hot_dog
````

![dxnew](/assets/06_docs/dx_new_06.mp4)

You'll need to select a template to use to get started.

* Bare-bones: a very simple setup with just a `main.rs` and an `assets` folder.
* Jumpstart: a scaffolded app with components, views, and suggested structure.
* Workspace: a full cargo workspace setup with different crates per platform.

We're going to use the bare-bones template for *HotDog*. Our app won't be too complex and can fit in one file.

* Select "false" when asked if you want to create a fullstack website.
* Select "false" for the router, though we *will* eventually add the router to the app.
* Select "false" for TailwindCSS. If you want to use Tailwind, make sure to read the [TailwindCSS guide](../cookbook/tailwind.md).
* Select "Web" as the default platform.

 > 
 > ðŸ“£ You don't need `dx new` to create new Dioxus apps! Dioxus apps are Rust projects and can also be built with tools like cargo.

## Running the project

Once the project is generated, you can start it with the following command:

````sh
cd hot_dog
dx serve
````

![Serve](/assets/06_docs/dx_serve_06.mp4)

This will start the cargo build and launch a web server to serve your app. If you visit the "serve" address (in this case, `http://127.0.0.1:8080`), then you'll receive a loading screen in your browser:

![loading](/assets/06_docs/hotdog_loading.png)

Once the app is loaded, you should be greeted with the default Dioxus template app:

![app](/assets/06_docs/default_dioxus_app.png)

Congrats! You have your very first Dioxus app.

## Structure of the app

Open the app in your editor and take a look at its structure:

````sh
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Dioxus.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ assets
â”‚Â Â  â”œâ”€â”€ favicon.ico
â”‚Â Â  â”œâ”€â”€ header.svg
â”‚Â Â  â””â”€â”€ main.css
â””â”€â”€ src
    â””â”€â”€ main.rs
````

All Rust apps are comprised of a root `Cargo.toml` with a `main.rs` file located in the `src` folder. Our CLI `dx` pre-filled these files with the `dioxus` dependency and some starter code for us to get building quickly.

Assets in Dioxus can be placed anywhere in the project, but we suggest leaving them in the `assets` folder.

## The Cargo.toml

The `Cargo.toml` outlines the dependencies to our app and specifies compiler settings. All Rust apps are *compiled*: we execute the Rust tool `cargo` which aggregates our `.rs` files together and generates a final binary executable (like a `.exe`) that runs our app.

All Dioxus apps will include `dioxus` as a dependency:

````toml
[dependencies]
dioxus = { version = "0.6.0" }
````

The prebuilt Dioxus templates initialize different cargo features for your app. `dx` will use these to decide which cargo features to enable when you specify the `--platform` feature. For example, if you use `dx serve --platform desktop` to build your app for desktop, `dx` will call `cargo build --no-default-features --features desktop`.

````toml
[features]
default = ["web"]
web = ["dioxus/web"]
desktop = ["dioxus/desktop"]
mobile = ["dioxus/mobile"]
````

Starting with Dioxus 0.6, `dx` will also initialize separate [Cargo profiles](https://doc.rust-lang.org/cargo/reference/profiles.html) for your app. These profiles let you customize the optimization level of each platform. `dx` also uses these platforms as a mechanism of isolating builds from each other.

## Dioxus.toml

The `Dioxus.toml` file contains Dioxus-specific configuration for stages like bundling and deploying. Before Dioxus 0.5, we used the `Dioxus.toml` to specify asset inclusion and hot-reload watch paths, but as of Dioxus 0.6, these fields are deprecated and replaced by standards like `asset!()` and `.gitignore`.

We won't need to configure the `Dioxus.toml` for our app just yet.

## Assets Folder

To include assets in your Dioxus app, you'll want to use the `asset!()` macro that we'll cover later in the [Styling and Assets](assets.md) chapter. You can include assets from anywhere within your app's file tree, but we recommend using the pregenerated `assets` folder.

## main.rs

Finally, the `main.rs`. The `main.rs` file is the entrypoint of our app, containing the `fn main` function. All Rust executables start their life at `main`.

The `main` of our HotDog app looks like this:

````rs@guide_new_app.rs
use dioxus::prelude::*;

fn main() {
    dioxus::launch(App);
}
````

The `launch` function calls the platform-specific `launch` function depending on which feature (web/desktop/mobile) is enabled on `dioxus`. `launch` accepts a root component, typically called `App`.

We'll cover components more in-depth in the [next chapter](component.md).

## Resetting to Basics

The bare-bones template provides basic starter code for our app. However, we want to start *truly* from scratch, so we'll wipe away the `Hero` component and empty the `App` component to its basics:

````rs@guide_new_app.rs
use dioxus::prelude::*;

fn main() {
    dioxus::launch(App);
}

#[component]
fn App() -> Element {
    rsx! { "HotDog!" }
}
````
# Your First Component

Now that we've initialized our *HotDog* app, we can start building out its components.

## What is a component?

In Dioxus, apps are comprised of individual functions called *Components* that take in some *Properties* and render an *Element*:

````rs@guide_component.rs
fn DogApp(props: DogAppProps) -> Element {
    todo!()
}
````

## Component Properties

All components take an object that outlines which parameters the component can accept. All `Props` structs in Dioxus need to derive the `Properties` trait which requires both `Clone` and `PartialEq`:

````rs@guide_component.rs
#[derive(Props, PartialEq, Clone)]
struct DogAppProps {
    breed: String,
}
````

Dioxus provides the `#[component]` macro for simplifying how components are defined. This macro converts the parameters of the annotated function into a hidden accompanying struct.

````rs@guide_component.rs
#[component]
fn DogApp(breed: String) -> Element {
    todo!()
}
````

When building apps, you'll frequently use the `#[component]` macro. When building libraries, we generally suggest deriving Props instead.

## Properties are Immutable

If you're familiar with JavaScript, then you might also be familiar with libraries like [React](http://react.dev). Dioxus is *very* similar to React: if you know React then you will feel comfortable with Dioxus.

Just like React, Dioxus components are rendered by calling the function component. On every render, Dioxus makes a `.clone()` of the component's props. This ensures you can't accidentally modify your props which can lead to hard-to-track issues with state management.

````rs@guide_component.rs
#[component]
fn DogApp(breed: String) -> Element {
    tracing::info!("Rendered with breed: {breed}");

    todo!()
}
````

Dioxus provides types that make `.clone()` cheaper to call, so don't worry about performance gotchas here.

## Component Functions are Called Multiple Times

Just like React, Dioxus will call your component function multiple times throughout its lifecycle. This is called *re-rendering*. In Dioxus, re-renders are extremely cheap (much cheaper than React!). In most cases you shouldn't worry about re-rendering too frequently.

When Dioxus re-renders your component, it compares the `Element` returned from the *last* render against the `Element` returned in the *current* render.

For example, when the `breed` property changes on the DogApp component, Dioxus will call the DogApp function a second time and compare the previous Element against the new Element.

````rs@guide_component.rs
#[component]
fn DogApp(breed: String) -> Element {
    rsx! {
        "Breed: {breed}"
    }
}
````

![Diffing](/assets/06_docs/diffing_diagram.png)

Dioxus will re-render your component in only two circumstances:

* When the `Props` change as determined by `PartialEq`
* When a function like `signal.set()` or `signal.write()` calls `Scope.needs_update()`

Unlike React, all Dioxus components are *memoized by default* meaning Dioxus will always compare `Props` before deciding to re-render your component. As an additional optimization, Dioxus only compares dynamic parts of your RSX. Elements that don't contain dynamic data won't be checked for changes.

## Composing Components

In Dioxus, *Components* are composed together to create *Apps*. Each component will hold onto its own state and handle its own updates. This makes it easy to abstract your app into different parts and even share pieces of your app as libraries for others to use.

To compose components together, we'll use the `rsx! {}` macro to define the structure of our app.

````rs@guide_component.rs
#[component]
fn App() -> Element {
    rsx! {
        Header {}
        DogApp { breed: "corgi" }
        Footer {}
    }
}
````

We'll cover `rsx! {}` in more depth in the [next chapter](rsx.md).
# Describing the UI

Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* what we want the UI to look like using RSX.

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App() -> Element {
    rsx! {
        div { "Hello, world!" }
    }
}
````

Here, we use the `rsx!` macro to *declare* that we want a `div` element, containing the text `"Hello, world!"`. Dioxus takes the RSX and constructs a user interface from it.

## Editing RSX with Hot-Reloading

When using `dx serve`, your app's RSX is automatically hot-reloaded whenever you edit and save the file. You can edit RSX structure, add new elements, and style your markup without a full rebuild.

Whenever you edit *Rust* code, then `dx` will automatically force a "full rebuild" of your app.

![Dog App Hotreloading](/assets/06_docs/dog_app_hotreload.mp4)

For an in-depth guide on what can and can't be hot-reloaded, check the [hot-reload guide](../reference/hotreload.md) in the reference.

## RSX is just HTML

Dioxus provides the `rsx! {}` macro for assembling `Element`s in your app. The `rsx! {}` macro primarily speaks HTML: the web, desktop, and mobile Dioxus first-party renderers all use HTML and CSS as the layout and styling technologies.

This means you can reuse your knowledge of the web and build your app using `div`, `span`, `img`, `style`, `button`, and more.

The RSX syntax is a "strict" form of Rust that uses Rust's `Struct` syntax for assembling elements:

````rs@guide_rsx.rs
rsx! {
    div {
        class: "bg-red-100"
    }
}
````

Elements in RSX differ slightly from Rust struct syntax: they can also contain child structs placed immediately after the final attribute.

````rs@guide_rsx.rs
rsx! {
    div { class: "bg-red-100",
        button {
            onclick: move |_| info!("Clicked"),
            "Click me!"
        }
    }
}
````

Additionally, all quoted strings in RSX imply `format!()` automatically, so you can define a variable outside your markup and use it in your strings without an explicit format call:

````rs@guide_rsx.rs
rsx! {
    div { "Breed: {breed}" }
}
````

Any expression that can be rendered to a String can be included directly in RSX. RSX also accepts `Option<Element>` and iterators of Elements:

````rs@guide_rsx.rs
rsx! {
    // Anything that's `Display`
    {"Something"}

    // Optionals
    {show_title.then(|| rsx! { "title!" } )}

    // And iterators
    ul {
        {(0..5).map(|i| rsx! { "{i}" })}
    }
}
````

Dioxus provides two items of syntax sugar for these common cases: `for` loops and `if` chains. These blocks return the contained RSX directly.

````rs@guide_rsx.rs
rsx! {
    if show_title {
        "title!"
    }

    ul {
        for item in 0..5 {
            "{item}"
        }
    }
}
````

For lists, Dioxus uses the `key` attribute to ensure it's comparing the right elements between renders. If you forget to add a `key` attribute to your list item, you might run into performance and state management issues. Usually you can find a unique key to differentiate your list items:

````rs@guide_rsx.rs
rsx! {
    for user in users {
        div {
            key: "{user.id}",
            "{user.name}"
        }
    }
}
````

## Adding UI to our *HotDog* App

Let's add a basic UI to our app. We'll add a header, a body image for the dog photo, and some basic buttons.

````rs@guide_rsx.rs
#[component]
fn App() -> Element {
    rsx! {
        div { id: "title",
            h1 { "HotDog! ðŸŒ­" }
        }
        div { id: "dogview",
            img { src: "https://images.dog.ceo/breeds/pitbull/dog-3981540_1280.jpg" }
        }
        div { id: "buttons",
            button { id: "skip", "skip" }
            button { id: "save", "save!" }
        }
    }
}
````

Our app is coming together!

![Unstyled Dog App](/assets/06_docs/unstyled_dog_app.png)

Unfortunately, it's not very beautiful yet. Let's move on to [styling our app](assets.md).
# Styling and Assets

Unfortunately, our HotDog app isn't quite ready to show off - it's completely unstyled!

In this chapter we'll cover adding assets and styles to our app.

## Dioxus uses CSS for Styling

As mentioned earlier, Dioxus apps use HTML and CSS as the core markup and styling technology. Instead of re-inventing the wheel like Flutter and React-Native, we designed Dioxus to use HTML and CSS on every platform.

CSS is by-far the most popular styling system and is extremely capable. For example, here's a screenshot of [ebou](https://github.com/terhechte/Ebou), a very beautiful Mastodon client built with Dioxus.

![Ebou](/assets/06_docs/ebou-following.png)

HTML and CSS are very powerful - don't worry about being too limited!

## Adding the CSS File with asset!()

The bare-bones template already includes a base `main.css` in the `assets` folder.

````sh
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ assets
â”‚Â Â  â””â”€â”€ main.css
â””â”€â”€ src
    â””â”€â”€ main.rs
````

To include the CSS in our app, we can use the `asset!()` macro. This macro ensures the asset will be included in the final app bundle.

````rs@guide_assets.rs
static CSS: Asset = asset!("/assets/main.css");
````

We also need to load the asset into our app using the `document::Stylesheet` component. This component is equivalent to the `<link>` HTML element but also ensures the CSS will be pre-loaded during server-side-rendering.

````rs@guide_assets.rs
fn App() -> Element {
    rsx! {
        document::Stylesheet { href: CSS }
    }
}
````

Unlike Rust's `include_str!()` macro, the `asset!()` macro does not actually include the *contents* of the asset in our final executable. Instead, it generates a unique path so that the asset can be loaded at runtime. This is ideal for web apps where assets are loaded in parallel through different HTTP requests.

 > 
 > ðŸ“£ The `asset!()` macro generates a unique name that won't exactly match the input name. This helps prevents name collisions and improves caching.

## Hot-Reloading

All assets in Dioxus participate in hot-reloading. Try editing your app's `main.css` and watch changes propagate in real time.

![CSS Hot-reloading](/assets/06_docs/dog-asset-hotreload.mp4)

## Including Images

In Dioxus, you can include images in two ways:

* Dynamically with a URL
* Statically with the `asset!()` macro.

When including assets with a URL, simply fill the `src` attribute of `img {}`. Note that when the app is offline, URL-based images won't download.

````rs@guide_assets.rs
rsx! {
    // ...
    div {
        img { src: "https://images.dog.ceo/breeds/pitbull/dog-3981540_1280.jpg" }
    }
}
````

For static images, you can use the same `asset!()` macro that we used to include the app's CSS.

````rs@guide_assets.rs
static ICON: Asset = asset!("/assets/icon.png");

rsx! {
    img { src: ICON }
}
````

## Optimizations

By default, the `asset!()` macro will lightly optimize CSS, JavaScript, JSON, and images. The name of the asset will also be modified to include a content hash.

````rs@guide_assets.rs
// would output main-j1238nask123.css
asset!("/assets/main.css").to_string();
````

You can optimize assets even further, with an optional `Options` struct. For example, `dx` can automatically convert `.png` images to a more optimized `.avif` format:

````rs@guide_assets.rs
// outputs icon-j1238jd2.avif
asset!("/assets/icon.png", ImageAssetOptions::new().with_avif());
````

For many apps, asset optimization is the most effective way of improving load times. As developers, we frequently overlook the size of images and accidentally make our sites load slower.

Check out the [assets guide](../guides/assets.md) for a more in-depth explanation of how the Dioxus asset system works.

## The Final CSS

We can use the asset hot-reload system of `dx` and our knowledge of CSS to create a beautiful app:

![Styled Dog App](/assets/06_docs/dog_app_styled.png)

The final CSS is here for reference:

````css
/* App-wide styling */
html, body {
    background-color: #0e0e0e;
    color: white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    height: 100%;
    width: 100%;
    overflow: hidden;
    margin: 0;
}

#main {
    display: flex;
    flex-direction: column;
    height: 100%;
    justify-content: space-between;
}

#dogview {
    max-height: 80vh;
    flex-grow: 1;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

#dogview img {
    display: block;
    max-width: 50%;
    max-height: 50%;
    transform: scale(1.8);
    border-radius: 5px;
    border: 1px solid rgb(233, 233, 233);
    box-shadow: 0px 0px 5px 1px rgb(216, 216, 216, 0.5);
}

#title {
    text-align: center;
    padding-top: 10px;
    border-bottom: 1px solid #a8a8a8;
    display: flex;
    flex-direction: row;
    justify-content: space-evenly;
    align-items: center;
}

#title a {
    text-decoration: none;
    color: white;
}

a#heart {
    background-color: white;
    color: red;
    padding: 5px;
    border-radius: 5px;
}

#title span {
    width: 20px;
}

#title h1 {
    margin: 0.25em;
    font-style: italic;
}

#buttons {
    display: flex;
    flex-direction: row;
    justify-content: center;
    gap: 20px;
    /* padding-top: 20px; */
    padding-bottom: 20px;
}

#skip { background-color: gray }
#save { background-color: green; }

#skip, #save {
    padding: 5px 30px 5px 30px;
    border-radius: 3px;
    font-size: 2rem;
    font-weight: bold;
    color: rgb(230, 230, 230)
}

#navbar {
    border: 1px solid rgb(233, 233, 233);
    border-width: 1px 0px 0px 0px;
    display: flex;
    flex-direction: row;
    justify-content: space-evenly;
    padding: 20px;
    gap: 20px;
}

#navbar a {
    background-color: #a8a8a8;
    border-radius: 5px;
    border: 1px solid black;
    text-decoration: none;
    color: black;
    padding: 10px 30px 10px 30px;
}

#favorites {
    flex-grow: 1;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    padding: 10px;
}

#favorites-container {
    overflow-y: auto;
    overflow-x: hidden;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    padding: 10px;
}

.favorite-dog {
    max-height: 180px;
    max-width: 60%;
    position: relative;
}

.favorite-dog img {
    max-height: 150px;
    border-radius: 5px;
    margin: 5px;
}

.favorite-dog:hover button {
    display: block;
}

.favorite-dog button {
    display: none;
    position: absolute;
    bottom: 10px;
    left: 10px;
    z-index: 10;
}
````
# Interactivity

Now that our *HotDog* app is scaffolded and styled, we can finally add some interactive elements.

## Encapsulating State

Before we get too far, let's split our app into two parts: the `Title` and the `DogView`. This will help us organize our app and keep the `DogView` state separated from `Title` state.

````rs@guide_state.rs
#[component]
fn App() -> Element {
    rsx! {
        document::Stylesheet { href: CSS }
        Title {}
        DogView {}
    }
}

#[component]
fn Title() -> Element {
    rsx! {
        div { id: "title",
            h1 { "HotDog! ðŸŒ­" }
        }
    }
}

#[component]
fn DogView() -> Element {
    rsx! {
        div { id: "dogview",
            img { src: "https://images.dog.ceo/breeds/pitbull/dog-3981540_1280.jpg" }
        }
        div { id: "buttons",
            button { id: "skip", "skip" }
            button { id: "save", "save!" }
        }
    }
}
````

## Event Handlers

In the `DogView` component, we want to attach an action to the click of the buttons. For example: skipping or saving the current dog photo. We can use an [EventHandler](../reference/event_handlers.md) to listen for the `click` events.

Event handlers are similar to regular attributes, but their name usually starts with `on` - and they accept closures as values. The closure will be called whenever its corresponding event is triggered. The listener receives information about the event in the [Event](https://docs.rs/dioxus/latest/dioxus/prelude/struct.Event.html) object.

We'll add some closures inline and then pass them to the `onclick` attribute for both the *skip* and *save* buttons:

````rs@guide_state.rs
#[component]
fn DogView() -> Element {
    let skip = move |evt| {};
    let save = move |evt| {};

    rsx! {
        // ...
        div { id: "buttons",
            button { onclick: skip, id: "skip",  "skip" }
            button { onclick: save, id: "save",  "save!" }
        }
    }
}
````

 > 
 > You can read more about Event Handlers in the [Event Handler reference](../reference/event_handlers.md)

## State with use_hook

So far, our components have no internal state. For our `DogView`, we want to change the currently displayed dog photo whenever the user clicks *skip* or *save*.

To store state in components, Dioxus provides the `use_hook` function. This makes it possible for bare Rust functions to store and load state without the use of an extra struct.

When called in a component, the `use_hook` function will return a `.clone()` of the originally stored value:

````rs@guide_state.rs
#[component]
fn DogView() -> Element {
    let img_src = use_hook(|| "https://images.dog.ceo/breeds/pitbull/dog-3981540_1280.jpg");

    // ..

    rsx! {
        div { id: "dogview",
            img { src: "{img_src}" }
        }
        // ..
    }
}
````

Dioxus hooks are very similar to React's hooks and need to follow some [simple rules](../guides/rules_of_hooks.md#the-rules-of-hooks) to function properly.

## Signals and use_signal

While `use_hook` makes it possible to store any value that implements `Clone`, you'll frequently want a more capable form of state management. Built-in to Dioxus are *signals*.

`Signal` is a wrapper type around an ordinary Rust value that tracks reads and writes, bringing your app to life. You can wrap any Rust value in a signal. Signals can be created manually with `Signal::new()` but we strongly recommend using the `use_signal` hook instead.

 > 
 > ðŸ“£ Manually creating Signals requires remembering to call `.manually_drop()` on the signal whereas `use_signal` cleans the Signal up for you automatically.

Whenever a signal's value changes, its containing "reactive scope" will be "marked dirty" and re-run. By default, Dioxus components are reactive scopes, and thus, will re-render whenever a signal value changes.

![Basic Interactivity](/assets/06_docs/hotdog-interactivity.mp4)

Signals are core to Dioxus and take time to master. We recommend reading the [state management](../essentials/state/index.md) guide in depth before diving into your first large app.

## Global State with Context

While hooks are good for state *local* to components, occasionally you'll want to manage state for your *entire* app.

Dioxus provides two mechanisms: `Context` and `GlobalSignal`.

The `Context` API makes it possible for parent components to share state with child components without explicitly declaring an additional property field. This is used by larger apps and libraries to share state across the app without modifying component signatures.

To "provide" context, simply call `use_context_provider()` with a struct that implements `Clone`. To read the context in a child, call `use_context()`.

````rs@guide_state.rs
// Create a new wrapper type
#[derive(Clone)]
struct TitleState(String);

fn App() -> Element {
    // Provide that type as a Context
    use_context_provider(|| TitleState("HotDog".to_string()));
    rsx! {
        Title {}
    }
}

fn Title() -> Element {
    // Consume that type as a Context
    let title = use_context::<TitleState>();
    rsx! {
        h1 { "{title.0}" }
    }
}
````

You can combine `use_signal` and `Context` to provide reactive state to your app:

````rs@guide_state.rs
#[derive(Clone, Copy)]
struct MusicPlayer {
    song: Signal<String>,
}

fn use_music_player_provider() {
    let song = use_signal(|| "Drift Away".to_string());
    use_context_provider(|| MusicPlayer { song });
}
````

With `use_context` and `consume_context`, you can easily reach up to modify that state:

````rs@guide_state.rs
#[component]
fn Player() -> Element {
    rsx! {
        button {
            onclick: move |_| consume_context::<MusicPlayer>().song.set("Vienna".to_string()),
            "Shuffle"
        }
    }
}
````

Any components that read the song signal will automatically re-render when the value changes.

## Global Signals

Occasionally you'll want a simple global value. This is where `GlobalSignal` helps. GlobalSignals are a combination of the Context system and Signals that require no additional structs or setup.

Simply declare a GlobalSignal somewhere in your app:

````rs@guide_state.rs
static SONG: GlobalSignal<String> = Signal::global(|| "Drift Away".to_string());
````

And then read and write to it from anywhere:

````rs@guide_state.rs
#[component]
fn Player() -> Element {
    rsx! {
        h3 { "Now playing {SONG}" }
        button {
            onclick: move |_| *SONG.write() = "Vienna".to_string(),
            "Shuffle"
        }
    }
}
````

 > 
 > ðŸ“£ GlobalSignals are only global to one app - not the entire program. On the server, every app gets its own GlobalSignal.

We won't need either GlobalSignal or Context for *HotDog*, but it's important to know that these are available to you.
# Fetching Data

Our *HotDog* app has some basic interactivity but does not yet fetch new dog images. In this chapter, we'll interact with async and fetching data from an API.

## Adding Dependencies

Dioxus does not provide any built-in utilities for fetching data. Crates like [dioxus-query](https://github.com/marc2332/dioxus-query) exist, but for this tutorial we'll implement data-fetching from scratch.

First, we need to add two new dependencies to our app: [serde](https://crates.io/crates/serde) and [reqwest](https://crates.io/crates/reqwest).

* Reqwest provides an HTTP client for fetching.
* Serde will let us derive a JSON Deserializer to decode the response.

In a new terminal window, add these crates to your app with `cargo add`.

````bash
cargo add reqwest --features json
cargo add serde --features derive
````

## Defining a Response Type

We'll be using the amazing [dog.ceo/dog-api](https://dog.ceo/dog-api/) to fetch images of dogs for *HotDog*. Fortunately, the API response is quite simple to deserialize.

Let's create a new Rust struct that matches the format of the API and derive `Deserialize` for it.

The Dog API docs outline a sample API response:

````json
{
    "message": "https://images.dog.ceo/breeds/leonberg/n02111129_974.jpg",
    "status": "success"
}
````

Our Rust struct needs to match that format, though for now we'll only include the "message" field.

````rs@guide_data_fetching.rs
#[derive(serde::Deserialize)]
struct DogApi {
    message: String,
}
````

## Using `reqwest` and `async`

Dioxus has stellar support for asynchronous Rust. We can simply convert our `onclick` handler to be `async` and then set the `img_src` after the future has resolved.

![Dog Fetching](/assets/06_docs/fetch-dog.mp4)

The changes to our code are quite simple - just add the `reqwest::get` call and then call `.set()` on `img_src` with the result.

````rs@guide_data_fetching.rs
#[component]
fn DogView() -> Element {
    let mut img_src = use_signal(|| "".to_string());

    let fetch_new = move |_| async move {
        let response = reqwest::get("https://dog.ceo/api/breeds/image/random")
            .await
            .unwrap()
            .json::<DogApi>()
            .await
            .unwrap();

        img_src.set(response.message);
    };

    // ..

    rsx! {
        div { id: "dogview",
            img { src: "{img_src}" }
        }
        div { id: "buttons",
            // ..
            button { onclick: fetch_new, id: "save", "save!" }
        }
    }
}
````

Dioxus automatically calls `spawn` on asynchronous closures. You can also use `spawn` to perform async work *without* async closures - just call `spawn()` on any async block.

````rs@guide_data_fetching.rs
rsx! {
    button {
        onclick: move |_| {
            spawn(async move {
                // do some async work...
            });
        }
    }
}
````

The futures passed to `spawn` must not contain latent references to data outside the async block. Data that is `Copy` *can* be captured by async blocks, but all other data must be *moved*, usually by calling `.clone()`.

## Managing Data Fetching with use_resource

Eventually, using bare `async` calls might lead to race conditions and weird state bugs. For example, if the user clicks the *fetch* button too quickly, then two requests will be made in parallel. If the request is updating data somewhere else, the wrong request might finish early and causes a race condition.

In Dioxus, *Resources* are pieces of state whose value is dependent on the completion of some asynchronous work. The `use_resource` hook provides a `Resource` object with helpful methods to start, stop, pause, and modify the asynchronous state.

Let's change our component to use a resource instead:

````rs@guide_data_fetching.rs
#[component]
fn DogView() -> Element {
    let mut img_src = use_resource(|| async move {
        reqwest::get("https://dog.ceo/api/breeds/image/random")
            .await
            .unwrap()
            .json::<DogApi>()
            .await
            .unwrap()
            .message
    });

    rsx! {
        div { id: "dogview",
            img { src: img_src.cloned().unwrap_or_default() }
        }
        div { id: "buttons",
            button { onclick: move |_| img_src.restart(), id: "skip", "skip" }
            button { onclick: move |_| img_src.restart(), id: "save", "save!" }
        }
    }
}
````

Resources are very powerful: they integrate with Suspense, Streaming HTML, reactivity, and more.

The details of the `Resource` API are not terribly important right now, but you'll be using Resources frequently in larger apps, so it's a good idea to [read the docs](../reference/use_resource.md).
# Adding a Backend

Dioxus is a *fullstack* framework, meaning it allows you to seamlessly build your frontend alongside your backend.

We provide a number of utilities like *Server Functions*, *Server Futures*, and *Server State* for you to integrate into your apps. In this chapter, we'll cover loading and saving state to our backend with *Server Functions*. For an in-depth guide on fullstack, check out the dedicated [Fullstack Guide](../guides/fullstack/index.md).

## Enabling Fullstack

Before we can start using server functions, we need to enable the "fullstack" feature on Dioxus in our Cargo.toml.

````toml
[dependencies]
dioxus = { version = "0.6.0", features = ["fullstack"] }
````

We also need to add the "server" feature to our app's features in the Cargo.toml and remove the default web target.

````toml
[features]
default = [] # <----- remove the default web target
web = ["dioxus/web"]
desktop = ["dioxus/desktop"]
mobile = ["dioxus/mobile"]
server = ["dioxus/server"] # <----- add this additional target
````

If you selected *yes* to the "use fullstack?" prompt when creating your app, you will already have this set up!

 > 
 > ðŸ“£ Unfortunately, `dx` doesn't know how to hot-reload this change, so we'll need to kill our currently running `dx serve` process and launch it again.

Now instead of running `dx serve`, you need to run with a manual platform with `dx serve --platform web`. Give your app a moment to build again and make sure that the "fullstack" feature is enabled in the dashboard.

![Fullstack Enabled](/assets/06_docs/serve_with_fullstack.png)

## Server Functions: an inline RPC system

Dioxus integrates with the [server_fn](https://crates.io/crates/server_fn) crate to provide a simple inline communication system for your apps. The server_fn crate makes it easy to build your app's backend with just basic Rust functions. Server Functions are `async` functions annotated with the `#[server]` attribute.

A typical server function looks like this:

````rs@guide_backend.rs
#[server]
async fn save_dog(image: String) -> Result<(), ServerFnError> {
    Ok(())
}
````

Every server function is an async function that takes some parameters and returns a `Result<(), ServerFnError>`. Whenever the client calls the server function, it sends an HTTP request to a corresponding endpoint on the server. The parameters of the server function are serialized as the body of the HTTP request. As a result, each argument must be serializable.

On the client, the server function expands to a `reqwest` call:

````rs@guide_backend.rs
// on the client:
async fn save_dog(image: String) -> Result<(), ServerFnError> {
    reqwest::Client::new()
        .post("http://localhost:8080/api/save_dog")
        .json(&image)
        .send()
        .await?;
    Ok(())
}
````

On the server, the server function expands to an [axum](https://github.com/tokio-rs/axum) handler:

````rs@guide_backend.rs
// on the server:
struct SaveDogArgs {
    image: String,
}

async fn save_dog(Json(args): Json<SaveDogArgs>) -> Result<(), ServerFnError> {
    Ok(())
}
````

When `dioxus::launch` is called, the server functions are automatically registered for you and set up as an Axum router.

````rs@guide_backend.rs
async fn launch(config: ServeConfig, app: fn() -> Element) {
    // register server functions
    let router = axum::Router::new().serve_dioxus_application(config, app);

    // start server
    let socket_addr = dioxus::cli_config::fullstack_address_or_localhost();
    let listener = tokio::net::TcpListener::bind(socket_addr).await.unwrap();
    axum::serve(listener, router).await.unwrap();
}
````

As of Dioxus 0.6, we only support the `axum` server framework. We plan to build additional server features in the future and only support `axum` to ship faster.

In some cases, the `dioxus::launch` function might be too limiting for your use-case on the server. You can easily drop down to axum by changing your main.rs. The `dioxus::launch` function also handles setting up logging and reading environment variables, which you will have to handle yourself.

````rs@guide_backend.rs
fn main() {
    #[cfg(feature = "server")]
    tokio::runtime::Runtime::new()
        .unwrap()
        .block_on(launch_server());
    #[cfg(not(feature = "server"))]
    dioxus::launch(App);
}

#[cfg(feature = "server")]
async fn launch_server() {
    // Connect to dioxus' logging infrastructure
    dioxus::logger::initialize_default();

    // Connect to the IP and PORT env vars passed by the Dioxus CLI (or your dockerfile)
    let socket_addr = dioxus::cli_config::fullstack_address_or_localhost();

    // Build a custom axum router
    let router = axum::Router::new()
        .serve_dioxus_application(ServeConfigBuilder::new(), App)
        .into_make_service();

    // And launch it!
    let listener = tokio::net::TcpListener::bind(socket_addr).await.unwrap();
    axum::serve(listener, router).await.unwrap();
}
````

## The Client/Server split

When Dioxus builds your fullstack apps, it actually creates two separate applications: the server and the client. To achieve this, `dx` passes different features to each build.

* The client is built with `--feature web`
* The server is built with `--feature server`

![Server Client Split](/assets/06_docs/server_split.png)

When embedding server code in our apps, we need to be careful about which code gets compiled. The body of the server function is designed to only be *executed on the server* - not the client. Any code configured by the `"server"` feature will not be present in the final app. Conversely, any code not configured by the `"server"` feature *will* make it into the final app.

````rs@guide_backend.rs
// âŒ this will leak your DB_PASSWORD to your client app!
static DB_PASSWORD: &str = "1234";

#[server]
async fn DoThing() -> Result<(), ServerFnError> {
    connect_to_db(DB_PASSWORD).await
    // ...
}
````

Instead, we recommend placing server-only code within modules configured for the `"server"` feature.

````rs@guide_backend.rs
// âœ… code in this module can only be accessed on the server
#[cfg(feature = "server")]
mod server_utils {
    pub static DB_PASSWORD: &str = "1234";
}
````

In addition to the "server" feature, Dioxus expects a client side rendering feature like "web" or "desktop". Some libraries like web-sys only work when running in the browser, so make sure to not run specific client code in your server functions or before your `launch`. You can place client only code under a config for a client target feature like "web".

````rs@guide_backend.rs
fn main() {
    // âŒ attempting to use web_sys on the server will panic!
    let window = web_sys::window();

    // ..

    dioxus::launch(App);
}
````

## Managing Dependencies

Some dependencies like [Tokio](https://github.com/tokio-rs/tokio) only compile properly when targeting native platforms. Other dependencies like [jni-sys](https://github.com/jni-rs/jni-sys) only work properly when running on a specific platform. In these cases, you'll want to make sure that these dependencies are only compiled when a particular feature is enabled. To do this, we can use Rust's `optional` [flag on dependencies in our Cargo.toml](https://doc.rust-lang.org/cargo/reference/features.html#optional-dependencies).

````toml
[dependencies]
tokio = { version = "1", optional = true }

[features]
default = []
server = ["dep:tokio"]
````

Eventually, if your project becomes large enough, you might want to pull your server functions out into their own crate to be used across different apps. We'd create a `server` crate in our workspace:

````sh
â”œâ”€â”€ Cargo.toml
â””â”€â”€ crates
 Â Â  â”œâ”€â”€ dashboard
 Â Â  â”œâ”€â”€ marketplace
 Â Â  â””â”€â”€ server
````

And then we'd import the server functions in our app, disabling their `"server"` feature.

````toml
[dependencies]
server = { workspace = true, default-features = false }
````

We provide a longer guide about the details of managing dependencies across the server and the client [here](../guides/fullstack/managing_dependencies.md).

## Our HotDog Server Function

Revisiting our HotDog app, let's create a new server function that saves our favorite dog to a file called `dogs.txt`. In production, you'd want to use a proper database as covered in [the next chapter](databases.md), but for now we'll use a simple file to test things out.

````rs@guide_backend.rs
// Expose a `save_dog` endpoint on our server that takes an "image" parameter
#[server]
async fn save_dog(image: String) -> Result<(), ServerFnError> {
    use std::io::Write;

    // Open the `dogs.txt` file in append-only mode, creating it if it doesn't exist;
    let mut file = std::fs::OpenOptions::new()
        .write(true)
        .append(true)
        .create(true)
        .open("dogs.txt")
        .unwrap();

    // And then write a newline to it with the image url
    file.write_fmt(format_args!("{image}\n"));

    Ok(())
}
````

### Calling the server function

Now, in our client code, we can actually call the server function.

````rs@guide_backend.rs
fn DogView() -> Element {
    let mut img_src = use_resource(snipped!());

    // ...
    rsx! {
        // ...
        div { id: "buttons",
            // ...
            button {
                id: "save",
                onclick: move |_| async move {
                    let current = img_src.cloned().unwrap();
                    img_src.restart();
                    _ = save_dog(current).await;
                },

                "save!"
            }
        }
    }
}
}
````

Wow, our app is really coming together!

![Working Server Functions](/assets/06_docs/dog-save-serverfn.mp4)

Server functions are extremely capable and can even be used during server-side-rendering. Check out the complete [fullstack guide](../guides/fullstack/index.md) for more information.
# Working with Databases

Our HotDog app is coming together nicely! We implemented a very simple backend that saves the user's favorite dog images to a local "dogs.txt" file.

In practice, you will likely want to store data in a proper database. Modern databases are *much* more powerful than a text file!

If you already have a good understanding of databases, jump ahead to the [section where we integrate Sqlite with HotDog](#adding-database-operations-to-hotdog);

## Choosing a Database

In today's age of app development, there are *many* databases to choose from, each with their own strengths, weaknesses, and tradeoffs to consider. For apps with just a few users, it is fine to select a "simpler" database that's easier to manage. For apps with many users, you might want to consider more advanced databases with additional tooling to meet stricter requirements.

Here is a (incomplete!) list of databases and a short summary of each:

* [PostgreSQL](https://www.postgresql.org): Advanced database known for its powerful plugin system.
* [MySQL](https://www.mysql.com): World's most popular open source database good for all apps.
* [SQLite](https://www.sqlite.org): Simple file-based engine known for its reliability and embeddability.
* [Oracle](https://www.oracle.com/database/): Advanced commercial database known for its enterprise features.
* [Redis](http://redis.io): Simple key-value database known for its great performance.
* [MongoDB](https://www.mongodb.com/): A database ideal for data that doesn't fit into rows and columns.
* [SurrealDB](https://surrealdb.com/): A new "all-in-one" database that combines many models.
* [CockroachDB](https://www.cockroachlabs.com): Distributed SQL database designed for high-availability.
* [and many more](https://dev.to/shreyvijayvargiya/list-of-45-databases-in-the-world-57e8)!

There are many different types of databases, each good at different tasks. These might include:

* **Relational**: traditional row/column/table approach.
* **Document**: storing unstructured or loosely structured blobs of data.
* **Timeseries**: storing and querying lots of data that changes over time.
* **Graph**: querying data based on its connections to other data.
* **Key-value**: storing just key-value pairs - a fast concurrent HashMap.
* **In-memory**: designed for low-latency operations usually used as a cache.
* **Embedded**: a database that is shipped *inside* your app.

For most apps - unless you have specific requirements - we recommend a mainstream relational database like PostgreSQL or MySQL.

 > 
 > ðŸ“£ PostgreSQL is currently a very interesting option: it can be extended to support time-series, vector, graph, search and geo-spatial data with plugins.

In some cases, you might want a database that's specific to *just one app instance* or the *user's machine*. In these cases, you'll want to use an embedded database like [SQLite](https://www.sqlite.org) or [RocksDB](https://rocksdb.org).

## Adding Database operations to HotDog

For *HotDog*, we're going to use Sqlite. *HotDog* is a very simple app and will only ever have one user: you!

To add sqlite functionality to *HotDog*, we'll pull in the `rusqlite` crate. Note that `rusqlite` is only meant to be compiled on the server, so we'll feature gate it behind the `"server"` feature in our Cargo.toml.

````toml
[dependencies]
# ....
rusqlite = { version = "0.32.1", optional = true } # <--- add rusqlite

[features]
# ....
server = ["dioxus/server", "dep:rusqlite"] # <---- add dep:rusqlite
````

To connect to our database, we're going to use the `rusqlite::Connection`. Rusqlite connections are not thread-safe and must exist once-per-thread, so we'll need to wrap it in a thread_locals.

When the connection is initialized, we'll run a SQL action to create the "dogs" table with our data.

````rs@guide_databases.rs
// The database is only available to server code
#[cfg(feature = "server")]
thread_local! {
    pub static DB: rusqlite::Connection = {
        // Open the database from the persisted "hotdog.db" file
        let conn = rusqlite::Connection::open("hotdog.db").expect("Failed to open database");

        // Create the "dogs" table if it doesn't already exist
        conn.execute_batch(
            "CREATE TABLE IF NOT EXISTS dogs (
                id INTEGER PRIMARY KEY,
                url TEXT NOT NULL
            );",
        ).unwrap();

        // Return the connection
        conn
    };
}
````

Now, in our `save_dog` server function, we can use SQL to insert the value into the database:

````rs@guide_databases.rs
#[server]
async fn save_dog(image: String) -> Result<(), ServerFnError> {
    DB.with(|f| f.execute("INSERT INTO dogs (url) VALUES (?1)", &[&image]))?;
    Ok(())
}
````

Once the app is launched, you should see a "hotdog.db" file in your crate's directory. Let's save a few dog photos and then open the database in a database viewer. If all goes well, you should see the saved dog photos!

![Databaseview](/assets/06_docs/hotdog-db-view.mp4)

## Notes on Databases and Rust

While there are many database providers, Rust support can be limited. Rust is still a new choice for web development. In this section we'll provide our own (biased!) opinions on what libraries we recommend for interacting with databases.

It's also important to note that several libraries exist at a higher level abstraction than raw SQL. These are called an *Object Relationship Mapper (ORM)*. Rust ORM libraries map the SQL language into ordinary Rust functions. We generally recommend just sticking with SQL, but ORMs can make working writing some queries easier.

* [Sqlx](https://github.com/launchbadge/sqlx): A straightforward yet large interface to Postgres, MySql, and Sqlite.
* [SeaORM](https://github.com/SeaQL/sea-orm): An ORM built on top of Sqlx for deriving databases.
* [rusqlite](https://github.com/rusqlite/rusqlite): An intuitive sqlite interface with no special ORM magic.
* [rust-postgres](https://github.com/sfackler/rust-postgres): An interface to Postgres with an API similar to rusqlite.
* [Turbosql](https://github.com/trevyn/turbosql): A *very* terse interface to Sqlite with automatic derives.

We aren't including libraries like [Diesel](http://diesel.rs) in this list since it seems that the Rust ecosystem has evolved towards newer projects with 1st-class async support.

There are many libraries we haven't tested yet, but might be worth checking out:

* [firebase-rs](https://github.com/emreyalvac/firebase-rs): Firebase client crate
* [postgrest-rs](https://github.com/supabase-community/postgrest-rs): Supabase client crate
* [mongo-rust-driver](https://github.com/mongodb/mongo-rust-driver): Official MongoDB client crate

## Choosing a Database Provider

While there are just a handful of databases you might consider for your app, there are many *database providers*, each with their own strengths and weaknesses. We are not sponsored by any of these providers - this is just a list of providers we have seen in use by Rust apps.

You *do not* need to use a database provider. Databases providers provide paid database hosting. It will cost you money to use these providers! Many have a free tier and some support "scale-to-zero" to help you save money on small apps. At any time, you are free to host and manage your own database.

For popular relational databases:

* [GCP](https://cloud.google.com/products/databases): Provides AlloyDB (enterprise postgres), CloudSQL (MySql, Postgres), and more.
* [AWS](https://aws.amazon.com/products/databases/): Provides RDS, Aurora, DynamoDB, and more.
* [PlanetScale](https://planetscale.com): Reliable MySQL-compatible database with sharding designed for scale.
* [Firebase](https://firebase.google.com): Google's comprehensive real-time database designed for rapid app development.
* [Supabase](https://supabase.com): Hosted Postgres known for its great dashboard and tooling.
* [Neon](https://neon.tech): Hosted Postgres that separates compute and storage for scale-to-zero apps.

For Sqlite:

* [LiteFS](https://fly.io/docs/litefs/): A distributed Sqlite sync engine designed to be used with Fly.io
* [Turso](https://turso.tech): A "multi-tenant" sqlite provider that maintains one isolated database per user

The "scale-to-zero" relational solutions:

* [AWS Aurora](https://aws.amazon.com/rds/aurora/)
* [LiteFS](https://fly.io/docs/litefs/)

We don't suggest any particular database provider.

* If you have lots of free cloud credits, consider AWS/GCP/Azure.
* If you want Postgres with a good dashboard, consider Supabase or Neon.
* If you want a simple experience, consider Turso or LiteFS.
# Adding More Routes

So far, our app has only had a single page. Let's change that!

In this chapter, we'll be adding a Navbar, a welcome screen, and a "favorites" page where we can revisit our favorite dogs.

## Organizing our Project

Before we get too far with adding new pages to our app, let's organize our codebase a bit better. For larger projects you might want to break your app into different smaller crates. For HotDog, we'll keep it simple.

 > 
 > The `dx new` Jumpstart and Workspace templates provide great scaffolding for new apps!

We generally recommend splitting your components, models, and backend functionality into different files. For HotDog, we're going to use a simple directory structure:

````sh
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ assets
â”‚   â””â”€â”€ main.css
â””â”€â”€ src
    â”œâ”€â”€ backend.rs
    â”œâ”€â”€ components
    â”‚   â”œâ”€â”€ favorites.rs
    â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”œâ”€â”€ nav.rs
    â”‚   â””â”€â”€ view.rs
    â””â”€â”€ main.rs
````

We'll have a `backend.rs` that contains our server functions and a `components` folder that contains our components. We don't have a `NavBar` or a `Favorites` component yet, but we'll still create the relevant files before adding them. By splitting out our server functions into a `backend.rs` file, we'll make it easier to extract our backend functionality as a shared library for different apps in the future.

Our `components/mod.rs` file will simply import and re-export the components in `view.rs`, `nav.rs`, and `favorites.rs`:

````rust
mod favorites;
mod nav;
mod view;

pub use favorites::*;
pub use nav::*;
pub use view::*;
````

Finally, we need to bring `backend` and `components` into scope in our `main.rs` file:

````rust
mod components;
mod backend;

use crate::components::*;
````

For more information on organizing Rust projects with modules, see the [Modules section](https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html) of the Rust Book.

## Creating a Route

Most Dioxus apps you'll build will have different screens. This could include pages like *Login*, *Settings*, and *Profile*. Our HotDog app will have two screens: a *DogView* page and a *Favorites* page.

Dioxus provides a first-party router that natively integrates with web, desktop, and mobile. For example, on web, whenever you visit the `/favorites` url in your browser, the corresponding *Favorites* page will load. The Dioxus router is very powerful, and most importantly, type-safe. You can rest easy knowing that users will never be sent to an invalid route. To achieve this, we first need to add the "Router" feature to the Cargo.toml file:

````toml
[dependencies]
dioxus = { version = "0.6.0", features = ["fullstack", "router"] } # <----- add "router"
````

Next, the Dioxus router is defined as an enum with the `Routable` derive attribute:

````rs@guide_router.rs
#[derive(Routable, Clone, PartialEq)]
enum Route {
    #[route("/")]
    DogView,
}
````

With the Dioxus router, every route is an enum variant with a `#[route]` attribute that specifics the route's URL. Whenever the router renders our route, the component of the same name will be rendered.

````rs@guide_router.rs
use dioxus::prelude::*;

#[derive(Routable, Clone, PartialEq)]
enum Route {
    #[route("/")]
    DogView, // <---- a DogView component must be in scope
}

fn DogView() -> Element {
    todo!()
}
````

## Rendering the Route

Now that we have our app's `Route` defined, we need to render it. Let's change our `app` component to render the `Route {}` component instead of the `DogView`.

````rs@guide_router.rs
fn app() -> Element {
    rsx! {
        document::Stylesheet { href: asset!("/assets/main.css") }

        // ðŸ“£ delete Title and DogView and replace it with the Router component.
        Router::<Route> {}
    }
}
````

When the `Router {}` component renders, it will parse the document's current URL into a `Route` variant. If the url doesn't parse properly, the router will render nothing unless you add a "catch-all" route:

````rs@guide_router.rs
#[derive(Routable, Clone, PartialEq)]
enum Route {
    // ...
    // We can collect the segments of the URL into a Vec<String>
    #[route("/:..segments")]
    PageNotFound { segments: Vec<String> },
}
````

Note here that the `PageNotFound` route takes the "segments" parameter. Dioxus routes are not only type-safe as variants, but also type-safe with URL parameters. For more information on how this works, [check the router guide](../router/index.md).

At this point, we should see our app, but this time without its Title.

![No Navbar](/assets/06_docs/no_navbar.png)

## Rendering the NavBar with a Layout

We're rendering our DogView component, but unfortunately we no longer see our Title. Let's add that back and turn it into a NavBar!

In our `src/components/nav.rs` file, we'll add back our Title code, but rename it to NavBar and modify it with two new items: the `Link {}` and `Outlet` components.

````rust@guide_router.rs
use crate::Route;
use dioxus::prelude::*;

#[component]
pub fn NavBar() -> Element {
    rsx! {
        div { id: "title",
            Link { to: Route::DogView,
                h1 { "ðŸŒ­ HotDog! " }
            }
        }
        Outlet::<Route> {}
    }
}
````

The `Link {}` component wraps the anchor `<a>` element with a type-safe interface. This means any struct that implements `Routable` - anything that can `.to_string()` - is a valid navigation target.

````rs@guide_router.rs
// Using the Link with Route
Link { to: Route::DogView }

// Or passing in a "/" route directly
Link { to: "/" }
````

The Link component takes many different arguments, making it possible to extend and customize for your use-case.

In `NavBar`, we also added an `Outlet::<Route> {}` component. When the Router component renders, it first looks for any child `Outlet` components. If one is present, it renders the current route *under the outlet*. This lets us wrap the current page in extra elements - in this case, the NavBar. If no Outlet is present, then the current route is simply rendered where the `Router {}` is declared.

To actually add the NavBar component to our app, we need to update our `Route` enum with the `#[layout]` attribute. This forces the router to render the `NavBar` component *first* so it can expose its `Outlet {}`.

````rs@guide_router.rs
#[derive(Routable, PartialEq, Clone)]
enum Route {
    #[layout(NavBar)] // <---- add the #[layout] attribute
    #[route("/")]
    DogView,
}
````

The `layout` attribute instructs the Router to wrap the following enum variants in the given component.

````rust, ignore
Router  {
    NavBar {
        Outlet {
            if route == â€œ/â€ {
                DogView {}
            }
        }
    }
}
````

Visually, this should be straight-forward to understand. Note that the Router and Outlet share the same `Route` generic type.

![RouterLayout](/assets/06_docs/routeroutlet.png)

## Adding a Favorites Route

Now that we understand the fundamentals of routing, let's finally add our *Favorites* page so we can view the dog photos we saved.

We'll start by creating an empty component `src/components/favorites.rs`:

````rs@guide_router.rs
use dioxus::prelude::*;

#[component]
pub fn Favorites() -> Element {
    rsx! { "favorites!" }
}
````

And then let's make sure to add a new variant in our `Route` enum:

````rs@guide_router.rs
#[derive(Routable, PartialEq, Clone)]
enum Route {
    #[layout(NavBar)]
    #[route("/")]
    DogView,

    #[route("/favorites")]
    Favorites, // <------ add this new variant
}
````

To make sure the user can reach this page, let's also add a button in the nav that points to it.

````rust@guide_router.rs
use crate::Route;
use dioxus::prelude::*;

#[component]
pub fn NavBar() -> Element {
    rsx! {
        div { id: "title",
            Link { to: Route::DogView,
                h1 { "ðŸŒ­ HotDog! " }
            }
            Link { to: Route::Favorites, id: "heart", "â™¥ï¸" } // <------- add this Link
        }
        Outlet::<Route> {}
    }
}
````

## Our Favorites Page

Finally, we can build our favorites page. Let's add a new `list_dogs` server function that fetches the 10 most recently saved dog photos:

````rs@guide_router.rs
// Query the database and return the last 10 dogs and their url
#[server]
pub async fn list_dogs() -> Result<Vec<(usize, String)>, ServerFnError> {
    let dogs = DB.with(|f| {
        f.prepare("SELECT id, url FROM dogs ORDER BY id DESC LIMIT 10")
            .unwrap()
            .query_map([], |row| Ok((row.get(0)?, row.get(1)?)))
            .unwrap()
            .map(|r| r.unwrap())
            .collect()
    });

    Ok(dogs)
}
````

Now, we can fill in our component. We're going to use the same `use_resource` hook from earlier. Resolving the request from the server might take some time, so we'll use the `.suspend()?` method on `Resource` to wait for the request to finish before mapping the contents to a list.

````rs@guide_router.rs
use dioxus::prelude::*;

#[component]
pub fn Favorites() -> Element {
    // Create a pending resource that resolves to the list of dogs from the backend
    // Wait for the favorites list to resolve with `.suspend()`
    let mut favorites = use_resource(super::backend::list_dogs).suspend()?;

    rsx! {
        div { id: "favorites",
            div { id: "favorites-container",
                for (id, url) in favorites().unwrap() {
                    // Render a div for each photo using the dog's ID as the list key
                    div {
                        key: id,
                        class: "favorite-dog",
                        img { src: "{url}" }
                    }
                }
            }
        }
    }
}
````

As a stretch goal, try adding a button that lets the user also delete items from the database.

![FullDemo](/assets/06_docs/hotdogfull.mp4)
# Bundling

Congratulations! You built your first fully-functional Dioxus app, completely loaded with Routing, asynchronous data-fetching, Server Functions, and a database! That's incredible for just a few minutes of work.

Let's get your app bundled for multiple platforms and then ready to deploy.

## Testing on Desktop and Mobile

So far, we've been testing our app in a simple web browser. Let's actually build and test our app for mobile platforms.

In Dioxus 0.6, `dx` finally supports `dx serve` for Android and iOS!

### Testing on iOS

To test iOS, your development environment needs to be setup to build iOS apps. This involves a few steps:

* Make sure you are developing on a device running macOS
* Install XCode
* [Download a recent iOS SDK and Emulator pack](https://developer.apple.com/ios/)
* Install the iOS Rust toolchains (`aarch64-apple-ios aarch64-apple-ios-sim`)

This is a multi-step process and requires creating an Apple Developer account. You shouldn't need to pay any fees until you want to sign your app. Signing your app is required for deploying to the Apple App Store and testing on your iOS device.

If everything is installed properly, you should be able to open the Simulator app:

````sh
open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app
````

If the Simulator app opens but no device pops up, you might need to open a specific device. Use `xcrun` to discover which devices you have installed.

````sh
xcrun simctl list
````

Identify an available device. We're going to simulate an iPhone 15 Pro Max:

````sh
xcrun simctl boot "iPhone 15 Pro Max"
````

Once the simulator is booted, we can run `dx serve --platform ios`.

![DogApp](/assets/06_docs/dog-app-ios.mp4)

Fantastic - our app works seamlessly with no changes.

### Testing on Android

Setting up your environment for Android development takes time, so make sure to read the [mobile tooling guide](../guides/mobile/index.md).

* Install the Android NDK and SDK
* Set JAVA_HOME, ANDROID_HOME, NDK_HOME, and fix PATH issues to use the `emulator` tool
* Install and set up an Android emulator
* Install the Android rustup targets (`aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android`)

Let's start an emulator. We can use the `emulator` command which should be in your PATH if setup properly. We're going to use our `Pixel_6_API_34` emulator, but you can use any device you've configured.

````sh
emulator -avd Pixel_6_API_34  -netdelay none -netspeed full
````

If we try to `dx serve --platform android`, we'll find that our app fails to build for Android. This is not good!

````text
12:45:39 [cargo]   Could not find directory of OpenSSL installation, and this `-sys` crate cannot
12:45:39 [cargo]   proceed without this knowledge. If OpenSSL is installed and this crate had
12:45:39 [cargo]   trouble finding it,  you can set the `OPENSSL_DIR` environment variable for the
12:45:39 [cargo]   compilation process.
12:45:39 [cargo]   Make sure you also have the development packages of openssl installed.
12:45:39 [cargo]   For example, `libssl-dev` on Ubuntu or `openssl-devel` on Fedora.
12:45:39 [cargo]   If you're in a situation where you think the directory *should* be found
12:45:39 [cargo]   automatically, please open a bug at https://github.com/sfackler/rust-openssl
12:45:39 [cargo]   and include information about your system as well as this message.
12:45:39 [cargo]   $HOST = aarch64-apple-darwin
12:45:39 [cargo]   $TARGET = aarch64-linux-android
12:45:39 [cargo]   openssl-sys = 0.9.104
````

Currently, `rust-openssl` does not cross-compile properly for Android targets. To fix this, we need to add the `openssl` crate to our Cargo.toml and then enable its "vendored" feature. This will build OpenSSL from source instead of trying and failing to read it from the Android NDK.

We're only going to enable the vendored feature when targeting Android.

````toml
[target.'cfg(target_os = "android")'.dependencies]
openssl = { version = "0.10", features = ["vendored"] }
````

In the future, Dioxus might add OpenSSL's vendored feature implicitly to make this error go away. We're covering it here since it's important to understand that not every Rust dependency works out-of-the-box for iOS and Android. Unfortunately, the Rust ecosystem for mobile is still quite young and you'll need to know how to solve problems like these.

Let's try again!

````
dx serve --platform android
````

![Android DogApp](/assets/06_docs/android-dogapp.mp4)

## Testing on Desktop

HotDog also works on macOS, Windows, and Linux! We can use `dx serve --platform desktop` to serve our app as a desktop app.

![HotDogDesktop](/assets/06_docs/hotdog-desktop.png)

## Bundling for the web

After we're done making changes to our server and client apps, we can build bundles that are ready to distribute.

We're going to follow the same pattern as `dx serve` but with `dx bundle`. To start, let's build the web version of our app.

````sh
dx bundle --platform web
````

We should receive a series of INFO traces from the CLI as it builds, and then finally a path to the `public` folder it generates. Let's `cd` into its public directory and then check out its parent directory (cd ..) (the "web" folder).

````sh
â¯ tree -L 3 --gitignore
.
â”œâ”€â”€ public
â”‚   â”œâ”€â”€ assets
â”‚   â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”‚   â”œâ”€â”€ header.svg
â”‚   â”‚   â”œâ”€â”€ main-14aa55e73f669f3e.css
â”‚   â”‚   â”œâ”€â”€ main.css
â”‚   â”‚   â””â”€â”€ screenshot.png
â”‚   â”œâ”€â”€ index.html
â”‚   â””â”€â”€ wasm
â”‚       â”œâ”€â”€ hot_dog.js
â”‚       â”œâ”€â”€ hot_dog.js.br
â”‚       â”œâ”€â”€ hot_dog_bg.wasm
â”‚       â”œâ”€â”€ hot_dog_bg.wasm.br
â”‚       â””â”€â”€ snippets
â””â”€â”€ server
````

`dx` built a `public` folder containing our assets, index.html, and various JavaScript snippets. Alongside our public folder is a `server` binary. When we deploy our web assets, we'll also want to deploy the server since it provides our server functions.

We can manually run the server simply by executing it. If you're using a default `dioxus::launch` setup, then the server will read the `IP` and `PORT` environment variables to serve.

 > 
 > ðŸ“£ If you intend to serve from within a container (e.g., Docker), then you need to override the default `127.0.0.1` address with `IP=0.0.0.0` to listen for external connections.

![Serving the server](/assets/06_docs/serving_server.png)

## Bundling for Desktop and Mobile

To bundle desktop and mobile apps for deployment, we'll again use `dx bundle`. As of today, `dx bundle` only builds desktop apps for the native platform and architecture. Unfortunately, you can't build macOS apps from Windows, Linux apps from Mac, etc. We recommend using a Continuous Integration Matrix (like [Github Actions](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow)) to perform a "cross-build" of your app in multiple different containers.

When bundling installable apps, there are many distribution formats to choose from. We can specify these formats using the `--package-types` flag on `dx bundle`. Dioxus supports packaging a broad number of package types:

* macOS: `.app`, `.dmg`
* Linux: `.appimage`, `.rpm`, `.deb`
* Windows: `.msi`, `.exe`
* iOS: `.ipa`
* Android: `.apk`

You can specify package types like so:

````sh
dx bundle --platform desktop \
    --package-types "macos" \
    --package-types "dmg"
````

Note that not all package-types are compatible with each platform - eg. only `.exe` can be built when specifying `--platform desktop`.

We should see the outputs in our terminal:

````sh
18.252s  INFO Bundled app successfully!
18.252s  INFO App produced 2 outputs:
18.252s  INFO app - [/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/macos/HotDog.app]
18.252s  INFO dmg - [/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/dmg/HotDog_0.1.0_aarch64.dmg]
````

Generally, you can distribute desktop apps without needing an app store. However, some platforms like macOS might require you to sign and notarize your application to be considered "safe" for your users to open.

When distributing mobile apps, you *are required* to sign and notarize your apps. Currently, Dioxus doesn't provide built-in utilities for this, so you'll need to figure out signing by reading 3rd-party documentation.

Tauri provides documentation on the signing process:

* [macOS](https://tauri.app/distribute/sign/macos/)
* [iOS](https://tauri.app/distribute/sign/iOS/)
* [Android](https://tauri.app/distribute/sign/android/)
* [Windows](https://tauri.app/distribute/sign/Windows/)
* [Linux](https://tauri.app/distribute/sign/Linux/)

## Customizing your Bundle

Before you ship your app, you might want to configure how your app icon looks, what entitlements it has, and other details. Our `dx bundle` tool can help you configure your bundles in a variety of ways.

To configure our bundle, we'll use our `Dioxus.toml` and modify the bundle section.

````toml
[application]
name = "docsite"

[bundle]
identifier = "com.dioxuslabs"
publisher = "DioxusLabs"
icon = ["assets/icon.png"]
````

For a full list of options, see the [reference page on the `bundle` section](../cookbook/bundling.md).

## Automating dx bundle with JSON mode

Also added in Dioxus 0.6 is a JSON output mode for `dx`. This makes it possible to parse the output of the CLI using tools like [jq](https://jqlang.github.io/jq/) which provide stdin/stdout support for JSON parsing.

This mode is not particular friendly to humans, but does contain more information than the standard trace output.

````sh
{"timestamp":"   9.927s","level":"INFO","message":"Bundled app successfully!","target":"dx::cli::bundle"}
{"timestamp":"   9.927s","level":"INFO","message":"App produced 2 outputs:","target":"dx::cli::bundle"}
{"timestamp":"   9.927s","level":"DEBUG","message":"Bundling produced bundles: [\n    Bundle {\n        package_type: MacOsBundle,\n        bundle_paths: [\n            \"/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/macos/HotDog.app\",\n        ],\n    },\n    Bundle {\n        package_type: Dmg,\n        bundle_paths: [\n            \"/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/dmg/HotDog_0.1.0_aarch64.dmg\",\n        ],\n    },\n]","target":"dx::cli::bundle"}
{"timestamp":"   9.927s","level":"INFO","message":"app - [/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/macos/HotDog.app]","target":"dx::cli::bundle"}
{"timestamp":"   9.927s","level":"INFO","message":"dmg - [/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/dmg/HotDog_0.1.0_aarch64.dmg]","target":"dx::cli::bundle"}
{"timestamp":"   9.927s","level":"DEBUG","json":"{\"BundleOutput\":{\"bundles\":[\"/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/macos/HotDog.app\",\"/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/dmg/HotDog_0.1.0_aarch64.dmg\"]}}","target":"dx"}
````

JSON mode works with all `dx` commands. However, it is most useful with `dx build` and `dx bundle`. The CLI always guarantees that the last emitted line is the result of the command. To collect the list of bundles from the `dx bundle` command, we can use `tail -1` and simple jq.

````sh
dx bundle --platform desktop \
    --json-output \
    --verbose \
    | tail -1 \
    | jq -r '.json | fromjson | .BundleOutput.bundles []'
````

This returns the list of bundles:

````
/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/macos/HotDog.app
/Users/jonkelley/Development/Tinkering/06-demos/hot_dog/target/dx/hot_dog/bundle/macos/bundle/dmg/HotDog_0.1.0_aarch64.dmg
````
# Deploying

We're *finally* ready to deploy our bundled apps into the world. Congrats on making it this far!

This step is optional for the tutorial but worth covering to understand the process. Feel free to skip ahead to [next steps](next_steps.md) if you're not interested in deploying.

## Dioxus Deploy

As mentioned in the [introduction](../index.md#whos-funding-dioxus), Dioxus is an independent project with aspirations to fund itself through a paid deploy platform. Hopefully, one day, enough people ship apps with [Dioxus Deploy](https://dioxuslabs.com/deploy) to fund development on Dioxus itself!

Currently, Dioxus does not provide its own deploy platform. If you want to sign-up for the beta and help us design the ideal "end-to-end app-development experience," please [join the waitlist!](https://forms.gle/zeBZmrjSkajqg7hUA)

![Deploy](/assets/06_docs/deploy_screenshot.png)

## Deploying your Desktop and Mobile apps

Generally, deploying a desktop app is as simple as distributing the bundle directly. Simply upload your app bundles to a host like GitHub or S3. With a download link, your users can easily download and install your apps.

 > 
 > ðŸ“£ When shipping fullstack apps to production, you'll want to make sure to set your backend API URL properly as [covered later](#fullstack-desktop-and-mobile).

If you'd like to distribute your app through app stores, you'll need to follow some additional steps.

* [iOS](https://developer.apple.com/ios/submit/): Directly publish to the Apple App Store
* [macOS](https://developer.apple.com/macos/submit/): Directly publish to the Apple App Store
* [Android](https://developer.android.com/studio/publish): Directly publish to the Google Play Store

Tauri provides some [helpful guides](https://tauri.app/distribute/) for deploying Tauri apps which, while not Dioxus apps, need to follow many of the same steps for deploying to app stores.

Making native app distribution easier is a top priority for Dioxus Deploy!

## Deploy Requirements

Dioxus web apps are structured as a Client bundle and a Server executable. Generally, any deploy provider that exposes a simple container will be sufficient for a Dioxus fullstack web application.

Some providers like [Cloudflare Workers](http://workers.cloudflare.com) and [Fermyon Spin](https://www.fermyon.com/spin) provide WASM-based containers for apps. WASM runtimes are typically cheaper to operate and can horizontally scale better than a traditional virtual-machine based container. When deploying on WASM runtimes, you will need to create a WASM build of your server manually.

Running the webserver is as simple as executing `./server`. Make sure to set the IP and PORT environment variables correctly:

![Serving a Server](/assets/06_docs/serving_server.png)

## Choosing a deploy provider

There are *many* deploy providers! We're not going to get too deep into the pros/cons of any particular provider. Generally, providers are good at one of a few categories: price, performance, UI/UX, advanced features, and enterprise requirements.

Depending on your app, you might have strict requirements like SOC2 or HIPAA compliance. Make sure to do your own research for your own use-case.

* [AWS](http://aws.amazon.com): Full-featured cloud provider powered by Amazon.
* [GCP](https://cloud.google.com): Full-featured cloud provider powered by Google.
* [Azure](http://azure.microsoft.com): Full-featured cloud provider powered by Microsoft.
* [Fly.io](http://fly.io): Simple scale-to-zero micro-vm-based cloud with integrated wireguard.
* [Vercel](https://vercel.com): Developer-focused cloud built on AWS cloud functions popular with JavaScript frameworks.
* [Render](http://render.com): A "Modern Heroku" focused on developer experience and simplicity.
* [Digital Ocean](https://www.digitalocean.com): A cloud built around virtual machines, databases, and storage.

For *HotDog* we're going to deploy on [Fly.io](http://fly.io). We like [Fly.io](http://fly.io) for a number of reasons. Most importantly, Fly is built on Amazon's [Firecracker](https://firecracker-microvm.github.io) project which is entirely written in Rust!

Fly is also quite simple to get started - just log in with either your GitHub account or Google account.

## Building a Dockerfile

Some deploy providers have prebuilt solutions for various runtimes. For example, some have dedicated NodeJS and Python runtimes with strict requirements.

With Rust apps, there generally isn't a prebuilt "pack" to target. In these cases, we need to write a simple Dockerfile which compiles and starts our apps.

Our Dockerfile will have three phases. The first phase downloads and caches dependencies so incremental builds stay fast:

````dockerfile
FROM rust:1 AS chef
RUN cargo install cargo-chef
WORKDIR /app

FROM chef AS planner
COPY . .
RUN cargo chef prepare --recipe-path recipe.json
````

In the second phase, we use cargo chef to load cached dependencies and preform the build:

````dockerfile
FROM chef AS builder
COPY --from=planner /app/recipe.json recipe.json
RUN cargo chef cook --release --recipe-path recipe.json
COPY . .

# Install `dx`
RUN curl -L --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash
RUN cargo binstall dioxus-cli --root /.cargo -y --force
ENV PATH="/.cargo/bin:$PATH"

# Create the final bundle folder. Bundle always executes in release mode with optimizations enabled
RUN dx bundle --platform web
````

Finally, we copy the built "web" folder to the "slim" runtime that serves our app.

````dockerfile
FROM chef AS runtime
COPY --from=builder /app/target/dx/hot_dog/release/web/ /usr/local/app

# set our port and make sure to listen for all connections
ENV PORT=8080
ENV IP=0.0.0.0

# expose the port 8080
EXPOSE 8080

WORKDIR /usr/local/app
ENTRYPOINT [ "/usr/local/app/server" ]
````

It's also a smart idea to set up a `.dockerignore` file:

````
**/target
**/dist
LICENSES
LICENSE
temp
README.md
````

## Deploying to Fly

To get started with Fly, we need to go through the [Sign Up flow](https://fly.io/app/sign-up) and enter our details. This shouldn't take too long.

We'll add the dockerfile from above along with the dockerignore. We'll want to [install `flyctl`](https://fly.io/docs/flyctl/install/) which also installs the `fly` CLI.

Let's call [`fly launch`](https://fly.io/docs/flyctl/launch/) which will automatically initialize our `fly.toml`.

![Fly Launch](/assets/06_docs/fly_launch.png)

`fly launch` will spin up a build machine for us and build our app. In a minute or two, our app should be fully built and deployed.

If we ever want to re-deploy our code, we can run `fly deploy`.

![Running fly deploy](/assets/06_docs/fly_deploy.mp4)

We can also add a volume to our app to persist our Sqlite database by adding a `[mounts]` section to our Fly.toml:

````toml
[mounts]
  source = "hotdogdb"
  destination = "/usr/local/app/hotdogdb"
````

Once the build is complete, Fly will assign our app a URL that we can customize later. With any luck, our app should be live!

![Live App](/assets/06_docs/fly-deployed.png)

## Continuous Deployment

Fly also supports [continuous deployment](https://fly.io/docs/app-guides/continuous-deployment-with-github-actions/). Whenever we push to our GitHub repository, we can execute `fly deploy` automatically. This can serve as a foundation for staging environments and automatic releases.

Our app just needs a `.github/workflows/fly-deploy.yml`.

````yml
name: Fly Deploy
on:
  push:
    branches:
      - main
jobs:
  deploy:
    name: Deploy app
    runs-on: ubuntu-latest
    concurrency: deploy-group
    steps:
      - uses: actions/checkout@v4
      - uses: superfly/flyctl-actions/setup-flyctl@master
      - run: flyctl deploy --remote-only
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
````

## Fullstack Desktop and Mobile

Now that our backend is live, we can wire up the API to our native apps. By default, Dioxus doesn't know where to find your API, so you'll need to specify the URL manually by calling `server_fn::client::set_server_url`.

````rs@guide_deploy.rs
fn main() {
    #[cfg(not(feature = "server"))]
    server_fn::client::set_server_url("https://hot-dog.fly.dev");

    dioxus::launch(App);
}
````

Note that as our app changes, the "true" endpoint of our server functions might change. The `#[server]` macro generates an API endpoint with the form of `/api/fetch_dogs-jkhj12` where the trailing data is a unique hash. As we update our server functions, the hash will change.

To make server functions maintain a stable endpoint, we can manually name them with the `endpoint = "xyz"` attribute.

````rs@guide_deploy.rs
#[server(endpoint = "list_dogs")]
pub async fn list_dogs() -> Result<Vec<(usize, String)>, ServerFnError> {
    todo!()
}

#[server(endpoint = "remove_dog")]
pub async fn remove_dog(id: usize) -> Result<(), ServerFnError> {
    todo!()
}

#[server(endpoint = "save_dog")]
pub async fn save_dog(image: String) -> Result<(), ServerFnError> {
    todo!()
}
````

Let's re-deploy our web app with `fly deploy`. This deploy should complete faster thanks to `cargo chef` caching our build.

Now, with `dx serve --platform desktop`, we should be able to interact with the same backend across web and desktop.

Amazing! Our startup is coming along nicely.

![Full Cross Build](/assets/06_docs/full-crossplatform.png)

## Next Steps

Our app isn't done yet, but this guide has become pretty long!

There's so much extra to do:

* Adding users, login, and auth.
* Protecting our site from DDOS with tools Cloudflare.
* Adding more features
* Marketing and sharing with friends!
# Wrapping Up

Congrats on making it through our *HotDog* tutorial!

Hopefully this isn't the end of our journey, but rather, a bold new beginning.

## Up Next

We strongly recommend moving on to the [Essential Topics](../essentials/index.md) to become familiar with the important details of Dioxus.

The essentials section will guide you through key concepts in Dioxus:

* [Building UIs with RSX](../essentials/rsx/index.md) will teach you how to define html inside your Dioxus app with rsx.

* [Component Lifecycle](../essentials/lifecycle/index.md) teaches you about the lifecycle of components along with the hooks you need to run code when the component is first created, mounted, and removed.

* [Managing State](../essentials/state/index.md) guides you through how state works in Dioxus. It will teach you how to create state with `use_signal`, derive state with `use_memo`, and integrate state with asynchronous tasks with `use_resource`. Along the way, you will learn about how you can use reactivity to declaratively describe your UI.

* [Breaking Out](../essentials/breaking/index.md) will teach you how to break out of Dioxus' rendering model to run JavaScript or interact with the DOM directly with `web-sys`.

## Ideas for New Features

Challenge yourself by adding new features to *HotDog*.

* Add animations to your app with CSS or [dioxus-motion](https://github.com/wheregmis/dioxus-motion).
* Style your app with a library like [TailwindCSS](http://tailwindcss.com).
* Add inputs to allow users to upload their own dog photos.
* Make it social! Add login, user accounts, and a feed.
* Remix HotDog for something entirely new.

## FAQ

You might be curious how particular features work in Dioxus. Let's try to address a few popular question:

### Is Dioxus Fast?

Dioxus is really fast. Dioxus is built around an *extremely* performant VirtualDom. While a VirtualDom might sound like ["pure overhead"](https://svelte.dev/blog/virtual-dom-is-pure-overhead), Dioxus leverages compile-time optimizations that make it faster than nearly all UI frameworks.

On the web, Dioxus [is on par with frameworks like Solid and Svelte](https://krausest.github.io/js-framework-benchmark/2023/table_chrome_120.0.6099.62.html) which leverage new reactivity models or custom compilers.

### Is Rust too hard?

Rust is a notoriously difficult language to learn, but it's extremely powerful. Dioxus has been designed to use the "easy" parts of Rust. For example, Dioxus primarily uses single-threaded code and avoids complicated generic interfaces.

All-in-all, the productivity you gain by building once and deploying everywhere usually makes up for the steeper learning curve. Plus, as Dioxus matures, interfaces become easier to use and the ecosystem improves.

### Does Dioxus support "xyz"?

* TailwindCSS: Yes, but it requires an additional step, see the [docs for more info](../cookbook/tailwind.md).
* Native Widgets: Yes, but you might need to write this code yourself. The Rust ecosystem is young.
* Shadcn-ui: Not yet, a radix-ui port to Dioxus is underway but we're not done yet.
* Actix/Rocket: Yes, kind-of. In Dioxus, Server-Functions are built on axum, but you can use server-side-rendering with any framework.
* Static-site-generation: Yes! The docs are currently under construction, so stay tuned. ðŸ—ï¸
* Animations: Yes, you can use CSS animations, [dioxus-motion](https://github.com/wheregmis/dioxus-motion), or integrate with the system animation APIs.
* Accessibility: Yes. Use semantic HTML and aria-tags for good screen-reader support.
* WGPU: Yes, kinda. You can overlay Dioxus on a WGPU scene or experiment with Dioxus-Native which renders with WGPU.
* AI: Yes, you can interface with providers like [OpenAI](https://crates.io/crates/openai-api-rs) or even [build your own provider](https://github.com/DioxusLabs/dioxus-ai).

If you have an FAQ not covered here, suggest an edit!

### Why RSX instead of HTML?

If you've seen React's JSX or the `html!{}` Rust macro, you might be curious as to why Dioxus chose to use its own syntax instead of a syntax that looks more similar to HTML.

A few reasons:

* RSX gets token coloring and code-folding without additional tooling
* RSX is faster to type since curly braces are auto-closed
* Not all RSX is HTML - Dioxus can be used in non-HTML contexts
* HTML is not valid Rust - not all HTML can be used in html!{}

We want the out-of-the-box experience for Dioxus to be great without setting up any custom tooling.

The Dioxus [VSCode Extension](http://marketplace.visualstudio.com/items?itemName=DioxusLabs.dioxus) can convert HTML to RSX as well as the CLI with `dx translate`.

### Should I use Dioxus or Tauri or Leptos or Iced or...?

There's a budding ecosystem of Rust projects for building apps and websites! We have a good comparison in our [Readme.md](https://github.com/DioxusLabs/dioxus#dioxus-vs-other-frameworks)

Dioxus is an "all-in-one" solution for building apps with Rust. We try to be helpful every step of the way: getting started, iterating, testing, bundling, and deploying.

* **Tauri**: You can use Dioxus with Tauri, but we focus primarily on the standalone Dioxus experience. Tauri is a good choice if you want to use a JavaScript frontend or need full-featured access to the Webview DOM.
* **Leptos**: Dioxus and Leptos are both good choices for fullstack web development with differences in syntax and reactivity models. Dioxus is architected to support desktop and mobile "1st-class" whereas Leptos is primarily a web framework.
* **Iced:** Iced is GUI framework that renders using its own render engine, making it highly customizable. Iced is a good choice for apps that need access to lower-level rendering through WGPU. Dioxus will be releasing its own WGPU renderer in early 2025, so stay tuned!

Dioxus is quite a large project and has been a bit slower to mature than other projects with larger development teams or smaller scopes. With 0.6, Dioxus is more mature but still has some ground to cover.
# Core Topics

This section will guide you through key concepts in Dioxus:

* [Building UIs with RSX](rsx/index.md) will teach you how to define html inside your Dioxus app with rsx.

* [Component Lifecycle](lifecycle/index.md) teaches you about the lifecycle of components along with the hooks you need to run code when the component is first created, mounted, and removed.

* [Managing State](state/index.md) guides you through how state works in Dioxus. It will teach you how to create state with `use_signal`, derive state with `use_memo`, and integrate state with asynchronous tasks with `use_resource`. Along the way, you will learn about you can use reactivity to declaratively describe your UI.

* [Breaking Out](breaking/index.md) will teach you how to break out of Dioxus' rendering model to run JavaScript or interact with the DOM directly with `web-sys`.

* [Async](async/index.md) will teach you how to integrate async tasks with Dioxus and how to handle loading states while waiting for async tasks to finish.

* [Error Handling](error_handling/index.md) will teach you how to throw and handle errors in Dioxus.
# Building UIs with RSX

Dioxus renders to HTML, if you are not familiar with HTML, this guide will help you get started with the basics. For more detail, the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTML) are a great resource.

## Text Nodes

Any content surrounded by quotes is rendered as a text node in rsx:

````rs@building_uis_with_rsx.rs
rsx! {
    "Hello world"
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::Text {}
}
````

You can include formatted segments inside of the text just like the `format!` macro:

````rs@building_uis_with_rsx.rs
let user = use_signal(|| User {
    name: "Dioxus".to_string(),
});
rsx! {
    // Unlike the format macro, you can include many expressions inline in the formatted text
    "Hello {user.read().name}"
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::FormattedText {}
}
````

## Elements

The most basic building block of HTML is an element. In rsx, you can create elements with the name and then curly braces. One of the most common elements is the `input` element. The input element creates an interactive input box:

````rs@building_uis_with_rsx.rs
rsx! {
    input {}
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::Input {}
}
````

 > 
 > Bonus: web components
 > Any element with a dash in the name is a web component. Web components are rendered directly in dioxus without type checking. We recommend wrapping web components in a type safe component to make them easier to use.
 > 
 > ````rs@building_uis_with_rsx.rs
 > rsx! {
 >     my-web-component {}
 > }
 > ````

## Attributes

Attributes provide extra information about an element. You can specify attributes in dioxus inside an element's braces by typing the name of the attribute, a colon, and then the value (typically a formatted string). We can use an attribute to set the `type` of an input element. The default type is `text` which shows a text input box, but we can set it to `number` to only accept numbers:

````rs@building_uis_with_rsx.rs
rsx! {
    input { type: "number" }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputType {}
}
````

Just like text nodes, attributes can include formatted segments. We can set the value of the input element to a signal to control it:

````rs@building_uis_with_rsx.rs
let mut value = use_signal(|| "Hello world".to_string());
rsx! {
    input { value: "{value}" }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputValue {}
}
````

### Conditional Attributes

You can conditionally set an attribute by setting the attribute value to an unterminated if statement. If the if statement evaluates to true, the attribute will be set:

````rs@building_uis_with_rsx.rs
let number_type = use_signal(|| false);
rsx! {
    input { type: if number_type() { "number" } }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputDisabled {}
}
````

## Event Listeners

Event listeners allow you to respond to user input. In rsx, event handlers always start with `on`. The syntax is the same as normal attributes, but event handlers only accept a closure that responds to the event. We can attach an event listener to the `oninput` event of the input element to listen for changes to the input:

````rs@building_uis_with_rsx.rs
let mut value = use_signal(|| "Hello world".to_string());
rsx! {
    input {
        oninput: move |event| value.set(event.value()),
        value: "{value}"
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::OnInput {}
}
````

## Children

You can add children to an element after all attributes and event listeners. Elements can accept text, components or other elements as children. We can add a `div` element around our input to center it:

````rs@building_uis_with_rsx.rs
rsx! {
    div {
        // display sets the layout mode of the element
        display: "flex",
        // justify-content centers the element horizontally
        justify_content: "center",
        input {
            type: "number"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputChildren {}
}
````

## Loops

You can insert for loops directly in rsx. The body of the loop accepts any number of children that will be rendered with each iteration of the loop. The `ul` element in html renders an unordered list with any number of `li` (list item) elements. We can use those two elements to render a list of items in a loop:

````rs@building_uis_with_rsx.rs
let mut items = use_signal(|| vec!["Hello", "Dioxus"]);

rsx! {
    ul {
        for item in items.iter() {
            li { "{item}" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::ForLoop {}
}
````

Each item in your list should have unique value that is stable across rerenders called a key. Keys are used to identify how items move while diffing. Without keys, it is easy to accidentally lose or move state when you reorder items in a list. We can add keys to our list items by using the `key` attribute:

````rs@building_uis_with_rsx.rs
let mut items = use_signal(|| vec!["Hello", "Dioxus"]);

rsx! {
    ul {
        for item in items.iter() {
            li { key: "{item}", "{item}" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::KeyedForLoop {}
}
````

## If Statements

You can also use if/else statements in rsx. Each branch of the if statement accepts child nodes that will be rendered if the condition is true. We can use the `if` statement to conditionally render a login screen:

````rs@building_uis_with_rsx.rs
let logged_in = use_signal(|| false);

rsx! {
    div {
        if logged_in() {
            "You are logged in"
        } else {
            "You are not logged in"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::IfStatement {}
}
````

## Why RSX and not HTML ?

If you've seen React's JSX or the `html!{}` Rust macro, you might be curious as to why Dioxus chose to use its own syntax instead of a syntax that looks more similar to HTML.

A few reasons:

* RSX gets token coloring and code-folding without additional tooling
* RSX is faster to type since curly braces are auto-closed
* Not all RSX is HTML - Dioxus can be used in non-HTML contexts
* HTML is not valid Rust - not all HTML can be used in html!{}
# Component Lifecycle

## Initializing State with `use_hook`

`use_hook` lets you create new state for your component. The closure you pass to `use_hook` will be called once the first time the component is rendered. Every time the component is re-rendered, the value that was created the first run will be re-used.

````rs@component_lifecycle.rs
fn UseHook() -> Element {
    // The closure that is passed to use_hook will be called once the first time the component is rendered
    let random_number = use_hook(|| {
        let new_random_number = random_number();

        log!("{new_random_number}");

        new_random_number
    });

    rsx! {
        div { "Random {random_number}" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::UseHookDemo {}
}
````

## Rerendering

You can use [tracked values](../state/index.md) to re-render your component whenever a value changes.

````rs@component_lifecycle.rs
fn Rerenders() -> Element {
    let mut count = use_signal(|| 0);

    log!("Rerendering parent component with {}", *count.peek());

    rsx! {
        button { onclick: move |_| count += 1, "Increment" }
        // Since we read count here, the component will rerender when count changes
        Count { current_count: count() }
    }
}

// If the count prop changes, the component will rerender
#[component]
fn Count(current_count: i32) -> Element {
    log!("Rerendering child component with {current_count}");

    rsx! {
        div { "The count is {current_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::RerenderDemo {}
}
````

### âš ï¸ Don't mutate state in the body of a component

You should avoid changing state in the body of a component. If you read and write to state in the body of a component, you can cause an infinite loop as the component tries to rerender because of the change which triggers another state change.

````rs@component_lifecycle.rs
fn Bad() -> Element {
    let mut count = use_signal(|| 0);

    // âŒ Don't mutate state in the body of the component.
    // It can easily cause an infinite loop!
    count += 1;

    rsx! { "{count}" }
}
````

Instead, derive state with `use_memo`, `use_resource`, or mutate state in a effect.

## Using Effects

You can use effects to run code whenever a component is rendered.

````rs@component_lifecycle.rs
fn Effect() -> Element {
    // Effects run after the component is rendered
    // You can use them to read or modify the rendered component
    use_effect(|| {
        log!("Effect ran");
        document::eval(&format!(
            "document.getElementById('effect-output').innerText = 'Effect ran'"
        ));
    });

    rsx! {
        div { id: "effect-output", "This will be changed by the effect" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::EffectDemo {}
}
````

## Cleaning Up Components with Drop

Before a component is dropped, it will drop all of its hooks. You can use this drop behavior to clean up any resources that your component is using. If you just need the drop effect, you can use the [`use_drop`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_drop.html) hook.

````rs@component_lifecycle.rs
fn TogglesChild() -> Element {
    let mut show = use_signal(|| true);

    rsx! {
        button { onclick: move |_| show.toggle(), "Toggle" }
        if show() {
            Child {}
        }
    }
}

fn Child() -> Element {
    // You can use the use_drop hook to clean up any resources
    use_drop(|| {
        log!("Child dropped");
    });

    rsx! {
        div { "Child" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::DropDemo {}
}
````
# Managing State

In Dioxus, your app is defined as a function of the current state. As the state changes, the parts of your app that depend on that state will automatically re-run. Reactivity automatically tracks state and updates derived state in your application.

## Creating State

You can create mutable state in Dioxus with Signals. Signals are tracked values that automatically update your app when you change them. They form the skeleton of your app's state from which you can derive other state. Signals are often driven directly from user input through event handlers or async tasks.

You can create a signal with the `use_signal` hook:

````rs@reactivity.rs
let mut signal = use_signal(|| 0);
````

Once you have your signal, you can clone it by calling the signal like a function or get a reference to the inner value with the `.read()` method:

````rs@reactivity.rs
// Call the signal like a function to clone the current value
let value: i32 = signal();
// get a reference to the inner value with the .read() method
let value: &i32 = &signal.read();
// or use one of the traits implemented for Signal like Display
log!("{signal}");
````

Finally, you can set the value of the signal with the `.set()` method or get a mutable reference to the inner value with the `.write()` method:

````rs@reactivity.rs
// Set the value from the signal
signal.set(1);

// get a mutable reference to the inner value with the .write() method
let mut value: &mut i32 = &mut signal.write();
*value += 1;
````

### Reactive Scopes

The simplest reactive primitive in Dioxus is the `use_effect` hook. It creates a closure that is run any time a tracked value that is run inside the closure changes.

Any value you read inside the closure will become a dependency of the effect. If the value changes, the effect will rerun.

````rs@reactivity.rs
fn Effect() -> Element {
    // use_signal creates a tracked value called count
    let mut count = use_signal(|| 0);

    use_effect(move || {
        // When we read count, it becomes a dependency of the effect
        let current_count = count();
        // Whenever count changes, the effect will rerun
        log!("{current_count}");
    });

    rsx! {
        button { onclick: move |_| count += 1, "Increment" }

        div { "Count is {count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::EffectDemo {}
}
````

### Derived State

`use_memo` is a reactive primitive that lets you derive state from any tracked value. It takes a closure that computes the new state and returns a tracked value with the current state of the memo. Any time a dependency of the memo changes, the memo will rerun.

The value you return from the closure will only change when the output of the closure changes (`PartialEq` between the old and new value returns false).

````rs@reactivity.rs
fn Memo() -> Element {
    let mut count = use_signal(|| 0);

    // use_memo creates a tracked value that is derived from count
    // Since we read count inside the closure, it becomes a dependency of the memo
    // Whenever count changes, the memo will rerun
    let half_count = use_memo(move || count() / 2);

    use_effect(move || {
        // half_count is itself a tracked value
        // When we read half_count, it becomes a dependency of the effect
        // and the effect will rerun when half_count changes
        log!("{half_count}");
    });

    rsx! {
        button { onclick: move |_| count += 1, "Increment" }

        div { "Count is {count}" }
        div { "Half count is {half_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::MemoDemo {}
}
````

### Derived Async State

`use_resource` is a reactive primitive that lets you derive state from any async closure. It takes an async closure that computes the new state and returns a tracked value with the current state of the resource. Any time a dependency of the resource changes, the resource will rerun.

The value you return from the closure will only change when the state of the future changes. Unlike `use_memo`, the resource's output is not memoized with `PartialEq`.

````rs@reactivity.rs
fn Resource() -> Element {
    let mut count = use_signal(|| 0);

    // use_resource creates a tracked value that is derived from count
    // Since we read count inside the closure, it becomes a dependency of the resource
    // Whenever count changes, the resource will rerun
    let half_count = use_resource(move || async move {
        // You can do async work inside resources
        gloo_timers::future::TimeoutFuture::new(100).await;
        count() / 2
    });

    use_effect(move || {
        // half_count is itself a tracked value
        // When we read half_count, it becomes a dependency of the effect
        // and the effect will rerun when half_count changes
        log!("{:?}", half_count());
    });

    rsx! {
        button { onclick: move |_| count += 1, "Change Signal" }

        div { "Count is {count}" }
        div { "Half count is {half_count():?}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::ResourceDemo {}
}
````

### Derived UI

Components are functions that return some UI. They memorize the output of the function just like memos. Components keep track of any dependencies you read inside the component and rerun when those dependencies change.

````rs@reactivity.rs
fn Component() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        button { onclick: move |_| count += 1, "Change Signal" }

        // Since we read count inside Component, it becomes a dependency of Component
        // Whenever count changes, Component will rerun
        Count { count: count() }
    }
}

// Components automatically memorize their props. If the props change, Count will rerun
#[component]
fn Count(count: i32) -> Element {
    rsx! {
        div { "Count: {count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::ComponentDemo {}
}
````

### Working with Untracked State

Most of the state in your app will be tracked values. All built in hooks return tracked values, and we encourage custom hooks to do the same. However, there are times when you need to work with untracked state. For example, you may receive a raw untracked value in props. When you read an untracked value inside a reactive scope, it will not subscribe to the value:

````rs@reactivity.rs
fn Component() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        button { onclick: move |_| count += 1, "Change Signal" }

        Count { count: count() }
    }
}

// The count reruns the component when it changes, but it is not a tracked value
#[component]
fn Count(count: i32) -> Element {
    // When you read count inside the memo, it does not subscribe to the count signal
    // because the value is not reactive
    let double_count = use_memo(move || count * 2);

    rsx! {
        div { "Double count: {double_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::NonReactiveDemo {}
}
````

You can start tracking raw state with the `use_reactive` hook. This hook takes a tuple of dependencies and returns a reactive closure. When the closure is called in a reactive scope, it will track subscribe to the dependencies and rerun the closure when the dependencies change.

````rs@reactivity.rs
#[component]
fn Count(count: i32) -> Element {
    // You can manually track a non-reactive value with the use_reactive hook
    let double_count = use_memo(
        // Use reactive takes a tuple of dependencies and returns a reactive closure
        use_reactive!(|(count,)| count * 2),
    );

    rsx! {
        div { "Double count: {double_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::UseReactiveDemo {}
}
````

### Opting Out of Subscriptions

In some situations, you may need to read a reactive value without subscribing to it. You can use the `peek` method to get a reference to the inner value without registering the value as a dependency of the current reactive scope:

````rs@reactivity.rs
fn Peek() -> Element {
    let mut count = use_signal(|| 0);

    // The toggle signal is a tracked value
    let mut toggle = use_signal(|| false);

    use_effect(move || {
        // When we read count, it becomes a dependency of the effect
        let current_count = count();
        log!("current_count is {current_count}");

        if current_count % 4 == 0 {
            // We peek at the value of toggle instead of reading it,
            // so it does not become a dependency
            let current_toggle = *toggle.peek();
            // We didn't subscribe to toggle, so this will not cause
            // the effect to rerun forever
            toggle.set(!current_toggle);
            log!("flipped toggle to {toggle}");
        }
    });

    rsx! {
        button { onclick: move |_| count += 1, "Change Signal" }

        div { "Count is {count}" }
        div { "Toggle is {toggle}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::PeekDemo {}
}
````

### Making Props Reactive

To avoid losing reactivity with props, we recommend you wrap any props you want to track in a `ReadOnlySignal`. Dioxus will automatically convert `T` into `ReadOnlySignal<T>` when you pass props to the component. This will ensure your props are tracked and rerun any state you derive in the component:

````rs@reactivity.rs
// You can track props by wrapping the type in a ReadOnlySignal
// Dioxus will automatically convert T into ReadOnlySignal<T> when you pass
// props to the component
#[component]
fn Count(count: ReadOnlySignal<i32>) -> Element {
    // Then when you read count inside the memo, it subscribes to the count signal
    let double_count = use_memo(move || count() * 2);

    rsx! {
        div { "Double count: {double_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::MakingPropsReactiveDemo {}
}
````

## Moving Around State

As you create signals and derived state in your app, you will need to move around that state between components. Dioxus provides three different ways to pass around state:

### Passing props

You can pass your values through component [props](../../reference/component_props.md). This should be your default when passing around state. It is the most explicit and local to your component. Use this until it gets annoying to pass around the value:

````rs@moving_state_around.rs
pub fn ParentComponent() -> Element {
    let count = use_signal(|| 0);

    rsx! {
        "Count is {count}"
        IncrementButton {
            count
        }
    }
}

#[component]
fn IncrementButton(mut count: Signal<i32>) -> Element {
    rsx! {
        button {
            onclick: move |_| count += 1,
            "Increment"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    moving_state_around::PassingProps {}
}
````

### Passing context

If you need a slightly more powerful way to pass around state, you can use the context API.

The context API lets you pass state from a parent component to all children. This is useful if you want to share state between many components. You can insert a unique type into the context with the [`use_context_provider`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context_provider.html) hook in the parent component. Then you can access the context in any child component with the [`use_context`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context.html) hook.

````rs@moving_state_around.rs
#[derive(Clone, Copy)]
struct MyState {
    count: Signal<i32>,
}

pub fn ParentComponent() -> Element {
    // Use context provider provides an unique type to all children of this component
    let state = use_context_provider(|| MyState {
        count: Signal::new(0),
    });

    rsx! {
        "Count is {state.count}"
        // IncrementButton will have access to the count without explicitly passing it through props
        IncrementButton {}
    }
}

#[component]
fn IncrementButton() -> Element {
    // Use context gets the value from a parent component
    let mut count = use_context::<MyState>().count;

    rsx! {
        button {
            onclick: move |_| count += 1,
            "Increment"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    moving_state_around::PassingContext {}
}
````

This is slightly less explicit than passing it as a prop, but it is still local to the component. This is really great if you want state that is global to part of your app. It lets you create multiple global-ish states while still making state different when you reuse components. If I create a new `ParentComponent`, it will have a new `MyState`.

### Using globals

Finally, if you have truly global state, you can put your state in a `Global<T>` static. This is useful if you want to share state with your whole app:

````rs@moving_state_around.rs
use dioxus::prelude::*;
// Globals are created the first time you access them with the closure you pass to Global::new
static COUNT: GlobalSignal<i32> = Global::new(|| 0);

pub fn ParentComponent() -> Element {
    rsx! {
        "Count is {COUNT}"
        IncrementButton {}
    }
}

fn IncrementButton() -> Element {
    rsx! {
        button {
            // You don't need to pass anything around or get anything out of the context because COUNT is global
            onclick: move |_| *COUNT.write() += 1,
            "Increment"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    moving_state_around::UsingGlobals {}
}
````

Global state can be very ergonomic if your state is truly global, but you shouldn't use it if you need state to be different for different instances of your component. If I create another `IncrementButton` it will use the same `COUNT`. Libraries should generally avoid this to make components more reusable.

 > 
 > Note: Even though it is in a static, `COUNT` will be different for each app instance so you don't need to worry about state mangling when multiple instances of your app are running on the server
# Handling Asynchronous Tasks

Asynchronous tasks are a core part of any modern application. Dioxus provides a few different methods to handle asynchronous tasks. This guide will cover how to use each of them. If you already know what kind of asynchronous task you need, you can skip to the section for that task:

* [spawn](#running-futures-with-spawn) is great for futures you need to run in the background that don't return a value
* [use_resource](#asynchronous-state-with-use-resource) handles asynchronous state while retaining control of exactly what happens while the future is running
* It can be combined with [Suspense](#unified-loading-views-with-suspense) to handle many pending tasks with the same loading view

## Running Futures with `spawn`

The [`spawn`](https://docs.rs/dioxus/0.6.2/dioxus/prelude/fn.spawn.html) method spawns a future in the background and returns a `Task` that you can use to cancel the future. Spawn is great for futures you want to start and then forget about like sending analytics data to a server:

````rs@asynchronous.rs
let mut response = use_signal(|| "Click to start a request".to_string());

rsx! {
    button {
        onclick: move |_| {
            response.set("...".into());
            // Spawn will start a task running in the background
            spawn(async move {
                let resp = reqwest::Client::new()
                    .get("https://dioxuslabs.com")
                    .send()
                    .await;

                if resp.is_ok() {
                    response.set("dioxuslabs.com responded!".into());
                } else  {
                    response.set("failed to fetch response!".into());
                }
            });
        },
        "{response}"
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::SpawnButton {}
}
````

Since spawning in event handlers is very common, Dioxus provides a more concise syntax for async event handlers. If you return a future from an event handler, Dioxus will automatically `spawn` it:

````rs@asynchronous.rs
let mut response = use_signal(|| "Click to start a request".to_string());

rsx! {
    button {
        // Async closures passed to event handlers are automatically spawned
        onclick: move |_| async move {
            response.set("...".into());
            let resp = reqwest::Client::new()
                .get("https://dioxuslabs.com")
                .send()
                .await;

            if resp.is_ok() {
                response.set("dioxuslabs.com responded!".into());
            } else  {
                response.set("failed to fetch response!".into());
            }
        },
        "{response}"
    }
}
````

<div class="warning">

The future you pass to the `spawn` will automatically be cancelled when the component is unmounted. If you need to keep the future running until it is finished, you can use [`spawn_forever`](https://docs.rs/dioxus/0.6.2/dioxus/prelude/fn.spawn_forever.html) instead.

</div>

## Asynchronous State with `use_resource`

The [`use_resource`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_resource.html) can be used to derive asynchronous state. It takes an async closure to calculate the state and returns a tracked value with the current state of the future. Any time a dependency of the resource changes, the resource will rerun:

````rs@asynchronous.rs
let mut breed = use_signal(|| "hound".to_string());
let dogs = use_resource(move || async move {
    reqwest::Client::new()
        // Since breed is read inside the async closure, the resource will subscribe to the signal
        // and rerun when the breed is written to
        .get(format!("https://dog.ceo/api/breed/{breed}/images"))
        .send()
        .await?
        .json::<BreedResponse>()
        .await
});

rsx! {
    input {
        value: "{breed}",
        // When the input is changed and the breed is set, the resource will rerun
        oninput: move |evt| breed.set(evt.value()),
    }

    div {
        display: "flex",
        flex_direction: "row",
        // You can read resource just like a signal. If the resource is still
        // running, it will return None
        if let Some(response) = &*dogs.read() {
            match response {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        } else {
            "Loading..."
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::UseResource {}
}
````

The `use_resource` hook might look similar to the `use_memo` hook, but unlike `use_memo`, the resource's output is not memoized with `PartialEq`. That means any components/reactive hooks that read the output will rerun if the future reruns even if the value it returns is the same:

````rs@asynchronous.rs
let mut number = use_signal(|| 0);

// Resources rerun any time their dependencies change. They will
// rerun any reactive scopes that read the resource when they finish
// even if the value hasn't changed
let halved_resource = use_resource(move || async move { number() / 2 });

log!("Component reran");

rsx! {
    button {
        onclick: move |_| number += 1,
        "Increment"
    }
    p {
        if let Some(halved) = halved_resource() {
            "Halved: {halved}"
        } else {
            "Loading..."
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::UseResourceDemo {}
}
````

 > 
 > Note: The future you pass to `use_resource` must be cancel safe. Cancel safe futures are futures that can be stopped at any point without causing issues. For example, this task is not cancel safe:
 > 
 > ````rs@asynchronous.rs
 > static RESOURCES_RUNNING: GlobalSignal<HashSet<String>> = Signal::global(|| HashSet::new());
 > let mut breed = use_signal(|| "hound".to_string());
 > let dogs = use_resource(move || async move {
 >     // Modify some global state
 >     RESOURCES_RUNNING.write().insert(breed());
 > 
 >     // Wait for a future to finish. The resource may cancel
 >     // without warning if breed is changed while the future is running. If
 >     // it does, then the breed pushed to RESOURCES_RUNNING will never be popped
 >     let response = reqwest::Client::new()
 >         .get(format!("https://dog.ceo/api/breed/{breed}/images"))
 >         .send()
 >         .await?
 >         .json::<BreedResponse>()
 >         .await;
 > 
 >     // Restore some global state
 >     RESOURCES_RUNNING.write().remove(&breed());
 > 
 >     response
 > });
 > ````
 > 
 > ````inject-dioxus
 > DemoFrame {
 >     asynchronous::NotCancelSafe {}
 > }
 > ````
 > 
 > It can be fixed by making sure the global state is restored when the future is dropped:
 > 
 > ````rs@asynchronous.rs
 > static RESOURCES_RUNNING: GlobalSignal<HashSet<String>> = Signal::global(|| HashSet::new());
 > let mut breed = use_signal(|| "hound".to_string());
 > let dogs = use_resource(move || async move {
 >     // Modify some global state
 >     RESOURCES_RUNNING.write().insert(breed());
 > 
 >     // Automatically restore the global state when the future is dropped, even if
 >     // isn't finished
 >     struct DropGuard(String);
 >     impl Drop for DropGuard {
 >         fn drop(&mut self) {
 >             RESOURCES_RUNNING.write().remove(&self.0);
 >         }
 >     }
 >     let _guard = DropGuard(breed());
 > 
 >     // Wait for a future to finish. The resource may cancel
 >     // without warning if breed is changed while the future is running. If
 >     // it does, then it will be dropped and the breed will be popped
 >     reqwest::Client::new()
 >         .get(format!("https://dog.ceo/api/breed/{breed}/images"))
 >         .send()
 >         .await?
 >         .json::<BreedResponse>()
 >         .await
 > });
 > ````
 > 
 > ````inject-dioxus
 > DemoFrame {
 >     asynchronous::CancelSafe {}
 > }
 > ````
 > 
 > Async methods will often mention if they are cancel safe in their documentation.

## Unified Loading Views with suspense

`SuspenseBoundary` is a convenient way to bundle multiple async tasks into a single loading view. It accepts a loading closure and children. You can suspend tasks in children to pause rendering of that child until the future is finished. The suspense boundary will show the loading view instead of the children while any of its children are suspended. Once that suspense is resolved, it will show the children again.

We can use a suspense boundary to show a grid of different breeds of dogs without handling each loading state individually:

````rs@asynchronous.rs
fn DogGrid() -> Element {
    rsx! {
        SuspenseBoundary {
            // When any child components (like BreedGallery) are suspended, this closure will
            // be called and the loading view will be rendered instead of the children
            fallback: |_| rsx! {
                div {
                    width: "100%",
                    height: "100%",
                    display: "flex",
                    align_items: "center",
                    justify_content: "center",
                    "Loading..."
                }
            },
            div {
                display: "flex",
                flex_direction: "column",
                BreedGallery {
                    breed: "hound"
                }
                BreedGallery {
                    breed: "poodle"
                }
                BreedGallery {
                    breed: "beagle"
                }
            }
        }
    }
}

#[component]
fn BreedGallery(breed: ReadOnlySignal<String>) -> Element {
    let response = use_resource(move || async move {
        // Artificially slow down the request to make the loading indicator easier to seer
        gloo_timers::future::TimeoutFuture::new(1000).await;
        reqwest::Client::new()
            .get(format!("https://dog.ceo/api/breed/{breed}/images"))
            .send()
            .await?
            .json::<BreedResponse>()
            .await
    })
    // Calling .suspend()? will suspend the component and return early while the future is running
    .suspend()?;

    // Then you can just handle the happy path with the resolved future
    rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            match &*response.read() {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::DogGridView {}
}
````

If you need to change the loading view while a specific task is loading, you can provide a different loading view with the `with_loading_placeholder` method. The loading placeholder you return from the method will be passed to the suspense boundary and may choose to render it instead of the default loading view:

````rs@asynchronous.rs
fn DogGrid() -> Element {
    rsx! {
        SuspenseBoundary {
            // The fallback closure accepts a SuspenseContext which contains
            // information about the suspended component
            fallback: |suspense_context: SuspenseContext| if let Some(view) = suspense_context.suspense_placeholder() {
                view
            } else {
                rsx! {
                    div {
                        width: "100%",
                        height: "100%",
                        display: "flex",
                        align_items: "center",
                        justify_content: "center",
                        "Loading..."
                    }
                }
            },
            div {
                display: "flex",
                flex_direction: "column",
                BreedGallery {
                    breed: "hound"
                }
                BreedGallery {
                    breed: "poodle"
                }
                BreedGallery {
                    breed: "beagle"
                }
            }
        }
    }
}

#[component]
fn BreedGallery(breed: ReadOnlySignal<String>) -> Element {
    let response = use_resource(move || async move {
        gloo_timers::future::TimeoutFuture::new(breed().len() as u32 * 100).await;
        reqwest::Client::new()
            .get(format!("https://dog.ceo/api/breed/{breed}/images"))
            .send()
            .await?
            .json::<BreedResponse>()
            .await
    })
    .suspend()
    // You can pass up a loading placeholder to the nearest SuspenseBoundary
    // with the with_loading_placeholder method
    .with_loading_placeholder(move || {
        rsx! {
            div {
                width: "100%",
                height: "100%",
                display: "flex",
                align_items: "center",
                justify_content: "center",
                "Loading {breed}..."
            }
        }
    })?;

    // Then you can just handle the happy path with the resolved future
    rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            match &*response.read() {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::DogGridViewWithLoadingPlaceholder {}
}
````

## Suspense with Fullstack

To use suspense in your fullstack application, you need to use the `use_server_future` hook instead of `use_resource`. `use_server_future` handles serialization of the result of the future for hydration. It will also suspend automatically, so you don't need to call `.suspend()` on the future.

````rs@asynchronous.rs
#[component]
fn BreedGallery(breed: ReadOnlySignal<String>) -> Element {
    // use_server_future is very similar to use_resource, but the value returned from the future
    // must implement Serialize and Deserialize and it is automatically suspended
    let response = use_server_future(move || async move {
        // The future will run on the server during SSR and then get sent to the client
        reqwest::Client::new()
            .get(format!("https://dog.ceo/api/breed/{breed}/images"))
            .send()
            .await
            // reqwest::Result does not implement Serialize, so we need to map it to a string which
            // can be serialized
            .map_err(|err| err.to_string())?
            .json::<BreedResponse>()
            .await
            .map_err(|err| err.to_string())
        // use_server_future calls `suspend` internally, so you don't need to call it manually, but you
        // do need to bubble up the suspense variant with `?`
    })?;

    // If the future was still pending, it would have returned suspended with the `?` above
    // we can unwrap the None case here to get the inner result
    let response_read = response.read();
    let response = response_read.as_ref().unwrap();

    // Then you can just handle the happy path with the resolved future
    rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            match response {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::DogGridFullstack {}
}
````

Unlike `use_resource`, `use_server_future` is only reactive in the closure, not the future itself. If you need to subscribe to another reactive value, you need to read it in the closure before passing it to the future:

````rs@asynchronous.rs
let id = use_signal(|| 0);
// âŒ The future inside of use_server_future is not reactive
use_server_future(move || {
    async move {
        // But the future is not reactive which means that the future will not subscribe to any reads here
        println!("{id}");
    }
});
// âœ… The closure that creates the future for use_server_future is reactive
use_server_future(move || {
    // The closure itself is reactive which means the future will subscribe to any signals you read here
    let cloned_id = id();
    async move {
        // But the future is not reactive which means that the future will not subscribe to any reads here
        println!("{cloned_id}");
    }
});
````

When you use suspense with fullstack without streaming enabled, dioxus will wait until all suspended futures are resolved before sending the resolved html to the client. If you [enable](https://docs.rs/dioxus/0.6.2/dioxus/prelude/struct.ServeConfigBuilder.html#method.enable_out_of_order_streaming) out of order streaming, dioxus will send the finished HTML chunks to the client one at a time as they are resolved:

````rs@asynchronous.rs
fn main() {
    dioxus::LaunchBuilder::new()
        .with_cfg(server_only! {
            // Enable out of order streaming during SSR
            dioxus::fullstack::ServeConfig::builder().enable_out_of_order_streaming()
        })
        .launch(DogGrid);
}
````

![Out of order streaming](/assets/06_docs/streaming_dogs.mp4)

## Conclusion

This guide has covered the basics of asynchronous tasks in Dioxus. More detailed documentation about specific hooks are available in docs.rs:

* [use_resource](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_resource.html)
* [use_server_future](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_server_future.html)
* [SuspenseBoundary](https://docs.rs/dioxus/latest/dioxus/prelude/fn.SuspenseBoundary.html)
* [spawn](https://docs.rs/dioxus/latest/dioxus/prelude/fn.spawn.html)
* [spawn_forever](https://docs.rs/dioxus/latest/dioxus/prelude/fn.spawn_forever.html)

More examples of futures and asynchronous tasks are available in the [example folder](https://github.com/DioxusLabs/dioxus/tree/v0.6/examples) in the dioxus repo.
# Breaking Out of Dioxus

Dioxus makes it easy to build reactive user interfaces. However, there are some cases where you may need to break out of the reactive paradigm to interact with the DOM directly.

## Interacting with JavaScript with `eval` and `web-sys`

Dioxus exposes a limited number of [web apis](https://developer.mozilla.org/en-US/docs/Web/API) with a nicer interface. If you need access to more APIs, you can use the `eval` function to run JavaScript in the browser.

For example, you can use the eval function to read the domain of the current page:

````rs@breaking_out.rs
pub fn Eval() -> Element {
    let mut domain = use_signal(String::new);
    rsx! {
        button {
            // When you click the button, some javascript will run in the browser
            // to read the domain and set the signal
            onclick: move |_| async move {
                domain.set(document::eval("return document.domain").await.unwrap().to_string());
            },
            "Read Domain"
        }
        "Current domain: {domain}"
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::Eval {}
}
````

If you are only targeting web, you can also use the [`web-sys`](https://crates.io/crates/web-sys) crate for typed access to the web APIs. Here is what reading the domain looks like with web-sys:

````rs@breaking_out.rs
use ::web_sys::window;
use wasm_bindgen::JsCast;
pub fn WebSys() -> Element {
    let mut domain = use_signal(String::new);
    rsx! {
        button {
            // When you click the button, we use web-sys to read the domain and a signal
            onclick: move |_| {
                domain
                    .set(
                        window()
                            .unwrap()
                            .document()
                            .unwrap()
                            .dyn_into::<::web_sys::HtmlDocument>()
                            .unwrap()
                            .domain(),
                    );
            },
            "Read Domain"
        }
        "Current domain: {domain}"
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::WebSys {}
}
````

## Synchronizing DOM updates with `use_effect`

If you do need to interact with the DOM directly, you should do so in a `use_effect` hook. This hook will run after the component is rendered and all of the Dioxus UI has been rendered. You can read or modify the DOM in this hook.

For example, you can use the `use_effect` hook to write to a canvas element after it is created:

````rs@breaking_out.rs
pub fn Canvas() -> Element {
    let mut count = use_signal(|| 0);

    use_effect(move || {
        // Effects are reactive like memos, and resources. If you read a value inside the effect, the effect will rerun when that value changes
        let count = count.read();

        // You can use the count value to update the DOM manually
        document::eval(&format!(
            r#"var c = document.getElementById("dioxus-canvas");
var ctx = c.getContext("2d");
ctx.clearRect(0, 0, c.width, c.height);
ctx.font = "30px Arial";
ctx.fillText("{count}", 10, 50);"#
        ));
    });

    rsx! {
        button {
            // When you click the button, count will be incremented and the effect will rerun
            onclick: move |_| count += 1,
            "Increment"
        }
        canvas { id: "dioxus-canvas" }
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::Canvas {}
}
````

## Getting access to elements with `onmounted`

If you need a handle to an element that is rendered by dioxus, you can use the `onmounted` event. This event will fire after the element is first mounted to the DOM. It returns a live reference to the element with some methods to interact with it.

You can use the onmounted event to do things like focus or scroll to an element after it is rendered:

````rs@breaking_out.rs
pub fn OnMounted() -> Element {
    let mut input_element = use_signal(|| None);

    rsx! {
        div { height: "100px",
            button {
                class: "focus:outline-2 focus:outline-blue-600 focus:outline-dashed",
                // The onmounted event will run the first time the button element is mounted
                onmounted: move |element| input_element.set(Some(element.data())),
                "First button"
            }

            button {
                // When you click the button, if the button element has been mounted, we focus to that element
                onclick: move |_| async move {
                    if let Some(header) = input_element() {
                        let _ = header.set_focus(true).await;
                    }
                },
                "Focus first button"
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::OnMounted {}
}
````

## Down casting web sys events

Dioxus provides platform agnostic wrappers over each event type. These wrappers are often nicer to interact with than the raw event types, but they can be more limited. If you are targeting web, you can downcast the event with the `as_web_event` method to get the underlying web-sys event:

````rs@breaking_out.rs
pub fn Downcast() -> Element {
    let mut event_text = use_signal(|| 0);

    rsx! {
        div {
            onmousemove: move |event| {
                #[cfg(feature = "web")]
                {
                    use dioxus::web::WebEventExt;
                    event_text.set(event.as_web_event().movement_x());
                }
            },
            "movement_x was {event_text}"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::Downcast {}
}
````
# Error handling

A selling point of Rust for web development is the reliability of always knowing where errors can occur and being forced to handle them. Dioxus provides ErrorBoundarys to help you handle errors in a declarative way. This guide will teach you how to use ErrorBoundaries and other error handling strategies in Dioxus.

## Returning Errors from Components

Astute observers might have noticed that `Element` is actually a type alias for `Result<VNode, RenderError>`. The `RenderError` type can be created from an error type that implements `Error`. You can use `?` to bubble up any errors you encounter while rendering to the nearest error boundary:

````rs@error_handling.rs
#[component]
fn ThrowsError() -> Element {
    // You can return any type that implements `Error`
    let number: i32 = use_hook(|| "1.234").parse()?;

    todo!()
}
````

## Capturing errors with ErrorBoundaries

When you return an error from a component, it gets sent to the nearest error boundary. That error boundary can then handle the error and render a fallback UI with the handle_error closure:

````rs@error_handling.rs
#[component]
fn Parent() -> Element {
    rsx! {
        ErrorBoundary {
            // The error boundary accepts a closure that will be rendered when an error is thrown in any
            // of the children
            handle_error: |_| {
                rsx! { "Oops, we encountered an error. Please report this to the developer of this application" }
            },
            ThrowsError {}
        }
    }
}
````

## Throwing Errors from Event Handlers

In addition to components, you can throw errors from event handlers. If you throw an error from an event handler, it will bubble up to the nearest error boundary just like a component:

````rs@error_handling.rs
#[component]
fn ThrowsError() -> Element {
    rsx! {
        button {
            onclick: move |_| {
                // Event handlers can return errors just like components
                let number: i32 = "1...234".parse()?;

                tracing::info!("Parsed number: {number}");

                Ok(())
            },
            "Throw error"
        }
    }
}
````

## Adding context to errors

You can add additional context to your errors with the [`Context`](https://docs.rs/dioxus/0.6/dioxus/prelude/trait.Context.html) trait. Calling `context` on a `Result` will add the context to the error variant of the `Result`:

````rs@error_handling.rs
#[component]
fn ThrowsError() -> Element {
    // You can call the context method on results to add more information to the error
    let number: i32 = use_hook(|| "1.234")
        .parse()
        .context("Failed to parse name")?;

    todo!()
}
````

If you need some custom UI for the error message, you can call `show` on a result to attach an Element to the error variant. The parent error boundary can choose to render this element instead of the default error message:

````rs@error_handling.rs
#[component]
fn Parent() -> Element {
    rsx! {
        ErrorBoundary {
            // The error boundary accepts a closure that will be rendered when an error is thrown in any
            // of the children
            handle_error: |error: ErrorContext| {
                if let Some(error_ui) = error.show() {
                    rsx! {
                        {error_ui}
                    }
                } else {
                    rsx! {
                        div {
                            "Oops, we encountered an error. Please report this to the developer of this application"
                        }
                    }
                }
            },
            ThrowsError {}
        }
    }
}
````

## Local Error Handling

If you need more fine-grained control over error states, you can store errors in reactive hooks and use them just like any other value. For example, if you need to show a phone number validation error, you can store the error in a memo and show it below the input field if it is invalid:

````rs@error_handling.rs
#[component]
pub fn PhoneNumberValidation() -> Element {
    let mut phone_number = use_signal(|| String::new());
    let parsed_phone_number = use_memo(move || phone_number().parse::<PhoneNumber>());

    rsx! {
        input {
            class: "border border-gray-300 rounded-md p-2 mb-4",
            placeholder: "Phone number",
            value: "{phone_number}",
            oninput: move |e| {
                phone_number.set(e.value());
            },
        }

        match parsed_phone_number() {
            Ok(phone_number) => rsx! {
                div {
                    "Parsed phone number: {phone_number}"
                }
            },
            Err(error) => rsx! {
                div {
                    "Phone number is invalid: {error}"
                }
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    error_handling::PhoneNumberValidation {}
}
````
# Dioxus Guides

These guides contain more detailed explanations for some concepts covered in the [`guide`](../guide/index.md) and more.

## State

* [Rules of hooks](rules_of_hooks.md) Overview of the rules of hooks

## Assets

* [`Assets`](assets.md) Overview of how to include assets in your application

## Platforms

* [`Desktop`](desktop/index.md) Overview of desktop specific APIS
* [`Web`](web/index.md) Overview of web specific APIS
* [`Fullstack`](fullstack/index.md) Overview of Fullstack specific APIS
  * [`Server Functions`](fullstack/server_functions.md) Server functions make it easy to communicate between your server and client
  * [`Extractors`](fullstack/extractors.md) Extractors allow you to get extra information out of the headers of a request
  * [`Middleware`](fullstack/middleware.md) Middleware allows you to wrap a server function request or response
  * [`Authentication`](fullstack/authentication.md) An overview of how to handle authentication with server functions
  * [`Routing`](fullstack/routing.md) An overview of how to work with the router in the fullstack renderer
* [`SSR`](ssr.md) Overview of the SSR renderer
# The Rules of Hooks

Hooks are a powerful way to manage state in Dioxus, but there are some rules you need to follow to ensure they work as expected. Dioxus uses the order you call hooks to differentiate between hooks. Because the order you call hooks matters, you must follow these rules:

1. Hooks may be only used in components or other hooks (we'll get to that later)
1. On every call to the component function
   1. The same hooks must be called
   1. In the same order
1. Hooks name's should start with `use_` so you don't accidentally confuse them with regular functions

These rules mean that there are certain things you can't do with hooks:

#### No Hooks in Conditionals

````rs@hooks_bad.rs
// âŒ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy && you_know_it {
    let something = use_signal(|| "hands");
    println!("clap your {something}")
}

// âœ… instead, *always* call use_signal
// You can put other stuff in the conditional though
let something = use_signal(|| "hands");
if you_are_happy && you_know_it {
    println!("clap your {something}")
}
````

#### No Hooks in Closures

````rs@hooks_bad.rs
// âŒ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
    let b = use_signal(|| 0);
    b()
};

// âœ… instead, move hook `b` outside
let b = use_signal(|| 0);
let _a = || b();
````

#### No Hooks in Loops

````rs@hooks_bad.rs
// `names` is a Vec<&str>

// âŒ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &names {
    let is_selected = use_signal(|| false);
    println!("selected: {is_selected}");
}

// âœ… Instead, use a hashmap with use_signal
let selection_map = use_signal(HashMap::<&str, bool>::new);

for name in &names {
    let is_selected = selection_map.read()[name];
    println!("selected: {is_selected}");
}
````
# Introduction

 > 
 > If you are not familiar with Dioxus itself, check out the [Dioxus guide](../guide/index.md) first.

Whether you are building a website, desktop app, or mobile app, splitting your app's views into "pages" can be an effective method for organization and maintainability.

For this purpose, Dioxus provides a router. Use the `cargo add` command to add the dependency:

````sh
cargo add dioxus --features router
````

Then, add this to your `Dioxus.toml` (learn more about configuration [here](../CLI/configure)):

````toml
[web.watcher]
index_on_404 = true
````

 > 
 > This configuration only works when using `dx serve`. If you host your app in a different way (which you most likely do in production), you need to find out how to add a fallback 404 page to your app, and make it a copy of the generated `dist/index.html`.

This will instruct `dx serve` to redirect any unknown route to the index, to then be resolved by the router.
The router works on the client. If we connect through the index route (e.g., `localhost:8080`, then click a link to go to `localhost:8080/contact`), the app renders the new route without reloading.
However, when we go to a route *before* going to the index (go straight to `localhost:8080/contact`), we are trying to access a static route from the server, but the only static route on our server is the index (because the Dioxus frontend is a Single Page Application) and it will fail unless we redirect all missing routes to the index.

This book is intended to get you up to speed with Dioxus Router. It is split
into two sections:

1. The [reference](reference/index.md) section explains individual features in
   depth. You can read it from start to finish, or you can read individual chapters
   in whatever order you want.
1. If you prefer a learning-by-doing approach, you can check out the
   *[example project](example/index.md)*. It guides you through
   creating a dioxus app, setting up the router, and using some of its
   functionality.

 > 
 > Please note that this is not the only documentation for the Dioxus Router. You can also check out the [API Docs](https://docs.rs/dioxus-router/).
# Overview

In this guide, you'll learn to effectively use Dioxus Router whether you're
building a small todo app or the next FAANG company. We will create a small
website with a blog, homepage, and more!

 > 
 > To follow along with the router example, you'll need a working Dioxus app.
 > Check out the [Dioxus book](https://dioxuslabs.com/learn/0.6/getting_started) to get started.

 > 
 > Make sure to add Dioxus Router as a dependency, as explained in the
 > [introduction](../index.md).

## You'll learn how to

* Create routes and render "pages".
* Utilize nested routes, create a navigation bar, and render content for a
  set of routes.
* Parse URL parameters to dynamically display content.
* Redirect visitors to different routes.

 > 
 > **Disclaimer**
 > 
 > The example will only display the features of Dioxus Router. It will not
 > include any actual functionality. To keep things simple we will only be using
 > a single file, this is not the recommended way of doing things with a real
 > application.

You can find the complete application in the [full code](full-code.md) chapter.
# Creating Our First Route

In this chapter, we will start utilizing Dioxus Router and add a homepage and a
404 page to our project.

## Fundamentals

The core of the Dioxus Router is the [`Routable`] macro and the [`Router`] component.

Routable is a trait for anything that can:

* Be parsed from a URL
* Be turned into a URL
* Be rendered as to a Element

Let's create a new router. First, we need an actual page to route to! Let's add a homepage component:

````rs@first_route.rs
#[component]
fn Home() -> Element {
    rsx! { h1 { "Welcome to the Dioxus Blog!" } }
}
````

## Creating Routes

We want to use Dioxus Router to separate our application into different "pages".
Dioxus Router will then determine which page to render based on the URL path.

To start using Dioxus Router, we need to use the [`Routable`] macro.

The [`Routable`] macro takes an enum with all of the possible routes in our application. Each variant of the enum represents a route and must be annotated with the `#[route(path)]` attribute.

````rs@first_route.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route("/")]
    Home {},
}
````

The [`Router`] component will provide a router context for all the inner components and hooks to use. You usually will want to place this at the top of your components tree.

````rs@first_route.rs
fn App() -> Element {
    rsx! { Router::<Route> {} }
}
````

If you head to your application's browser tab, you should now see the text
`Welcome to Dioxus Blog!` when on the root URL (`http://localhost:8080/`). If
you enter a different path for the URL, nothing should be displayed.

This is because we told Dioxus Router to render the `Home` component only when
the URL path is `/`.

## Fallback Route

In our example, when a route doesn't exist Dioxus Router doesn't render anything. Many sites also have a "404" page when a path does not exist. Let's add one to our site.

First, we create a new `PageNotFound` component.

````rs@catch_all.rs
#[component]
fn PageNotFound(route: Vec<String>) -> Element {
    rsx! {
        h1 { "Page not found" }
        p { "We are terribly sorry, but the page you requested doesn't exist." }
        pre { color: "red", "log:\nattemped to navigate to: {route:?}" }
    }
}
````

Next, register the route in the Route enum to match if all other routes fail.

````rs@catch_all.rs
#[derive(Routable, Clone)]
enum Route {
    #[route("/")]
    Home {},
    // PageNotFound is a catch all route that will match any route and placing the matched segments in the route field
    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}
````

Now when you go to a route that doesn't exist, you should see the page not found
text.

## Conclusion

In this chapter, we learned how to create a route and tell Dioxus Router what
component to render when the URL path is `/`. We also created a 404 page to
handle when a route doesn't exist. Next, we'll create the blog portion of our
site. We will utilize nested routes and URL parameters.
# Building a Nest

In this chapter, we will begin to build the blog portion of our site which will
include links, nested routes, and route parameters.

## Site Navigation

Our site visitors won't know all the available pages and blogs on our site so we
should provide a navigation bar for them. Our navbar will be a list of links going between our pages.

We want our navbar component to be rendered on several different pages on our site. Instead of duplicating the code, we can create a component that wraps all children routes. This is called a layout component. To tell the router where to render the child routes, we use the [`Outlet`](https://docs.rs/dioxus-router/latest/dioxus_router/components/fn.Outlet.html) component.

Let's create a new `NavBar` component:

````rs@nested_routes.rs
#[component]
fn NavBar() -> Element {
    rsx! {
        nav {
            ul { li { "links" } }
        }
        // The Outlet component will render child routes (In this case just the Home component) inside the Outlet component
        Outlet::<Route> {}
    }
}
````

Next, let's add our `NavBar` component as a layout to our Route enum:

````rs@nested_routes.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // All routes under the NavBar layout will be rendered inside of the NavBar Outlet
    #[layout(NavBar)]
        #[route("/")]
        Home {},
    #[end_layout]
    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}
````

To add links to our `NavBar`, we could always use an HTML anchor element but that has two issues:

1. It causes a full-page reload
1. We can accidentally link to a page that doesn't exist

Instead, we want to use the [`Link`] component provided by Dioxus Router.

The [`Link`] is similar to a regular `<a>` tag. It takes a target and children.

Unlike a regular `<a>` tag, we can pass in our Route enum as the target. Because we annotated our routes with the `#[route(path)]` attribute, the [`Link`] will know how to generate the correct URL. If we use the Route enum, the rust compiler will prevent us from linking to a page that doesn't exist.

Let's add our links:

````rs@links.rs
#[component]
fn NavBar() -> Element {
    rsx! {
        nav {
            Link { to: Route::Home {}, "Home" }
        }
        Outlet::<Route> {}
    }
}
````

 > 
 > Using this method, the [`Link`] component only works for links within our
 > application. To learn more about navigation targets see
 > [here](./navigation-targets.md).

Now you should see a list of links near the top of your page. Click on one and
you should seamlessly travel between pages.

## URL Parameters and Nested Routes

Many websites such as GitHub put parameters in their URL. For example,
`https://github.com/DioxusLabs` utilizes the text after the domain to
dynamically search and display content about an organization.

We want to store our blogs in a database and load them as needed. We also
want our users to be able to send people a link to a specific blog post.
Instead of listing all of the blog titles at compile time, we can make a dynamic route.

We could utilize a search page that loads a blog when clicked but then our users
won't be able to share our blogs easily. This is where URL parameters come in.

The path to our blog will look like `/blog/myBlogPage`, `myBlogPage` being the
URL parameter.

First, let's create a layout component (similar to the navbar) that wraps the blog content. This allows us to add a heading that tells the user they are on the blog.

````rs@dynamic_route.rs
#[component]
fn Blog() -> Element {
    rsx! {
        h1 { "Blog" }
        Outlet::<Route> {}
    }
}
````

Now we'll create another index component, that'll be displayed when no blog post
is selected:

````rs@dynamic_route.rs
#[component]
fn BlogList() -> Element {
    rsx! {
        h2 { "Choose a post" }
        ul {
            li {
                Link {
                    to: Route::BlogPost {
                        name: "Blog post 1".into(),
                    },
                    "Read the first blog post"
                }
            }
            li {
                Link {
                    to: Route::BlogPost {
                        name: "Blog post 2".into(),
                    },
                    "Read the second blog post"
                }
            }
        }
    }
}
````

We also need to create a component that displays an actual blog post. This component will accept the URL parameters as props:

````rs@dynamic_route.rs
// The name prop comes from the /:name route segment
#[component]
fn BlogPost(name: String) -> Element {
    rsx! { h2 { "Blog Post: {name}" } }
}
````

Finally, let's tell our router about those components:

````rs@dynamic_route.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
            #[route("/")]
            BlogList {},
            #[route("/post/:name")]
            BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
````

That's it! If you head to `/blog/1` you should see our sample post.

## Conclusion

In this chapter, we utilized Dioxus Router's Link, and Route Parameter
functionality to build the blog portion of our application. In the next chapter,
we will go over how navigation targets (like the one we passed to our links)
work.
# Navigation Targets

In the previous chapter, we learned how to create links to pages within our app.
We told them where to go using the `target` property. This property takes something that can be converted to a [`NavigationTarget`].

## What is a navigation target?

A [`NavigationTarget`] is similar to the `href` of an HTML anchor element. It
tells the router where to navigate to. The Dioxus Router knows two kinds of
navigation targets:

* [`Internal`]: We used internal links in the previous chapter. It's a link to a page within our
  app represented as a Route enum.
* [`External`]: This works exactly like an HTML anchors' `href`. Don't use this for in-app
  navigation as it will trigger a page reload by the browser.

## External navigation

If we need a link to an external page we can do it like this:

````rs@external_link.rs
fn GoToDioxus() -> Element {
    rsx! {
        Link { to: "https://dioxuslabs.com", "ExternalTarget target" }
    }
}
````
# Redirection Perfection

You're well on your way to becoming a routing master!

In this chapter, we will cover creating redirects

## Creating Redirects

A redirect is very simple. When dioxus encounters a redirect while finding out
what components to render, it will redirect the user to the target of the
redirect.

As a simple example, let's say you want user to still land on your blog, even
if they used the path `/myblog` or `/myblog/:name`.

Redirects are special attributes in the router enum that accept a route and a closure
with the route parameters. The closure should return a route to redirect to.

Let's add a redirect to our router enum:

````rs@full_example.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
                #[route("/")]
                BlogList {},
                #[route("/post/:name")]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest("/myblog")]
        #[redirect("/", || Route::BlogList {})]
        #[redirect("/:name", |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
````

That's it! Now your users will be redirected to the blog.

### Conclusion

Well done! You've completed the Dioxus Router guide. You've built a small
application and learned about the many things you can do with Dioxus Router.
To continue your journey, you attempt a challenge listed below, look at the [router examples](https://github.com/DioxusLabs/dioxus/tree/main/packages/router/examples), or
the [API reference](https://docs.rs/dioxus-router/).

### Challenges

* Organize your components into separate files for better maintainability.
* Give your app some style if you haven't already.
* Build an about page so your visitors know who you are.
* Add a user system that uses URL parameters.
* Create a simple admin system to create, delete, and edit blogs.
* If you want to go to the max, hook up your application to a rest API and database.
# Full Code

````rs@full_example.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;

// ANCHOR: router
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
                #[route("/")]
                BlogList {},
                #[route("/post/:name")]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest("/myblog")]
        #[redirect("/", || Route::BlogList {})]
        #[redirect("/:name", |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
// ANCHOR_END: router

pub fn App() -> Element {
    rsx! { Router::<Route> {} }
}

#[component]
fn NavBar() -> Element {
    rsx! {
        nav {
            Link { to: Route::Home {}, "Home" }
            Link { to: Route::BlogList {}, "Blog" }
        }
        Outlet::<Route> {}
    }
}

#[component]
fn Home() -> Element {
    rsx! { h1 { "Welcome to the Dioxus Blog!" } }
}

#[component]
fn Blog() -> Element {
    rsx! {
        h1 { "Blog" }
        Outlet::<Route> {}
    }
}

#[component]
fn BlogList() -> Element {
    rsx! {
        h2 { "Choose a post" }
        ul {
            li {
                Link {
                    to: Route::BlogPost {
                        name: "Blog post 1".into(),
                    },
                    "Read the first blog post"
                }
            }
            li {
                Link {
                    to: Route::BlogPost {
                        name: "Blog post 2".into(),
                    },
                    "Read the second blog post"
                }
            }
        }
    }
}

#[component]
fn BlogPost(name: String) -> Element {
    rsx! { h2 { "Blog Post: {name}" } }
}

#[component]
fn PageNotFound(route: Vec<String>) -> Element {
    rsx! {
        h1 { "Page not found" }
        p { "We are terribly sorry, but the page you requested doesn't exist." }
        pre { color: "red", "log:\nattemped to navigate to: {route:?}" }
    }
}

````
# Adding the router to your application

In this chapter, we will learn how to add the router to our app. By itself, this
is not very useful. However, it is a prerequisite for all the functionality
described in the other chapters.

 > 
 > Make sure you added the `dioxus-router` dependency as explained in the
 > [introduction](../index.md).

In most cases, we want to add the router to the root component of our app. This
way, we can ensure that we have access to all its functionality everywhere.

First, we define the router with the router macro:

````rs@first_route.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route("/")]
    Home {},
}
````

Then we render the router with the \[`Router`\] component.

````rs@first_route.rs
fn App() -> Element {
    rsx! { Router::<Route> {} }
}
````
# Defining Routes

When creating a \[`Routable`\] enum, we can define routes for our application using the `route("path")` attribute.

## Route Segments

Each route is made up of segments. Most segments are separated by `/` characters in the path.

There are four fundamental types of segments:

1. [Static segments](#static-segments) are fixed strings that must be present in the path.
1. [Dynamic segments](#dynamic-segments) are types that can be parsed from a segment.
1. [Catch-all segments](#catch-all-segments) are types that can be parsed from multiple segments.
1. [Query segments](#query-segments) are types that can be parsed from the query string.

Routes are matched:

* First, from most specific to least specific (Static then Dynamic then Catch All) (Query is always matched)
* Then, if multiple routes match the same path, the order in which they are defined in the enum is followed.

## Static segments

Fixed routes match a specific path. For example, the route `#[route("/about")]` will match the path `/about`.

````rs@static_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // Routes always start with a slash
    #[route("/")]
    Home {},
    // You can have multiple segments in a route
    #[route("/hello/world")]
    HelloWorld {},
}

#[component]
fn Home() -> Element {
    todo!()
}

#[component]
fn HelloWorld() -> Element {
    todo!()
}
````

## Dynamic Segments

Dynamic segments are in the form of `:name` where `name` is
the name of the field in the route variant. If the segment is parsed
successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromStr`.

````rs@dynamic_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with : are dynamic segments
    #[route("/post/:name")]
    BlogPost {
        // You must include dynamic segments in child variants
        name: String,
    },

    #[route("/document/:id")]
    Document {
        // You can use any type that implements FromStr
        // If the segment can't be parsed, the route will not match
        id: usize,
    },
}

// Components must contain the same dynamic segments as their corresponding variant
#[component]
fn BlogPost(name: String) -> Element {
    todo!()
}

#[component]
fn Document(id: usize) -> Element {
    todo!()
}
````

## Catch All Segments

Catch All segments are in the form of `:..name` where `name` is the name of the field in the route variant. If the segments are parsed successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromSegments`. (`Vec<String>` implements this by default)

Catch All segments must be the *last route segment* in the path (query segments are not counted) and cannot be included in nests.

````rs@catch_all_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with :.. are catch all segments
    #[route("/blog/:..segments")]
    BlogPost {
        // You must include catch all segment in child variants
        segments: Vec<String>,
    },
}

// Components must contain the same catch all segments as their corresponding variant
#[component]
fn BlogPost(segments: Vec<String>) -> Element {
    todo!()
}
````

## Query Segments

Query segments are in the form of `?:name&:othername` where `name` and `othername` are the names of fields in the route variant.

Unlike [Dynamic Segments](#dynamic-segments) and [Catch All Segments](#catch-all-segments), parsing a Query segment must not fail.

The segment can be of any type that implements `FromQueryArgument`.

Query segments must be the *after all route segments* and cannot be included in nests.

````rs@query_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with ?: are query segments
    #[route("/blog?:name&:surname")]
    BlogPost {
        // You must include query segments in child variants
        name: String,
        surname: String,
    },
}

#[component]
fn BlogPost(name: String, surname: String) -> Element {
    rsx! {
        div { "This is your blogpost with a query segment:" }
        div { "Name: {name}" }
        div { "Surname: {surname}" }
    }
}

fn App() -> Element {
    rsx! { Router::<Route> {} }
}

fn main() {}
````
# Nested Routes

When developing bigger applications we often want to nest routes within each
other. As an example, we might want to organize a settings menu using this
pattern:

````plain
â”” Settings
  â”œ General Settings (displayed when opening the settings)
  â”œ Change Password
  â”” Privacy Settings
````

We might want to map this structure to these paths and components:

````plain
/settings		  -> Settings { GeneralSettings }
/settings/password -> Settings { PWSettings }
/settings/privacy  -> Settings { PrivacySettings }
````

Nested routes allow us to do this without repeating /settings in every route.

## Nesting

To nest routes, we use the `#[nest("path")]` and `#[end_nest]` attributes.

The path in nest must not:

1. Contain a [Catch All Segment](index.md#catch-all-segments)
1. Contain a [Query Segment](index.md#query-segments)

If you define a dynamic segment in a nest, it will be available to all child routes and layouts.

To finish a nest, we use the `#[end_nest]` attribute or the end of the enum.

````rs@nest.rs
#[derive(Routable, Clone)]
// Skipping formatting allows you to indent nests
#[rustfmt::skip]
enum Route {
    // Start the /blog nest
    #[nest("/blog")]
        // You can nest as many times as you want
        #[nest("/:id")]
            #[route("/post")]
            PostId {
                // You must include parent dynamic segments in child variants
                id: usize,
            },
        // End nests manually with #[end_nest]
        #[end_nest]
        #[route("/:id")]
        // The absolute route of BlogPost is /blog/:name
        BlogPost {
            id: usize,
        },
    // Or nests are ended automatically at the end of the enum
}

#[component]
fn BlogPost(id: usize) -> Element {
    todo!()
}

#[component]
fn PostId(id: usize) -> Element {
    todo!()
}
````
# Layouts

Layouts allow you to wrap all child routes in a component. This can be useful when creating something like a header that will be used in many different routes.

[`Outlet`] tells the router where to render content in layouts. In the following example,
the Index will be rendered within the [`Outlet`].

This page is built with Dioxus. It uses Layouts in several different places. Here is an outline of how layouts are used on the current page:

````inject-dioxus
LayoutsExplanation {}
````

Here is a more complete example of a layout wrapping the body of a page.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/")]
        Index {},
}

#[component]
fn Wrapper() -> Element {
    rsx! {
        header { "header" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index() -> Element {
    rsx! { h1 { "Index" } }
}
````

The example above will output the following HTML (line breaks added for
readability):

````html
<header>header</header>
<h1>Index</h1>
<footer>footer</footer>
````

## Layouts with dynamic segments

You can combine layouts with [nested routes](./routes/nested.md) to create dynamic layouts with content that changes based on the current route.

Just like routes, layouts components must accept a prop for each dynamic segment in the route. For example, if you have a route with a dynamic segment like `/:name`, your layout component must accept a `name` prop:

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[nest("/:name")]
        #[layout(Wrapper)]
            #[route("/")]
            Index {
                name: String,
            },
}

#[component]
fn Wrapper(name: String) -> Element {
    rsx! {
        header { "Welcome {name}!" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index(name: String) -> Element {
    rsx! { h1 { "This is a homepage for {name}" } }
}
````

Or to get the full route, you can use the `use_route` hook.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/:name")]
        Index {
            name: String,
        },
}

#[component]
fn Wrapper() -> Element {
    let full_route = use_route::<Route>();
    rsx! {
        header { "Welcome to {full_route}!" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index(name: String) -> Element {
    rsx! { h1 { "This is a homepage for {name}" } }
}
````
# Links & Navigation

When we split our app into pages, we need to provide our users with a way to
navigate between them. On regular web pages, we'd use an anchor element for that,
like this:

````html
<a href="/other">Link to an other page</a>
````

However, we cannot do that when using the router for three reasons:

1. Anchor tags make the browser load a new page from the server. This takes a
   lot of time, and it is much faster to let the router handle the navigation
   client-side.
1. Navigation using anchor tags only works when the app is running inside a
   browser. This means we cannot use them inside apps using Dioxus Desktop.
1. Anchor tags cannot check if the target page exists. This means we cannot
   prevent accidentally linking to non-existent pages.

To solve these problems, the router provides us with a \[`Link`\] component we can
use like this:

````rs@links.rs
#[component]
fn NavBar() -> Element {
    rsx! {
        nav {
            Link { to: Route::Home {}, "Home" }
        }
        Outlet::<Route> {}
    }
}
````

The `target` in the example above is similar to the `href` of a regular anchor
element. However, it tells the router more about what kind of navigation it
should perform. It accepts something that can be converted into a
\[`NavigationTarget`\]:

* The example uses a Internal route. This is the most common type of navigation.
  It tells the router to navigate to a page within our app by passing a variant of a \[`Routable`\] enum. This type of navigation can never fail if the link component is used inside a router component.
* \[`External`\] allows us to navigate to URLs outside of our app. This is useful
  for links to external websites. NavigationTarget::External accepts an URL to navigate to. This type of navigation can fail if the URL is invalid.

 > 
 > The \[`Link`\] accepts several props that modify its behavior. See the API docs
 > for more details.
# Programmatic Navigation

Sometimes we want our application to navigate to another page without having the
user click on a link. This is called programmatic navigation.

## Using a Navigator

We can get a navigator with the [`navigator`] function which returns a [`Navigator`].

We can use the [`Navigator`] to trigger four different kinds of navigation:

* `push` will navigate to the target. It works like a regular anchor tag.
* `replace` works like `push`, except that it replaces the current history entry
  instead of adding a new one. This means the prior page cannot be restored with the browser's back button.
* `Go back` works like the browser's back button.
* `Go forward` works like the browser's forward button.

````rs@navigator.rs
#[component]
fn Home() -> Element {
    let nav = navigator();

    // push
    nav.push(Route::PageNotFound { route: vec![] });

    // replace
    nav.replace(Route::Home {});

    // go back
    nav.go_back();

    // go forward
    nav.go_forward();

    rsx! { h1 { "Welcome to the Dioxus Blog!" } }
}
````

You might have noticed that, like [`Link`], the [`Navigator`]s `push` and
`replace` functions take a [`NavigationTarget`]. This means we can use either
`Internal`, or `External` targets.

## External Navigation Targets

Unlike a [`Link`], the [`Navigator`] cannot rely on the browser (or webview) to
handle navigation to external targets via a generated anchor element.

This means, that under certain conditions, navigation to external targets can
fail.
# History Providers

\[`HistoryProvider`\]s are used by the router to keep track of the navigation history
and update any external state (e.g. the browser's URL).

The router provides two \[`HistoryProvider`\]s, but you can also create your own.
The two default implementations are:

* The \[`MemoryHistory`\] is a custom implementation that works in memory.
* The \[`LiveviewHistory`\] is a custom implementation that works with the liveview renderer.
* The \[`WebHistory`\] integrates with the browser's URL.

By default, the router uses the \[`MemoryHistory`\]. It might be changed to use
\[`WebHistory`\] when the `web` feature is active, but that is not guaranteed.

You can override the default history:

````rs@history_provider.rs
#[component]
fn App() -> Element {
    rsx! {
        Router::<Route> { config: || RouterConfig::default() }
    }
}
````
# History Buttons

Some platforms, like web browsers, provide users with an easy way to navigate
through an app's history. They have UI elements or integrate with the OS.

However, native platforms usually don't provide such amenities, which means that
apps wanting users to have access to them, need to implement them. For this
reason, the router comes with two components, which emulate a browser's back and
forward buttons:

* [`GoBackButton`]
* [`GoForwardButton`]

 > 
 > If you want to navigate through the history programmatically, take a look at
 > [`programmatic navigation`](./navigation/programmatic.md).

````rs@history_buttons.rs
fn HistoryNavigation() -> Element {
    rsx! {
        GoBackButton { "Back to the Past" }
        GoForwardButton { "Back to the Future" }
    }
}
````

As you might know, browsers usually disable the back and forward buttons if
there is no history to navigate to. The router's history buttons try to do that
too, but depending on the \[history provider\] that might not be possible.

Importantly, neither `WebHistory` supports that feature.
This is due to limitations of the browser History API.

However, in both cases, the router will just ignore button presses, if there is
no history to navigate to.

Also, when using `WebHistory`, the history buttons might
navigate a user to a history entry outside your app.
# Routing Update Callback

In some cases, we might want to run custom code when the current route changes. For this reason, the [`RouterConfig`] exposes an `on_update` field.

## How does the callback behave?

The `on_update` is called whenever the current routing information changes. It is called after the router updated its internal state, but before dependent components and hooks are updated.

If the callback returns a [`NavigationTarget`], the router will replace the current location with the specified target. It will not call the `on_update` again.

If at any point the router encounters a navigation failure, it will go to the appropriate state without calling the `on_update`. It doesn't matter if the invalid target initiated the navigation, was found as a redirect target, or was returned by the `on_update` itself.

## Code Example

````rs@routing_update.rs
#[derive(Routable, Clone, PartialEq)]
enum Route {
    #[route("/")]
    Index {},
    #[route("/home")]
    Home {},
}

#[component]
fn Home() -> Element {
    rsx! { p { "Home" } }
}

#[component]
fn Index() -> Element {
    rsx! { p { "Index" } }
}

fn app() -> Element {
    rsx! {
        Router::<Route> {
            config: || {
                RouterConfig::default()
                    .on_update(|state| {
                        (state.current() == Route::Index {})
                            .then_some(NavigationTarget::Internal(Route::Home {}))
                    })
            }
        }
    }
}
````
# Assets

Assets are files that are included in the final build of the application. They can be images, fonts, stylesheets, or any other file that is not a source file. Dioxus includes first class support for assets, and provides a simple way to include them in your application and automatically optimize them for production.

Assets in dioxus are also compatible with libraries! If you are building a library, you can include assets in your library and they will be automatically included in the final build of any application that uses your library.

## Including images

To include an asset in your application, you can simply wrap the path to the asset in the `asset!` macro. For example, to include an image in your application, you can use the following code:

````rs@assets.rs
use dioxus::prelude::*;

fn App() -> Element {
    // You can link to assets that are relative to the package root or even link to an asset from a url
    // These assets will automatically be picked up by the dioxus cli, optimized, and bundled with your final applications
    const ASSET: Asset = asset!("/assets/static/ferrous_wave.png");

    rsx! {
        img { src: "{ASSET}" }
    }
}
````

You can also optimize, resize, and preload images using the `asset!` macro. Choosing an optimized file type (like Avif) and a reasonable quality setting can significantly reduce the size of your images which helps your application load faster. For example, you can use the following code to include an optimized image in your application:

````rs@assets.rs
pub const ENUM_ROUTER_IMG: Asset = asset!(
    "/assets/static/enum_router.png",
    // You can pass a second argument to the asset macro to set up options for the asset
    ImageAssetOptions::new()
        // You can set the image size in pixels at compile time to send the smallest possible image to the client
        .with_size(ImageSize::Manual {
            width: 52,
            height: 52
        })
        // You can also convert the image to a web friendly format at compile time. This can make your images significantly smaller
        .with_format(ImageFormat::Avif)
);

fn EnumRouter() -> Element {
    rsx! {
        img { src: "{ENUM_ROUTER_IMG}" }
    }
}
````

## Including arbitrary files

In dioxus desktop, you may want to include a file with data for your application. If you don't set any options for your asset and the file extension is not recognized, the asset will be copied without any changes. For example, you can use the following code to include a binary file in your application:

````rs@assets.rs
// You can also collect arbitrary files. Relative paths are resolved relative to the package root
const PATH_TO_BUNDLED_CARGO_TOML: Asset = asset!("/Cargo.toml");
````

These files will be automatically included in the final build of your application, and you can use them in your application as you would any other file.

## Including stylesheets

You can include stylesheets in your application using the `asset!` macro. Stylesheets will automatically be minified as they are bundled to speed up load times. For example, you can use the following code to include a stylesheet in your application:

````rs@assets.rs
// You can also bundle stylesheets with your application
// Any files that end with .css will be minified and bundled with your application even if you don't explicitly include them in your <head>
const _: Asset = asset!("/assets/tailwind.css");
````

 > 
 > The [tailwind guide](../cookbook/tailwind.md) has more information on how to use tailwind with dioxus.

#### SCSS Support

SCSS is also supported through the `asset!` macro. Include it the same way as a regular CSS file.

## Conclusion

Dioxus provides first class support for assets, and makes it easy to include them in your application. You can include images, arbitrary files, and stylesheets in your application, and dioxus will automatically optimize them for production. This makes it easy to include assets in your application and ensure that they are optimized for production.

You can read more about assets and all the options available to optimize your assets in the [manganis documentation](https://docs.rs/manganis/0.6.0/manganis).
# Web

To run on the Web, your app must be compiled to WebAssembly and depend on the `dioxus` and `dioxus-web` crates.

A build of Dioxus for the web will be roughly equivalent to the size of a React build (70kb vs 65kb) but it will load significantly faster because [WebAssembly can be compiled as it is streamed](https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/).

Examples:

* [TodoMVC](https://github.com/DioxusLabs/dioxus/blob/main/examples/todomvc.rs)
* [Tailwind App](https://github.com/DioxusLabs/dioxus/tree/main/examples/tailwind)

[![TodoMVC example](https://github.com/DioxusLabs/example-projects/raw/master/todomvc/example.png)](https://github.com/DioxusLabs/dioxus/blob/main/examples/todomvc.rs)

 > 
 > Note: Because of the limitations of Wasm, [not every crate will work](https://rustwasm.github.io/docs/book/reference/which-crates-work-with-wasm.html) with your web apps, so you'll need to make sure that your crates work without native system calls (timers, IO, etc).

## Support

The Web is the best-supported target platform for Dioxus.

* Because your app will be compiled to WASM you have access to browser APIs through [wasm-bindgen](https://rustwasm.github.io/docs/wasm-bindgen/introduction.html).
* Dioxus provides hydration to resume apps that are rendered on the server. See the [fullstack](../fullstack/index.md) reference for more information.

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus web exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    let future = use_resource(move || async move {
        // You can create as many eval instances as you want
        let mut eval = document::eval(
            r#"
            // You can send messages from JavaScript to Rust with the dioxus.send function
            dioxus.send("Hi from JS!");
            // You can receive messages from Rust to JavaScript with the dioxus.recv function
            let msg = await dioxus.recv();
            console.log(msg);
            "#,
        );

        // You can send messages to JavaScript with the send method
        eval.send("Hi from Rust!").unwrap();

        // You can receive any message from JavaScript with the recv method
        eval.recv::<String>().await.unwrap()
    });

    match future.read_unchecked().as_ref() {
        Some(v) => rsx! {
            p { "{v}" }
        },
        _ => rsx! {
            p { "hello" }
        },
    }
}

````

If you are targeting web, but don't plan on targeting any other Dioxus renderer you can also use the generated wrappers in the [web-sys](https://rustwasm.github.io/wasm-bindgen/web-sys/index.html) and [gloo](https://gloo-rs.web.app/) crates.

## Customizing Index Template

Dioxus supports providing custom index.html templates. The index.html must include a `div` with the id `main` to be used. Hot Reload is still supported. An example
is provided in the [PWA-Example](https://github.com/DioxusLabs/dioxus/blob/main/examples/pwa/index.html).
# Desktop

This guide will cover concepts specific to the Dioxus desktop renderer.

Apps built with Dioxus desktop use the system WebView to render the page. This makes the final size of application much smaller than other WebView renderers (typically under 5MB).

Although desktop apps are rendered in a WebView, your Rust code runs natively. This means that browser APIs are *not* available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs *are* accessible, so streaming, WebSockets, filesystem, etc are all easily accessible though system APIs.

Dioxus desktop is built on top of [wry](https://github.com/tauri-apps/wry), a Rust library for creating desktop applications with a WebView.

 > 
 > In the future, we plan to move to a custom web renderer-based DOM renderer with WGPU integrations ([Blitz](https://github.com/DioxusLabs/blitz)).

## Examples

* [File Explorer](https://github.com/DioxusLabs/dioxus/tree/v0.6/example-projects/file-explorer)
* [Tailwind App](https://github.com/DioxusLabs/dioxus/tree/v0.6/examples/tailwind)

[![Tailwind App screenshot](/assets/static/tailwind_desktop_app.png)](https://github.com/DioxusLabs/dioxus/tree/main/examples/tailwind)

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus desktop exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    let future = use_resource(move || async move {
        // You can create as many eval instances as you want
        let mut eval = document::eval(
            r#"
            // You can send messages from JavaScript to Rust with the dioxus.send function
            dioxus.send("Hi from JS!");
            // You can receive messages from Rust to JavaScript with the dioxus.recv function
            let msg = await dioxus.recv();
            console.log(msg);
            "#,
        );

        // You can send messages to JavaScript with the send method
        eval.send("Hi from Rust!").unwrap();

        // You can receive any message from JavaScript with the recv method
        eval.recv::<String>().await.unwrap()
    });

    match future.read_unchecked().as_ref() {
        Some(v) => rsx! {
            p { "{v}" }
        },
        _ => rsx! {
            p { "hello" }
        },
    }
}

````

## Custom Assets

You can link to local assets in dioxus desktop instead of using a url:

````rs@custom_assets.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    rsx! {
        div {
            img { src: asset!("/assets/static/scanner.png") }
        }
    }
}

````

You can read more about assets in the [assets](../assets.md) reference.

## Integrating with Wry

In cases where you need more low level control over your window, you can use wry APIs exposed through the [Desktop Config](https://docs.rs/dioxus-desktop/0.6.0/dioxus_desktop/struct.Config.html) and the [use_window hook](https://docs.rs/dioxus-desktop/0.6.0/dioxus_desktop/fn.use_window.html)
# Mobile App

Build a mobile app with Dioxus!

## Support

The Rust ecosystem for mobile continues to mature, with Dioxus offering strong support for mobile applications. Mobile is a first-class target for Dioxus apps, with a robust WebView implementation that supports CSS animations and transparency effects.

Mobile apps are rendered with either the platform's WebView or experimentally with WGPU. While native Android animations and widgets aren't currently supported, CSS-based animations and styling provide a powerful alternative.

Mobile support is well-suited for most application types, from business tools to consumer apps, making it an excellent choice for teams looking to build cross-platform applications with a single codebase.

## Getting Set up

## Android

Android devices run a different executable architecture than desktop and web. We need to install these toolchains to build Dioxus apps for Android.

First, install the Rust Android targets:

````sh
rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android
````

To develop on Android, you will need to [install Android Studio](https://developer.android.com/studio).

Once you have installed Android Studio, you will need to install the Android SDK and NDK:

1. Create a blank Android project
1. Select `Tools > SDK manager`
1. Navigate to the `SDK tools` window:

![NDK install window](/assets/static/android_ndk_install.png)

Then select:

* The SDK
* The SDK Command line tools
* The NDK (side by side)
* CMAKE

4. Select `apply` and follow the prompts

 > 
 > More details that could be useful for debugging any errors you encounter are available [in the official android docs](https://developer.android.com/studio/intro/update#sdk-manager)

Next set the Java, Android, NDK, and PATH variables:

Mac:

````sh
export JAVA_HOME="/Applications/Android Studio.app/Contents/jbr/Contents/Home"
export ANDROID_HOME="$HOME/Library/Android/sdk"
export NDK_HOME="$ANDROID_HOME/ndk/25.2.9519653"
export PATH="$PATH:$ANDROID_HOME/emulator:$ANDROID_HOME/platform-tools"
````

Windows:

````powershell
[System.Environment]::SetEnvironmentVariable("JAVA_HOME", "C:\Program Files\Android\Android Studio\jbr", "User")
[System.Environment]::SetEnvironmentVariable("ANDROID_HOME", "$env:LocalAppData\Android\Sdk", "User")
[System.Environment]::SetEnvironmentVariable("NDK_HOME", "$env:LocalAppData\Android\Sdk\ndk\25.2.9519653", "User")
````

 > 
 > The NDK version in the paths should match the version you installed in the last step

We manually set the PATH variable to include the Android emulator since some distributions of Android Studio include the emulator in the wrong location.

## IOS

To develop on IOS, you will need to [install XCode](https://apps.apple.com/us/app/xcode/id497799835). Also make sure to install the iOS targets

````sh
rustup target add aarch64-apple-ios aarch64-apple-ios-sim
````

 > 
 > If you are using M1, you will have to run `cargo build --target x86_64-apple-ios` instead of `cargo apple build` if you want to run in simulator.

You will also need to install the iOS SDK and the Xcode command line tools.

## Running your app

Starting with Dioxus 0.6, `dx` ships with built-in support for mobile.

Simply create a new Dioxus project:

````sh
dx new my-app
````

Make sure to launch the relevant mobile simulator. For Android, you can use the Android Studio emulator, or the Android Emulator in the terminal. Make sure to adjust the device name depending on which emulator you installed.

````shell
emulator -avd Pixel_6_API_34  -netdelay none -netspeed full
````

For iOS, you can use the iOS simulator. You can launch it with:

````sh
open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app
xcrun simctl boot "iPhone 15 Pro Max"
````

And then run the app with:

````sh
cd my-app
dx serve
````

This will start the app in development mode.
# Mobile

This guide will cover concepts specific to the Dioxus mobile renderer.

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus desktop exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    let future = use_resource(move || async move {
        // You can create as many eval instances as you want
        let mut eval = document::eval(
            r#"
            // You can send messages from JavaScript to Rust with the dioxus.send function
            dioxus.send("Hi from JS!");
            // You can receive messages from Rust to JavaScript with the dioxus.recv function
            let msg = await dioxus.recv();
            console.log(msg);
            "#,
        );

        // You can send messages to JavaScript with the send method
        eval.send("Hi from Rust!").unwrap();

        // You can receive any message from JavaScript with the recv method
        eval.recv::<String>().await.unwrap()
    });

    match future.read_unchecked().as_ref() {
        Some(v) => rsx! {
            p { "{v}" }
        },
        _ => rsx! {
            p { "hello" }
        },
    }
}

````

## Custom Assets

You can link to local assets in dioxus mobile instead of using a url:

````rs@custom_assets.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    rsx! {
        div {
            img { src: asset!("/assets/static/scanner.png") }
        }
    }
}

````

## Integrating with Wry

In cases where you need more low level control over your window, you can use wry APIs exposed through the [Desktop Config](https://docs.rs/dioxus-desktop/0.6.0/dioxus_desktop/type.DesktopContext.html) and the [use_window hook](https://docs.rs/dioxus-desktop/0.6.0/dioxus_desktop/fn.use_window.html)
# Server-Side Rendering

For lower-level control over the rendering process, you can use the `dioxus-ssr` crate directly. This can be useful when integrating with a web framework that `dioxus-fullstack` does not support, or pre-rendering pages.

## Setup

For this guide, we're going to show how to use Dioxus SSR with [Axum](https://docs.rs/axum/latest/axum/).

Make sure you have Rust and Cargo installed, and then create a new project:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the ssr renderer as dependencies:

````shell
cargo add dioxus
cargo add dioxus-ssr
````

Next, add all the Axum dependencies. This will be different if you're using a different Web Framework

````
cargo add tokio --features full
cargo add axum
````

Your dependencies should look roughly like this:

````toml
[dependencies]
axum = "0.7"
dioxus = { version = "*" }
dioxus-ssr = { version = "*" }
tokio = { version = "1.15.0", features = ["full"] }
````

Now, set up your Axum app to respond on an endpoint.

````rs@ssr.rs
use axum::{response::Html, routing::get, Router};
use dioxus::prelude::*;

#[tokio::main]
async fn main() {
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();

    println!("listening on http://127.0.0.1:3000");

    axum::serve(
        listener,
        Router::new()
            .route("/", get(app_endpoint))
            .into_make_service(),
    )
    .await
    .unwrap();
}
````

And then add our endpoint. We can either render `rsx!` directly:

````rs@ssr.rs
async fn app_endpoint() -> Html<String> {
    // render the rsx! macro to HTML
    Html(dioxus_ssr::render_element(rsx! { div { "hello world!" } }))
}
````

Or we can render VirtualDoms.

````rs@ssr.rs
async fn app_endpoint() -> Html<String> {
    // create a component that renders a div with the text "hello world"
    fn app() -> Element {
        rsx! { div { "hello world" } }
    }
    // create a VirtualDom with the app component
    let mut app = VirtualDom::new(app);
    // rebuild the VirtualDom before rendering
    app.rebuild_in_place();

    // render the VirtualDom to HTML
    Html(dioxus_ssr::render(&app))
}
````

Finally, you can run it using `cargo run` rather than `dx serve`.

## Multithreaded Support

The Dioxus VirtualDom, sadly, is not currently `Send`. Internally, we use quite a bit of interior mutability which is not thread-safe.
When working with web frameworks that require `Send`, it is possible to render a VirtualDom immediately to a String â€“ but you cannot hold the VirtualDom across an await point. For retained-state SSR (essentially LiveView), you'll need to spawn a VirtualDom on its own thread and communicate with it via channels or create a pool of VirtualDoms.
You might notice that you cannot hold the VirtualDom across an await point. Because Dioxus is currently not ThreadSafe, it *must* remain on the thread it started. We are working on loosening this requirement.
# Fullstack development

Dioxus Fullstack contains helpers for:

* Incremental, static, and server side rendering
* Hydrating your application on the Client
* Communicating between a server and a client

This guide will teach you everything you need to know about how to use the utilities in Dioxus fullstack to create amazing fullstack applications.

 > 
 > In addition to this guide, you can find more examples of full-stack apps and information about how to integrate with other frameworks and desktop renderers in the [examples directory](https://github.com/DioxusLabs/dioxus/tree/main/examples).
# Hydration

In dioxus fullstack, the server renders the initial HTML for improved loading times. This initial version of the page is what most web crawlers and search engines see. After the initial HTML is rendered, the client makes the page interactive and takes over rendering in a process called **hydration**. Most of the time, you shouldn't need to think about hydration, but there are a few things you need to keep in mind to avoid [hydration errors](#hydration-errors). To better understand hydration, let's walk through a simple example:

````rs@hydration.rs
fn Weather() -> Element {
    let mut weather = use_server_future(fetch_weather)?;

    rsx! {
        div {
            "{weather:?}"
        }
        button {
            onclick: move |_| weather.restart(),
            "Refetch"
        }
    }
}
````

## Rendering the initial HTML

When the server receives a request to render the `Weather` component, it renders the page to HTML and serializes some additional data the client needs to hydrate the page. It will follow these steps to render our component:

1. Run the component
1. Wait until all server futures are resolved
1. Serialize any non-deterministic data (like the `weather` future) for the client
1. Render the HTML

[![](https://mermaid.ink/img/pako:eNpdkDFTwzAMhf-KT3M70HbKwELhGMqSdAIziFhNfI2lnGzDQa__HZfk4Iq1-D1_ejr5BK04ggoOg3y0PWoy-61lE_Nbpzj2Jt68WGhI30lN4x2ZmtiReu4svBZwPs4rtckLm13958ZVaa4zmzsJozBxumqK6ynb4-C_yMxTHnLKSvGa3FyCfiabx_3Tbn4sxsTElVkub0vgLNeT3FieChYQSAN6V1Y9XSALqadAFqpydahHC5bPhcOcpPnkFqqkmRagkrseqgMOsag8Oky09Vh-J_y6I_KzSPhH3TufRGfz_A3Ce3PT?type=png)](https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNpdkDFTwzAMhf-KT3M70HbKwELhGMqSdAIziFhNfI2lnGzDQa__HZfk4Iq1-D1_ejr5BK04ggoOg3y0PWoy-61lE_Nbpzj2Jt68WGhI30lN4x2ZmtiReu4svBZwPs4rtckLm13958ZVaa4zmzsJozBxumqK6ynb4-C_yMxTHnLKSvGa3FyCfiabx_3Tbn4sxsTElVkub0vgLNeT3FieChYQSAN6V1Y9XSALqadAFqpydahHC5bPhcOcpPnkFqqkmRagkrseqgMOsag8Oky09Vh-J_y6I_KzSPhH3TufRGfz_A3Ce3PT)

Once the server finishes rendering, it will send this structure to the client as HTML:

[![](https://mermaid.ink/img/pako:eNqFUcFKAzEQ_ZUwh57agy22sAUFqaCgF1sQNCLTZLYbupss2VmLlv67s92luoo4uSRv3nvzhuzBBEuQQJqHnckwslottFdVvd5ELDNVjZ81LCk6zN0HWbVARg0vQpGyLpJhF7xaXbVIU_5MJCmxyV53hJxR7ATkbc96Irxb71i81c3q_u4_3ybKIOe5dW-DDc9P9GPzXJr7bl5yeeg3p51yXTOLa_Amd2b722QmvAdKI1XZH5mb3R57W7VVjb_dJ1_KY241Gl1IQjWQJB02bbGZ9u2BIRQUC3RWPmPfkDTIkII0JHK1GLcatD8ID2sOy3dvIOFY0xBiqDcZJCnmlbzq0iLTwqEELk5oif4phOIH69o6DrEDD5_uGqQ1?type=png)](https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNqFUcFKAzEQ_ZUwh57agy22sAUFqaCgF1sQNCLTZLYbupss2VmLlv67s92luoo4uSRv3nvzhuzBBEuQQJqHnckwslottFdVvd5ELDNVjZ81LCk6zN0HWbVARg0vQpGyLpJhF7xaXbVIU_5MJCmxyV53hJxR7ATkbc96Irxb71i81c3q_u4_3ybKIOe5dW-DDc9P9GPzXJr7bl5yeeg3p51yXTOLa_Amd2b722QmvAdKI1XZH5mb3R57W7VVjb_dJ1_KY241Gl1IQjWQJB02bbGZ9u2BIRQUC3RWPmPfkDTIkII0JHK1GLcatD8ID2sOy3dvIOFY0xBiqDcZJCnmlbzq0iLTwqEELk5oif4phOIH69o6DrEDD5_uGqQ1)

## Hydrating on the client

When the client receives the initial HTML, it hydrates the HTML by rerunning each component and linking each node that component renders to the node the server rendered. Rerunning each component lets the client re-construct some non-serializable state like event handlers and kick off any client side logic like `use_effect` and `use_future`.

It will follow these steps:

1. Deserialize any non-deterministic data from the server (like the `weather` future)
1. Run the component with the deserialized data. All server futures are immediately resolved with the deserialized data from the server.
1. Hydrate the HTML sent from the server. This adds all event handlers and links the html nodes to the component so they can be moved or modified later

[![](https://mermaid.ink/img/pako:eNpdkLFuAjEMhl_F8gxDgemGLlyrDnThmNp0SC-Gi7g4JydpRRHvXsOdkFpnif__s534jG10hBXu-_jddlYy7GrDkMrnQezQQXp4N7juPXGGxjuCl5MT63Nkgx8Kajgv1GYfGTbbUblGWmphTYnE297_EDQkXyTwXHIRSvfqG7tQdlsY1jEMkXXWX3ul9m1u1vm7183kErsRSkuYzx-1zZQuxnRleDw4w0ASrHf60_MVMpg7CmSw0quzcjRo-KKcLTk2J26xylJohhLLocNqb_ukWRmcvqH2VpcT7upg-S3G8I96crolmcTLL4RBdIg?type=png)](https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNpdkLFuAjEMhl_F8gxDgemGLlyrDnThmNp0SC-Gi7g4JydpRRHvXsOdkFpnif__s534jG10hBXu-_jddlYy7GrDkMrnQezQQXp4N7juPXGGxjuCl5MT63Nkgx8Kajgv1GYfGTbbUblGWmphTYnE297_EDQkXyTwXHIRSvfqG7tQdlsY1jEMkXXWX3ul9m1u1vm7183kErsRSkuYzx-1zZQuxnRleDw4w0ASrHf60_MVMpg7CmSw0quzcjRo-KKcLTk2J26xylJohhLLocNqb_ukWRmcvqH2VpcT7upg-S3G8I96crolmcTLL4RBdIg)

## Hydration errors

For hydration to work, **the component must render exactly the same thing on the client and the server**. If it doesn't, you might see an error like this:

````
Uncaught TypeError: Cannot set properties of undefined (setting 'textContent')
at RawInterpreter.run (yourwasm-hash.js:1:12246)
````

Or this:

````
Error deserializing data:
Semantic(None, "invalid type: floating point `1.2`, expected integer")
This type was serialized on the server at src/main.rs:11:5 with the type name f64. The client failed to deserialize the type i32 at /path/to/server_future.rs
````

### Non-deterministic data with server cached

You must put any non-deterministic data in `use_server_future`, `use_server_cached` or `use_effect` to avoid hydration errors. For example, if you need to render a random number on your page, you can use `use_server_cached` to cache the random number on the server and then use it on the client:

````rs@hydration.rs
// âŒ The random number will be different on the client and the server
let random: u8 = use_hook(|| rand::random());
// âœ… The same random number will be serialized on the server and deserialized on the client
let random: u8 = use_server_cached(|| rand::random());
````

### Async loading with server futures

If you need render some data from a server future, you need to use `use_server_future` to serialize the data instead of waiting for the (non-deterministic) amount of time `use_resource(...).suspend()?` takes:

````rs@hydration.rs
// âŒ The server function result may be finished on the server, but pending on the client
let random: u8 = use_resource(|| random_server_function()).suspend()?().unwrap_or_default();
// âœ… Once the server function is resolved on the server, it will be sent to the client
let random: u8 = use_server_future(|| random_server_function())?()
    .unwrap()
    .unwrap_or_default();
````

### Client only data with effects

If you need to grab some data that is only available on the client, make sure you get it inside of a `use_effect` hook which runs after the component has been hydrated:

````rs@hydration.rs
// âŒ Using a different value client side before hydration will cause hydration issues
// because the server rendered the html with another value
let mut storage = use_signal(|| {
    #[cfg(feature = "server")]
    return None;
    let window = web_sys::window().unwrap();
    let local_storage = window.local_storage().unwrap().unwrap();
    local_storage.set_item("count", "1").unwrap();
    local_storage.get_item("count").unwrap()
});

// âœ… Changing the value inside of an effect is fine because effects run after hydration
let mut storage = use_signal(|| None);
use_effect(move || {
    let window = web_sys::window().unwrap();
    let local_storage = window.local_storage().unwrap().unwrap();
    local_storage.set_item("count", "1").unwrap();
    storage.set(local_storage.get_item("count").unwrap());
});
````

### Avoid side effects in server cached hooks

The dioxus fullstack specific hooks `use_server_cached` and `use_server_future` don't run the same on the server and the client. The server will always run the closure, but the client may not run the closure if the server serialized the result. Because of this, the code you run inside these hooks **cannot have side effects**. If it does, the side effects will not be serialized and it can cause a hydration mismatch error:

````rs@hydration.rs
// âŒ The state of the signal cannot be serialized on the server
let mut storage = use_signal(|| None);
use_server_future(move || async move {
    storage.set(Some(server_future().await));
})?;

// âœ… The value returned from use_server_future will be serialized on the server and hydrated on the client
let storage = use_server_future(|| async move { server_future().await })?;
````
# Managing Fullstack Dependencies

Fullstack applications build to at least two different binaries:

* The client application that runs the desktop, mobile, or web application
* The server that renders the initial HTML and runs server functions

Those binaries tend to have different dependencies and those dependencies often are only compatible with a specific target platform. This guide will cover how fullstack manages each binary's dependencies and how to add dependencies that are only compatible with one binary/target.

## Client and Server Feature Flags

Dioxus uses feature flags to differentiate between the different binaries a single library can produce. Each target binary should have a feature flag in your `Cargo.toml` file that enables the corresponding feature in dioxus. For example, if you are targeting `web` and `desktop` with a fullstack server, you would add the following to your `Cargo.toml`:

````toml
[dependencies]
# Don't include any renderer features in your dioxus dependency directly. They will be added in feature flags.
# The fullstack feature enables the bindings between the server and client without enabling a specific binary target.
dioxus = { version = "0.6", features = ["fullstack"] }

[features]
# The web feature enables the web renderer. Dioxus will automatically enable the feature you define that activates `dioxus/web` when building the client WASM bundle.
web = ["dioxus/web"]
# The desktop feature enables the desktop renderer. Dioxus will automatically enable the feature you define that activates `dioxus/desktop` when building the client native bundle.
desktop = ["dioxus/desktop"]
# The server feature enables server functions and server-side rendering. Dioxus will automatically enable the feature you define that activates `dioxus/server` when building the server binary.
server = ["dioxus/server"]
````

Feature flags like these for the client and server are automatically generated by the CLI when you run `dx new` with fullstack enabled. If you are creating a project from scratch, you will need to add the feature flags manually.

 > 
 > If you are not familiar with features in rust, you can read more about feature flags in the [cargo reference](https://doc.rust-lang.org/cargo/reference/features.html).

## Adding Server Only Dependencies

Many dependencies like [`tokio`](https://docs.rs/tokio/latest/tokio/index.html) and [`axum`](https://docs.rs/axum/latest/axum/index.html) are only compatible with the server. If these dependencies are enabled when building a WASM bundle for the browser client, you will get a compilation error. For example, if we want to interact with the filesystem in a server function, we might want to add `tokio`. `tokio` has utilities for working with async IO like [`tokio::fs::File`](https://docs.rs/tokio/latest/tokio/fs/struct.File.html). Let's try it as a dependency to our fullstack project:

````toml
[dependencies]
# ...
# âŒ If tokio is added as a required dependency, it will be included in both the server
# and the web bundle. The web bundle will fail to build because tokio is not
# compatible with wasm
tokio = { version = "1", features = ["full"] }
````

If we try to compile with tokio as a required dependency, we will get a compilation error like this:

````shell
error[E0432]: unresolved import `crate::sys::IoSourceState`
  --> /Users/user/.cargo/registry/src/index.crates.io-6f17d22bba15001f/mio-1.0.2/src   |source.rs:14:5
14 | use crate::sys::IoSourceState;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ no `IoSourceState` in `sys`
...
````

Since we added `tokio` as a dependency for all three binaries, cargo tries to compile it for each target. This fails because `tokio` is not compatible with the `wasm32-unknown-unknown` target.

To fix the issue, we can **make the dependency optional and only enable it in the server feature**:

````toml
[dependencies]
# ...
# âœ… Since the tokio dependency is optional, it is not included in the web and desktop
# bundles.
tokio = { version = "1", features = ["full"], optional = true }

[features]
# ...
# âœ… Since the tokio dependency is enabled in the server feature, it is included in
# the server binary.
server = ["dioxus/server", "dep:tokio"]
````

Now when we build with `dx serve`, the project compiles successfully.

## Adding Client Only Dependencies

Many dependencies like [`wasm-bindgen`](https://docs.rs/wasm-bindgen/latest/wasm_bindgen/index.html) and [`web-sys`](https://docs.rs/web-sys/latest/web_sys/index.html) are only compatible with the client. Unlike server-only dependencies, these dependencies can generally compile on native targets, but they will panic when used outside of the browser.

You can cut down on build times for your server and native binaries by only including web dependencies in the browser client binary.

Instead of adding web only dependencies every binary in your project like this:

````toml
[dependencies]
# ...
# âŒ If web-sys is added as a required dependency, it will be included in the server,
# native, and the web bundle which makes build times longer.
web-sys = { version = "0.3.60", features = ["console"] }
````

You can make the dependency optional and only enable it in the `web` feature in your `Cargo.toml`:

````toml
[dependencies]
# ...
# âœ… Since the web-sys dependency is optional, it is not included in the server and
# native bundles.
web-sys = { version = "0.3.60", features = ["console"], optional = true }

[features]
# ...
# âœ… Since the web-sys dependency is enabled in the web feature, it is included in
# the web bundle.
web = ["dioxus/web", "dep:web-sys"]
````

## Managing Binary Specific Imports

Once you have set up binary specific dependencies, you need to adjust any of your imports to only import the dependencies when building for the binary that includes those dependencies.

For example, if `tokio` is only enabled in the server feature, you will need to import it like this:

````rs@server_tokio_import.rs
// Since the tokio dependency is only enabled in the server feature,
// we need to only import it when the server feature is enabled.
#[cfg(feature = "server")]
use tokio::fs::File;
#[cfg(feature = "server")]
use tokio::io::AsyncReadExt;
````

You also need to only compile any usage of the dependency when the feature is enabled:

````rs@server_tokio_import.rs
// Since the tokio dependency is only enabled in the server feature,
// we need to only compile any usage of the dependency when the server feature is enabled.
#[cfg(feature = "server")]
async fn read_file() -> Result<String, std::io::Error> {
    let mut file = File::open("path/to/file").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}

// The bodies of server functions automatically only compile when the server feature is enabled.
#[server]
async fn get_file_contents() -> Result<String, ServerFnError> {
    let mut file = File::open("path/to/file").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}
````

It may be more convenient to group server or client specific code into a module that is only compiled when the feature is enabled:

````rs@server_tokio_import.rs
// Instead of configuring each item that is only used in the server, you can group
// them into a module that is only compiled when the server feature is enabled.
#[cfg(feature = "server")]
mod tokio_utilities {
    use std::path::PathBuf;
    use tokio::fs::File;
    use tokio::io::AsyncReadExt;

    pub async fn read_file(path: PathBuf) -> Result<String, std::io::Error> {
        let mut file = File::open(path).await?;
        let mut contents = String::new();
        file.read_to_string(&mut contents).await?;
        Ok(contents)
    }
}

// Then you can define your server functions using shared utilities you defined for
// server only code.
#[server]
async fn get_file_contents() -> Result<String, ServerFnError> {
    let file = tokio_utilities::read_file(PathBuf::from("path/to/file")).await?;
    Ok(file)
}

#[server]
async fn get_other_file_contents() -> Result<String, ServerFnError> {
    let file = tokio_utilities::read_file(PathBuf::from("path/to/other/file")).await?;
    Ok(file)
}
````

 > 
 > The [rust reference](https://doc.rust-lang.org/reference/conditional-compilation.html) has more information about conditional compilation in rust.
# Communicating with the server

`dioxus-fullstack` provides server functions that allow you to call an automatically generated API on the server from the client as if it were a local function.

To make a server function, simply add the `#[server(YourUniqueType)]` attribute to a function. The function must:

* Be an async function
* Have arguments and a return type that both implement serialize and deserialize (with [serde](https://serde.rs/)).
* Return a `Result` with an error type of ServerFnError

 > 
 > If you are targeting WASM on the server with WASI, you must call `register` on the type you passed into the server macro in your main function before starting your server to tell Dioxus about the server function. For all other targets, the server function will be registered automatically.

Let's continue building on the app we made in the [getting started](../../getting_started/index.md) guide. We will add a server function to our app that allows us to double the count on the server.

First, add serde as a dependency:

````shell
cargo add serde
````

Next, add the server function to your `main.rs`:

````rs@server_function.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;

fn main() {
    launch(App)
}

fn App() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
        button {
            onclick: move |_| {
                async move {
                    if let Ok(new_count) = double_server(count()).await {
                        count.set(new_count);
                    }
                }
            },
            "Double"
        }
    }
}

#[server]
async fn double_server(number: i32) -> Result<i32, ServerFnError> {
    // Perform some expensive computation or access a database on the server
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    let result = number * 2;
    println!("server calculated {result}");
    Ok(result)
}

````

Now, build your client-side bundle with `dx build --features web` and run your server with `cargo run --features ssr`. You should see a new button that multiplies the count by 2.

## Cached data fetching

One common use case for server functions is fetching data from the server:

````rs@server_data_fetch.rs
#![allow(non_snake_case, unused)]

use dioxus::prelude::*;

fn main() {
    launch(app)
}

fn app() -> Element {
    let mut count = use_resource(get_server_data);

    rsx! { "server data is {count.value():?}" }
}

#[server]
async fn get_server_data() -> Result<String, ServerFnError> {
    // Access a database
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    Ok("Hello from the server!".to_string())
}

````

If you navigate to the site above, you will first see `server data is None`, then after the `WASM` has loaded and the request to the server has finished, you will see `server data is Some(Ok("Hello from the server!"))`.

This approach works, but it can be slow. Instead of waiting for the client to load and send a request to the server, what if we could get all of the data we needed for the page on the server and send it down to the client with the initial HTML page?

This is exactly what the `use_server_future` hook allows us to do! `use_server_future` is similar to the `use_resource` hook, but it allows you to wait for a future on the server and send the result of the future down to the client.

Let's change our data fetching to use `use_server_future`:

````rs@server_data_prefetch.rs
#![allow(non_snake_case, unused)]

use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    let mut count = use_server_future(get_server_data)?;

    rsx! {"server data is {count.value():?}"}
}

#[server]
async fn get_server_data() -> Result<String, ServerFnError> {
    // Access a database
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    Ok("Hello from the server!".to_string())
}

````

 > 
 > Notice the `?` after `use_server_future`. This is what tells Dioxus fullstack to wait for the future to resolve before continuing rendering. If you want to not wait for a specific future, you can just remove the ? and deal with the `Option` manually.

Now when you load the page, you should see `server data is Ok("Hello from the server!")`. No need to wait for the `WASM` to load or wait for the request to finish!

````inject-dioxus
SandBoxFrame {
	url: "https://codesandbox.io/p/sandbox/dioxus-fullstack-server-future-qwpp4p?file=/src/main.rs:3,24"
}
````

## Running the client with dioxus-desktop

The project presented so far makes a web browser interact with the server, but it is also possible to make a desktop program interact with the server in a similar fashion. (The full example code is available in the [Dioxus repo](https://github.com/DioxusLabs/dioxus/tree/main/packages/fullstack/examples/axum-desktop))

First, we need to make two binary targets, one for the desktop program (the `client.rs` file), one for the server (the `server.rs` file). The client app and the server functions are written in a shared `lib.rs` file.

The desktop and server targets have slightly different build configuration to enable additional dependencies or features.
The Cargo.toml in the full example has more information, but the main points are:

* the client.rs has to be run with the `desktop` feature, so that the optional `dioxus-desktop` dependency is included
* the server.rs has to be run with the `ssr` features; this will generate the server part of the server functions and will run our backend server.

Once you create your project, you can run the server executable with:

````bash
cargo run --bin server --features ssr
````

and the client desktop executable with:

````bash
cargo run --bin client --features desktop
````

### Client code

The client file is pretty straightforward. You only need to set the server url in the client code, so it knows where to send the network requests. Then, dioxus_desktop launches the app.

For development, the example project runs the server on `localhost:8080`. **Before you release remember to update the url to your production url.**

### Server code

In the server code, first you have to set the network address and port where the server will listen to.

````rs@server_function_desktop_client.rs
let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
    .await
    .unwrap();
println!("listening on http://127.0.0.1:3000");
````

Then, you have to register the types declared in the server function macros into the server.
For example, consider this server function:

````rs@server_function_desktop_client.rs
#[server(GetServerData)]
async fn get_server_data() -> Result<String, ServerFnError> {
    Ok("Hello from the server!".to_string())
}
````

Finally, the server is started and it begins responding to requests.
# Extractors

Server functions are an ergonomic way to call a function on the server. Server function work by registering an endpoint on the server and using requests on the client. Most of the time, you shouldn't need to worry about how server functions operate, but there are some times when you need to get some value from the request other than the data passed in the server function.

For example, requests contain information about the user's browser (called the [user agent](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent)). We can use an extractor to retrieve that information.

You can use the `extract` method within a server function to extract something from the request. You can extract any type that implements `FromServerContext` (or when axum is enabled, you can use axum extractors directly):

````rs@server_function_extract.rs
#[server]
pub async fn log_headers() -> Result<(), ServerFnError> {
    let headers: http::HeaderMap = extract().await?;
    log::info!("{:?}", headers[http::header::USER_AGENT]);
    Ok(())
}
````
# Middleware

Extractors allow you to wrap your server function in some code that changes either the request or the response. Dioxus fullstack integrates with [Tower](https://docs.rs/tower/latest/tower/index.html) to allow you to wrap your server functions in middleware.

You can use the `#[middleware]` attribute to add a layer of middleware to your server function. Let's add a timeout middleware to a server function. This middleware will stop running the server function if it reaches a certain timeout:

````rs@server_function_middleware.rs
#[server]
// Add a timeout middleware to the server function that will return an error if the function takes longer than 1 second to execute
#[middleware(tower_http::timeout::TimeoutLayer::new(std::time::Duration::from_secs(1)))]
pub async fn timeout() -> Result<(), ServerFnError> {
    tokio::time::sleep(std::time::Duration::from_secs(2)).await;
    Ok(())
}
````
# Authentication

You can use [extractors](./extractors) to integrate auth with your Fullstack application.

You can create a custom extractors that extracts the auth session from the request. From that auth session, you can check if the user has the required privileges before returning the private data.

A [full auth example](https://github.com/DioxusLabs/dioxus/blob/v0.6/examples/fullstack-auth) with the complete implementation is available in the fullstack examples.
# Routing

You can easily integrate your fullstack application with a client side router using Dioxus Router. This allows you to create different scenes in your app and navigate between them. You can read more about the router in the [router reference](../../router/index.md)

````rs@server_router.rs
#![allow(non_snake_case)]

use axum::Router;
use dioxus::prelude::*;

use serde::{Deserialize, Serialize};

fn main() {
    launch(|| rsx! { Router::<Route> {} });
}

#[derive(Clone, Routable, Debug, PartialEq, Serialize, Deserialize)]
enum Route {
    #[route("/")]
    Home {},
    #[route("/blog/:id")]
    Blog { id: i32 },
}

#[component]
fn Blog(id: i32) -> Element {
    rsx! {
        Link { to: Route::Home {}, "Go to counter" }
        table {
            tbody {
                for _ in 0..id {
                    tr {
                        for _ in 0..id {
                            td { "hello world!" }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn Home() -> Element {
    let mut count = use_signal(|| 0);
    let mut text = use_signal(|| "...".to_string());

    rsx! {
        Link { to: Route::Blog { id: count() }, "Go to blog" }
        div {
            h1 { "High-Five counter: {count}" }
            button { onclick: move |_| count += 1, "Up high!" }
            button { onclick: move |_| count -= 1, "Down low!" }
            button {
                onclick: move |_| {
                    async move {
                        if let Ok(data) = get_server_data().await {
                            println!("Client received: {}", data);
                            text.set(data.clone());
                            post_server_data(data).await.unwrap();
                        }
                    }
                },
                "Run server function!"
            }
            "Server said: {text}"
        }
    }
}

#[server(PostServerData)]
async fn post_server_data(data: String) -> Result<(), ServerFnError> {
    println!("Server received: {}", data);

    Ok(())
}

#[server(GetServerData)]
async fn get_server_data() -> Result<String, ServerFnError> {
    Ok("Hello from the server!".to_string())
}

````

````inject-dioxus
SandBoxFrame {
	url: "https://codesandbox.io/p/sandbox/dioxus-fullstack-router-s75v5q?file=%2Fsrc%2Fmain.rs%3A7%2C1"
}
````
# Static Site Generation

Static site generation (SSG) lets you pre-generate all static pages of your application at build time. Once you have the static html pages, you can deploy them to any static hosting provider like GitHub Pages.

## Setting up the ServeConfig

SSG builds on top of the incremental rendering feature of Dioxus fullstack. We need to set up the `ServeConfig` to enable incremental rendering. The incremental config needs to render to the `public` directory where Dioxus places all other public files like the wasm binary and static assets. The `public` directory in the web folder will always be placed alongside the server binary.

````rs@static_site_generation.rs
fn main() {
    dioxus::LaunchBuilder::new()
        // Set the server config only if we are building the server target
        .with_cfg(server_only! {
            ServeConfig::builder()
                // Enable incremental rendering
                .incremental(
                    IncrementalRendererConfig::new()
                        // Store static files in the public directory where other static assets like wasm are stored
                        .static_dir(
                            std::env::current_exe()
                                .unwrap()
                                .parent()
                                .unwrap()
                                .join("public")
                        )
                        // Don't clear the public folder on every build. The public folder has other files including the wasm
                        // binary and static assets required for the app to run
                        .clear_cache(false)
                )
                .enable_out_of_order_streaming()
        })
        .launch(app);
}
````

## Configuring static routes

Once you have incremental rendering enabled, you need to tell the CLI about the static routes in your app. The CLI looks for a server function at the endpoint `"static_routes"` that returns a list of all static urls. It will call this server function at build time and pre-render all of the routes in the list.

````rs@static_site_generation.rs
#[derive(Routable, Clone, PartialEq)]
pub enum Route {
    // Any routes with no dynamic segments in your router will be included in the static routes list
    #[route("/")]
    Index {},
    #[route("/other")]
    Other {},
}

// The server function at the endpoint "static_routes" will be called by the CLI to generate the list of static
// routes. You must explicitly set the endpoint to `"static_routes"` in the server function attribute instead of
// the default randomly generated endpoint.
#[server(endpoint = "static_routes", output = server_fn::codec::Json)]
async fn static_routes() -> Result<Vec<String>, ServerFnError> {
    // The `Routable` trait has a `static_routes` method that returns all static routes in the enum
    Ok(Route::static_routes().iter().map(ToString::to_string).collect())
}
````

## Publishing static sites

Finally, you can bundle your site with `dx bundle --platform web --ssg`. Once the CLI finishes bundling, you should see a `public` folder in the dx folder of your project:

![Dioxus SSG](/assets/06_docs/ssg_folder.png)

The folder contains all of the static assets that you need to serve your site. You can copy the public folder into any static hosting provider like GitHub Pages.
# Axum integration

Dioxus fullstack is built on top of Axum under the hood. The launch function will set up a default Axum server for your fullstack project, but if you need more control you can drop down to a custom axum server. This guide will show you how to set up an Axum server with your Dioxus fullstack project.

## Adding axum to your project

First, we need to add axum and tokio as dependencies. Since we only need these dependencies on the server, we need to make them optional and enable them in the server feature flag. More information about server only dependencies can be found in the [dependencies guide](./managing_dependencies.md#adding-server-only-dependencies):

````toml
[dependencies]
dioxus = { version = "0.6.0", features = ["fullstack"] }
# Axum is optional because we only use it on the server
axum = { version = "0.7", optional = true }
tokio = { version = "1.0", features = ["full"], optional = true }

[features]
# ...
web = ["dioxus/web"]
# The server feature enables the axum dependency
server = ["dioxus/server", "dep:axum", "dep:tokio"]
````

## Splitting up the main function

Next we to split up our main function into two parts: one that will start dioxus on the client with the launch function, and one that will serve our Axum router. We can use `#[cfg]` attribute to control what code compiles when the web feature or server feature is enabled:

````rs@axum_integration.rs
fn main() {
    #[cfg(feature = "web")]
    // Hydrate the application on the client
    dioxus::launch(App);

    // Launch axum on the server
    #[cfg(feature = "server")]
    {
        tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async move {
                launch_server(App).await;
            });
    }
}
````

## Starting the axum server

Now we can setup our axum server in the launch_server function. Since this code should only compile when the server is enabled, we need to gate it behind a `#[cfg(feature = "server")]` attribute again.

When we serve our app the CLI will try to proxy the backend under a random port. The proxy adds devtool endpoints for hot reloading and logging to make it easier to develop your app. We need to look for the port the CLI gives us in dev mode with `server_ip` and `server_port`. If we don't find a port from the CLI, we can serve at our own ip and port for production.

Finally, when building our Axum server, we need to call `serve_dioxus_application` on the router to add all the routes Dioxus needs to serve your app.

````rs@axum_integration.rs
#[cfg(feature = "server")]
async fn launch_server(component: fn() -> Element) {
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};

    // Get the address the server should run on. If the CLI is running, the CLI proxies fullstack into the main address
    // and we use the generated address the CLI gives us
    let ip =
        dioxus::cli_config::server_ip().unwrap_or_else(|| IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));
    let port = dioxus::cli_config::server_port().unwrap_or(8080);
    let address = SocketAddr::new(ip, port);
    let listener = tokio::net::TcpListener::bind(address).await.unwrap();
    let router = axum::Router::new()
        // serve_dioxus_application adds routes to server side render the application, serve static assets, and register server functions
        .serve_dioxus_application(ServeConfigBuilder::default(), App)
        .into_make_service();
    axum::serve(listener, router).await.unwrap();
}
````

## Running your application

Now we can run our application with the CLI. The CLI will automatically detect the server feature (that enables `dioxus/server`) and the client feature (which enables `dioxus/web`, `dioxus/desktop` or `dioxus/mobile`) and build once for each platform. To run the application, we can use the following command:

````bash
dx serve
````

## Conclusion

This guide showed you how to set up a custom Axum server with your Dioxus fullstack project. You can now use all of the features of Axum in your Dioxus app, including middleware, routing, and more. If you need even more granular control over your router, you can split up the `serve_dioxus_application` function into [`serve_static_assets`](https://docs.rs/dioxus-fullstack/0.6.3/dioxus_fullstack/server/trait.DioxusRouterExt.html#tymethod.serve_static_assets), [`register_server_functions`](https://docs.rs/dioxus-fullstack/0.6.3/dioxus_fullstack/server/trait.DioxusRouterExt.html#method.register_server_functions), and [`render_handler`](https://docs.rs/dioxus-fullstack/0.6.3/dioxus_fullstack/server/fn.render_handler.html). See the documentation on each method for more details

If you want to learn more about Axum, check out the [Axum documentation](https://docs.rs/axum/latest/axum/). Axum is built on top of the tower ecosystem which means you can use any tower service with your Axum server. The [tower-http](https://docs.rs/tower-http/latest/tower_http/) crate contains many useful utilities for your server like logging, compression, and file serving.
# Publishing

After you have build your application, you will need to publish it somewhere. This reference will outline different methods of publishing your desktop or web application.

## Web: Publishing with GitHub Pages

Edit your `Dioxus.toml` to point your `out_dir` to the `docs` folder and the `base_path` to the name of your repo:

````toml
[application]
# ...
[web.app]
base_path = "your_repo"
````

Then build your app and publish it to Github:

* Make sure GitHub Pages is set up for your repo to publish any static files in the docs directory
* Build your app into the `docs` directory with:

````sh
dx bundle --out-dir docs
````

* Move the static content from `docs/public` to `docs`

````sh
mv docs/public/* docs
````

* Make a copy of your `docs/index.html` file and rename the copy to `docs/404.html` so that your app will work with client-side routing:

````sh
cp docs/index.html docs/404.html
````

* Add and commit with git
* Push to GitHub

## Desktop: Creating an installer

Dioxus desktop app uses your operating system's WebView library, so it's portable to be distributed for other platforms.

In this section, we'll cover how to bundle your app for macOS, Windows, and Linux.

## Preparing your application for bundling

Depending on your platform, you may need to add some additional code to your `main.rs` file to make sure your app is ready for bundling. On Windows, you'll need to add the `#![windows_subsystem = "windows"]` attribute to your `main.rs` file to hide the terminal window that pops up when you run your app. **If you're developing on Windows, only use this when bundling.** It will disable the terminal, so you will not get logs of any kind. You can gate it behind a feature, like so:

````toml
# Cargo.toml
[features]
bundle = []
````

And then your `main.rs`:

````rust
#![cfg_attr(feature = "bundle", windows_subsystem = "windows")]
````

## Adding assets to your application

If you want to bundle assets with your application, you can either use them with the `manganis` crate (covered more in the [assets](../guides/assets.md) page), or you can include them in your `Dioxus.toml` file:

````toml
[bundle]
# The list of files to include in the bundle. These can contain globs.
resources = ["main.css", "header.svg", "**/*.png"]
````

## Install `dioxus CLI`

The first thing we'll do is install the [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli). This extension to cargo will make it very easy to package our app for the various platforms.

To install, simply run

`cargo install dioxus-cli`

## Building

To bundle your application you can simply run `dx bundle --release` (also add `--features bundle` if you're using that, see the [this](#preparing-your-application-for-bundling) for more) to produce a final app with all the optimizations and assets builtin.

Once you've ran the command, your app should be accessible in `dist/bundle/`.

For example, a macOS app would look like this:

![Published App](/assets/static/publish.png)

Nice! And it's only 4.8 Mb â€“ extremely lean!! Because Dioxus leverages your platform's native WebView, Dioxus apps are extremely memory efficient and won't waste your battery.

 > 
 > Note: not all CSS works the same on all platforms. Make sure to view your app's CSS on each platform â€“ or web browser (Firefox, Chrome, Safari) before publishing.
# Antipatterns

This example shows what not to do and provides a reason why a given pattern is considered an "AntiPattern". Most anti-patterns are considered wrong for performance or code re-usability reasons.

## Unnecessarily Nested Fragments

Fragments don't mount a physical element to the DOM immediately, so Dioxus must recurse into its children to find a physical DOM node. This process is called "normalization". This means that deeply nested fragments make Dioxus perform unnecessary work. Prefer one or two levels of fragments / nested components until presenting a true DOM element.

Only Component and Fragment nodes are susceptible to this issue. Dioxus mitigates this with components by providing an API for registering shared state without the Context Provider pattern.

````rs@anti_patterns.rs
// âŒ Don't unnecessarily nest fragments
let _ = rsx! {
    Fragment {
        Fragment {
            Fragment {
                Fragment {
                    Fragment { div { "Finally have a real node!" } }
                }
            }
        }
    }
};

// âœ… Render shallow structures
rsx! { div { "Finally have a real node!" } }
````

## Incorrect Iterator Keys

As described in the [dynamic rendering chapter](../reference/dynamic_rendering#the-key-attribute), list items must have unique keys that are associated with the same items across renders. This helps Dioxus associate state with the contained components and ensures good diffing performance. Do not omit keys, unless you know that the list will never change.

````rs@anti_patterns.rs
let data: &HashMap<_, _> = &props.data;

// âŒ No keys
rsx! {
    ul {
        for value in data.values() {
            li { "List item: {value}" }
        }
    }
};

// âŒ Using index as keys
rsx! {
    ul {
        for (index , value) in data.values().enumerate() {
            li { key: "{index}", "List item: {value}" }
        }
    }
};

// âœ… Using unique IDs as keys:
rsx! {
    ul {
        for (key , value) in props.data.iter() {
            li { key: "{key}", "List item: {value}" }
        }
    }
}
````

## Avoid Interior Mutability in Props

While it is technically acceptable to have a `Mutex` or a `RwLock` in the props, they will be difficult to use.

Suppose you have a struct `User` containing the field `username: String`. If you pass a `Mutex<User>` prop to a `UserComponent` component, that component may wish to write to the `username` field. However, when it does, the parent component will not be aware of the change, and the component will not re-render which causes the UI to be out of sync with the state. Instead, consider passing down a reactive value like a `Signal` or immutable data.

````rs@anti_patterns.rs
// âŒ Mutex/RwLock/RefCell in props
#[derive(Props, Clone)]
struct AntipatternInteriorMutability {
    map: Rc<RefCell<HashMap<u32, String>>>,
}

impl PartialEq for AntipatternInteriorMutability {
    fn eq(&self, other: &Self) -> bool {
        std::rc::Rc::ptr_eq(&self.map, &other.map)
    }
}

fn AntipatternInteriorMutability(map: Rc<RefCell<HashMap<u32, String>>>) -> Element {
    rsx! {
        button {
            onclick: {
                let map = map.clone();
                move |_| {
                    // Writing to map will not rerun any components
                    map.borrow_mut().insert(0, "Hello".to_string());
                }
            },
            "Mutate map"
        }
        // Since writing to map will not rerun any components, this will get out of date
        "{map.borrow().get(&0).unwrap()}"
    }
}

// âœ… Use a signal to pass mutable state
#[component]
fn AntipatternInteriorMutabilitySignal(map: Signal<HashMap<u32, String>>) -> Element {
    rsx! {
        button {
            onclick: move |_| {
                // Writing to map will rerun any components that read the map
                map.write().insert(0, "Hello".to_string());
            },
            "Mutate map"
        }
        // Since writing to map will rerun subscribers, this will get updated
        "{map.read().get(&0).unwrap()}"
    }
}
````

## Avoid Updating State During Render

Every time you update the state, Dioxus needs to re-render the component â€“ this is inefficient! Consider refactoring your code to avoid this.

Also, if you unconditionally update the state during render, it will be re-rendered in an infinite loop.

````rs@anti_patterns.rs
// âŒ Updating state in render
let first_signal = use_signal(|| 0);
let mut second_signal = use_signal(|| 0);

// Updating the state during a render can easily lead to infinite loops
if first_signal() + 1 != second_signal() {
    second_signal.set(first_signal() + 1);
}

// âœ… Update state in an effect
let first_signal = use_signal(|| 0);
let mut second_signal = use_signal(|| 0);

// The closure you pass to use_effect will be rerun whenever any of the dependencies change without re-rendering the component
use_effect(move || {
    if first_signal() + 1 != second_signal() {
        second_signal.set(first_signal() + 1);
    }
});

// âœ… Deriving state with use_memo
let first_signal = use_signal(|| 0);
// Memos are specifically designed for derived state. If your state fits this pattern, use it.
let second_signal = use_memo(move || first_signal() + 1);
````

## Avoid Large Groups of State

It can be tempting to have a single large state struct that contains all of your application's state. However, this can lead to issues:

* It can be easy to accidentally mutate the state in a way that causes an infinite loop
* It can be difficult to reason about when and how the state is updated
* It can lead to performance issues because many components will need to re-render when the state changes

Instead, consider breaking your state into smaller, more manageable pieces. This will make it easier to reason about the state, avoid update loops, and improve performance.

````rs@anti_patterns.rs
fn app() -> Element {
    // âŒ Large state struct
    #[derive(Props, Clone, PartialEq)]
    struct LargeState {
        users: Vec<User>,
        logged_in: bool,
        warnings: Vec<String>,
    }

    #[derive(Props, Clone, PartialEq)]
    struct User {
        name: String,
        email: String,
    }

    let mut all_my_state = use_signal(|| LargeState {
        users: vec![User {
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        }],
        logged_in: true,
        warnings: vec![],
    });

    use_effect(move || {
        // It is very easy to accidentally read and write to the state object if it contains all your state
        let read = all_my_state.read();
        let logged_in = read.logged_in;
        if !logged_in {
            all_my_state
                .write_unchecked()
                .warnings
                .push("You are not logged in".to_string());
        }
    });

    // âœ… Use multiple signals to manage state
    let users = use_signal(|| {
        vec![User {
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        }]
    });
    let logged_in = use_signal(|| true);
    let mut warnings = use_signal(|| vec![]);

    use_effect(move || {
        // Now you can read and write to separate signals which will not cause issues
        if !logged_in() {
            warnings.write().push("You are not logged in".to_string());
        }
    });

    // âœ… Use memos to create derived state when larger states are unavoidable
    // Notice we didn't split everything into separate signals. Users still make sense as a vec of data
    let users = use_signal(|| {
        vec![User {
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        }]
    });
    let logged_in = use_signal(|| true);
    let warnings: Signal<Vec<String>> = use_signal(|| vec![]);

    // In child components, you can use the memo to create derived that will only update when a specific part of the state changes
    // This will help you avoid unnecessary re-renders and infinite loops
    #[component]
    fn FirstUser(users: Signal<Vec<User>>) -> Element {
        let first_user = use_memo(move || users.read().first().unwrap().clone());

        rsx! {
            div {
                "First user: {first_user().name}"
            }
        }
    }

    rsx! {
        FirstUser {
            users
        }
    }
}
````

## Running Non-Deterministic Code in the Body of a Component

If you have a component that contains non-deterministic code, that code should generally not be run in the body of the component. If it is put in the body of the component, it will be executed every time the component is re-rendered which can lead to performance issues.

Instead, consider moving the non-deterministic code into a hook that only runs when the component is first created or an effect that reruns when dependencies change.

````rs@anti_patterns.rs
// âŒ Non-deterministic code in the body of a component
#[component]
fn NonDeterministic(name: String) -> Element {
    let my_random_id = rand::random::<u64>();

    rsx! {
        div {
            // Id will change every single time the component is re-rendered
            id: "{my_random_id}",
            "Hello {name}"
        }
    }
}

// âœ… Use a hook to run non-deterministic code
fn NonDeterministicHook(name: String) -> Element {
    // If you store the result of the non-deterministic code in a hook, it will stay the same between renders
    let my_random_id = use_hook(|| rand::random::<u64>());

    rsx! {
        div {
            id: "{my_random_id}",
            "Hello {name}"
        }
    }
}
````

## Overly Permissive PartialEq for Props

You may have noticed that `Props` requires a `PartialEq` implementation. That `PartialEq` is very important for Dioxus to work correctly. It is used to determine if a component should re-render or not when the parent component re-renders.

If you cannot derive `PartialEq` for your `Props`, you will need to implement it yourself. If you do implement `PartialEq`, make sure to return `false` any time the props change in a way that would cause the UI in the child component to change.

In general, returning `false` from `PartialEq` if you aren't sure if the props have changed or not is better than returning `true`. This will help you avoid out of date UI in your child components.

````rs@anti_patterns.rs
// âŒ Permissive PartialEq for Props
#[derive(Props, Clone)]
struct PermissivePartialEqProps {
    name: String,
}

// This will cause the component to **never** re-render when the parent component re-renders
impl PartialEq for PermissivePartialEqProps {
    fn eq(&self, _: &Self) -> bool {
        true
    }
}

fn PermissivePartialEq(name: PermissivePartialEqProps) -> Element {
    rsx! {
        div {
            "Hello {name.name}"
        }
    }
}

#[component]
fn PermissivePartialEqParent() -> Element {
    let name = use_signal(|| "Alice".to_string());

    rsx! {
        PermissivePartialEq {
            // The PermissivePartialEq component will not get the updated value of name because the PartialEq implementation says that the props are the same
            name: name()
        }
    }
}

// âœ… Derive PartialEq for Props
#[derive(Props, Clone, PartialEq)]
struct DerivePartialEqProps {
    name: String,
}

fn DerivePartialEq(name: DerivePartialEqProps) -> Element {
    rsx! {
        div {
            "Hello {name.name}"
        }
    }
}

#[component]
fn DerivePartialEqParent() -> Element {
    let name = use_signal(|| "Alice".to_string());

    rsx! {
        DerivePartialEq {
            name: name()
        }
    }
}

// âœ… Return false from PartialEq if you are unsure if the props have changed
#[derive(Debug)]
struct NonPartialEq;

#[derive(Props, Clone)]
struct RcPartialEqProps {
    name: Rc<NonPartialEq>,
}

impl PartialEq for RcPartialEqProps {
    fn eq(&self, other: &Self) -> bool {
        // This will almost always return false because the Rc will likely point to a different value
        // Implementing PartialEq for NonPartialEq would be better, but if it is controlled by another library, it may not be possible
        // **Always** return false if you are unsure if the props have changed
        std::rc::Rc::ptr_eq(&self.name, &other.name)
    }
}

fn RcPartialEq(name: RcPartialEqProps) -> Element {
    rsx! {
        div {
            "Hello {name.name:?}"
        }
    }
}

fn RcPartialEqParent() -> Element {
    let name = use_signal(|| Rc::new(NonPartialEq));

    rsx! {
        RcPartialEq {
            // Generally, RcPartialEq will rerun even if the value of name hasn't actually changed because the Rc will point to a different value
            name: name()
        }
    }
}
````
This section of the guide provides getting started guides for common tools used with Dioxus.

* [Logging](./logging.md)
* [Internationalization](./internationalization.md)
# Logging

Dioxus has a wide range of supported platforms, each with their own logging requirements. We'll discuss the different options available for your projects.

## Dioxus Logger

Dioxus provides a first-party logger as part of `launch`. This sets up a tracing subscriber that cleanly integrates with the Dioxus CLI and platforms like Web and Mobile. In development mode, the `Debug` tracing level is set, and in release only the `Info` level is set.

````rust
use dioxus::prelude::*;

fn main() {
    dioxus::launch(|| {
        // Will only log in "dev" mode
        tracing::debug!("Rendering app!");

        // Will log in dev and release
        tracing::info!("Rendering app!");

        rsx! {}
    })
}
````

To override the default or initialize the logger before `launch`, you can use the `init` function yourself:

To use Dioxus Logger, call the `init()` function:

````rs
use tracing::Level;

fn main() {
    // Init logger
    dioxus_logger::init(Level::INFO).expect("failed to init logger");

    // Dioxus launch code
    dioxus::launch(|| rsx! {})
}
````

## The Tracing Crate

The [Tracing](https://crates.io/crates/tracing) crate is the logging interface that the dioxus-logger uses. It is not required to use the Tracing crate, but you will not receive logs from the Dioxus library.

The Tracing crate provides a variety of simple `println`-like macros with varying levels of severity.
The available macros are as follows with the highest severity on the bottom:

````rs
fn main() {
    tracing::trace!("trace");
    tracing::debug!("debug");
    tracing::info!("info");
    tracing::warn!("warn");
    tracing::error!("error");
}
````

All the loggers provided on this page are, besides configuration and initialization, interfaced using these macros. Often you will also utilize the Tracing crate's `Level` enum. This enum usually represents the maximum log severity you want your application to emit and can be loaded from a variety of sources such as configuration file, environment variable, and more.

For more information, visit the Tracing crate's [docs](https://docs.rs/tracing/latest/tracing/).

## Platform Intricacies

On web, Dioxus Logger will use [tracing-wasm](https://crates.io/crates/tracing-wasm). On Desktop and server-based targets, Dioxus Logger will use [tracing-subscriber](https://crates.io/crates/tracing-subscriber)'s `FmtSubscriber`.

## Viewing Logs

Android logs are sent to logcat. To use logcat through the Android debugger, run:

````cmd
adb -d logcat
````

Your Android device will need developer options/usb debugging enabled.

For more information, visit android_logger's [docs](https://docs.rs/android_logger/latest/android_logger/).

iOS logs are sent to oslog.

For more information, visit [oslog](https://crates.io/crates/oslog).

#### Final Notes

Dioxus Logger is the preferred logger to use with Dioxus if it suites your needs. There are more features to come. If there are any feature suggestions or issues with Dioxus Logger, feel free to reach out on the [Dioxus Discord Server](https://discord.gg/XgGxMSkvUM)!

For more information, visit Dioxus Logger's [docs](https://docs.rs/dioxus-logger/latest/dioxus_logger/).
# Internationalization

If your application supports multiple languages, the [dioxus-i18n](https://github.com/dioxus-community/dioxus-i18n) crate contains helpers to make working with translations in your application easier.

You can find an example [here](https://github.com/dioxus-community/dioxus-i18n/blob/main/examples/dioxus-desktop.rs).
# State Cookbook

* [External State](external/index.md)
* [Custom Hook](custom_hooks/index.md)
# Working with External State

This guide will help you integrate your Dioxus application with some external state like a different thread or a websocket connection.

## Working with non-reactive State

[Coroutines](../../../reference/use_coroutine.md) are great tool for dealing with non-reactive (state you don't render directly) state within your application.

You can store your state inside the coroutine async block and communicate with the coroutine with messages from any child components.

````rs@use_coroutine.rs
// import futures::StreamExt to use the next() method
use futures::StreamExt;
let mut response_state = use_signal(|| None);
let tx = use_coroutine(move |mut rx| async move {
    // Define your state before the loop
    let mut state = reqwest::Client::new();
    let mut cache: HashMap<String, String> = HashMap::new();
    loop {
        // Loop and wait for the next message
        if let Some(request) = rx.next().await {
            // Resolve the message
            let response = if let Some(response) = cache.get(&request) {
                response.clone()
            } else {
                let response = state
                    .get(&request)
                    .send()
                    .await
                    .unwrap()
                    .text()
                    .await
                    .unwrap();
                cache.insert(request, response.clone());
                response
            };
            response_state.set(Some(response));
        } else {
            break;
        }
    }
});
// Send a message to the coroutine
tx.send("https://example.com".to_string());
// Get the current state of the coroutine
let response = response_state.read();
````

## Making Reactive State External

If you have some reactive state (state that is rendered), that you want to modify from another thread, you can use a signal that is sync. Signals take an optional second generic value with information about syncness. Sync signals have a slightly higher overhead than thread local signals, but they can be used in a multithreaded environment.

````rs@sync_signal.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    let mut signal = use_signal_sync(|| 0);

    use_hook(|| {
        std::thread::spawn(move || loop {
            std::thread::sleep(std::time::Duration::from_secs(1));
            // You can easily update the signal from a different thread
            signal += 1;
        });
    });

    rsx! {
        button { onclick: move |_| signal += 1, "Increase" }
        "{signal}"
    }
}

````
# Custom Hooks

Hooks are a great way to encapsulate business logic. If none of the existing hooks work for your problem, you can write your own.

When writing your hook, you can make a function that starts with `use_` and takes any arguments you need. You can then use the `use_hook` method to create a hook that will be called the first time the component is rendered.

## Composing Hooks

To avoid repetition, you can encapsulate business logic based on existing hooks to create a new hook.

For example, if many components need to access an `AppSettings` struct, you can create a "shortcut" hook:

````rs@hooks_composed.rs
fn use_settings() -> Signal<AppSettings> {
    consume_context()
}
````

Or if you want to wrap a hook that persists reloads with the storage API, you can build on top of the use_signal hook to work with mutable state:

````rs@hooks_composed.rs
use gloo_storage::{LocalStorage, Storage};
use serde::{de::DeserializeOwned, Serialize};

/// A persistent storage hook that can be used to store data across application reloads.
#[allow(clippy::needless_return)]
pub fn use_persistent<T: Serialize + DeserializeOwned + Default + 'static>(
    // A unique key for the storage entry
    key: impl ToString,
    // A function that returns the initial value if the storage entry is empty
    init: impl FnOnce() -> T,
) -> UsePersistent<T> {
    // Use the use_signal hook to create a mutable state for the storage entry
    let state = use_signal(move || {
        // This closure will run when the hook is created
        let key = key.to_string();
        let value = LocalStorage::get(key.as_str()).ok().unwrap_or_else(init);
        StorageEntry { key, value }
    });

    // Wrap the state in a new struct with a custom API
    UsePersistent { inner: state }
}

struct StorageEntry<T> {
    key: String,
    value: T,
}

/// Storage that persists across application reloads
pub struct UsePersistent<T: 'static> {
    inner: Signal<StorageEntry<T>>,
}

impl<T> Clone for UsePersistent<T> {
    fn clone(&self) -> Self {
        *self
    }
}

impl<T> Copy for UsePersistent<T> {}

impl<T: Serialize + DeserializeOwned + Clone + 'static> UsePersistent<T> {
    /// Returns a reference to the value
    pub fn get(&self) -> T {
        self.inner.read().value.clone()
    }

    /// Sets the value
    pub fn set(&mut self, value: T) {
        let mut inner = self.inner.write();
        // Write the new value to local storage
        LocalStorage::set(inner.key.as_str(), &value);
        inner.value = value;
    }
}
````

## Custom Hook Logic

You can use [`use_hook`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_hook.html) to build your own hooks. In fact, this is what all the standard hooks are built on!

`use_hook` accepts a single closure for initializing the hook. It will be only run the first time the component is rendered. The return value of that closure will be used as the value of the hook â€“ Dioxus will take it, and store it for as long as the component is alive. On every render (not just the first one!), you will get a reference to this value.

 > 
 > Note: You can use the `use_on_destroy` hook to clean up any resources the hook uses when the component is destroyed.

Inside the initialization closure, you will typically make calls to other `cx` methods. For example:

* The `use_signal` hook tracks state in the hook value, and uses [`ReactiveContext`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ReactiveContext.html) to make Dioxus re-render any component that has observed it whenever the signal's value changes.

Here is a simplified implementation of the `use_signal` hook:

````rs@hooks_custom_logic.rs
use std::cell::RefCell;
use std::collections::HashSet;
use std::rc::Rc;
use std::sync::{Arc, Mutex};

struct Signal<T> {
    value: Rc<RefCell<T>>,
    subscribers: Arc<Mutex<HashSet<ReactiveContext>>>,
}

impl<T> Clone for Signal<T> {
    fn clone(&self) -> Self {
        Self {
            value: self.value.clone(),
            subscribers: self.subscribers.clone(),
        }
    }
}

fn my_use_signal<T: 'static>(init: impl FnOnce() -> T) -> Signal<T> {
    use_hook(|| {
        // A set of subscribers to notify about changes to this signals value
        let subscribers = Default::default();
        // Create the initial state
        let value = Rc::new(RefCell::new(init()));

        Signal { value, subscribers }
    })
}

impl<T: Clone> Signal<T> {
    fn get(&self) -> T {
        // Subscribe the context observing the signal (if any) to updates of its value.
        if let Some(reactive_context) = ReactiveContext::current() {
            reactive_context.subscribe(self.subscribers.clone());
        }

        self.value.borrow().clone()
    }

    fn set(&self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render of the components that observed the signal's previous value
        let mut subscribers = std::mem::take(&mut *self.subscribers.lock().unwrap());
        subscribers.retain(|reactive_context| reactive_context.mark_dirty());
        // Extend the subscribers list instead of overwriting it in case a subscriber is added while reactive contexts are marked dirty
        self.subscribers.lock().unwrap().extend(subscribers);
    }
}
````

* The `use_context` hook calls [`consume_context`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.consume_context.html) (which would be expensive to call on every render) to get some context from the component

Here is an implementation of the `use_context` and `use_context_provider` hooks:

````rs@hooks_custom_logic.rs
pub fn use_context<T: 'static + Clone>() -> T {
    use_hook(|| consume_context())
}

pub fn use_context_provider<T: 'static + Clone>(f: impl FnOnce() -> T) -> T {
    use_hook(|| {
        let val = f();
        // Provide the context state to the component
        provide_context(val.clone());
        val
    })
}

````
### Bundling config

The `[bundle]` section of our Dioxus.toml can take a variety of options.

Here are the options, in the form of Rust structs.

````rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct BundleConfig {
    /// eg. com.dioxuslabs
    pub(crate) identifier: Option<String>,
    /// eg. DioxusLabs
    pub(crate) publisher: Option<String>,
    /// eg. assets/icon.png
    pub(crate) icon: Option<Vec<String>>,
    /// eg. Extra assets like "img.png"
    pub(crate) resources: Option<Vec<String>>,
    /// eg. DioxusLabs
    pub(crate) copyright: Option<String>,
    /// eg. "Social Media"
    pub(crate) category: Option<String>,
    /// eg. "A great social media app"
    pub(crate) short_description: Option<String>,
    /// eg. "A social media app that makes people love app development"
    pub(crate) long_description: Option<String>,
    /// eg. extra binaries (like tools) to include in the final app
    pub(crate) external_bin: Option<Vec<String>>,
    /// Additional debian-only settings (see below)
    pub(crate) deb: Option<DebianSettings>,
    /// Additional macos settings (see below)
    pub(crate) macos: Option<MacOsSettings>,
    /// Additional windows settings (see below)
    pub(crate) windows: Option<WindowsSettings>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct DebianSettings {
    // OS-specific settings:
    /// the list of debian dependencies.
    pub depends: Option<Vec<String>>,
    /// the list of dependencies the package provides.
    pub provides: Option<Vec<String>>,
    /// the list of package conflicts.
    pub conflicts: Option<Vec<String>>,
    /// the list of package replaces.
    pub replaces: Option<Vec<String>>,
    /// List of custom files to add to the deb package.
    /// Maps the path on the debian package to the path of the file to include (relative to the current working directory).
    pub files: HashMap<PathBuf, PathBuf>,
    /// Path to a custom desktop file Handlebars template.
    ///
    /// Available variables: `categories`, `comment` (optional), `exec`, `icon` and `name`.
    pub desktop_template: Option<PathBuf>,
    /// Define the section in Debian Control file. See : <https://www.debian.org/doc/debian-policy/ch-archive.html#s-subsections>
    pub section: Option<String>,
    /// Change the priority of the Debian Package. By default, it is set to `optional`.
    /// Recognized Priorities as of now are :  `required`, `important`, `standard`, `optional`, `extra`
    pub priority: Option<String>,
    /// Path of the uncompressed Changelog file, to be stored at /usr/share/doc/package-name/changelog.gz. See
    /// <https://www.debian.org/doc/debian-policy/ch-docs.html#changelog-files-and-release-notes>
    pub changelog: Option<PathBuf>,
    /// Path to script that will be executed before the package is unpacked. See
    /// <https://www.debian.org/doc/debian-policy/ch-maintainerscripts.html>
    pub pre_install_script: Option<PathBuf>,
    /// Path to script that will be executed after the package is unpacked. See
    /// <https://www.debian.org/doc/debian-policy/ch-maintainerscripts.html>
    pub post_install_script: Option<PathBuf>,
    /// Path to script that will be executed before the package is removed. See
    /// <https://www.debian.org/doc/debian-policy/ch-maintainerscripts.html>
    pub pre_remove_script: Option<PathBuf>,
    /// Path to script that will be executed after the package is removed. See
    /// <https://www.debian.org/doc/debian-policy/ch-maintainerscripts.html>
    pub post_remove_script: Option<PathBuf>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct WixSettings {
    pub(crate) language: Vec<(String, Option<PathBuf>)>,
    pub(crate) template: Option<PathBuf>,
    pub(crate) fragment_paths: Vec<PathBuf>,
    pub(crate) component_group_refs: Vec<String>,
    pub(crate) component_refs: Vec<String>,
    pub(crate) feature_group_refs: Vec<String>,
    pub(crate) feature_refs: Vec<String>,
    pub(crate) merge_refs: Vec<String>,
    pub(crate) skip_webview_install: bool,
    pub(crate) license: Option<PathBuf>,
    pub(crate) enable_elevated_update_task: bool,
    pub(crate) banner_path: Option<PathBuf>,
    pub(crate) dialog_image_path: Option<PathBuf>,
    pub(crate) fips_compliant: bool,
    /// MSI installer version in the format `major.minor.patch.build` (build is optional).
    ///
    /// Because a valid version is required for MSI installer, it will be derived from [`PackageSettings::version`] if this field is not set.
    ///
    /// The first field is the major version and has a maximum value of 255. The second field is the minor version and has a maximum value of 255.
    /// The third and fourth fields have a maximum value of 65,535.
    ///
    /// See <https://learn.microsoft.com/en-us/windows/win32/msi/productversion> for more info.
    pub version: Option<String>,
    /// A GUID upgrade code for MSI installer. This code **_must stay the same across all of your updates_**,
    /// otherwise, Windows will treat your update as a different app and your users will have duplicate versions of your app.
    ///
    /// By default, tauri generates this code by generating a Uuid v5 using the string `<productName>.exe.app.x64` in the DNS namespace.
    /// You can use Tauri's CLI to generate and print this code for you by running `tauri inspect wix-upgrade-code`.
    ///
    /// It is recommended that you set this value in your tauri config file to avoid accidental changes in your upgrade code
    /// whenever you want to change your product name.
    pub upgrade_code: Option<uuid::Uuid>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub(crate) struct MacOsSettings {
    pub(crate) frameworks: Option<Vec<String>>,
    pub(crate) minimum_system_version: Option<String>,
    pub(crate) license: Option<String>,
    pub(crate) exception_domain: Option<String>,
    pub(crate) signing_identity: Option<String>,
    pub(crate) provider_short_name: Option<String>,
    pub(crate) entitlements: Option<String>,
    pub(crate) info_plist_path: Option<PathBuf>,
    /// List of custom files to add to the application bundle.
    /// Maps the path in the Contents directory in the app to the path of the file to include (relative to the current working directory).
    pub files: HashMap<PathBuf, PathBuf>,
    /// Preserve the hardened runtime version flag, see <https://developer.apple.com/documentation/security/hardened_runtime>
    ///
    /// Settings this to `false` is useful when using an ad-hoc signature, making it less strict.
    pub hardened_runtime: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct WindowsSettings {
    pub(crate) digest_algorithm: Option<String>,
    pub(crate) certificate_thumbprint: Option<String>,
    pub(crate) timestamp_url: Option<String>,
    pub(crate) tsp: bool,
    pub(crate) wix: Option<WixSettings>,
    pub(crate) icon_path: Option<PathBuf>,
    pub(crate) webview_install_mode: WebviewInstallMode,
    pub(crate) webview_fixed_runtime_path: Option<PathBuf>,
    pub(crate) allow_downgrades: bool,
    pub(crate) nsis: Option<NsisSettings>,
    /// Specify a custom command to sign the binaries.
    /// This command needs to have a `%1` in it which is just a placeholder for the binary path,
    /// which we will detect and replace before calling the command.
    ///
    /// Example:
    /// ```text
    /// sign-cli --arg1 --arg2 %1
    /// ```
    ///
    /// By Default we use `signtool.exe` which can be found only on Windows so
    /// if you are on another platform and want to cross-compile and sign you will
    /// need to use another tool like `osslsigncode`.
    pub sign_command: Option<CustomSignCommandSettings>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct NsisSettings {
    pub(crate) template: Option<PathBuf>,
    pub(crate) license: Option<PathBuf>,
    pub(crate) header_image: Option<PathBuf>,
    pub(crate) sidebar_image: Option<PathBuf>,
    pub(crate) installer_icon: Option<PathBuf>,
    pub(crate) install_mode: NSISInstallerMode,
    pub(crate) languages: Option<Vec<String>>,
    pub(crate) custom_language_files: Option<HashMap<String, PathBuf>>,
    pub(crate) display_language_selector: bool,
    pub(crate) start_menu_folder: Option<String>,
    pub(crate) installer_hooks: Option<PathBuf>,
    /// Try to ensure that the WebView2 version is equal to or newer than this version,
    /// if the user's WebView2 is older than this version,
    /// the installer will try to trigger a WebView2 update.
    pub minimum_webview2_version: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) enum NSISInstallerMode {
    CurrentUser,
    PerMachine,
    Both,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) enum WebviewInstallMode {
    Skip,
    DownloadBootstrapper { silent: bool },
    EmbedBootstrapper { silent: bool },
    OfflineInstaller { silent: bool },
    FixedRuntime { path: PathBuf },
}


#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustomSignCommandSettings {
    /// The command to run to sign the binary.
    pub cmd: String,
    /// The arguments to pass to the command.
    ///
    /// "%1" will be replaced with the path to the binary to be signed.
    pub args: Vec<String>,
}

#[derive(Clone, Copy, Debug)]
pub(crate) enum PackageType {
    /// "macos"
    MacOsBundle,
    /// "ios"
    IosBundle,
    /// "msi"
    WindowsMsi,
    /// "nsis"
    Nsis,
    /// "deb"
    Deb,
    /// "rpm"
    Rpm,
    /// "appimage"
    AppImage,
    /// "dmg"
    Dmg,
    /// "updater"
    Updater,
}
````
# Testing

When building application or libraries with Dioxus, you may want to include some tests to check the behavior of parts of your application. This guide will teach you how to test different parts of your Dioxus application.

## Component Testing

You can use a combination of [pretty-assertions](https://docs.rs/pretty_assertions/latest/pretty_assertions/) and [dioxus-ssr](http://crates.io/crates/dioxus-ssr) to check that two snippets of rsx are equal:

````rs@component_test.rs
use futures::FutureExt;
use std::{cell::RefCell, sync::Arc};

use dioxus::prelude::*;

#[test]
fn test() {
    assert_rsx_eq(
        rsx! {
            div { "Hello world" }
            div { "Hello world" }
        },
        rsx! {
            for _ in 0..2 {
                div { "Hello world" }
            }
        },
    )
}

fn assert_rsx_eq(first: Element, second: Element) {
    let first = dioxus_ssr::render_element(first);
    let second = dioxus_ssr::render_element(second);
    pretty_assertions::assert_str_eq!(first, second);
}

````

## Hook Testing

When creating libraries around Dioxus, it can be helpful to make tests for your [custom hooks](./state/custom_hooks/index.md).

Dioxus does not currently have a full hook testing library, but you can build a bespoke testing framework by manually driving the virtual dom.

````rs@hook_test.rs
use futures::FutureExt;
use std::{cell::RefCell, rc::Rc, sync::Arc, thread::Scope};

use dioxus::{dioxus_core::NoOpMutations, prelude::*};

#[test]
fn test() {
    test_hook(
        || use_signal(|| 0),
        |mut value, mut proxy| match proxy.generation {
            0 => {
                value.set(1);
            }
            1 => {
                assert_eq!(*value.read(), 1);
                value.set(2);
            }
            2 => {
                proxy.rerun();
            }
            3 => {}
            _ => todo!(),
        },
        |proxy| assert_eq!(proxy.generation, 4),
    );
}

fn test_hook<V: 'static>(
    initialize: impl FnMut() -> V + 'static,
    check: impl FnMut(V, MockProxy) + 'static,
    mut final_check: impl FnMut(MockProxy) + 'static,
) {
    #[derive(Props)]
    struct MockAppComponent<I: 'static, C: 'static> {
        hook: Rc<RefCell<I>>,
        check: Rc<RefCell<C>>,
    }

    impl<I, C> PartialEq for MockAppComponent<I, C> {
        fn eq(&self, _: &Self) -> bool {
            true
        }
    }

    impl<I, C> Clone for MockAppComponent<I, C> {
        fn clone(&self) -> Self {
            Self {
                hook: self.hook.clone(),
                check: self.check.clone(),
            }
        }
    }

    fn mock_app<I: FnMut() -> V, C: FnMut(V, MockProxy), V>(
        props: MockAppComponent<I, C>,
    ) -> Element {
        let value = props.hook.borrow_mut()();

        props.check.borrow_mut()(value, MockProxy::new());

        rsx! { div {} }
    }

    let mut vdom = VirtualDom::new_with_props(
        mock_app,
        MockAppComponent {
            hook: Rc::new(RefCell::new(initialize)),
            check: Rc::new(RefCell::new(check)),
        },
    );

    vdom.rebuild_in_place();

    while vdom.wait_for_work().now_or_never().is_some() {
        vdom.render_immediate(&mut NoOpMutations);
    }

    vdom.in_runtime(|| {
        ScopeId::ROOT.in_runtime(|| {
            final_check(MockProxy::new());
        })
    })
}

struct MockProxy {
    rerender: Arc<dyn Fn()>,
    pub generation: usize,
}

impl MockProxy {
    fn new() -> Self {
        let generation = generation();
        let rerender = schedule_update();

        Self {
            rerender,
            generation,
        }
    }

    pub fn rerun(&mut self) {
        (self.rerender)();
    }
}

````

## End to End Testing

You can use [Playwright](https://playwright.dev/) to create end to end tests for your dioxus application.

In your `playwright.config.js`, you will need to run cargo run or dx serve instead of the default build command. Here is a snippet from the end to end web example:

````js
//...
webServer: [
    {
        cwd: path.join(process.cwd(), 'playwright-tests', 'web'),
        command: 'dx serve',
        port: 8080,
        timeout: 10 * 60 * 1000,
        reuseExistingServer: !process.env.CI,
        stdout: "pipe",
    },
],
````

* [Web example](https://github.com/DioxusLabs/dioxus/tree/main/packages/playwright-tests/web)
* [Liveview example](https://github.com/DioxusLabs/dioxus/tree/main/packages/playwright-tests/liveview)
* [Fullstack example](https://github.com/DioxusLabs/dioxus/tree/main/packages/playwright-tests/fullstack)
# Tailwind

You can style your Dioxus application with whatever CSS framework you choose, or just write vanilla CSS.

One popular option for styling your Dioxus application is [Tailwind](https://tailwindcss.com/). Tailwind allows you to style your elements with CSS utility classes. This guide will show you how to setup Tailwind CSS with your Dioxus application.

## Setup

1. Install the Dioxus CLI:

````bash
cargo install dioxus-cli
````

2. Install NPM: [https://docs.npmjs.com/downloading-and-installing-node-js-and-npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)

2. Install the Tailwind CSS CLI: [https://tailwindcss.com/docs/installation/tailwind-cli](https://tailwindcss.com/docs/installation/tailwind-cli)

2. Create a `input.css` file in the root of your project with the following content:

````css
@import "tailwindcss";
@source "./src/**/*.{rs,html,css}";
````

5. Create a link to the `tailwind.css` file using manganis somewhere in your rust code:

````rs@tailwind.rs
use dioxus::prelude::*;

#[component]
fn app() -> Element {
    rsx! {
        // The Stylesheet component inserts a style link into the head of the document
        document::Stylesheet {
            // Urls are relative to your Cargo.toml file
            href: asset!("/assets/tailwind.css")
        }
    }
}

````

### Bonus Steps

1. Install the Tailwind CSS VSCode extension
1. Go to the settings for the extension and find the experimental regex support section. Edit the setting.json file to look like this:

````json
"tailwindCSS.experimental.classRegex": ["class: \"(.*)\""],
"tailwindCSS.includeLanguages": {
    "rust": "html"
},
````

## Development

* Run the following command in the root of the project to start the Tailwind CSS compiler:

````bash
npx @tailwindcss/cli -i ./input.css -o ./assets/tailwind.css --watch
````

### Web

* Run the following command in the root of the project to start the Dioxus dev server:

````bash
dx serve
````

* Open the browser to [http://localhost:8080](http://localhost:8080).

### Desktop

* Launch the Dioxus desktop app:

````bash
dx serve --platform desktop
````
# Optimizing

*Note: This is written primarily for the web, but the main optimizations will work on other platforms too.*

You might have noticed that Dioxus binaries are pretty big.
The WASM binary of a [TodoMVC app](https://github.com/tigerros/dioxus-todo-app) weighs in at 2.36mb!
Don't worry; we can get it down to a much more manageable 234kb.
This will get obviously lower over time.
With nightly features, you can even reduce the binary size of a hello world app to less than 100kb!

We will also discuss ways to optimize your app for increased speed.

However, certain optimizations will sacrifice speed for decreased binary size or the other way around.
That's what you need to figure out yourself. Does your app perform performance-intensive tasks, such as graphical processing or tons of DOM manipulations?
You could go for increased speed. In most cases, though, decreased binary size is the better choice, especially because Dioxus WASM binaries are quite large.

To test binary sizes, we will use [this](https://github.com/tigerros/dioxus-todo-app) repository as a sample app.
The `no-optimizations` package will serve as the base, which weighs 2.36mb as of right now.

Additional resources:

* [WASM book - Shrinking `.wasm` code size](https://rustwasm.github.io/docs/book/reference/code-size.html)
* [min-sized-rust](https://github.com/johnthagen/min-sized-rust)

## Building in release mode

This is the best way to optimize. In fact, the 2.36mb figure at the start of the guide is with release mode.
In debug mode, it's actually a whopping 32mb! It also increases the speed of your app.

We can use the `--release` flag to create an optimized build of our application which will be both faster and smaller:

`dx build --release`

## UPX

If you're not targeting web, you can use the [UPX](https://github.com/upx/upx) CLI tool to compress your executables.

Setup:

* Download a [release](https://github.com/upx/upx/releases) and extract the directory inside to a sensible location.
* Add the executable located in the directory to your path variable.

You can run `upx --help` to get the CLI options, but you should also view `upx-doc.html` for more detailed information.
It's included in the extracted directory.

An example command might be: `upx --best -o target/release/compressed.exe target/release/your-executable.exe`.

## Build configuration

*Note: Settings defined in `.cargo/config.toml` will override settings in `Cargo.toml`.*

Other than the `--release` flag, this is the easiest way to optimize your projects, and also the most effective way,
at least in terms of reducing binary size.

### Stable

This configuration is 100% stable and decreases the binary size from 2.36mb to 310kb.
Add this to your `.cargo/config.toml`:

````toml
[profile.release]
opt-level = "z"
debug = false
lto = true
codegen-units = 1
panic = "abort"
strip = true
incremental = false
````

Links to the documentation of each value:

* [`opt-level`](https://doc.rust-lang.org/rustc/codegen-options/index.html#opt-level)
* [`debug`](https://doc.rust-lang.org/rustc/codegen-options/index.html#debuginfo)
* [`lto`](https://doc.rust-lang.org/rustc/codegen-options/index.html#lto)
* [`codegen-units`](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units)
* [`panic`](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic)
* [`strip`](https://doc.rust-lang.org/rustc/codegen-options/index.html#strip)
* [`incremental`](https://doc.rust-lang.org/rustc/codegen-options/index.html#incremental)

### Unstable

This configuration contains some unstable features, but it should work just fine.
It decreases the binary size from 310kb to 234kb.
Add this to your `.cargo/config.toml`:

````toml
[unstable]
build-std = ["std", "panic_abort", "core", "alloc"]
build-std-features = ["panic_immediate_abort"]

[build]
rustflags = [
    "-Clto",
    "-Zvirtual-function-elimination",
    "-Zlocation-detail=none"
]

# Same as in the Stable section
[profile.release]
opt-level = "z"
debug = false
lto = true
codegen-units = 1
panic = "abort"
strip = true
incremental = false
````

*Note: The omitted space in each flag (e.g., `-C<no space here>lto`) is intentional. It is not a typo.*

The values in `[profile.release]` are documented in the [Stable](#stable) section. Links to the documentation of each value:

* [`[build.rustflags]`](https://doc.rust-lang.org/cargo/reference/config.html#buildrustflags)
* [`-C lto`](https://doc.rust-lang.org/rustc/codegen-options/index.html#lto)
* [`-Z virtual-function-elimination`](https://doc.rust-lang.org/stable/unstable-book/compiler-flags/virtual-function-elimination.html)
* [`-Z location-detail`](https://doc.rust-lang.org/stable/unstable-book/compiler-flags/location-detail.html)

## wasm-opt

*Note: In the future, `wasm-opt` will be supported natively through the [Dioxus CLI](https://crates.io/crates/dioxus-cli).*

`wasm-opt` is a tool from the [binaryen](https://github.com/WebAssembly/binaryen) library that optimizes your WASM files.
To use it, install a [binaryen release](https://github.com/WebAssembly/binaryen/releases) and run this command from the package directory:

````
wasm-opt dist/assets/dioxus/APP_NAME_bg.wasm -o dist/assets/dioxus/APP_NAME_bg.wasm -Oz
````

The `-Oz` flag specifies that `wasm-opt` should optimize for size. For speed, use `-O4`.

## Improving Dioxus code

Let's talk about how you can improve your Dioxus code to be more performant.

It's important to minimize the number of dynamic parts in your `rsx`, like conditional rendering.
When Dioxus is rendering your component, it will skip parts that are the same as the last render.
That means that if you keep dynamic rendering to a minimum, your app will speed up, and quite a bit if it's not just hello world.
To see an example of this, check out [Dynamic Rendering](../reference/dynamic_rendering.md).

Also check out [Anti-patterns](antipatterns.md) for patterns that you should avoid.
Obviously, not all of them are just about performance, but some of them are.

## Optimizing the size of assets

Assets can be a significant part of your app's size. Dioxus includes alpha support for first party [assets](../guides/assets.md). Any assets you include with the `asset!` macro will be optimized for production in release builds.
# How to Upgrade to Dioxus 0.6

This guide will outline the API changes between the `0.5` and `0.6` releases. The `0.6` release contains breaking changes to:

* The `Element` type
* Prevent default
* Assets with Manganis
* `dioxus_logger` integration with `dioxus`
* The `launch` function
* The `eval` function
* The `dioxus-fullstack` crate
* The router crate
* The `derive(Props)` macro
* The `dioxus-core` crate
* Custom renderer API
* Global state management

## Element

The element type has changed from `Option<VNode>` to `Result<VNode, RenderError>`. This makes it possible to bubble up errors while rendering with the `?` operator, but it does remove the ability to return `None` from a component. Instead of returning `None`, you can return `VNode::empty()` or an empty `rsx!` macro.

Dioxus 0.5:

````rust
use dioxus::prelude::*;

fn app() -> Element {
    let number = use_signal(|| -1);

    if number() < 0 {
        // âŒ In dioxus 0.6, the element type is a result, so None values cannot be returned directly
        return None;
    }

    rsx! {
        "Positive number: {number}"
    }
}
````

Dioxus 0.6:

````rs@migration.rs
use dioxus::prelude::*;

fn app() -> Element {
    let number = use_signal(|| -1);

    if number() < 0 {
        // âœ… You can return VNode::empty() instead
        return VNode::empty();
    }
    if number() < 0 {
        // âœ… Or an empty rsx! macro
        return rsx! {};
    }

    rsx! {
        "Positive number: {number}"
    }
}
````

## Prevent Default

Dioxus 0.1-0.5 used the `prevent_default` attribute to prevent default behavior of event handlers for every event. Dioxus 0.6 introduces more fine-grained control over preventing default behavior with the `prevent_default` function on the event type. Instead of setting the `prevent_default` attribute for all events you want to prevent, you can create event handlers that call `event.prevent_default()`.

Dioxus 0.5:

````rs@migration.rs
use dioxus::prelude::*;

fn app() -> Element {
    rsx! {
        a {
            href: "https://dioxuslabs.com",
            // âŒ The prevent default attribute is deprecated in dioxus 0.6
            prevent_default: "onclick",
            "Don't navigate to dioxuslabs.com"
        }
    }
}
````

Dioxus 0.6:

````rs@migration.rs
use dioxus::prelude::*;

fn app() -> Element {
    rsx! {
        a {
            href: "https://dioxuslabs.com",
            // âœ… Instead, you can call event.prevent_default() inside the event handler
            onclick: move |event| event.prevent_default(),
            "Don't navigate to dioxuslabs.com"
        }
    }
}
````

 > 
 > Note: Since event handlers run on the server in Liveview, events cannot be prevented quickly inside the event handler. Because of this, the new `prevent_default` method does not prevent default behavior in Liveview.
 > 
 > Instead you can use javascript inside the `onclick` handler to prevent default behavior.
 > 
 > ````rs@migration.rs
 > use dioxus::prelude::*;
 > 
 > fn app() -> Element {
 >     rsx! {
 >         a {
 >             href: "https://dioxuslabs.com",
 >             // âœ… In liveview, you can use javascript to prevent default behavior
 >             "onclick": "event.preventDefault()",
 >             "Don't navigate to dioxuslabs.com"
 >         }
 >     }
 > }
 > ````

## Assets

The syntax of the `asset!` macro has changed in Dioxus 0.6. Instead of accepting a single argument with both the path and the configuration for the asset, you can now pass in the path as the first argument and the configuration as a optional second argument.

The path the `asset!` macro accepts has also changed. Previously, the macro used to accept absolute and relative paths where relative paths were relative to the current crate directory. Now the macro only accepts absolute paths which are resolved relative to the root of the crate.

Dioxus 0.5:

````rust
use dioxus::prelude::*;

fn app() -> Element {
    rsx! {
        img {
            src: asset!(image("./assets/static/bundle.png").size(100, 100))
        }
    }
}
````

Dioxus 0.6:

````rs@migration.rs
use dioxus::prelude::*;

fn app() -> Element {
    rsx! {
        img {
            src: asset!("/assets/static/bundle.png", ImageAssetOptions::new().with_size(ImageSize::Manual { width: 100, height: 100 }))
        }
    }
}
````

## Logging

Dioxus 0.6 brings the `dioxus-logger` crate directly into dioxus itself.

Previously, you needed to add `dioxus-logger` to your Cargo.toml and then call its init function:

````rs
// cargo.toml:
// dioxus-logger = "0.5"

use dioxus::prelude::*;
use tracing::Level;

fn main() {
    // Init logger
    dioxus_logger::init(Level::INFO).expect("failed to init logger");

    // Dioxus launch code
    dioxus::launch(app)
}
````

Now, in Dioxus 0.6, the logger is implicit with `launch`. Simply call launch and the logger is initialized to a default log level. In development mode, the `Debug` tracing level is set, and in release only the `Info` level is set.

````rust
use dioxus::prelude::*;

fn main() {
    dioxus::launch(app);
}
````

If you still need to set the level manually or configure a custom subscriber, do that before `launch`. We expose the `initialize_default` function in case you need additional logging before your `launch` call:

````rust
use dioxus::prelude::*;

fn main() {
    dioxus::logger::initialize_default();

    tracing::info!("Logs received!");

    dioxus::launch(app);
}
````

## Launch

The `launch` function was removed from the prelude. You must now import the launch method from `dioxus` or use it by its full path:

````rust
use dioxus::prelude::*;

fn main() {
    // âŒ launch(app);
    dioxus::launch(app); // âœ…
}
````

See <https://github.com/DioxusLabs/dioxus/pull/2967> for more details.

## Eval

* `eval` was moved from the prelude to the `document` module. You must now call it with `document::eval` instead of `eval`:

````rust
use dioxus::prelude::*;

fn app() -> Element {
    // âŒ use_effect(|| eval("console.log(1)"));
    use_effect(|| document::eval("console.log(1)")); // âœ…

    rsx! {}
}
````

* The `eval` feature flag was removed from the `dioxus-html` crate and the functionality of `EvalProvider` was moved to the new `dioxus-document` crate. Custom renderers must now provide a `Rc<dyn Document>` context to the application to make `eval` and head elements work correctly. See <https://github.com/DioxusLabs/dioxus/pull/2635> for more details.
* `Eval::recv` and `Eval::join` now returns any value that implements `DeserializeOwned` instead of `serde_json::Value`. `Eval::send` now accepts any value that implements `Serialize`. See <https://github.com/DioxusLabs/dioxus/pull/3035> for more details

## Fullstack

* The feature `dioxus/axum` was renamed to `dioxus/server`

````toml
[features]
default = []
# âŒ server = ["dioxus/axum"]
server = ["dioxus/server"] # âœ…
web = ["dioxus/web"]
````

See <https://github.com/DioxusLabs/dioxus/pull/3186> for more details

* The `fullstack::Config` item was removed. You can now pass the platform configs into the `LaunchBuilder` directly. For example, if you want to set the rootname on each platform, you can set the root name in each config:

````rust
LaunchBuilder::new()
    // Only set the server config if the server feature is enabled
    .with_cfg(server_only! {
        ServeConfigBuilder::default().root_id("app")
    })
    // You also need to set the root id in your web config
    .with_cfg(web! {
        dioxus::web::Config::default().rootname("app")
    })
    // And desktop config
    .with_cfg(desktop! {
        dioxus::desktop::Config::default().with_root_name("app")
    })
    .launch(app);
````

See <https://github.com/DioxusLabs/dioxus/pull/2967> for more details.

* The dioxus-cli now proxies fullstack applications at a port behind a reverse proxy. If you have a custom axum server, you must serve your application at the port returned by `dioxus_cli_config::server_port` and the address returned by `dioxus_cli_config::server_ip` or the complete address returned by `dioxus_cli_config::fullstack_address_or_localhost` during development:

````rust
#[cfg(feature = "server")]
#[tokio::main]
async fn main() {
    // Get the address the server should run on. If the CLI is running, the CLI proxies fullstack into the main address
    // and we use the generated address the CLI gives us
    let address = dioxus_cli_config::fullstack_address_or_localhost();

    // Launch the fullstack application on the address the CLI is proxying
    let router = axum::Router::new()
        .serve_dioxus_application(ServeConfigBuilder::default(), App);

    let router = router.into_make_service();
    let listener = tokio::net::TcpListener::bind(address).await.unwrap();
    axum::serve(listener, router).await.unwrap();
}
````

See <https://github.com/DioxusLabs/dioxus/pull/2258> for more details.

* `serve_dioxus_application` was changed to accept a component directly instead of a virtual dom factory. See <https://github.com/DioxusLabs/dioxus/pull/2515> for more details.
* `register_server_fns` was renamed to `register_server_functions`. See <https://github.com/DioxusLabs/dioxus/pull/2515> for more details.
* `RenderHandleState::new` accepts a new `ServeConfig` argument. See <https://github.com/DioxusLabs/dioxus/pull/2862> for more details.
* `ServeConfigBuilder::build` returns a result. It may fail during desktop builds if no `index.html` file is found. This error is fine to ignore in desktop builds. You can pass the builder directly to `serve_dioxus_application` to only serve the index.html file if it exists. See <https://github.com/DioxusLabs/dioxus/pull/2862> for more details.
* `dioxus_fullstack::Config::addr` was removed. You can now export the `PORT` and `IP` environment variables to set the address the `launch` method uses for the server.

## Router

* The `Routable` derive macro no longer accepts fields that are not present in the `route("/route")` if the web feature is enabled. See <https://github.com/DioxusLabs/dioxus/pull/2159> for more details.
* The `ToRouteSegments` trait in the router was changed from accepting `self` to accepting `&self`. This means you can now implement it for `T` directly instead of `&T`. See <https://github.com/DioxusLabs/dioxus/pull/2283> for more details.

## derive(Props)

* `#[props(into)]` is ignore on any String props. String props already accept `impl ToString` which is implemented for many of the same types, but if you implement `Into<String>` for a specific type, your code may require some changes. See <https://github.com/DioxusLabs/dioxus/pull/2501> for more details
* Properties that start with an uppercase letter are no longer accepted. This allows us to autocomplete Components. See <https://github.com/DioxusLabs/dioxus/pull/2652> for more details.

## State Management

* `use_coroutine` now accepts `impl FnMut` instead of `impl FnOnce`. This was required to support restarting the coroutine without rerunning the component. See <https://github.com/DioxusLabs/dioxus/pull/3005> for more details.
* `Signal::global_memo` now requires `T: PartialEq` just like `use_memo`. See <https://github.com/DioxusLabs/dioxus/pull/2851> for more details.
* `GlobalMemo<T>` is now a trait alias for `Global<Memo<T>, T>` and `GlobalSignal<T>` is now a trait alias for `Global<Signal<T>, T>`. To get the underlying `Memo` or `Signal`, you can now use the `resolve` method instead of `signal` or `memo`. See <https://github.com/DioxusLabs/dioxus/pull/2851> for more details.
* The `Readable` trait in dioxus signals now requires a `try_peek_unchecked` method instead of `peek_unchecked`. See <https://github.com/DioxusLabs/dioxus/pull/2714> for more details.
* The `check_generation` feature flag was removed from the `generational-box` crate. See <https://github.com/DioxusLabs/dioxus/pull/2638> for more details.

## Core changes

* The `Template::name` field was removed. See <https://github.com/DioxusLabs/dioxus/pull/2799> for more details.
* `Properties::into_vcomponent` now accepts only the `render_fn` instead of the `render_fn` and `component_name`. This change fixes the name of re-exported components. Fixes <https://github.com/DioxusLabs/dioxus/pull/2744>
* The field `VNode::template` is now `Template` instead of `Cell<Template>`. See <https://github.com/DioxusLabs/dioxus/pull/2705> for more details
* `Mutations::santize` was renamed to `Mutations::sanitize`. See <https://github.com/DioxusLabs/dioxus/pull/2653> for more details.
* The variant `AttributeValue::Any` now contains `Rc<dyn AnyValue>` instead of `Box<dyn AnyValue>` to make `AttributeValue` `Clone`. See <https://github.com/DioxusLabs/dioxus/pull/2705> for more details

## Custom Renderers

If you are building a custom renderer, there were some breaking changes to hot reloading and rsx that you should be aware of:

* The CLI hot reloading format changed significantly. Custom renderers must switch from `dioxus-hot-reload` to `dioxus_devtools`. Renderers can connect to the hot reloading engine with the \[connect\](<https://docs.rs/dioxus>-devtools/0.6.0/dioxus_devtools/fn.connect.html) function. See <https://github.com/DioxusLabs/dioxus/pull/2258> for more details.
* The format of custom elements was changed to improve autocomplete. The `dioxus_elements` namespace must now contain each element as a module with a TAG_NAME and NAME_SPACE constant inside that module. Each attribute should be another constant in that module. The top-level `dioxus_elements` module should contain a `completions` module with a `CompleteWithBraces` enum that re-exports each element the namespace supports for braces autocomplete. See <https://github.com/DioxusLabs/dioxus/pull/2421> for more details.
* The format for custom event handlers changed include `eventname::call_with_explicit_closure` to provide better type inference for inline closures. See <https://github.com/DioxusLabs/dioxus/pull/2437> for more details

If you are also using dioxus-html, there are a few more breaking changes:

* A `file_size` method was added to the `FileEngine` trait. Any custom renderers must implement this method. See <https://github.com/DioxusLabs/dioxus/pull/2323/files> for more details.
* `HtmlEventConverter` has a new `convert_resize_data` method which must be implemented by any custom renderers that use dioxus-html. See <https://github.com/DioxusLabs/dioxus/pull/2479> for more details
* The web and native features were removed from the `dioxus-html` crate. See <https://github.com/DioxusLabs/dioxus/pull/3006> for more details.
* `dioxus_html::AttributeDiscription ` was renamed to `dioxus_html::AttributeDescription`. See <https://github.com/DioxusLabs/dioxus/pull/2653> for more details.

## Minor Breaking Changes

There were several more minor breaking changes in Dioxus 0.6:

* Many implicit features from dioxus crates were removed. These features were automatically generated by cargo and generally not functional. See <https://github.com/DioxusLabs/dioxus/pull/2512> for more details.
* `dioxus_autofmt::write_block_out` accepts `&CallBody` instead of `CallBody`. See <https://github.com/DioxusLabs/dioxus/pull/2573> for more details.
* The `panic_hook` feature which provides a console panic message for wasm panics was moved from the `dioxus-web` crate to the `dioxus-logger` crate. The handler is still provided by default. See <https://github.com/DioxusLabs/dioxus/pull/3302> for more details.
# Reference

This portion of the Dioxus Docs contains specific details about features that provide more depth than what is necessary for most reading.

* [RSX](./rsx.md)
* [Components](./components.md)
* [Props](./component_props.md)
* [Event Handlers](./event_handlers.md)
* [Hooks](./hooks.md)
* [User Input](./user_input.md)
* [Context](./context.md)
* [Dynamic Rendering](./dynamic_rendering.md)
* [Routing](./router.md)
* [Resource](./use_resource.md)
* [UseCoroutine](./use_coroutine.md)
* [Spawn](./spawn.md)
# Dioxus Hot-Reloading Reference

The Dioxus Hot-Reload is very powerful. When used properly, it is by-far the fastest tool to build apps with Rust.

Dioxus 0.5 featured a slightly limited form of hot-reloading while Dioxus 0.6 drastically improved it.

 > 
 > Currently Dioxus cannot hot-reload *Rust* code, only RSX markup. Usually, modifying Rust code requires a full rebuild.

We provide this text guide as a resource for the details of hot-reloading. This guide also has an accompanying video as well:

<iframe style="width: 100%" height="500px" class="centered-overflow" src="https://www.youtube.com/embed/Q4Xzz8OJEoc" title="Dioxus 0.6" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

# Describing the UI

Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* what we want the UI to look like using RSX.

You have already seen a simple example of RSX syntax in the "hello world" application:

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App() -> Element {
    rsx! {
        div { "Hello, world!" }
    }
}
````

Here, we use the `rsx!` macro to *declare* that we want a `div` element, containing the text `"Hello, world!"`. Dioxus takes the RSX and constructs a UI from it.

## RSX Features

RSX is very similar to HTML in that it describes elements with attributes and children. Here's an empty `button` element in RSX, as well as the resulting HTML:

````rs@rsx_overview.rs
rsx! {
    button {
        // attributes / listeners
        // children
        "Hello, World!"
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Button {}
}
````

### Attributes

Attributes (and [event handlers](event_handlers.md)) modify the behavior or appearance of the element they are attached to. They are specified inside the `{}` brackets, using the `name: value` syntax. You can provide the value as a literal in the RSX:

````rs@rsx_overview.rs
rsx! {
    img {
        src: "https://avatars.githubusercontent.com/u/79236386?s=200&v=4",
        class: "primary_button",
        width: "10px",
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Attributes {}
}
````

Some attributes, such as the `type` attribute for `input` elements won't work on their own in Rust. This is because `type` is a reserved Rust keyword. To get around this, Dioxus uses the `r#` specifier:

````rs@rsx_overview.rs
rsx! {
    input { r#type: "text", color: "red" }
}
````

 > 
 > Note: All attributes defined in `dioxus-html` follow the snake_case naming convention. They transform their `snake_case` names to HTML's `camelCase` attributes.

 > 
 > Note: Styles can be used directly outside of the `style:` attribute. In the above example, `color: "red"` is turned into `style="color: red"`.

#### Conditional Attributes

You can also conditionally include attributes by using an if statement without an else branch. This is useful for adding an attribute only if a certain condition is met:

````rs@rsx_overview.rs
let large_font = true;
rsx! {
    div { class: if large_font { "text-xl" }, "Hello, World!" }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::ConditionalAttributes {}
}
````

#### Custom Attributes

Dioxus has a pre-configured set of attributes that you can use. RSX is validated at compile time to make sure you didn't specify an invalid attribute. If you want to override this behavior with a custom attribute name, specify the attribute in quotes:

````rs@rsx_overview.rs
rsx! {
    div { "style": "width: 20px; height: 20px; background-color: red;" }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::CustomAttributes {}
}
````

### Special Attributes

While most attributes are simply passed on to the HTML, some have special behaviors.

#### The HTML Escape Hatch

If you're working with pre-rendered assets, output from templates, or output from a JS library, then you might want to pass HTML directly instead of going through Dioxus. In these instances, reach for `dangerous_inner_html`.

For example, shipping a markdown-to-Dioxus converter might significantly bloat your final application size. Instead, you'll want to pre-render your markdown to HTML and then include the HTML directly in your output. We use this approach for the [Dioxus homepage](https://dioxuslabs.com):

````rs@dangerous_inner_html.rs
// this should come from a trusted source
let contents = "live <b>dangerously</b>";

rsx! {
    div { dangerous_inner_html: "{contents}" }
}
````

````inject-dioxus
DemoFrame {
	dangerous_inner_html::App {}
}
````

 > 
 > Note! This attribute is called "dangerous_inner_html" because it is **dangerous** to pass it data you don't trust. If you're not careful, you can easily expose [cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks to your users.
 > 
 > If you're handling untrusted input, make sure to sanitize your HTML before passing it into `dangerous_inner_html` â€“ or just pass it to a Text Element to escape any HTML tags.

#### Boolean Attributes

Most attributes, when rendered, will be rendered exactly as the input you provided. However, some attributes are considered "boolean" attributes and just their presence determines whether they affect the output. For these attributes, a provided value of `"false"` will cause them to be removed from the target element.

So this RSX wouldn't actually render the `hidden` attribute:

````rs@boolean_attribute.rs
rsx! {
    div { hidden: false, "hello" }
}
````

````inject-dioxus
DemoFrame {
	boolean_attribute::App {}
}
````

Not all attributes work like this however. *Only the following attributes* have this behavior:

* `allowfullscreen`
* `allowpaymentrequest`
* `async`
* `autofocus`
* `autoplay`
* `checked`
* `controls`
* `default`
* `defer`
* `disabled`
* `formnovalidate`
* `hidden`
* `ismap`
* `itemscope`
* `loop`
* `multiple`
* `muted`
* `nomodule`
* `novalidate`
* `open`
* `playsinline`
* `readonly`
* `required`
* `reversed`
* `selected`
* `truespeed`

For any other attributes, a value of `"false"` will be sent directly to the DOM.

### Interpolation

Similarly to how you can [format](https://doc.rust-lang.org/rust-by-example/hello/print/fmt.html) Rust strings, you can also interpolate in RSX text. Use `{variable}` to Display the value of a variable in a string, or `{variable:?}` to use the Debug representation:

````rs@rsx_overview.rs
let coordinates = (42, 0);
let country = "es";
rsx! {
    div {
        class: "country-{country}",
        left: "{coordinates.0:?}",
        top: "{coordinates.1:?}",
        // arbitrary expressions are allowed,
        // as long as they don't contain `{}`
        div { "{country.to_uppercase()}" }
        div { "{7*6}" }
        // {} can be escaped with {{}}
        div { "{{}}" }
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Formatting {}
}
````

### Children

To add children to an element, put them inside the `{}` brackets after all attributes and listeners in the element. They can be other elements, text, or [components](components.md). For example, you could have an `ol` (ordered list) element, containing 3 `li` (list item) elements, each of which contains some text:

````rs@rsx_overview.rs
rsx! {
    ol {
        li { "First Item" }
        li { "Second Item" }
        li { "Third Item" }
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Children {}
}
````

### Fragments

You can render multiple elements at the top level of `rsx!` and they will be automatically grouped.

````rs@rsx_overview.rs
rsx! {
    p { "First Item" }
    p { "Second Item" }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::ManyRoots {}
}
````

### Expressions

You can include arbitrary Rust expressions as children within RSX by surrounding your expression with `{}`s. Any expression that implements [IntoDynNode](https://docs.rs/dioxus-core/0.3/dioxus_core/trait.IntoDynNode.html) can be used within rsx. This is useful for displaying data from an [iterator](https://doc.rust-lang.org/stable/book/ch13-02-iterators.html#processing-a-series-of-items-with-iterators):

````rs@rsx_overview.rs
let text = "Dioxus";
rsx! {
    span {
        {text.to_uppercase()}
        // create a list of text from 0 to 9
        {(0..10).map(|i| rsx! {
        "{i}"
        })}
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Expression {}
}
````

### Loops

In addition to iterators you can also use for loops directly within RSX:

````rs@rsx_overview.rs
rsx! {
    // use a for loop where the body itself is RSX
    div {
        // create a list of text from 0 to 9
        for i in 0..3 {
            // NOTE: the body of the loop is RSX not a rust statement
            div { "{i}" }
        }
    }
    // iterator equivalent
    div {
        {(0..3).map(|i| rsx! {
            div { "{i}" }
        })}
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Loops {}
}
````

### If statements

You can also use if statements without an else branch within RSX:

````rs@rsx_overview.rs
rsx! {
    // use if statements without an else
    if true {
        div { "true" }
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::IfStatements {}
}
````
# Components

Just like you wouldn't want to write a complex program in a single, long, `main` function, you shouldn't build a complex UI in a single `App` function. Instead, you should break down the functionality of an app in logical parts called components.

A component is a Rust function, named in [UpperCamelCase](https://en.wikipedia.org/wiki/Camel_case), that either takes no parameters or a properties struct and returns an `Element` describing the UI it wants to render.

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App() -> Element {
    rsx! {
        div { "Hello, world!" }
    }
}
````

 > 
 > You'll probably want to add `#![allow(non_snake_case)]` to the top of your crate to avoid warnings about `UpperCamelCase` component names

A Component is responsible for some rendering task â€“ typically, rendering an isolated part of the user interface. For example, you could have an `About` component that renders a short description of Dioxus Labs:

````rs@components.rs
pub fn About() -> Element {
    rsx! {
        p {
            b { "Dioxus Labs" }
            " An Open Source project dedicated to making Rust UI wonderful."
        }
    }
}
````

````inject-dioxus
DemoFrame {
	components::About {}
}
````

Then, you can render your component in another component, similarly to how elements are rendered:

````rs@components.rs
pub fn App() -> Element {
    rsx! {
        About {}
        About {}
    }
}
````

````inject-dioxus
DemoFrame {
	components::App {}
}
````

 > 
 > At this point, it might seem like components are nothing more than functions. However, as you learn more about the features of Dioxus, you'll see that they are actually more powerful!
# Component Props

Just like you can pass arguments to a function or attributes to an element, you can pass props to a component that customize its behavior! The components we've seen so far didn't accept any props â€“ so let's write some components that do.

## derive(Props)

Component props are a single struct annotated with `#[derive(PartialEq, Clone, Props)]`. For a component to accept props, the type of its argument must be `YourPropsStruct`.

Example:

````rs@component_owned_props.rs
#[derive(PartialEq, Props, Clone)]
struct LikesProps {
    score: i32,
}

fn Likes(props: LikesProps) -> Element {
    rsx! {
        div {
            "This post has "
            b { "{props.score}" }
            " likes"
        }
    }
}
````

You can then pass prop values to the component the same way you would pass attributes to an element:

````rs@component_owned_props.rs
pub fn App() -> Element {
    rsx! { Likes { score: 42 } }
}
````

````inject-dioxus
DemoFrame {
    component_owned_props::App {}
}
````

## Prop Options

The `#[derive(Props)]` macro has some features that let you customize the behavior of props.

### Optional Props

You can create optional fields by using the `Option<â€¦>` type for a field:

````rs@component_props_options.rs
#[derive(PartialEq, Clone, Props)]
struct OptionalProps {
    title: String,
    subtitle: Option<String>,
}

fn Title(props: OptionalProps) -> Element {
    rsx! {
        h1 { "{props.title}: ", {props.subtitle.unwrap_or_else(|| "No subtitle provided".to_string())} }
    }
}
````

Then, you can choose to either provide them or not:

````rs@component_props_options.rs
Title { title: "Some Title" }
Title { title: "Some Title", subtitle: "Some Subtitle" }
// Providing an Option explicitly won't compile though:
// Title {
//     title: "Some Title",
//     subtitle: None,
// },
````

### Explicitly Required Option

If you want to explicitly require an `Option`, and not an optional prop, you can annotate it with `#[props(!optional)]`:

````rs@component_props_options.rs
#[derive(PartialEq, Clone, Props)]
struct ExplicitOptionProps {
    title: String,
    #[props(!optional)]
    subtitle: Option<String>,
}

fn ExplicitOption(props: ExplicitOptionProps) -> Element {
    rsx! {
        h1 { "{props.title}: ", {props.subtitle.unwrap_or_else(|| "No subtitle provided".to_string())} }
    }
}
````

Then, you have to explicitly pass either `Some("str")` or `None`:

````rs@component_props_options.rs
ExplicitOption { title: "Some Title", subtitle: None }
ExplicitOption { title: "Some Title", subtitle: Some("Some Title".to_string()) }
// This won't compile:
// ExplicitOption {
//     title: "Some Title",
// },
````

### Default Props

You can use `#[props(default = 42)]` to make a field optional and specify its default value:

````rs@component_props_options.rs
#[derive(PartialEq, Props, Clone)]
struct DefaultProps {
    // default to 42 when not provided
    #[props(default = 42)]
    number: i64,
}

fn DefaultComponent(props: DefaultProps) -> Element {
    rsx! { h1 { "{props.number}" } }
}
````

Then, similarly to optional props, you don't have to provide it:

````rs@component_props_options.rs
DefaultComponent { number: 5 }
DefaultComponent {}
````

### Automatic Conversion with into

It is common for Rust functions to accept `impl Into<SomeType>` rather than just `SomeType` to support a wider range of parameters. If you want similar functionality with props, you can use `#[props(into)]`. For example, you could add it on a `String` prop â€“ and `&str` will also be automatically accepted, as it can be converted into `String`:

````rs@component_props_options.rs
#[derive(PartialEq, Props, Clone)]
struct IntoProps {
    #[props(into)]
    string: String,
}

fn IntoComponent(props: IntoProps) -> Element {
    rsx! { h1 { "{props.string}" } }
}
````

Then, you can use it so:

````rs@component_props_options.rs
IntoComponent { string: "some &str" }
````

## The component macro

So far, every Component function we've seen had a corresponding ComponentProps struct to pass in props. This was quite verbose... Wouldn't it be nice to have props as simple function arguments? Then we wouldn't need to define a Props struct, and instead of typing `props.whatever`, we could just use `whatever` directly!

`component` allows you to do just that. Instead of typing the "full" version:

````rust, no_run
#[derive(Props, Clone, PartialEq)]
struct TitleCardProps {
    title: String,
}

fn TitleCard(props: TitleCardProps) -> Element {
    rsx!{
        h1 { "{props.title}" }
    }
}
````

...you can define a function that accepts props as arguments. Then, just annotate it with `#[component]`, and the macro will turn it into a regular Component for you:

````rust, no_run
#[component]
fn TitleCard(title: String) -> Element {
    rsx!{
        h1 { "{title}" }
    }
}
````

 > 
 > While the new Component is shorter and easier to read, this macro should not be used by library authors since you have less control over Prop documentation.

## Component Children

In some cases, you may wish to create a component that acts as a container for some other content, without the component needing to know what that content is. To achieve this, create a prop of type `Element`:

````rs@component_element_props.rs
#[derive(PartialEq, Clone, Props)]
struct ClickableProps {
    href: String,
    body: Element,
}

fn Clickable(props: ClickableProps) -> Element {
    rsx! {
        a { href: "{props.href}", class: "fancy-button", {props.body} }
    }
}
````

Then, when rendering the component, you can pass in the output of `rsx!{...}`:

````rs@component_element_props.rs
rsx! {
    Clickable {
        href: "https://www.youtube.com/watch?v=C-M2hs3sXGo",
        body: rsx! {
            "How to " i { "not" } " be seen"
        }
    }
}
````

 > 
 > Warning: While it may compile, do not include the same `Element` more than once in the RSX. The resulting behavior is unspecified.

### The children field

Rather than passing the RSX through a regular prop, you may wish to accept children similarly to how elements can have children. The "magic" `children` prop lets you achieve this:

````rs@component_children.rs
#[derive(PartialEq, Clone, Props)]
struct ClickableProps {
    href: String,
    children: Element,
}

fn Clickable(props: ClickableProps) -> Element {
    rsx! {
        a { href: "{props.href}", class: "fancy-button", {props.children} }
    }
}
````

This makes using the component much simpler: simply put the RSX inside the `{}` brackets â€“ and there is no need for a `render` call or another macro!

````rs@component_children.rs
rsx! {
    Clickable { href: "https://www.youtube.com/watch?v=C-M2hs3sXGo",
        "How to "
        i { "not" }
        " be seen"
    }
}
````

````inject-dioxus
DemoFrame {
    component_children::App {}
}
````
# Event Handlers

Event handlers are used to respond to user actions. For example, an event handler could be triggered when the user clicks, scrolls, moves the mouse, or types a character.

Event handlers are attached to elements. For example, we usually don't care about all the clicks that happen within an app, only those on a particular button.

Event handlers are similar to regular attributes, but their name usually starts with `on`- and they accept closures as values. The closure will be called whenever the event it listens for is triggered and will be passed that event.

For example, to handle clicks on an element, we can specify an `onclick` handler:

````rs@event_click.rs
rsx! {
    button { onclick: move |event| log::info!("Clicked! Event: {event:?}"), "click me!" }
}
````

````inject-dioxus
DemoFrame {
    event_click::App {}
}
````

## The Event object

Event handlers receive an [`Event`](https://docs.rs/dioxus-core/latest/dioxus_core/struct.Event.html) object containing information about the event. Different types of events contain different types of data. For example, mouse-related events contain [`MouseData`](https://docs.rs/dioxus/latest/dioxus/events/struct.MouseData.html), which tells you things like where the mouse was clicked and what mouse buttons were used.

In the example above, this event data was logged to the terminal:

````
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
````

To learn what the different event types for HTML provide, read the [events module docs](https://docs.rs/dioxus-html/latest/dioxus_html/events/index.html).

### Event propagation

Some events will trigger first on the element the event originated at upward. For example, a click event on a `button` inside a `div` would first trigger the button's event listener and then the div's event listener.

 > 
 > For more information about event propagation see [the mdn docs on event bubbling](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling)

If you want to prevent this behavior, you can call `stop_propagation()` on the event:

````rs@event_nested.rs
rsx! {
    div { onclick: move |_event| {},
        "outer"
        button {
            onclick: move |event| {
                event.stop_propagation();
            },
            "inner"
        }
    }
}
````

## Prevent Default

Some events have a default behavior. For keyboard events, this might be entering the typed character. For mouse events, this might be selecting some text.

In some instances, might want to avoid this default behavior. For this, you can add the `prevent_default` attribute with the name of the handler whose default behavior you want to stop. This attribute can be used for multiple handlers using their name separated by spaces:

````rs@event_prevent_default.rs
rsx! {
    a {
        href: "https://example.com",
        onclick: |evt| {
            evt.prevent_default();
            log::info!("link clicked")
        },
        "example.com"
    }
}
````

````inject-dioxus
DemoFrame {
    event_prevent_default::App {}
}
````

Any event handlers will still be called.

## Handler Props

Sometimes, you might want to make a component that accepts an event handler. A simple example would be a `FancyButton` component, which accepts an `onclick` handler:

````rs@event_handler_prop.rs
#[derive(PartialEq, Clone, Props)]
pub struct FancyButtonProps {
    onclick: EventHandler<MouseEvent>,
}

pub fn FancyButton(props: FancyButtonProps) -> Element {
    rsx! {
        button {
            class: "fancy-button",
            onclick: move |evt| props.onclick.call(evt),
            "click me pls."
        }
    }
}
````

Then, you can use it like any other handler:

````rs@event_handler_prop.rs
rsx! {
    FancyButton {
        onclick: move |event| println!("Clicked! {event:?}"),
    }
}
````

 > 
 > Note: just like any other attribute, you can name the handlers anything you want! Any closure you pass in will automatically be turned into an `EventHandler`.

## Custom Data

Event Handlers are generic over any type, so you can pass in any data you want to them, e.g:

````rs@event_handler_prop.rs
struct ComplexData(i32);

#[derive(PartialEq, Clone, Props)]
pub struct CustomFancyButtonProps {
    onclick: EventHandler<ComplexData>,
}

pub fn CustomFancyButton(props: CustomFancyButtonProps) -> Element {
    rsx! {
        button {
            class: "fancy-button",
            onclick: move |_| props.onclick.call(ComplexData(0)),
            "click me pls."
        }
    }
}
````

## Returning a value from an event handler

If you want to accept a closure like an event handler that returns a value, you can use the `Callback` type. The callback type accepts two generic arguments, `I`, the input type, and `O`, the output type. Just like `EventHandler`, `Callback` is automatically converted in props and can be easily copied into anywhere in your component:

````rs@event_handler_prop.rs
#[derive(PartialEq, Clone, Props)]
pub struct CounterProps {
    modify: Callback<u32, u32>,
}

pub fn Counter(props: CounterProps) -> Element {
    let mut count = use_signal(|| 1);

    rsx! {
        button {
            onclick: move |_| count.set(props.modify.call(count())),
            "double"
        }
        div { "count: {count}" }
    }
}
````
# Hooks and component state

So far, our components have had no state like a normal Rust function. However, in a UI component, it is often useful to have stateful functionality to build user interactions. For example, you might want to track whether the user has opened a drop-down and render different things accordingly.

Hooks allow us to create state in our components. Hooks are Rust functions you call in a constant order in a component that add additional functionality to the component.

Dioxus provides many built-in hooks, but if those hooks don't fit your specific use case, you also can [create your own hook](../cookbook/state/custom_hooks/index.md)

## use_signal hook

[`use_signal`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_signal.html) is one of the simplest hooks.

* You provide a closure that determines the initial value: `let mut count = use_signal(|| 0);`
* `use_signal` gives you the current value, and a way to write to the value
* When the value updates, `use_signal` makes the component re-render (along with any other component that references it), and then provides you with the new value.

For example, you might have seen the counter example, in which state (a number) is tracked using the `use_signal` hook:

````rs@hooks_counter.rs
pub fn App() -> Element {
    // count will be initialized to 0 the first time the component is rendered
    let mut count = use_signal(|| 0);

    rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    }
}
````

````inject-dioxus
DemoFrame {
   hooks_counter::App {}
}
````

Every time the component's state changes, it re-renders, and the component function is called, so you can describe what you want the new UI to look like. You don't have to worry about "changing" anything â€“ describe what you want in terms of the state, and Dioxus will take care of the rest!

 > 
 > `use_signal` returns your value wrapped in a smart pointer of type [`Signal`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.Signal.html) that is `Copy`. This is why you can both read the value and update it, even within an event handler.

You can use multiple hooks in the same component if you want:

````rs@hooks_counter_two_state.rs
pub fn App() -> Element {
    let mut count_a = use_signal(|| 0);
    let mut count_b = use_signal(|| 0);

    rsx! {
        h1 { "Counter_a: {count_a}" }
        button { onclick: move |_| count_a += 1, "a++" }
        button { onclick: move |_| count_a -= 1, "a--" }
        h1 { "Counter_b: {count_b}" }
        button { onclick: move |_| count_b += 1, "b++" }
        button { onclick: move |_| count_b -= 1, "b--" }
    }
}
````

````inject-dioxus
DemoFrame {
  hooks_counter_two_state::App {}
}
````

You can also use `use_signal` to store more complex state, like a Vec. You can read and write to the state with the `read` and `write` methods:

````rs@hooks_use_signal.rs
pub fn App() -> Element {
    let mut list = use_signal(Vec::new);

    rsx! {
        p { "Current list: {list:?}" }
        button {
            onclick: move |event| {
                let list_len = list.len();
                list.push(list_len);
                list.push(list_len);
            },
            "Add two elements!"
        }
    }
}
````

````inject-dioxus
DemoFrame {
  hooks_use_signal::App {}
}
````

## Rules of hooks

The above example might seem a bit magic since Rust functions are typically not associated with state. Dioxus allows hooks to maintain state across renders through a hidden scope that is associated with the component.

But how can Dioxus differentiate between multiple hooks in the same component? As you saw in the second example, both `use_signal` functions were called with the same parameters, so how come they can return different things when the counters are different?

````rs@hooks_counter_two_state.rs
let mut count_a = use_signal(|| 0);
let mut count_b = use_signal(|| 0);
````

This is only possible because the two hooks are always called in the same order, so Dioxus knows which is which. Because the order you call hooks matters, you must follow certain rules when using hooks:

1. Hooks may be only used in components or other hooks (we'll get to that later).
1. On every call to a component function.
1. The same hooks must be called (except in the case of early returns, as explained later in the [Error Handling chapter](../essentials/error_handling/index.md)).
1. In the same order.
1. Hook names should start with `use_` so you don't accidentally confuse them with regular
   functions (`use_signal()`, `use_effect()`, `use_resource()`, etc...).

These rules mean that there are certain things you can't do with hooks:

### No hooks in conditionals

````rs@hooks_bad.rs
// âŒ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy && you_know_it {
    let something = use_signal(|| "hands");
    println!("clap your {something}")
}

// âœ… instead, *always* call use_signal
// You can put other stuff in the conditional though
let something = use_signal(|| "hands");
if you_are_happy && you_know_it {
    println!("clap your {something}")
}
````

### No hooks in closures

````rs@hooks_bad.rs
// âŒ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
    let b = use_signal(|| 0);
    b()
};

// âœ… instead, move hook `b` outside
let b = use_signal(|| 0);
let _a = || b();
````

### No hooks in loops

````rs@hooks_bad.rs
// `names` is a Vec<&str>

// âŒ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &names {
    let is_selected = use_signal(|| false);
    println!("selected: {is_selected}");
}

// âœ… Instead, use a hashmap with use_signal
let selection_map = use_signal(HashMap::<&str, bool>::new);

for name in &names {
    let is_selected = selection_map.read()[name];
    println!("selected: {is_selected}");
}
````

## Additional resources

* [dioxus_hooks API docs](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/)
* [dioxus_hooks source code](https://github.com/DioxusLabs/dioxus/tree/main/packages/hooks)
# User Input

Interfaces often need to provide a way to input data: e.g. text, numbers, checkboxes, etc. In Dioxus, there are two ways you can work with user input.

## Controlled Inputs

With controlled inputs, you are directly in charge of the state of the input. This gives you a lot of flexibility, and makes it easy to keep things in sync. For example, this is how you would create a controlled text input:

````rs@input_controlled.rs
pub fn App() -> Element {
    let mut name = use_signal(|| "bob".to_string());

    rsx! {
        input {
            // we tell the component what to render
            value: "{name}",
            // and what to do when the value changes
            oninput: move |event| name.set(event.value())
        }
    }
}
````

````inject-dioxus
DemoFrame {
    input_controlled::App {}
}
````

Notice the flexibility â€“ you can:

* Also display the same contents in another element, and they will be in sync
* Transform the input every time it is modified (e.g. to make sure it is upper case)
* Validate the input every time it changes
* Have custom logic happening when the input changes (e.g. network request for autocompletion)
* Programmatically change the value (e.g. a "randomize" button that fills the input with nonsense)

## Uncontrolled Inputs

As an alternative to controlled inputs, you can simply let the platform keep track of the input values. If we don't tell a HTML input what content it should have, it will be editable anyway (this is built into the browser). This approach can be more performant, but less flexible. For example, it's harder to keep the input in sync with another element.

Since you don't necessarily have the current value of the uncontrolled input in state, you can access it either by listening to `oninput` events (similarly to controlled components), or, if the input is part of a form, you can access the form data in the form events (e.g. `oninput` or `onsubmit`):

````rs@input_uncontrolled.rs
pub fn App() -> Element {
    rsx! {
        form {
            onsubmit: move |event| {
                event.prevent_default(); // Prevent the default form submission behavior
                log::info!("Submitted! {event:?}");
            },
            input { name: "name" }
            input { name: "age" }
            input { name: "date" }
            input { r#type: "submit" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    input_uncontrolled::App {}
}
````

````
Submitted! UiEvent { data: FormData { value: "", values: {"age": "very old", "date": "1966", "name": "Fred"} } }
````

## Handling files

You can insert a file picker by using an input element of type `file`. This element supports the `multiple` attribute, to let you pick more files at the same time. You can select a folder by adding the `directory` attribute: Dioxus will map this attribute to browser specific attributes, because there is no standardized way to allow a directory to be selected.

`type` is a Rust keyword, so when specifying the type of the input field, you have to write it as `r#type:"file"`.

Extracting the selected files is a bit different from what you may typically use in Javascript.

The `FormData` event contains a `files` field with data about the uploaded files. This field contains a `FileEngine` struct which lets you fetch the filenames selected by the user. This example saves the filenames of the selected files to a `Vec`:

````rs@input_fileengine.rs
pub fn App() -> Element {
    let mut filenames: Signal<Vec<String>> = use_signal(Vec::new);
    rsx! {
        input {
            // tell the input to pick a file
            r#type: "file",
            // list the accepted extensions
            accept: ".txt,.rs",
            // pick multiple files
            multiple: true,
            onchange: move |evt| {
                if let Some(file_engine) = &evt.files() {
                    let files = file_engine.files();
                    for file_name in files {
                        filenames.write().push(file_name);
                    }
                }
            }
        }
    }
}
````

If you're planning to read the file content, you need to do it asynchronously, to keep the rest of the UI interactive. This example event handler loads the content of the selected files in an async closure:

````rs@input_fileengine_async.rs
onchange: move |evt| {
    async move {
        if let Some(file_engine) = evt.files() {
            let files = file_engine.files();
            for file_name in &files {
                if let Some(file) = file_engine.read_file_to_string(file_name).await
                {
                    files_uploaded.write().push(file);
                }
            }
        }
    }
}
````

Lastly, this example shows you how to select a folder, by setting the `directory` attribute to `true`.

````rs@input_fileengine_folder.rs
input {
    r#type: "file",
    // Select a folder by setting the directory attribute
    directory: true,
    onchange: move |evt| {
        if let Some(file_engine) = evt.files() {
            let files = file_engine.files();
            for file_name in files {
                println!("{}", file_name);
            }
        }
    }
}
````
# Sharing State

Often, multiple components need to access the same state. Depending on your needs, there are several ways to implement this.

## Lifting State

One approach to share state between components is to "lift" it up to the nearest common ancestor. This means putting the `use_signal` hook in a parent component, and passing the needed values down as props.

Suppose we want to build a meme editor. We want to have an input to edit the meme caption, but also a preview of the meme with the caption. Logically, the meme and the input are 2 separate components, but they need access to the same state (the current caption).

 > 
 > Of course, in this simple example, we could write everything in one component â€“ but it is better to split everything out in smaller components to make the code more reusable, maintainable, and performant (this is even more important for larger, complex apps).

We start with a `Meme` component, responsible for rendering a meme with a given caption:

````rs@meme_editor.rs
#[component]
fn Meme(caption: String) -> Element {
    let container_style = r#"
        position: relative;
        width: fit-content;
    "#;

    let caption_container_style = r#"
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 16px 8px;
    "#;

    let caption_style = r"
        font-size: 32px;
        margin: 0;
        color: white;
        text-align: center;
    ";

    rsx! {
        div { style: "{container_style}",
            img { src: "https://i.imgflip.com/2zh47r.jpg", height: "500px" }
            div { style: "{caption_container_style}", p { style: "{caption_style}", "{caption}" } }
        }
    }
}
````

 > 
 > Note that the `Meme` component is unaware where the caption is coming from â€“ it could be stored in `use_signal`, or a constant. This ensures that it is very reusable â€“ the same component can be used for a meme gallery without any changes!

We also create a caption editor, completely decoupled from the meme. The caption editor must not store the caption itself â€“ otherwise, how will we provide it to the `Meme` component? Instead, it should accept the current caption as a prop, as well as an event handler to delegate input events to:

````rs@meme_editor.rs
#[component]
fn CaptionEditor(caption: String, oninput: EventHandler<FormEvent>) -> Element {
    let input_style = r"
        border: none;
        background: cornflowerblue;
        padding: 8px 16px;
        margin: 0;
        border-radius: 4px;
        color: white;
    ";

    rsx! {
        input {
            style: "{input_style}",
            value: "{caption}",
            oninput: move |event| oninput.call(event)
        }
    }
}
````

Finally, a third component will render the other two as children. It will be responsible for keeping the state and passing down the relevant props.

````rs@meme_editor.rs
fn MemeEditor() -> Element {
    let container_style = r"
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin: 0 auto;
        width: fit-content;
    ";

    let mut caption = use_signal(|| "me waiting for my rust code to compile".to_string());

    rsx! {
        div { style: "{container_style}",
            h1 { "Meme Editor" }
            Meme { caption: caption }
            CaptionEditor { caption: caption, oninput: move |event: FormEvent| caption.set(event.value()) }
        }
    }
}
````

![Meme Editor Screenshot: An old plastic skeleton sitting on a park bench. Caption: "me waiting for a language feature"](/assets/static/meme_editor_screenshot.png)

## Using Shared State

Sometimes, some state needs to be shared between multiple components far down the tree, and passing it down through props is very inconvenient.

Suppose now that we want to implement a dark mode toggle for our app. To achieve this, we will make every component select styling depending on whether dark mode is enabled or not.

 > 
 > Note: we're choosing this approach for the sake of an example. There are better ways to implement dark mode (e.g. using CSS variables). Let's pretend CSS variables don't exist â€“ welcome to 2013!

Now, we could write another `use_signal` in the top component, and pass `is_dark_mode` down to every component through props. But think about what will happen as the app grows in complexity â€“ almost every component that renders any CSS is going to need to know if dark mode is enabled or not â€“ so they'll all need the same dark mode prop. And every parent component will need to pass it down to them. Imagine how messy and verbose that would get, especially if we had components several levels deep!

Dioxus offers a better solution than this "prop drilling" â€“ providing context. The [`use_context_provider`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context_provider.html) hook provides any Clone context (including Signals!) to any child components. Child components can use the [`use_context`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context.html) hook to get that context and if it is a Signal, they can read and write to it.

First, we have to create a struct for our dark mode configuration:

````rs@meme_editor_dark_mode.rs
#[derive(Clone, Copy)]
struct DarkMode(bool);
````

Now, in a top-level component (like `App`), we can provide the `DarkMode` context to all children components:

````rs@meme_editor_dark_mode.rs
use_context_provider(|| Signal::new(DarkMode(false)));
````

As a result, any child component of `App` (direct or not), can access the `DarkMode` context.

````rs@meme_editor_dark_mode.rs
let dark_mode_context = use_context::<Signal<DarkMode>>();
````

 > 
 > `use_context` returns `Signal<DarkMode>` here, because the Signal was provided by the parent. If the context hadn't been provided `use_context` would have panicked.

If you have a component where the context might or not be provided, you might want to use `try_consume_context`instead, so you can handle the `None` case. The drawback of this method is that it will not memoize the value between renders, so it won't be as as efficient as `use_context`, you could do it yourself with `use_hook` though.

For example, here's how we would implement the dark mode toggle, which both reads the context (to determine what color it should render) and writes to it (to toggle dark mode):

````rs@meme_editor_dark_mode.rs
pub fn DarkModeToggle() -> Element {
    let mut dark_mode = use_context::<Signal<DarkMode>>();

    let style = if dark_mode().0 { "color:white" } else { "" };

    rsx! {
        label { style: "{style}",
            "Dark Mode"
            input {
                r#type: "checkbox",
                oninput: move |event| {
                    let is_enabled = event.value() == "true";
                    dark_mode.write().0 = is_enabled;
                }
            }
        }
    }
}
````
# Dynamic Rendering

Sometimes you want to render different things depending on the state/props. With Dioxus, just describe what you want to see using Rust control flow â€“ the framework will take care of making the necessary changes on the fly if the state or props change!

## Conditional Rendering

To render different elements based on a condition, you could use an `if-else` statement:

````rs@conditional_rendering.rs
if is_logged_in {
    rsx! {
        "Welcome!"
        button { onclick: move |_| log_out.call(()), "Log Out" }
    }
} else {
    rsx! {
        button { onclick: move |_| log_in.call(()), "Log In" }
    }
}
````

````inject-dioxus
DemoFrame {
  conditional_rendering::App {}
}
````

 > 
 > You could also use `match` statements, or any Rust function to conditionally render different things.

### Improving the `if-else` Example

You may have noticed some repeated code in the `if-else` example above. Repeating code like this is both bad for maintainability and performance. Dioxus will skip diffing static elements like the button, but when switching between multiple `rsx` calls it cannot perform this optimization. For this example either approach is fine, but for components with large parts that are reused between conditionals, it can be more of an issue.

We can improve this example by splitting up the dynamic parts and inserting them where they are needed.

````rs@conditional_rendering.rs
rsx! {
    // We only render the welcome message if we are logged in
    // You can use if statements in the middle of a render block to conditionally render elements
    if is_logged_in {
        // Notice the body of this if statement is rsx code, not an expression
        "Welcome!"
    }
    button {
        // depending on the value of `is_logged_in`, we will call a different event handler
        onclick: move |_| if is_logged_in { log_out.call(()) } else { log_in.call(()) },
        if is_logged_in {
            // if we are logged in, the button should say "Log Out"
            "Log Out"
        } else {
            // if we are not logged in, the button should say "Log In"
            "Log In"
        }
    }
}
````

````inject-dioxus
DemoFrame {
  conditional_rendering::LogInImprovedApp {}
}
````

### Inspecting `Element` props

Since `Element` is a `Result<VNode, RenderError>`, components accepting `Element` as a prop can inspect its contents, and render different things based on that. Example:

````rs@component_children_inspect.rs
fn Clickable(props: ClickableProps) -> Element {
    rsx! {
        div { class: "wrapper", {props.children} }
    }
}
````

You can't mutate the `Element`, but if you need a modified version of it, you can construct a new one based on its attributes/children/etc.

## Rendering Nothing

To render nothing, you can return `None` from a component. This is useful if you want to conditionally hide something:

````rs@conditional_rendering.rs
if is_logged_in {
    return rsx!();
}

rsx! {
    p { "You must be logged in to comment" }
}
````

````inject-dioxus
DemoFrame {
  conditional_rendering::LogInWarningApp {}
}
````

This works because the `Element` type is just an alias for `Result<VNode, RenderError>`

 > 
 > Again, you may use a different method to conditionally return `None`. For example the boolean's [`then()`](https://doc.rust-lang.org/std/primitive.bool.html#method.then) function could be used.

## Rendering Lists

Often, you'll want to render a collection of components. For example, you might want to render a list of all comments on a post.

For this, Dioxus accepts iterators that produce `Element`s. So we need to:

* Get an iterator over all of our items (e.g., if you have a `Vec` of comments, iterate over it with `iter()`)
* `.map` the iterator to convert each item into a `LazyNode` using `rsx!{...}`
  * Add a unique `key` attribute to each iterator item
* Include this iterator in the final RSX (or use it inline)

Example: suppose you have a list of comments you want to render. Then, you can render them like this:

````rs@rendering_lists.rs
let mut comment_field = use_signal(String::new);
let mut next_id = use_signal(|| 0);
let mut comments = use_signal(Vec::<CommentData>::new);

let comments_lock = comments.read();
let comments_rendered = comments_lock.iter().map(|comment| {
    rsx! { Comment { comment: comment.clone() } }
});

rsx! {
    form {
        onsubmit: move |_| {
            comments
                .write()
                .push(CommentData {
                    content: comment_field(),
                    id: next_id(),
                });
            next_id += 1;
            comment_field.set(String::new());
        },
        input {
            value: "{comment_field}",
            oninput: move |event| comment_field.set(event.value())
        }
        input { r#type: "submit" }
    }
    {comments_rendered}
}
````

````inject-dioxus
DemoFrame {
  rendering_lists::App {}
}
````

### Inline for loops

Because of how common it is to render a list of items, Dioxus provides a shorthand for this. Instead of using `.iter`, `.map`, and `rsx`, you can use a `for` loop with a body of rsx code:

````rs@rendering_lists.rs
let mut comment_field = use_signal(String::new);
let mut next_id = use_signal(|| 0);
let mut comments = use_signal(Vec::<CommentData>::new);

rsx! {
    form {
        onsubmit: move |_| {
            comments
                .write()
                .push(CommentData {
                    content: comment_field(),
                    id: next_id(),
                });
            next_id += 1;
            comment_field.set(String::new());
        },
        input {
            value: "{comment_field}",
            oninput: move |event| comment_field.set(event.value())
        }
        input { r#type: "submit" }
    }
    for comment in comments() {
        // Notice the body of this for loop is rsx code, not an expression
        Comment { comment }
    }
}
````

````inject-dioxus
DemoFrame {
  rendering_lists::AppForLoop {}
}
````

### The key Attribute

Every time you re-render your list, Dioxus needs to keep track of which items go where to determine what updates need to be made to the UI.

For example, suppose the `CommentComponent` had some state â€“ e.g. a field where the user typed in a reply. If the order of comments suddenly changes, Dioxus needs to correctly associate that state with the same comment â€“ otherwise, the user will end up replying to a different comment!

To help Dioxus keep track of list items, we need to associate each item with a unique key. In the example above, we dynamically generated the unique key. In real applications, it's more likely that the key will come from e.g. a database ID. It doesn't matter where you get the key from, as long as it meets the requirements:

* Keys must be unique in a list
* The same item should always get associated with the same key
* Keys should be relatively small (i.e. converting the entire Comment structure to a String would be a pretty bad key) so they can be compared efficiently

You might be tempted to use an item's index in the list as its key. Thatâ€™s what Dioxus will use if you donâ€™t specify a key at all. This is only acceptable if you can guarantee that the list is constant â€“ i.e., no re-ordering, additions, or deletions.

 > 
 > Note that if you pass the key to a component you've made, it won't receive the key as a prop. Itâ€™s only used as a hint by Dioxus itself. If your component needs an ID, you have to pass it as a separate prop.
# Router

In many of your apps, you'll want to have different "scenes". For a webpage, these scenes might be the different webpages with their own content. For a desktop app, these scenes might be different views in your app.

To unify these platforms, Dioxus provides a first-party solution for scene management called Dioxus Router.

## What is it?

For an app like the Dioxus landing page (https://dioxuslabs.com), we want to have several different scenes:

* Homepage
* Blog

Each of these scenes is independent â€“ we don't want to render both the homepage and blog at the same time.

The Dioxus router makes it easy to create these scenes. To make sure we're using the router, add the `router` feature to your `dioxus` dependency:

````shell
cargo add dioxus --features router
````

## Using the router

Unlike other routers in the Rust ecosystem, our router is built declaratively at compile time. This makes it possible to compose our app layout simply by defining an enum.

````rs@router_reference.rs
// All of our routes will be a variant of this Route enum
#[derive(Routable, PartialEq, Clone)]
enum Route {
    // if the current location is "/home", render the Home component
    #[route("/home")]
    Home {},
    // if the current location is "/blog", render the Blog component
    #[route("/blog")]
    Blog {},
}

fn Home() -> Element {
    todo!()
}

fn Blog() -> Element {
    todo!()
}
````

Whenever we visit this app, we will get either the Home component or the Blog component rendered depending on which route we enter at. If neither of these routes match the current location, then nothing will render.

We can fix this one of two ways:

* A fallback 404 page

````rs@router_reference.rs
// All of our routes will be a variant of this Route enum
#[derive(Routable, PartialEq, Clone)]
enum Route {
    #[route("/home")]
    Home {},
    #[route("/blog")]
    Blog {},
    //  if the current location doesn't match any of the above routes, render the NotFound component
    #[route("/:..segments")]
    NotFound { segments: Vec<String> },
}

fn Home() -> Element {
    todo!()
}

fn Blog() -> Element {
    todo!()
}

#[component]
fn NotFound(segments: Vec<String>) -> Element {
    todo!()
}
````

* Redirect 404 to home

````rs@router_reference.rs
// All of our routes will be a variant of this Route enum
#[derive(Routable, PartialEq, Clone)]
enum Route {
    #[route("/home")]
    //  if the current location doesn't match any of the other routes, redirect to "/home"
    #[redirect("/:..segments", |segments: Vec<String>| Route::Home {})]
    Home {},
    #[route("/blog")]
    Blog {},
}
````

## Links

For our app to navigate these routes, we can provide clickable elements called Links. These simply wrap `<a>` elements that, when clicked, navigate the app to the given location. Because our route is an enum of valid routes, if you try to link to a page that doesn't exist, you will get a compiler error.

````rs@router_reference.rs
rsx! {
    Link { to: Route::Home {}, "Go home!" }
}
````

## More reading

This page is just a very brief overview of the router. For more information, check out the [router book](../router/index.md) or some of the [router examples](https://github.com/DioxusLabs/dioxus/blob/master/examples/router.rs).
# Resource

[`use_resource`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_resource.html) lets you run an async closure, and provides you with its result.

For example, we can make an API request (using [reqwest](https://docs.rs/reqwest/latest/reqwest/index.html)) inside `use_resource`:

````rs@use_resource.rs
let mut future = use_resource(|| async move {
    reqwest::get("https://dog.ceo/api/breeds/image/random")
        .await
        .unwrap()
        .json::<ApiResponse>()
        .await
});
````

The code inside `use_resource` will be submitted to the Dioxus scheduler once the component has rendered.

We can use `&*future.read_unchecked()` to get the result of the future. On the first run, since there's no data ready when the component loads, its value will be `None`. However, once the future is finished, the component will be re-rendered and the value will now be `Some(...)`, containing the return value of the closure.

We can then render that result:

````rs@use_resource.rs
match &*future.read_unchecked() {
    Some(Ok(response)) => rsx! {
        button { onclick: move |_| future.restart(), "Click to fetch another doggo" }
        div {
            img {
                max_width: "500px",
                max_height: "500px",
                src: "{response.image_url}",
            }
        }
    },
    Some(Err(_)) => rsx! {
        div { "Loading dogs failed" }
    },
    None => rsx! {
        div { "Loading dogs..." }
    },
}
````

````inject-dioxus
DemoFrame {
    use_resource::App {}
}
````

## Restarting the Future

The `Resource` handle provides a `restart` method. It can be used to execute the future again, producing a new value.

## Dependencies

Often, you will need to run the future again every time some value (e.g. a state) changes. Rather than calling `restart` manually, you can read a signal inside of the future. It will automatically re-run the future when any of the states you read inside the future change. Example:

````rs@use_resource.rs
let future = use_resource(move || async move {
    reqwest::get(format!("https://dog.ceo/api/breed/{breed}/images/random"))
        .await
        .unwrap()
        .json::<ApiResponse>()
        .await
});

// You can also add non-reactive state to the resource hook with the use_reactive method
let non_reactive_state = "poodle";
use_resource(use_reactive!(|(non_reactive_state,)| async move {
    reqwest::get(format!(
        "https://dog.ceo/api/breed/{non_reactive_state}/images/random"
    ))
    .await
    .unwrap()
    .json::<ApiResponse>()
    .await
}));
````
# Coroutines

Another tool in your async toolbox are coroutines. Coroutines are futures that can have values sent to them.

Like regular futures, code in a coroutine will run until the next `await` point before yielding. This low-level control over asynchronous tasks is quite powerful, allowing for infinitely looping tasks like WebSocket polling, background timers, and other periodic actions.

## use_coroutine

The `use_coroutine` hook allows you to create a coroutine. Most coroutines we write will be polling loops using await.

````rs@use_coroutine_reference.rs
use futures_util::StreamExt;

fn app() {
    let ws: Coroutine<()> = use_coroutine(|rx| async move {
        // Connect to some sort of service
        let mut conn = connect_to_ws_server().await;

        // Wait for data on the service
        while let Some(msg) = conn.next().await {
            // handle messages
        }
    });
}
````

For many services, a simple async loop will handle the majority of use cases.

## Yielding Values

To yield values from a coroutine, simply bring in a `Signal` handle and set the value whenever your coroutine completes its work.

The future must be `'static` â€“ so any values captured by the task cannot carry any references to `cx`, such as a `Signal`.

You can use [to_owned](https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned) to create a clone of the hook handle which can be moved into the async closure.

````rs@use_coroutine_reference.rs
let mut sync_status = use_signal(|| Status::Launching);
let sync_task = use_coroutine(move |rx: UnboundedReceiver<SyncAction>| async move {
    loop {
        tokio::time::sleep(Duration::from_secs(1)).await;
        sync_status.set(Status::Working);
    }
});
````

To make this a bit less verbose, Dioxus exports the `to_owned!` macro which will create a binding as shown above, which can be quite helpful when dealing with many values.

````rs@use_coroutine_reference.rs
let sync_status = use_signal(|| Status::Launching);
let load_status = use_signal(|| Status::Launching);
let sync_task = use_coroutine(|rx: UnboundedReceiver<SyncAction>| {
    async move {
        // ...
    }
});
````

## Sending Values

You might've noticed the `use_coroutine` closure takes an argument called `rx`. What is that? Well, a common pattern in complex apps is to handle a bunch of async code at once. With libraries like Redux Toolkit, managing multiple promises at once can be challenging and a common source of bugs.

With Coroutines, we can centralize our async logic. The `rx` parameter is an Channel that allows code external to the coroutine to send data *into* the coroutine. Instead of looping on an external service, we can loop on the channel itself, processing messages from within our app without needing to spawn a new future. To send data into the coroutine, we would call "send" on the handle.

````rs@use_coroutine_reference.rs
use futures_util::StreamExt;

enum ProfileUpdate {
    SetUsername(String),
    SetAge(i32),
}

let profile = use_coroutine(|mut rx: UnboundedReceiver<ProfileUpdate>| async move {
    let mut server = connect_to_server().await;

    while let Some(msg) = rx.next().await {
        match msg {
            ProfileUpdate::SetUsername(name) => server.update_username(name).await,
            ProfileUpdate::SetAge(age) => server.update_age(age).await,
        }
    }
});

rsx! {
    button { onclick: move |_| profile.send(ProfileUpdate::SetUsername("Bob".to_string())),
        "Update username"
    }
}
````

 > 
 > Note: In order to use/run the `rx.next().await` statement you will need to extend the \[`Stream`\] trait (used by \[`UnboundedReceiver`\]) by adding 'futures_util' as a dependency to your project and adding the `use futures_util::stream::StreamExt;`.

For sufficiently complex apps, we could build a bunch of different useful "services" that loop on channels to update the app.

````rs@use_coroutine_reference.rs
let profile = use_coroutine(profile_service);
let editor = use_coroutine(editor_service);
let sync = use_coroutine(sync_service);

async fn profile_service(rx: UnboundedReceiver<ProfileCommand>) {
    // do stuff
}

async fn sync_service(rx: UnboundedReceiver<SyncCommand>) {
    // do stuff
}

async fn editor_service(rx: UnboundedReceiver<EditorCommand>) {
    // do stuff
}
````

We can combine coroutines with Global State to emulate Redux Toolkit's Thunk system with much less headache. This lets us store all of our app's state *within* a task and then simply update the "view" values stored in Atoms. It cannot be understated how powerful this technique is: we get all the perks of native Rust tasks with the optimizations and ergonomics of global state. This means your *actual* state does not need to be tied up in a system like `Signal::global` or Redux â€“ the only Atoms that need to exist are those that are used to drive the display/UI.

````rs@use_coroutine_reference.rs
static USERNAME: GlobalSignal<String> = Signal::global(|| "default".to_string());

fn app() -> Element {
    use_coroutine(sync_service);

    rsx! {
        Banner {}
    }
}

fn Banner() -> Element {
    rsx! {
        h1 { "Welcome back, {USERNAME}" }
    }
}
````

Now, in our sync service, we can structure our state however we want. We only need to update the view values when ready.

````rs@use_coroutine_reference.rs
use futures_util::StreamExt;

static USERNAME: GlobalSignal<String> = Signal::global(|| "default".to_string());
static ERRORS: GlobalSignal<Vec<String>> = Signal::global(|| Vec::new());

enum SyncAction {
    SetUsername(String),
}

async fn sync_service(mut rx: UnboundedReceiver<SyncAction>) {
    while let Some(msg) = rx.next().await {
        match msg {
            SyncAction::SetUsername(name) => {
                if set_name_on_server(&name).await.is_ok() {
                    *USERNAME.write() = name;
                } else {
                    *ERRORS.write() = vec!["Failed to set username".to_string()];
                }
            }
        }
    }
}
````

## Automatic injection into the Context API

Coroutine handles are automatically injected through the context API. You can use the `use_coroutine_handle` hook with the message type as a generic to fetch a handle.

````rs@use_coroutine_reference.rs
fn Child() -> Element {
    let sync_task = use_coroutine_handle::<SyncAction>();

    sync_task.send(SyncAction::SetUsername);

    todo!()
}
````
# Spawning Futures

The `use_resource` and `use_coroutine` hooks are useful if you want to unconditionally spawn the future. Sometimes, though, you'll want to only spawn a future in response to an event, such as a mouse click. For example, suppose you need to send a request when the user clicks a "log in" button. For this, you can use `spawn`:

````rs@spawn.rs
let mut response = use_signal(|| String::from("..."));

let log_in = move |_| {
    spawn(async move {
        let resp = reqwest::Client::new()
            .get("https://dioxuslabs.com")
            .send()
            .await;

        match resp {
            Ok(_data) => {
                log::info!("dioxuslabs.com responded!");
                response.set("dioxuslabs.com responded!".into());
            }
            Err(err) => {
                log::info!("Request failed with error: {err:?}")
            }
        }
    });
};

rsx! {
    button { onclick: log_in, "Response: {response}" }
}
````

````inject-dioxus
DemoFrame {
    spawn::App {}
}
````

 > 
 > Note: `spawn` will always spawn a *new* future. You most likely don't want to call it on every render.

Calling `spawn` will give you a `JoinHandle` which lets you cancel or pause the future.

## Spawning Tokio Tasks

Sometimes, you might want to spawn a background task that needs multiple threads or talk to hardware that might block your app code. In these cases, we can directly spawn a Tokio task from our future. For Dioxus-Desktop, your task will be spawned onto Tokio's Multithreaded runtime:

````rs@spawn.rs
spawn(async {
    let _ = tokio::spawn(async {}).await;

    let _ = tokio::task::spawn_local(async {
        // some !Send work
    })
    .await;
});
````
# Contributing

Development happens in the [Dioxus GitHub repository](https://github.com/DioxusLabs/dioxus). If you've found a bug or have an idea for a feature, please submit an issue (but first check if someone hasn't [done it already](https://github.com/DioxusLabs/dioxus/issues)).

[GitHub discussions](https://github.com/DioxusLabs/dioxus/discussions) can be used as a place to ask for help or talk about features. You can also join [our Discord channel](https://discord.gg/XgGxMSkvUM) where some development discussion happens.

## Improving Docs

If you'd like to improve the docs, PRs are welcome! The Rust docs ([source](https://github.com/DioxusLabs/dioxus/tree/main/packages)) and this guide ([source](https://github.com/DioxusLabs/docsite/tree/main/docs-src/0.6)) can be found in their respective GitHub repos.

## Working on the Ecosystem

Part of what makes React great is the rich ecosystem. We'd like the same for Dioxus! So if you have a library in mind that you'd like to write and many people would benefit from, it will be appreciated. You can [browse npm.js](https://www.npmjs.com/search?q=keywords:react-component) for inspiration. Once you are done, add your library to the [awesome dioxus](https://github.com/DioxusLabs/awesome-dioxus) list or share it in the `#I-made-a-thing` channel on [Discord](https://discord.gg/XgGxMSkvUM).

## Bugs & Features

If you've fixed [an open issue](https://github.com/DioxusLabs/dioxus/issues), feel free to submit a PR! Consider [reaching out](https://discord.gg/XgGxMSkvUM) to the team first to make sure everyone's on the same page, and you don't do useless work!

All pull requests (including those made by a team member) must be approved by at least one other team member.
Larger, more nuanced decisions about design, architecture, breaking changes, trade-offs, etc. are made by team consensus.

## Before you contribute

You might be surprised that a lot of checks fail when making your first PR.
That's why you should first run these commands before contributing, and it will save you *lots* of time, because the
GitHub CI is much slower at executing all of these than your PC.

* Format code with [rustfmt](https://github.com/rust-lang/rustfmt):

````sh
cargo fmt -- src/**/**.rs
````

* You might need to install some packages on Linux (Ubuntu/deb) before the following commands will complete successfully (there is also a Nix flake in the repo root):

````sh
sudo apt install libgdk3.0-cil libatk1.0-dev libcairo2-dev libpango1.0-dev libgdk-pixbuf2.0-dev libsoup-3.0-dev libjavascriptcoregtk-4.1-dev libwebkit2gtk-4.1-dev
````

* Check all code [cargo check](https://doc.rust-lang.org/cargo/commands/cargo-check.html):

````sh
cargo check --workspace --examples --tests
````

* Check if [Clippy](https://doc.rust-lang.org/clippy/) generates any warnings. Please fix these!

````sh
cargo clippy --workspace --examples --tests -- -D warnings
````

* Test all code with [cargo-test](https://doc.rust-lang.org/cargo/commands/cargo-test.html):

````sh
cargo test --all --tests
````

* More tests, this time with [cargo-make](https://sagiegurari.github.io/cargo-make/). Here are all steps, including installation:

````sh
cargo install --force cargo-make
cargo make tests
````

* Test with Playwright. This tests the UI itself, right in a browser. Here are all steps, including installation:
  **Disclaimer: This might inexplicably fail on your machine without it being your fault.** Make that PR anyway!

````sh
cd playwright-tests
npm ci
npm install -D @playwright/test
npx playwright install --with-deps
npx playwright test
````

## How to test dioxus with local crate

If you are developing a feature, you should test it in your local setup before raising a PR. This process makes sure you are aware of your code functionality before being reviewed by peers.

* Fork the following github repo (DioxusLabs/dioxus):

`https://github.com/DioxusLabs/dioxus`

* Create a new or use an existing rust crate (ignore this step if you will use an existing rust crate):
  This is where we will be testing the features of the forked

````sh
cargo new --bin demo
````

* Add the dioxus dependency to your rust crate (new/existing) in Cargo.toml:

````toml
dioxus = { path = "<path to forked dioxus project>/dioxus/packages/dioxus", features = ["web", "router"] }
````

This above example is for dioxus-web, with dioxus-router. To know about the dependencies for different renderer visit [here](../getting_started/index.md).

* Run and test your feature

````sh
dx serve
````

If this is your first time with dioxus, please read [the guide](../guide/index.md) to get familiar with dioxus.
# Project Structure

There are many packages in the Dioxus organization. This document will help you understand the purpose of each package and how they fit together:

![Dioxus Dependency Graph](/assets/static/workspace-graph.png)

## Entry Points

* [dioxus](https://github.com/DioxusLabs/dioxus/tree/main/packages/dioxus): The main crate for Dioxus applications. The dioxus crate has different feature flags to enable a specific [renderer](#renderers) with the launch API and expose different features like the router and [fullstack](#fullstack). The [CLI](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli) uses the renderer feature flag that is enabled to determine what rust target to compile for.
* [dioxus-lib](https://github.com/DioxusLabs/dioxus/tree/main/packages/dioxus-lib): Dioxus lib is a re-export of the dioxus crate without any renderer features. This crate is recommended for libraries because it is impossible to pull in a renderer feature accidentally which would enable that renderer for any downstream crates.

## Renderers

Renderers are the entry point for Dioxus applications. They handle rendering the application, polling async tasks, and handling events. Each renderer depends on `dioxus-core` for the core virtual dom and implements both the history trait from `dioxus-history` and the event conversion trait from `dioxus-html`. Dioxus has four renderers in the main repository:

* [desktop](https://github.com/DioxusLabs/dioxus/tree/main/packages/desktop): A Render that Runs Dioxus applications natively, but renders them with the system webview
* [mobile](https://github.com/DioxusLabs/dioxus/tree/main/packages/mobile): A Render that Runs Dioxus applications natively, but renders them with the system webview. This is currently a think wrapper on top of the desktop renderer since both renderers use the webview
* [web](https://github.com/DioxusLabs/dioxus/tree/main/packages/web): Renders Dioxus applications in the browser by compiling to WASM and manipulating the DOM. The web renderer has a hydration feature to take over rendering from the server if [fullstack](#fullstack) is enabled
* [liveview](https://github.com/DioxusLabs/dioxus/tree/main/packages/liveview): A Render that Runs on the server, and renders using a websocket proxy in the browser. The liveview renderer is currently supported, but development has been deprioritized in favor of fullstack and it may be removed in the future

 > 
 > The [TUI](https://github.com/DioxusLabs/blitz/tree/legacy/packages/dioxus-tui) renderer has been deprecated but may be revisited in the future once the new version of Blitz is more stable

## Experimental Native Rendering

In addition to the renderers listed above, Dioxus also has an experimental native renderer called Blitz that uses WebGPU to render HTML+CSS for dioxus applications:

* [taffy](https://github.com/DioxusLabs/taffy): Layout engine powering Blitz-Core, Plasmo, and Bevy UI
* [blitz](https://github.com/DioxusLabs/blitz): An experimental native renderer for Dioxus applications using WGPU

## Fullstack

Fullstack can be layered on top of any renderer to add support for server functions and server-side rendering.

* [ssr](https://github.com/DioxusLabs/dioxus/tree/main/packages/ssr): dioxus-ssr handles rendering a dioxus virtual dom to a string for testing or on the server. SSR is used in the fullstack renderer to handle server side rendering and static generation.
* [isrg](https://github.com/DioxusLabs/dioxus/tree/main/packages/isrg): dioxus-isrg handles incremental static site generation for dioxus fullstack applications. It helps fullstack cache server side rendered routes in memory and on the file system.
* [fullstack](https://github.com/DioxusLabs/dioxus/tree/main/packages/fullstack): dioxus-fullstack package handles the integration between a [axum](https://github.com/tokio-rs/axum) server and a dioxus renderer. If the frontend renderer is targeting the web, the fullstack renderer will prepare html with embedded data so the client can take over rendering after the initial load (hydration)
* [server-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/server-macro): The server-macro crate defines the `server` macro used to define server functions in Dioxus applications. It integrates with the [server_fn](https://crates.io/crates/server_fn) to automatically register the server functions on the server and call them on the client.

## Core utilities

The core utilities contain the implementation of the virtual dom, and other macros used in all dioxus renderers. The core of dioxus doesn't assume it is running in a web context, so these utilities can be used by third party renderers like [Freya](https://github.com/marc2332/freya).

* [core](https://github.com/DioxusLabs/dioxus/tree/main/packages/core): The core virtual dom implementation every Dioxus application uses. The main entry point for core is the `VirtualDom`. The virtual dom diffing methods accept a cross platform `WriteMutations` trait that is called any time the renderer need to change what is rendered. The vdom also has methods for running futures, and inserting events. You can read more about the architecture of the core [in this blog post](https://dioxuslabs.com/blog/templates-diffing/)
* [core-types](https://github.com/DioxusLabs/dioxus/tree/main/packages/core-types): The core types crate contains some of the core functions used in both in dioxus core and the hot reloading engine.
* [core-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/core-macro): The core macro crate implement the `derive(Props)` and `#[component]` macros to derive builds for components. It also re-exports the rsx macro
* [rsx](https://github.com/DioxusLabs/dioxus/tree/main/packages/rsx): Implements parsing and expansion for the RSX macro. The parser is also used for hot reloading, and autoformatting in the CLI

## Web utilities

Every first party dioxus renderer targets html and css. With the exception of the blitz, all renderers run inside the browser context. Dioxus has a few utilities in the workspace with shared traits and javascript bindings to help interact with the browser:

* [interpreter](https://github.com/DioxusLabs/dioxus/tree/main/packages/interpreter): The interpreter implements the `WriteMutations` trait from dioxus core to modify the DOM with the diffs the virtual dom generates. The interpreter is used by the desktop, web and liveview renderers. It uses a combination of [`wasm-bindgen`](https://rustwasm.github.io/wasm-bindgen) and [`sledgehammer-bindgen`](https://github.com/ealmloff/sledgehammer_bindgen) to interact with the browser
* [html](https://github.com/DioxusLabs/dioxus/tree/main/packages/html): defines html specific elements, events, and attributes. The elements and attributes are used in the rsx macro and hot reloading engine to map the rust identifiers to the html names. The events defined in the html crate are traits defined for each platform.
* [html-internal-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/html-internal-macro): The html-internal-macro crate is used by the html crate to define the html elements and attributes.
* [lazy-js-bundle](https://github.com/DioxusLabs/dioxus/tree/main/packages/lazy-js-bundle): A library to bundle typescript files at build time with bun only if the contents change. Only compiling the typescript when the files change and committing the build output lets us not require a ts compiler to be installed when dioxus is added as a library.
* [history](https://github.com/DioxusLabs/dioxus/tree/main/packages/history): The dioxus-history crate defines the history trait backing each renderer must provide for use with the router. For web renderers, this should call the javascript history api. Native renderers maintain their own history stack in memory.
* [document](https://github.com/DioxusLabs/dioxus/tree/main/packages/document): The dioxus-document crate defines the document trait backing each renderer must provide for use with `eval` and the `document::*` components. `eval` runs javascript code from rust, and the `document::*` components create html elements in the head.

## State Management

* [generational-box](https://github.com/DioxusLabs/dioxus/tree/main/packages/generational-box): Generational Box is the core of all `Copy` state management in Dioxus. It allocates an arena of dynamically borrow checked values used throughout the dioxus ecosystem. The `GenerationalBox` type backs `Signal`, `Memo`, and `Resource` in dioxus signals. It is also used in `dioxus-core` to make the `Closure` and `EventHandler` types `Copy`.
* [signals](https://github.com/DioxusLabs/dioxus/tree/main/packages/signals): Signals are the main user facing state management crate for Dioxus. Signals track when they are read and written to and automatically re-run any `ReactiveContext`s that depends on the signal.
* [hooks](https://github.com/DioxusLabs/dioxus/tree/main/packages/hooks): Hooks are a collection of common hooks for Dioxus applications. Most hooks are a thin wrapper over the new methods in the `signals` crate to only create the object once when the component is created.

## Logging

* [logger](https://github.com/DioxusLabs/dioxus/tree/main/packages/logger): The logger crate provides a simple logging interface for Dioxus applications that works across native and wasm targets. It is automatically called in the launch function if the logging feature is enabled.

## Routing

* [router](https://github.com/DioxusLabs/dioxus/tree/main/packages/router): The router crate handles routing in Dioxus applications. It uses the history provider the renderer provides to get and modify the url. The route parsing logic is derived with the `derive(Routable)` macro defined in the dioxus-router-macro crate.
* [router-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/router-macro): The router-macro crate defines the `derive(Routable)` macro used to the route enum from a url and display it as a url.

## Assets

* [manganis](https://github.com/DioxusLabs/dioxus/tree/main/packages/manganis/manganis): Manganis is dioxus' asset system. It uses a macro to inject assets from rust code into the linker. Every asset gets a unique hash for cache busting. The CLI pulls the asset out of the linker and bundled them into the final application.
* [manganis-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/manganis/manganis-macro): Manganis-macro defines the `asset!()` macro used to include assets in Dioxus applications.
* [manganis-core](https://github.com/DioxusLabs/dioxus/tree/main/packages/manganis/manganis-core): Manganis-core contains the builders for all options passed into the `asset!()` macro and the link sections the asset macro and CLI use to bundle assets.
* [const-serialize](https://github.com/DioxusLabs/dioxus/tree/main/packages/const-serialize): Const Serialize defines a trait to serialize rust types to a cross platform format at compile time. This is used to serialize the options for assets at compile time in manganis.
* [const-serialize-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/const-serialize-macro): Const Serialize Macro defines a derive macro for types that can be serialized at compile time with the `const-serialize` crate.
* [cli-opt](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli-opt): The cli-opt optimizes the assets that manganis produces.

## Formatting

* [autofmt](https://github.com/DioxusLabs/dioxus/tree/main/packages/autofmt): The autofmt crate finds and formats all rsx macros in a rust project. It uses the `dioxus-rsx` crate to parse rsx.

## Linting

* [check](https://github.com/DioxusLabs/dioxus/tree/main/packages/check): The dioxus-check crate analyzes dioxus code to check for common errors like calling hooks in conditionals or loops.

## Translation

* [rsx-rosetta](https://github.com/DioxusLabs/dioxus/tree/main/packages/rsx-rosetta): The rsx-rosetta crate translates html to rsx. It uses the element definitions from `dioxus-html` to translate html elements and attributes to their rust names and the `rsx` crate to generate the rsx macro.

## Hot Reloading

* [rsx-hotreload](https://github.com/DioxusLabs/dioxus/tree/main/packages/rsx-hotreload): The rsx-hotreload crate handles diffing rsx macros between builds and creating the hot reload templates for the CLI.
* [devtools](https://github.com/DioxusLabs/dioxus/tree/main/packages/devtools): The devtools crate contains the frontend for hot reloading each renderer needs to integrate with. It receives hot reload messages from a websocket connection with the CLI
* [devtools-types](https://github.com/DioxusLabs/dioxus/tree/main/packages/devtools-types): The devtools-types crate contains the types used to communicate between the devtools frontend and the backend in the CLI.

## CLI

* [cli](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli): The cli crate contains the dioxus CLI. It integrates check, autofmt, cli-opt, and rsx-hotreload to build and serve Dioxus applications.
* [cli-config](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli-config): The cli-config crate has shared types that are provided at runtime from the CLI to crates the CLI are built with. It is used by `dioxus-desktop` to set the title from the `Dioxus.toml` file and by `dioxus-fullstack` to set the port the CLI proxies the server from.
* [dx-wire-format](https://github.com/DioxusLabs/dioxus/tree/main/packages/dx-wire-format): The dx-wire-format crate has the unstable types the CLI emits in json mode. This is used by the dioxus playground.

## Extension

* [extension](https://github.com/DioxusLabs/dioxus/tree/main/packages/extension): The extension folder contains the source code for the dioxus VSCode extension. It uses many of the same crates as the CLI, but packaged into a wasm+JS bundle for VSCode.

## Testing

* [playwright-tests](https://github.com/DioxusLabs/dioxus/tree/main/packages/playwright-tests): The playwright-tests folder contains end to end tests for dioxus-web, dioxus-liveview and fullstack. These crates are not published on crates.io
# Overall Goals

This document outlines some of the overall goals for Dioxus. These goals are not set in stone, but they represent general guidelines for the project.

The goal of Dioxus is to make it easy to build **cross-platform applications that scale**.

## Cross-Platform

Dioxus is designed to be cross-platform by default. This means that it should be easy to build applications that run on the web, desktop, and mobile. However, Dioxus should also be flexible enough to allow users to opt into platform-specific features when needed. The `use_eval` is one example of this. By default, Dioxus does not assume that the platform supports JavaScript, but it does provide a hook that allows users to opt into JavaScript when needed.

## Performance

As Dioxus applications grow, they should remain relatively performant without the need for manual optimizations. There will be cases where manual optimizations are needed, but Dioxus should try to make these cases as rare as possible.

One of the benefits of the core architecture of Dioxus is that it delivers reasonable performance even when components are rerendered often. It is based on a Virtual Dom which performs diffing which should prevent unnecessary re-renders even when large parts of the component tree are rerun. On top of this, Dioxus groups static parts of the RSX tree together to skip diffing them entirely.

## Type Safety

As teams grow, the Type safety of Rust is a huge advantage. Dioxus should leverage this advantage to make it easy to build applications with large teams.

To take full advantage of Rust's type system, Dioxus should try to avoid exposing public `Any` types and string-ly typed APIs where possible.

## Developer Experience

Dioxus should be easy to learn and ergonomic to use.

* The API of Dioxus attempts to remain close to React's API where possible. This makes it easier for people to learn Dioxus if they already know React

* We can avoid the tradeoff between simplicity and flexibility by providing multiple layers of API: One for the very common use case, one for low-level control
  
  * Hooks: the hooks crate has the most common use cases, but `use_hook` provides a way to access the underlying persistent value if needed.
  * The builder pattern in platform Configs: The builder pattern is used to default to the most common use case, but users can change the defaults if needed.
* Documentation:
  
  * All public APIs should have rust documentation
  * Examples should be provided for all public features. These examples both serve as documentation and testing. They are checked by CI to ensure that they continue to compile
  * The most common workflows should be documented in the guide
# Introduction

The âœ¨**Dioxus CLI**âœ¨ is a tool to get Dioxus projects off the ground.

There's no documentation for commands here, but you can see all commands using `dx --help` once you've installed the CLI! Furthermore, you can run `dx <command> --help` to get help with a specific command.

## Features

* Build and pack a Dioxus project.
* Format `rsx` code.
* Hot Reload.
* Create a Dioxus project from a template repository.
* And more!
# Create a Project

Once you have the Dioxus CLI installed, you can use it to create your own project!

## Initializing a project

First, run the `dx new` command to create a new project.

 > 
 > It clones this [template](https://github.com/DioxusLabs/dioxus-template), which is used to create dioxus apps.
 > 
 > You can create your project from a different template by passing the `template` argument:
 > 
 > ````
 > dx new --template gh:dioxuslabs/dioxus-template
 > ````

Next, navigate into your new project using `cd project-name`, or simply opening it in an IDE.

 > 
 > Make sure the WASM target is installed before running the projects.
 > You can install the WASM target for rust using rustup:
 > 
 > ````
 > rustup target add wasm32-unknown-unknown
 > ````

Finally, serve your project with `dx serve`! The CLI will tell you the address it is serving on, along with additional
info such as code warnings.
# Configure Project

This chapter will teach you how to configure the CLI with the `Dioxus.toml` file. There's an [example](#config-example) which has comments to describe individual keys. You can copy that or view this documentation for a more complete learning experience.

"ðŸ”’" indicates a mandatory item. Some headers are mandatory, but none of the keys inside them are. In that case, you only need to include the header, but no keys. It might look weird, but it's normal.

## Structure

Each header has its TOML form directly under it.

### Application ðŸ”’

````toml
[application]
````

Application-wide configuration. Applies to both web and desktop.

* **asset_dir** - The directory with your static assets. The CLI will automatically copy these assets into the **out_dir** after a build/serve.
  ````toml
  asset_dir = "public"
  ````

* **sub_package** - The sub package in the workspace to build by default.
  ````toml
  sub_package = "my-crate"
  ````

### Web.App ðŸ”’

````toml
[web.app]
````

Web-specific configuration.

* **title** - The title of the web page.
  ````toml
  # HTML title tag content
  title = "project_name"
  ````

* **base_path** - The base path to build the application for serving at. This can be useful when serving your application in a subdirectory under a domain. For example, when building a site to be served on GitHub Pages.
  ````toml
  # The application will be served at domain.com/my_application/, so we need to modify the base_path to the path where the application will be served
  base_path = "my_application"
  ````

### Web.Watcher ðŸ”’

````toml
[web.watcher]
````

Development server configuration.

* **reload_html** - If this is true, the cli will rebuild the index.html file every time the application is rebuilt
  
  ````toml
  reload_html = true
  ````

* **watch_path** - The files & directories to monitor for changes
  
  ````toml
  watch_path = ["src", "public"]
  ````

* **index_on_404** - If enabled, Dioxus will serve the root page when a route is not found.
  *This is needed when serving an application that uses the router*. However, when serving your app using something else than Dioxus (e.g. GitHub Pages), you will have to check how to configure it on that platform. In GitHub Pages, you can make a copy of `index.html` named `404.html` in the same directory.
  
  ````toml
  index_on_404 = true
  ````

### Web.Resource ðŸ”’

````toml
[web.resource]
````

Static resource configuration.

* **style** - CSS files to include in your application.
  
  ````toml
  style = [
     # Include from public_dir.
     "./assets/style.css",
     # Or some asset from online cdn.
     "https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.css"
  ]
  ````

* **script** - JavaScript files to include in your application.
  
  ````toml
  script = [
      # Include from asset_dir.
      "./public/index.js",
      # Or from an online CDN.
      "https://cdn.jsdelivr.net/npm/bootstrap/dist/js/bootstrap.js"
  ]
  ````

### Web.Resource.Dev ðŸ”’

````toml
[web.resource.dev]
````

This is the same as [`[web.resource]`](#webresource-), but it only works in development servers. For example, if you want to include a file in a `dx serve` server, but not a `dx serve --release` server, put it here.

### Web.Proxy

````toml
[[web.proxy]]
````

Configuration related to any proxies your application requires during development. Proxies will forward requests to a new service.

* **backend** - The URL to the server to proxy. The CLI will forward any requests under the backend relative route to the backend instead of returning 404
  ````toml
  backend = "http://localhost:8000/api/"
  ````
  
  This will cause any requests made to the dev server with prefix /api/ to be redirected to the backend server at http://localhost:8000. The path and query parameters will be passed on as-is (path rewriting is currently not supported).

### Web.https

````toml
[[web.https]]
````

Controls the https config for the CLI.

* **enabled** enables or disables https in the CLI
  ````toml
  enabled = true
  ````

* **mkcert** enables or disables generating certs with the mkcert CLI
  ````toml
  mkcert = true
  ````

* **key_path** sets the path to use for the https key
  ````toml
  key_path = "/path/to/key"
  ````

* **cert_path** sets the path to use for the https cert
  ````toml
  cert_path = "/path/to/cert"
  ````

### Web.pre_compress

If this setting is enabled, the CLI will pre-compress the built assets in release mode with brotli. This setting is enabled by default.

````toml
[web]
pre_compress = true
````

### Web.wasm_opt

Controls the wasm-opt config for the CLI.

* **level** sets the level of optimization to use for wasm-opt in release builds.
  * z: optimize aggressively for size
  * s: optimize for size
  * 1: optimize for speed
  * 2: optimize for more for speed
  * 3: optimize for even more for speed
  * 4: optimize aggressively for speed (default)
  ````toml
  level = "z"
  ````

* **debug** keep debug symbols in the wasm file even in release builds
  ````toml
  debug = true
  ````

### Bundle

````toml
[bundle]
````

Controls the bundling process for your application. Dioxus uses tauri-bundler under the hood. This section only includes a subset of the options available in tauri-bundler. More options can be found in the tauri-bundler [documentation](https://v1.tauri.app/v1/guides/building/#configuration-options).

* **identifier** - A unique identifier for your application (e.g., `com.dioxuslabs`).
  ````toml
  identifier = "com.dioxuslabs"
  ````

* **publisher** - The name of the entity publishing the application.
  ````toml
  publisher = "DioxusLabs"
  ````

* **icon** - Paths to icon files to be used in the bundle. Icon files must be square and 16, 24, 32, 64, or 256 pixels in size. PNG icons must have a 32 bit depth in the RGBA format. If you use a `.icns` file is must fit [this](https://github.com/tauri-apps/tauri/blob/d8db5042a28635259f646c329c3ec5ccf23eac9e/tooling/cli/src/helpers/icns.json) format. The icons must include a `.icns` icon for macOS, `.ico` for Windows and `.png` for Linux.
  ````toml
  icon = [
     "icons/32x32.png",
     "icons/128x128.png",
     "icons/128x128@2x.png",
     "icons/icon.icns",
     "icons/icon.ico"
  ]
  ````

* **resources** - Additional files to include in the bundle. Each asset is copied from the path and is accessible from the bundle at the same path. Any [assets](../guides/assets.md) are automatically bundled with the installer.
  ````toml
  resources = ["path/to/resource"]
  ````

* **copyright** - Copyright information for the application.
  ````toml
  copyright = "Copyright 2023 DioxusLabs"
  ````

* **category** - The category of the application. Must be one of `Business`, `DeveloperTool`, `Education`, `Entertainment`, `Finance`, `Game`, `ActionGame`, `AdventureGame`, `ArcadeGame`, `BoardGame`, `CardGame`, `CasinoGame`, `DiceGame`, `EducationalGame`, `FamilyGame`, `KidsGame`, `MusicGame`, `PuzzleGame`, `RacingGame`, `RolePlayingGame`, `SimulationGame`, `SportsGame`, `StrategyGame`, `TriviaGame`, `WordGame`, `GraphicsAndDesign`, `HealthcareAndFitness`, `Lifestyle`, `Medical`, `Music`, `News`, `Photography`, `Productivity`, `Reference`, `SocialNetworking`, `Sports`, `Travel`, `Utility`, `Video`, or `Weather`
  ````toml
  category = "Utility"
  ````

* **short_description** - A brief description of the application.
  ````toml
  short_description = "A utility application built with Dioxus"
  ````

* **long_description** - A detailed description of the application.
  ````toml
  long_description = "This application provides various utility functions..."
  ````

* **external_bin** - Paths to external sidecar binaries to include in the bundle. These bundles may be accessed at runtime with the name of the binary (not the absolute path). **the target triple will be automatically added to the binary name before it is added to the bundle.**
  ````toml
  external_bin = ["path/to/external_binary"] # On macos, the binary at path/to/external_binary-aarch64-apple-darwin will be included in the bundle. It can be accessed at runtime with the name external_binary
  ````

### Bundle.macos

````toml
[bundle.macos]
````

Configuration options for macOS bundles.

* **frameworks** - List of frameworks to include in the bundle.
  ````toml
  frameworks = ["CoreML"]
  ````

* **minimum_system_version** - Minimum macOS version required. (default: `10.13`)
  ````toml
  minimum_system_version = "10.13"
  ````

* **license** - Path to the license file.
  ````toml
  license = "LICENSE.txt"
  ````

* **exception_domain** - Domain for exception handling. The domain must be lowercase without a port or protocol.
  ````toml
  exception_domain = "mysite.com"
  ````

* **signing_identity** - macOS signing identity.
  ````toml
  signing_identity = "SIGNING IDENTITY KEYCHAIN ENTRY NAME"
  ````

* **provider_short_name** - Provider short name for the bundle.
  ````toml
  provider_short_name = "DioxusLabs"
  ````

* **entitlements** - Path to the entitlements file.
  ````toml
  entitlements = "entitlements.plist"
  ````

* **hardened_runtime** - Whether to enable the [hardened runtime](https://developer.apple.com/documentation/security/hardened-runtime) in the bundle.
  ````toml
  hardened_runtime = true
  ````

### Bundle.windows

````toml
[bundle.windows]
````

Configuration options for Windows bundles.

* **digest_algorithm** - Sets the file digest algorithm used for signing.
  ````toml
  digest_algorithm = "sha-256"
  ````

* **certificate_thumbprint** - SHA1 hash of the signing certificate.
  ````toml
  certificate_thumbprint = "A1B2C3D4E5F6..."
  ````

* **timestamp_url** - Sets the server to used for timestamping the signature.
  ````toml
  timestamp_url = "http://timestamp.digicert.com"
  ````

* **tsp** - Whether to use the time stamping protocol.
  ````toml
  tsp = true
  ````

* **icon_path** - Path to the icon for the system tray icon. (defaults to `./icons/icon.ico`)
  ````toml
  icon_path = "assets/icon.ico"
  ````

* **webview_install_mode** - Installation mode for WebView2.
  EmbedBootstrapper: embed the WebView2 bootstrapper into the installer
  ````toml
  [webview_install_mode.EmbedBootstrapper]
  silent = true
  ````
  
  DownloadBootstrapper: download the WebView2 bootstrapper in the installer at runtime
  ````toml
  [webview_install_mode.DownloadBootstrapper]
  silent = true
  ````
  
  OfflineInstaller: Embed the WebView2 installer into the main installer
  ````toml
  [webview_install_mode.OfflineInstaller]
  silent = true
  ````
  
  FixedRuntime: Use a fixed path to the WebView2 runtime
  ````toml
  [webview_install_mode.FixedRuntime]
  path = "path/to/runtime"
  ````
  
  Skip: Does not install WebView2 as part of the installer. This will cause the application to fail if webview was not already installed
  ````toml
  webview_install_mode = "Skip"
  ````

## Config example

This includes all fields, mandatory or not.

````toml
[application]

# App name
name = "project_name"

# `build` & `serve` output path
out_dir = "dist"

# The static resource path
asset_dir = "public"

[web.app]

# HTML title tag content
title = "project_name"

[web.watcher]

# When watcher is triggered, regenerate the `index.html`
reload_html = true

# Which files or dirs will be monitored
watch_path = ["src", "public"]

# Include style or script assets
[web.resource]

# CSS style file
style = []

# Javascript code file
script = []

[web.resource.dev]

# Same as [web.resource], but for development servers

# CSS style file
style = []

# JavaScript files
script = []

[[web.proxy]]
backend = "http://localhost:8000/api/"

[bundle]
identifier = "com.dioxuslabs"
publisher = "DioxusLabs"
icon = "assets/icon.png"
````
# Translating existing HTML

Dioxus uses a custom format called RSX to represent the HTML because it is more concise and looks more like Rust code. However, it can be a pain to convert existing HTML to RSX. That's why Dioxus comes with a tool called `dx translate` that can automatically convert HTML to RSX!

Dx translate can make converting large chunks of HTML to RSX much easier! Lets try translating some of the HTML from the Dioxus homepage:

````sh
dx translate --raw  "<div class=\"relative w-full mx-4 sm:mx-auto text-gray-600\"><div class=\"text-[3em] md:text-[5em] font-semibold dark:text-white text-ghdarkmetal font-sans py-12 flex flex-col\"><span>Fullstack, crossplatform,</span><span>lightning fast, fully typed.</span></div><h3 class=\"text-[2em] dark:text-white font-extralight text-ghdarkmetal pt-4 max-w-screen-md mx-auto\">Dioxus is a Rust library for building apps that run on desktop, web, mobile, and more.</h3><div class=\"pt-12 text-white text-[1.2em] font-sans font-bold flex flex-row justify-center space-x-4\"><a href=\"/learn/0.6/getting_started\" dioxus-prevent-default=\"onclick\" class=\"bg-red-600 py-2 px-8 hover:-translate-y-2 transition-transform duration-300\" data-dioxus-id=\"216\">Quickstart</a><a href=\"/learn/0.6/reference\" dioxus-prevent-default=\"onclick\" class=\"bg-blue-500 py-2 px-8 hover:-translate-y-2 transition-transform duration-300\" data-dioxus-id=\"214\">Read the docs</a></div><div class=\"max-w-screen-2xl mx-auto pt-36\"><h1 class=\"text-md\">Trusted by top companies</h1><div class=\"pt-4 flex flex-row flex-wrap justify-center\"><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/futurewei_bw.png\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/airbuslogo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/ESA_logo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/yclogo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/satellite.webp\"></div></div></div></div>"
````

We get the following RSX you can easily copy and paste into your code:

````rs
div { class: "relative w-full mx-4 sm:mx-auto text-gray-600",
   div { class: "text-[3em] md:text-[5em] font-semibold dark:text-white text-ghdarkmetal font-sans py-12 flex flex-col",
      span { "Fullstack, crossplatform," }
      span { "lightning fast, fully typed." }
   }
   h3 { class: "text-[2em] dark:text-white font-extralight text-ghdarkmetal pt-4 max-w-screen-md mx-auto",
      "Dioxus is a Rust library for building apps that run on desktop, web, mobile, and more."
   }
   div { class: "pt-12 text-white text-[1.2em] font-sans font-bold flex flex-row justify-center space-x-4",
      a {
         href: "/learn/0.6/getting_started",
         data_dioxus_id: "216",
         dioxus_prevent_default: "onclick",
         class: "bg-red-600 py-2 px-8 hover:-translate-y-2 transition-transform duration-300",
         "Quickstart"
      }
      a {
         dioxus_prevent_default: "onclick",
         href: "/learn/0.6/reference",
         data_dioxus_id: "214",
         class: "bg-blue-500 py-2 px-8 hover:-translate-y-2 transition-transform duration-300",
         "Read the docs"
      }
   }
   div { class: "max-w-screen-2xl mx-auto pt-36",
      h1 { class: "text-md", "Trusted by top companies" }
      div { class: "pt-4 flex flex-row flex-wrap justify-center",
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "/assets/static/futurewei_bw.png" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "/assets/static/airbuslogo.svg" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "/assets/static/ESA_logo.svg" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "/assets/static/yclogo.svg" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "/assets/static/satellite.webp" }
         }
      }
   }
}
````

## Usage

The `dx translate` command has several flags you can use to control your html input and rsx output.

You can use the `--file` flag to translate an HTML file to RSX:

````sh
dx translate --file index.html
````

Or you can use the `--raw` flag to translate a string of HTML to RSX:

````sh
dx translate --raw "<div>Hello world</div>"
````

Both of those commands will output the following RSX:

````rs
div { "Hello world" }
````

The `dx translate` command will output the RSX to stdout. You can use the `--output` flag to write the RSX to a file instead.

````sh
dx translate --raw "<div>Hello world</div>" --output index.rs
````

You can automatically create a component with the `--component` flag.

````sh
dx translate --raw "<div>Hello world</div>" --component
````

This will output the following component:

````rs
fn component() -> Element {
   rsx! {
      div { "Hello world" }
   }
}
````

To learn more about the different flags `dx translate` supports, run `dx translate --help`.
# Introduction

Dioxus is a portable, performant, and ergonomic framework for building cross-platform user interfaces in Rust. This guide will help you get started with writing Dioxus apps for the Web, Desktop, Mobile, and more.

````rs@readme.rs
use dioxus::prelude::*;

pub fn App() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    }
}

````

````inject-dioxus
DemoFrame {
    readme::App {}
}
````

Dioxus is heavily inspired by React. If you know React, getting started with Dioxus will be a breeze.

 > 
 > This guide assumes you already know some [Rust](https://www.rust-lang.org/)! If not, we recommend reading [*the book*](https://doc.rust-lang.org/book/ch01-00-getting-started.html) to learn Rust first.

## Features

* Cross platform apps in three lines of code. (Web, Desktop, Server, Mobile, and more)
* Incredibly ergonomic and powerful state management that combines the best parts of react, solid and svelte.
* Comprehensive inline documentation â€“ hover and guides for all HTML elements, listeners, and events.
* High performance applications [approaching the fastest web frameworks on the web](https://dioxuslabs.com/blog/templates-diffing) and native speeds on desktop.
* First-class async support.

### Multiplatform

Dioxus is a *portable* toolkit, meaning the Core implementation can run anywhere with no platform-dependent linking. Unlike many other Rust frontend toolkits, Dioxus is not intrinsically linked to WebSys. In fact, every element and event listener can be swapped out at compile time. By default, Dioxus ships with the `html` feature enabled, but this can be disabled depending on your target renderer.

Right now, we have several 1st-party renderers:

* WebSys/Sledgehammer (for WASM): Great support
* Tao/Tokio (for Desktop apps): Good support
* Tao/Tokio (for Mobile apps): Poor support
* Fullstack (for SSR and server functions): Good support
* TUI/Plasmo (for terminal-based apps): Experimental

## Stability

Dioxus has not reached a stable release yet.

Web: Since the web is a fairly mature platform, we expect there to be very little API churn for web-based features.

Desktop: APIs will likely be in flux as we figure out better patterns than our ElectronJS counterpart.

Fullstack: APIs will likely be in flux as we figure out the best API for server communication.
# Getting Started

This section will help you set up your Dioxus project!

## Prerequisites

### An Editor

Dioxus integrates very well with the [Rust-Analyzer LSP plugin](https://rust-analyzer.github.io) which will provide appropriate syntax highlighting, code navigation, folding, and more.

### Rust

Head over to [https://rust-lang.org](http://rust-lang.org) and install the Rust compiler.

We strongly recommend going through the [official Rust book](https://doc.rust-lang.org/book/ch01-00-getting-started.html) *completely*. However, we hope that a Dioxus app can serve as a great first Rust project. With Dioxus, you'll learn about:

* Error handling
* Structs, Functions, Enums
* Closures
* Macros

We've put a lot of care into making Dioxus syntax familiar and easy to understand, so you won't need deep knowledge of async, lifetimes, or smart pointers until you start building complex Dioxus apps.

### Platform-specific dependencies

Most platforms don't require any additional dependencies, but if you are targeting desktop, you can install the following dependencies:

````inject-dioxus
DesktopDependencies {}
````

### Dioxus CLI

Next, lets install the Dioxus CLI:

````
cargo install dioxus-cli
````

If you get an OpenSSL error on installation, ensure the dependencies listed [here](https://docs.rs/openssl/latest/openssl/#automatic) are installed.

## Create a new project

You can create a new Dioxus project by running the following command and following the prompts:

````sh
dx new
````

First you will need to select a platform. Each platform has its own reference with more information on how to set up a project for that platform. Here are the platforms we recommend starting with:

* Web
  * [Client Side](../reference/web/index.md): runs in the browser through WebAssembly
  * [Fullstack](../reference/fullstack/index.md): renders to HTML text on the server and hydrates it on the client

 > 
 > If you are not sure which web platform you want to use, check out the [choosing a web renderer](../reference/choosing_a_web_renderer.md) chapter.

* WebView
  * [Desktop](../reference/desktop/index.md): runs in a web view on desktop
  * [Mobile](../reference/mobile/index.md): runs in a web view on mobile. Mobile is currently not supported by the dioxus CLI. The [mobile reference](../reference/mobile/index.md) has more information about setting up a mobile project

Next, you can choose a styling library. For this project, we will use vanilla CSS.

Finally, you can choose to start the project with the router enabled. The router is covered in the [router guide](../router/index.md).

## Running the project

Once you have created your project, you can start it with the following command:

````sh
cd my_project
dx serve
````

For projects using the liveview template, run `dx serve --desktop`.

For Web targets the application will be served at [http://localhost:8080](http://localhost:8080)

## Conclusion

That's it! You now have a working Dioxus project. You can continue learning about dioxus by [making a hackernews clone in the guide](../guide/index.md), or learning about specific topics/platforms in the [reference](../reference/index.md). If you have any questions, feel free to ask in the [discord](https://discord.gg/XgGxMSkvUM) or [open a discussion](https://github.com/DioxusLabs/dioxus/discussions).
# Dioxus Guide

## Introduction

In this guide, you'll learn to use Dioxus to build user interfaces that run anywhere. We will recreate the hackernews homepage in Dioxus:

````inject-dioxus
DemoFrame {
    hackernews_complete::App {}
}
````

This guide serves a very brief overview of Dioxus. Throughout the guide, there will be links to the [reference](../reference/index.md) with more details about specific concepts.
# Your First Component

This chapter will teach you how to create a [Component](../reference/components.md) that displays a link to a post on hackernews.

## Setup

 > 
 > Before you start the guide, make sure you have the dioxus CLI and any required dependencies for your platform as described in the [getting started](../getting_started/index.md) guide.

First, let's create a new project for our hacker news app. We can use the CLI to create a new project. You can select a platform of your choice or view the getting started guide for more information on each option. If you aren't sure what platform to try out, we recommend getting started with web or desktop:

````sh
dx new
````

The template contains some boilerplate to help you get started. For this guide, we will be rebuilding some of the code from scratch for learning purposes. You can clear the `src/main.rs` file. We will be adding new code in the next sections.

Next, let's setup our dependencies. We need to set up a few dependencies to work with the hacker news API:

````sh
cargo add chrono --features serde
cargo add futures
cargo add reqwest --features json
cargo add serde --features derive
cargo add serde_json
cargo add async_recursion
````

## Describing the UI

Now, we can define how to display a post. Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* how we want the UI to look.

To declare what you want your UI to look like, you will need to use the `rsx` macro. Let's create a `main` function and an `App` component to show information about our story:

````rs@hackernews_post.rs
fn main() {
    launch(App);
}

pub fn App() -> Element {
    rsx! {"story"}
}
````

Now if you run your application you should see something like this:

````inject-dioxus
DemoFrame {
	hackernews_post::story_v1::App {}
}
````

 > 
 > RSX mirrors HTML. Because of this you will need to know some html to use Dioxus.
 > 
 > Here are some resources to help get you started learning HTML:
 > 
 > * [MDN HTML Guide](https://developer.mozilla.org/en-US/docs/Learn/HTML)
 > * [W3 Schools HTML Tutorial](https://www.w3schools.com/html/default.asp)
 > 
 > In addition to HTML, Dioxus uses CSS to style applications. You can either use traditional CSS (what this guide uses) or use a tool like [tailwind CSS](https://tailwindcss.com/docs/installation):
 > 
 > * [MDN Traditional CSS Guide](https://developer.mozilla.org/en-US/docs/Learn/HTML)
 > * [W3 Schools Traditional CSS Tutorial](https://www.w3schools.com/css/default.asp)
 > * [Tailwind tutorial](https://tailwindcss.com/docs/installation) (used with the [Tailwind setup example](https://github.com/DioxusLabs/dioxus/tree/v0.5/examples/tailwind))
 > 
 > If you have existing html code, you can use the [translate](../CLI/translate.md) command to convert it to RSX. Or if you prefer to write html, you can use the [html! macro](https://github.com/DioxusLabs/dioxus-html-macro) to write html directly in your code.

## Dynamic Text

Let's expand our `App` component to include the story title, author, score, time posted, and number of comments. We can insert dynamic text in the render macro by inserting variables inside `{}`s (this works similarly to the formatting in the [println!](https://doc.rust-lang.org/std/macro.println.html) macro):

````rs@hackernews_post.rs
pub fn App() -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    rsx! {"{title} by {by} ({score}) {time} {comments}"}
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v2::App {}
}
````

## Creating Elements

Next, let's wrap our post description in a [`div`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div). You can create HTML elements in Dioxus by putting a `{` after the element name and a `}` after the last child of the element:

````rs@hackernews_post.rs
pub fn App() -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    rsx! { div { "{title} by {by} ({score}) {time} {comments}" } }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v3::App {}
}
````

 > 
 > You can read more about elements in the [rsx reference](../reference/rsx.md).

## Setting Attributes

Next, let's add some padding around our post listing with an attribute.

Attributes (and [listeners](../reference/event_handlers.md)) modify the behavior or appearance of the element they are attached to. They are specified inside the `{}` brackets before any children, using the `name: value` syntax. You can format the text in the attribute as you would with a text node:

````rs@hackernews_post.rs
pub fn App() -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    rsx! {
        div { padding: "0.5rem", position: "relative",
            "{title} by {by} ({score}) {time} {comments}"
        }
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v4::App {}
}
````

 > 
 > Note: All attributes defined in [`dioxus-html`](https://docs.rs/dioxus-html/latest/dioxus_html/) follow the snake_case naming convention. They transform their `snake_case` names to HTML's `camelCase` attributes.

 > 
 > Note: Styles can be used directly outside of the `style:` attribute. In the above example, `padding: "0.5rem"` is turned into `style="padding: 0.5rem"`.

 > 
 > You can read more about elements in the [attribute reference](../reference/rsx.md)

## Creating a Component

Just like you wouldn't want to write a complex program in a single, long, `main` function, you shouldn't build a complex UI in a single `App` function. Instead, you should break down the functionality of an app in logical parts called components.

A component is a Rust function, named in UpperCamelCase, that takes a props parameter and returns an `Element` describing the UI it wants to render. In fact, our `App` function is a component!

Let's pull our story description into a new component:

````rs@hackernews_post.rs
fn StoryListing() -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    rsx! {
        div { padding: "0.5rem", position: "relative",
            "{title} by {by} ({score}) {time} {comments}"
        }
    }
}
````

We can render our component like we would an element by putting `{}`s after the component name. Let's modify our `App` component to render our new StoryListing component:

````rs@hackernews_post.rs
pub fn App() -> Element {
    rsx! { StoryListing {} }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v5::App {}
}
````

 > 
 > You can read more about elements in the [component reference](../reference/components.md)

## Creating Props

Just like you can pass arguments to a function or attributes to an element, you can pass props to a component that customize its behavior!

We can define arguments that components can take when they are rendered (called `Props`) by adding the `#[component]` macro before our function definition and adding extra function arguments.

Currently, our `StoryListing` component always renders the same story. We can modify it to accept a story to render as a prop.

We will also define what a post is and include information for how to transform our post to and from a different format using [serde](https://serde.rs). This will be used with the hackernews API in a later chapter:

````rs@hackernews_post.rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

// Define the Hackernews types
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryPageData {
    #[serde(flatten)]
    pub item: StoryItem,
    #[serde(default)]
    pub comments: Vec<CommentData>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CommentData {
    pub id: i64,
    /// there will be no by field if the comment was deleted
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub text: String,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    #[serde(default)]
    pub sub_comments: Vec<CommentData>,
    pub r#type: String,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryItem {
    pub id: i64,
    pub title: String,
    pub url: Option<String>,
    pub text: Option<String>,
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub score: i64,
    #[serde(default)]
    pub descendants: i64,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    pub r#type: String,
}

#[component]
fn StoryListing(story: ReadOnlySignal<StoryItem>) -> Element {
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        ..
    } = &*story.read();

    let comments = kids.len();

    rsx! {
        div { padding: "0.5rem", position: "relative",
            "{title} by {by} ({score}) {time} {comments}"
        }
    }
}
````

Make sure to also add [serde](https://serde.rs) as a dependency:

````bash
cargo add serde --features derive
cargo add serde_json
````

We will also use the [chrono](https://crates.io/crates/chrono) crate to provide utilities for handling time data from the hackernews API:

````bash
cargo add chrono --features serde
````

Now, let's modify the `App` component to pass the story to our `StoryListing` component like we would set an attribute on an element:

````rs@hackernews_post.rs
pub fn App() -> Element {
    rsx! {
        StoryListing {
            story: StoryItem {
                id: 0,
                title: "hello hackernews".to_string(),
                url: None,
                text: None,
                by: "Author".to_string(),
                score: 0,
                descendants: 0,
                time: chrono::Utc::now(),
                kids: vec![],
                r#type: "".to_string(),
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v6::App {}
}
````

 > 
 > You can read more about Props in the [Props reference](../reference/component_props.md)

## Cleaning Up Our Interface

Finally, by combining elements and attributes, we can make our post listing much more appealing:

Full code up to this point:

````rs@hackernews_post.rs
use dioxus::prelude::*;

// Define the Hackernews types
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryPageData {
    #[serde(flatten)]
    pub item: StoryItem,
    #[serde(default)]
    pub comments: Vec<CommentData>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CommentData {
    pub id: i64,
    /// there will be no by field if the comment was deleted
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub text: String,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    #[serde(default)]
    pub sub_comments: Vec<CommentData>,
    pub r#type: String,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryItem {
    pub id: i64,
    pub title: String,
    pub url: Option<String>,
    pub text: Option<String>,
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub score: i64,
    #[serde(default)]
    pub descendants: i64,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    pub r#type: String,
}

fn main() {
    launch(App);
}

pub fn App() -> Element {
    rsx! {
        StoryListing {
            story: StoryItem {
                id: 0,
                title: "hello hackernews".to_string(),
                url: None,
                text: None,
                by: "Author".to_string(),
                score: 0,
                descendants: 0,
                time: Utc::now(),
                kids: vec![],
                r#type: "".to_string(),
            }
        }
    }
}

#[component]
fn StoryListing(story: ReadOnlySignal<StoryItem>) -> Element {
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        ..
    } = &*story.read();

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} {}", if *score == 1 { " point" } else { " points" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    rsx! {
        div { padding: "0.5rem", position: "relative",
            div { font_size: "1.5rem",
                a { href: url, "{title}" }
                a {
                    color: "gray",
                    href: "https://news.ycombinator.com/from?site={hostname}",
                    text_decoration: "none",
                    " ({hostname})"
                }
            }
            div { display: "flex", flex_direction: "row", color: "gray",
                div { "{score}" }
                div { padding_left: "0.5rem", "by {by}" }
                div { padding_left: "0.5rem", "{time}" }
                div { padding_left: "0.5rem", "{comments}" }
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_final::App {}
}
````
# Interactivity

In this chapter, we will add a preview for articles you hover over or links you focus on.

## Creating a Preview

First, let's split our app into a Stories component on the left side of the screen, and a preview component on the right side of the screen:

````rs@hackernews_state.rs
pub fn App() -> Element {
    rsx! {
        div { display: "flex", flex_direction: "row", width: "100%",
            div { width: "50%", Stories {} }
            div { width: "50%", Preview {} }
        }
    }
}

// New
fn Stories() -> Element {
    rsx! {
        StoryListing {
            story: StoryItem {
                id: 0,
                title: "hello hackernews".to_string(),
                url: None,
                text: None,
                by: "Author".to_string(),
                score: 0,
                descendants: 0,
                time: chrono::Utc::now(),
                kids: vec![],
                r#type: "".to_string(),
            }
        }
    }
}

// New
#[derive(Clone, Debug)]
enum PreviewState {
    Unset,
    Loading,
    Loaded(StoryPageData),
}

// New
fn Preview() -> Element {
    let preview_state = PreviewState::Unset;
    match preview_state {
        PreviewState::Unset => rsx! {"Hover over a story to preview it here"},
        PreviewState::Loading => rsx! {"Loading..."},
        PreviewState::Loaded(story) => {
            rsx! {
                div { padding: "0.5rem",
                    div { font_size: "1.5rem", a { href: story.item.url, "{story.item.title}" } }
                    div { dangerous_inner_html: story.item.text }
                    for comment in &story.comments {
                        Comment { comment: comment.clone() }
                    }
                }
            }
        }
    }
}

// NEW
#[component]
fn Comment(comment: CommentData) -> Element {
    rsx! {
        div { padding: "0.5rem",
            div { color: "gray", "by {comment.by}" }
            div { dangerous_inner_html: "{comment.text}" }
            for kid in &comment.sub_comments {
                Comment { comment: kid.clone() }
            }
        }
    }
}

````

````inject-dioxus
DemoFrame {
    hackernews_state::app_v1::App {}
}
````

## Event Handlers

Next, we need to detect when the user hovers over a section or focuses a link. We can use an [event listener](../reference/event_handlers.md) to listen for the hover and focus events.

Event handlers are similar to regular attributes, but their name usually starts with `on`- and they accept closures as values. The closure will be called whenever the event it listens for is triggered. When an event is triggered, information about the event is passed to the closure through the [Event](https://docs.rs/dioxus/latest/dioxus/prelude/struct.Event.html) structure.

Let's create a [`onmouseenter`](https://docs.rs/dioxus/latest/dioxus/events/fn.onmouseenter.html) event listener in the `StoryListing` component:

````rs@hackernews_state.rs
rsx! {
    div {
        padding: "0.5rem",
        position: "relative",
        onmouseenter: move |_| {},
        div { font_size: "1.5rem",
            a { href: url, onfocus: move |_event| {}, "{title}" }
            a {
                color: "gray",
                href: "https://news.ycombinator.com/from?site={hostname}",
                text_decoration: "none",
                " ({hostname})"
            }
        }
        div { display: "flex", flex_direction: "row", color: "gray",
            div { "{score}" }
            div { padding_left: "0.5rem", "by {by}" }
            div { padding_left: "0.5rem", "{time}" }
            div { padding_left: "0.5rem", "{comments}" }
        }
    }
}
````

 > 
 > You can read more about Event Handlers in the [Event Handler reference](../reference/event_handlers.md)

## State

So far our components have had no state like normal rust functions. To make our application change when we hover over a link we need state to store the currently hovered link in the root of the application.

You can create state in dioxus using hooks. Hooks are Rust functions you call in a constant order in a component that add additional functionality to the component.

In this case, we will use the `use_context_provider` and `use_context` hooks:

* You can provide a closure to `use_context_provider` that determines the initial value of the shared state and provides the value to all child components
* You can then use the `use_context` hook to read and modify that state in the `Preview` and `StoryListing` components
* When the value updates, the `Signal` will cause the component to re-render, and provides you with the new value

 > 
 > Note: You should prefer local state hooks like use_signal or use_signal_sync when you only use state in one component. Because we use state in multiple components, we can use a [global state pattern](../reference/context.md)

````rs@hackernews_state.rs
pub fn App() -> Element {
    use_context_provider(|| Signal::new(PreviewState::Unset));
````

````rs@hackernews_state.rs
#[component]
fn StoryListing(story: ReadOnlySignal<StoryItem>) -> Element {
    let mut preview_state = consume_context::<Signal<PreviewState>>();
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        ..
    } = &*story.read();

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} point{}", if *score > 1 { "s" } else { "" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    rsx! {
        div {
            padding: "0.5rem",
            position: "relative",
            onmouseenter: move |_event| {
                *preview_state
                    .write() = PreviewState::Loaded(StoryPageData {
                    item: story(),
                    comments: vec![],
                });
            },
            div { font_size: "1.5rem",
                a {
                    href: url,
                    onfocus: move |_event| {
                        *preview_state
                            .write() = PreviewState::Loaded(StoryPageData {
                            item: story(),
                            comments: vec![],
                        });
                    },
````

````rs@hackernews_state.rs
fn Preview() -> Element {
    // New
    let preview_state = consume_context::<Signal<PreviewState>>();

    // New
    match preview_state() {
````

````inject-dioxus
DemoFrame {
    hackernews_state::App {}
}
````

 > 
 > You can read more about Hooks in the [Hooks reference](../reference/hooks.md)

### The Rules of Hooks

Hooks are a powerful way to manage state in Dioxus, but there are some rules you need to follow to insure they work as expected. Dioxus uses the order you call hooks to differentiate between hooks. Because the order you call hooks matters, you must follow these rules:

1. Hooks may be only used in components or other hooks (we'll get to that later)
1. On every call to the component function
   1. The same hooks must be called
   1. In the same order
1. Hooks name's should start with `use_` so you don't accidentally confuse them with regular functions

These rules mean that there are certain things you can't do with hooks:

#### No Hooks in Conditionals

````rs@hooks_bad.rs
// âŒ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy && you_know_it {
    let something = use_signal(|| "hands");
    println!("clap your {something}")
}

// âœ… instead, *always* call use_signal
// You can put other stuff in the conditional though
let something = use_signal(|| "hands");
if you_are_happy && you_know_it {
    println!("clap your {something}")
}
````

#### No Hooks in Closures

````rs@hooks_bad.rs
// âŒ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
    let b = use_signal(|| 0);
    b()
};

// âœ… instead, move hook `b` outside
let b = use_signal(|| 0);
let _a = || b();
````

#### No Hooks in Loops

````rs@hooks_bad.rs
// `names` is a Vec<&str>

// âŒ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &names {
    let is_selected = use_signal(|| false);
    println!("selected: {is_selected}");
}

// âœ… Instead, use a hashmap with use_signal
let selection_map = use_signal(HashMap::<&str, bool>::new);

for name in &names {
    let is_selected = selection_map.read()[name];
    println!("selected: {is_selected}");
}
````
# Fetching Data

In this chapter, we will fetch data from the hacker news API and use it to render the list of top posts in our application.

## Defining the API

First we need to create some utilities to fetch data from the hackernews API using [reqwest](https://docs.rs/reqwest/latest/reqwest/index.html):

````rs@hackernews_async.rs
// Define the Hackernews API
use futures::future::join_all;

pub static BASE_API_URL: &str = "https://hacker-news.firebaseio.com/v0/";
pub static ITEM_API: &str = "item/";
pub static USER_API: &str = "user/";
const COMMENT_DEPTH: i64 = 2;

pub async fn get_story_preview(id: i64) -> Result<StoryItem, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    reqwest::get(&url).await?.json().await
}

pub async fn get_stories(count: usize) -> Result<Vec<StoryItem>, reqwest::Error> {
    let url = format!("{}topstories.json", BASE_API_URL);
    let stories_ids = &reqwest::get(&url).await?.json::<Vec<i64>>().await?[..count];

    let story_futures = stories_ids[..usize::min(stories_ids.len(), count)]
        .iter()
        .map(|&story_id| get_story_preview(story_id));
    let stories = join_all(story_futures)
        .await
        .into_iter()
        .filter_map(|story| story.ok())
        .collect();
    Ok(stories)
}

pub async fn get_story(id: i64) -> Result<StoryPageData, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut story = reqwest::get(&url).await?.json::<StoryPageData>().await?;
    let comment_futures = story.item.kids.iter().map(|&id| get_comment(id));
    let comments = join_all(comment_futures)
        .await
        .into_iter()
        .filter_map(|c| c.ok())
        .collect();

    story.comments = comments;
    Ok(story)
}

#[async_recursion::async_recursion(?Send)]
pub async fn get_comment_with_depth(id: i64, depth: i64) -> Result<CommentData, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut comment = reqwest::get(&url).await?.json::<CommentData>().await?;
    if depth > 0 {
        let sub_comments_futures = comment
            .kids
            .iter()
            .map(|story_id| get_comment_with_depth(*story_id, depth - 1));
        comment.sub_comments = join_all(sub_comments_futures)
            .await
            .into_iter()
            .filter_map(|c| c.ok())
            .collect();
    }
    Ok(comment)
}

pub async fn get_comment(comment_id: i64) -> Result<CommentData, reqwest::Error> {
    let comment = get_comment_with_depth(comment_id, COMMENT_DEPTH).await?;
    Ok(comment)
}
````

The code above requires you to add the [reqwest](https://crates.io/crates/reqwest), [async_recursion](https://crates.io/crates/async-recursion), and [futures](https://crates.io/crates/futures) crate:

````bash
cargo add reqwest --features json
cargo add async_recursion
cargo add futures
````

A quick overview of the supporting crates:

* [reqwest](https://crates.io/crates/reqwest) allows us to create HTTP calls to the hackernews API.
* [async_recursion](https://crates.io/crates/async-recursion) provides a utility macro to allow us to recursively use an async function.
* [futures](https://crates.io/crates/futures) provides us with utilities all around Rust's futures.

## Working with Async

[`use_resource`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_resource.html) is a [hook](./state.md) that lets you run an async closure, and provides you with its result.

For example, we can make an API request (using [reqwest](https://docs.rs/reqwest/latest/reqwest/index.html)) inside `use_resource`:

````rs@hackernews_async.rs
fn Stories() -> Element {
    // Fetch the top 10 stories on Hackernews
    let stories = use_resource(move || get_stories(10));

    // check if the future is resolved
    match &*stories.read_unchecked() {
        Some(Ok(list)) => {
            // if it is, render the stories
            rsx! {
                div {
                    // iterate over the stories with a for loop
                    for story in list {
                        // render every story with the StoryListing component
                        StoryListing { story: story.clone() }
                    }
                }
            }
        }
        Some(Err(err)) => {
            // if there was an error, render the error
            rsx! {"An error occurred while fetching stories {err}"}
        }
        None => {
            // if the future is not resolved yet, render a loading message
            rsx! {"Loading items"}
        }
    }
}
````

The code inside `use_resource` will be submitted to the Dioxus scheduler once the component has rendered.

We can use `.read()` to get the result of the future. On the first run, since there's no data ready when the component loads, its value will be `None`.  However, once the future is finished, the component will be re-rendered and the value will now be `Some(...)`, containing the return value of the closure.

We can then render the result by looping over each of the posts and rendering them with the `StoryListing` component.

````inject-dioxus
DemoFrame {
	hackernews_async::fetch::App {}
}
````

 > 
 > You can read more about working with Async in Dioxus in the [Async reference](../reference/index.md)

## Lazily Fetching Data

Finally, we will lazily fetch the comments on each post as the user hovers over the post.

We need to revisit the code that handles hovering over an item. Instead of passing an empty list of comments, we can fetch all the related comments when the user hovers over the item.

We will cache the list of comments with a [use_signal](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_signal.html) hook. This hook allows you to store some state in a single component. When the user triggers fetching the comments we will check if the response has already been cached before fetching the data from the hackernews API.

````rs@hackernews_async.rs
// New
async fn resolve_story(
    mut full_story: Signal<Option<StoryPageData>>,
    mut preview_state: Signal<PreviewState>,
    story_id: i64,
) {
    if let Some(cached) = full_story.as_ref() {
        *preview_state.write() = PreviewState::Loaded(cached.clone());
        return;
    }

    *preview_state.write() = PreviewState::Loading;
    if let Ok(story) = get_story(story_id).await {
        *preview_state.write() = PreviewState::Loaded(story.clone());
        *full_story.write() = Some(story);
    }
}

#[component]
fn StoryListing(story: ReadOnlySignal<StoryItem>) -> Element {
    let mut preview_state = consume_context::<Signal<PreviewState>>();
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        id,
        ..
    } = story();
    // New
    let full_story = use_signal(|| None);

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} {}", if score == 1 { " point" } else { " points" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    rsx! {
        div {
            padding: "0.5rem",
            position: "relative",
            onmouseenter: move |_event| { resolve_story(full_story, preview_state, id) },
            div { font_size: "1.5rem",
                a {
                    href: url,
                    onfocus: move |_event| { resolve_story(full_story, preview_state, id) },
                    // ...

````

````inject-dioxus
DemoFrame {
	hackernews_async::App {}
}
````
# Conclusion

Well done! You've completed the Dioxus guide and built a hackernews application in Dioxus.

To continue your journey, you can attempt a challenge listed below, or look at the [Dioxus reference](../reference/index.md).

## Challenges

* Organize your components into separate files for better maintainability.
* Give your app some style if you haven't already.
* Integrate your application with the [Dioxus router](../router/index.md).

## The full code for the hacker news project

````rs@hackernews_complete.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

fn main() {
    launch(App);
}

pub fn App() -> Element {
    use_context_provider(|| Signal::new(PreviewState::Unset));

    rsx! {
        div { display: "flex", flex_direction: "row", width: "100%",
            div { width: "50%", Stories {} }
            div { width: "50%", Preview {} }
        }
    }
}

fn Stories() -> Element {
    let stories = use_resource(move || get_stories(10));

    match &*stories.read_unchecked() {
        Some(Ok(list)) => rsx! {
            div {
                for story in list {
                    StoryListing { story: story.clone() }
                }
            }
        },
        Some(Err(err)) => rsx! {"An error occurred while fetching stories {err}"},
        None => rsx! {"Loading items"},
    }
}

async fn resolve_story(
    mut full_story: Signal<Option<StoryPageData>>,
    mut preview_state: Signal<PreviewState>,
    story_id: i64,
) {
    if let Some(cached) = full_story.as_ref() {
        *preview_state.write() = PreviewState::Loaded(cached.clone());
        return;
    }

    *preview_state.write() = PreviewState::Loading;
    if let Ok(story) = get_story(story_id).await {
        *preview_state.write() = PreviewState::Loaded(story.clone());
        *full_story.write() = Some(story);
    }
}

#[component]
fn StoryListing(story: ReadOnlySignal<StoryItem>) -> Element {
    let preview_state = consume_context::<Signal<PreviewState>>();
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        id,
        ..
    } = story();
    let full_story = use_signal(|| None);

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} {}", if score == 1 { " point" } else { " points" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    rsx! {
        div {
            padding: "0.5rem",
            position: "relative",
            onmouseenter: move |_event| { resolve_story(full_story, preview_state, id) },
            div { font_size: "1.5rem",
                a {
                    href: url,
                    onfocus: move |_event| { resolve_story(full_story, preview_state, id) },
                    "{title}"
                }
                a {
                    color: "gray",
                    href: "https://news.ycombinator.com/from?site={hostname}",
                    text_decoration: "none",
                    " ({hostname})"
                }
            }
            div { display: "flex", flex_direction: "row", color: "gray",
                div { "{score}" }
                div { padding_left: "0.5rem", "by {by}" }
                div { padding_left: "0.5rem", "{time}" }
                div { padding_left: "0.5rem", "{comments}" }
            }
        }
    }
}

#[derive(Clone, Debug)]
enum PreviewState {
    Unset,
    Loading,
    Loaded(StoryPageData),
}

fn Preview() -> Element {
    let preview_state = consume_context::<Signal<PreviewState>>();

    match preview_state() {
        PreviewState::Unset => rsx! {"Hover over a story to preview it here"},
        PreviewState::Loading => rsx! {"Loading..."},
        PreviewState::Loaded(story) => {
            rsx! {
                div { padding: "0.5rem",
                    div { font_size: "1.5rem", a { href: story.item.url, "{story.item.title}" } }
                    div { dangerous_inner_html: story.item.text }
                    for comment in &story.comments {
                        Comment { comment: comment.clone() }
                    }
                }
            }
        }
    }
}

#[component]
fn Comment(comment: CommentData) -> Element {
    rsx! {
        div { padding: "0.5rem",
            div { color: "gray", "by {comment.by}" }
            div { dangerous_inner_html: "{comment.text}" }
            for kid in &comment.sub_comments {
                Comment { comment: kid.clone() }
            }
        }
    }
}

// Define the Hackernews API and types
use chrono::{DateTime, Utc};
use futures::future::join_all;
use serde::{Deserialize, Serialize};

pub static BASE_API_URL: &str = "https://hacker-news.firebaseio.com/v0/";
pub static ITEM_API: &str = "item/";
pub static USER_API: &str = "user/";
const COMMENT_DEPTH: i64 = 2;

pub async fn get_story_preview(id: i64) -> Result<StoryItem, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    reqwest::get(&url).await?.json().await
}

pub async fn get_stories(count: usize) -> Result<Vec<StoryItem>, reqwest::Error> {
    let url = format!("{}topstories.json", BASE_API_URL);
    let stories_ids = &reqwest::get(&url).await?.json::<Vec<i64>>().await?[..count];

    let story_futures = stories_ids[..usize::min(stories_ids.len(), count)]
        .iter()
        .map(|&story_id| get_story_preview(story_id));
    Ok(join_all(story_futures)
        .await
        .into_iter()
        .filter_map(|story| story.ok())
        .collect())
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryPageData {
    #[serde(flatten)]
    pub item: StoryItem,
    #[serde(default)]
    pub comments: Vec<CommentData>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CommentData {
    pub id: i64,
    /// there will be no by field if the comment was deleted
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub text: String,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    #[serde(default)]
    pub sub_comments: Vec<CommentData>,
    pub r#type: String,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryItem {
    pub id: i64,
    pub title: String,
    pub url: Option<String>,
    pub text: Option<String>,
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub score: i64,
    #[serde(default)]
    pub descendants: i64,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    pub r#type: String,
}

pub async fn get_story(id: i64) -> Result<StoryPageData, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut story = reqwest::get(&url).await?.json::<StoryPageData>().await?;
    let comment_futures = story.item.kids.iter().map(|&id| get_comment(id));
    let comments = join_all(comment_futures)
        .await
        .into_iter()
        .filter_map(|c| c.ok())
        .collect();

    story.comments = comments;
    Ok(story)
}

#[async_recursion::async_recursion(?Send)]
pub async fn get_comment_with_depth(id: i64, depth: i64) -> Result<CommentData, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut comment = reqwest::get(&url).await?.json::<CommentData>().await?;
    if depth > 0 {
        let sub_comments_futures = comment
            .kids
            .iter()
            .map(|story_id| get_comment_with_depth(*story_id, depth - 1));
        comment.sub_comments = join_all(sub_comments_futures)
            .await
            .into_iter()
            .filter_map(|c| c.ok())
            .collect();
    }
    Ok(comment)
}

pub async fn get_comment(comment_id: i64) -> Result<CommentData, reqwest::Error> {
    get_comment_with_depth(comment_id, COMMENT_DEPTH).await
}

````
# Dioxus Reference

This Reference contains more detailed explanations for all concepts covered in the [guide](../guide/index.md) and more.

## Rendering

* [`RSX`](rsx.md) Rsx is a HTML-like macro that allows you to declare UI
* [`Components`](components.md) Components are the building blocks of UI in Dioxus
* [`Props`](component_props.md) Props allow you pass information to Components
* [`Event Listeners`](event_handlers.md) Event listeners let you respond to user input
* [`User Input`](user_input.md) How to handle User input in Dioxus
* [`Dynamic Rendering`](dynamic_rendering.md) How to dynamically render data in Dioxus

## State

* [`Hooks`](hooks.md) Hooks allow you to create components state
* [`Context`](context.md) Context allows you to create state in a parent and consume it in children
* [`Routing`](router.md) The router helps you manage the URL state
* [`Resource`](use_resource.md) Use future allows you to create an async task and monitor it's state
* [`UseCoroutine`](use_coroutine.md) Use coroutine helps you manage external state
* [`Spawn`](spawn.md) Spawn creates an async task

## Platforms

* [`Choosing a Web Renderer`](choosing_a_web_renderer.md) Overview of the different web renderers
* [`Desktop`](desktop/index.md) Overview of desktop specific APIS
* [`Web`](web/index.md) Overview of web specific APIS
* [`Fullstack`](fullstack/index.md) Overview of Fullstack specific APIS
  * [`Server Functions`](fullstack/server_functions.md) Server functions make it easy to communicate between your server and client
  * [`Extractors`](fullstack/extractors.md) Extractors allow you to get extra information out of the headers of a request
  * [`Middleware`](fullstack/middleware.md) Middleware allows you to wrap a server function request or response
  * [`Authentication`](fullstack/authentication.md) An overview of how to handle authentication with server functions
  * [`Routing`](fullstack/routing.md) An overview of how to work with the router in the fullstack renderer
* [`SSR`](ssr.md) Overview of the SSR renderer
* [`Liveview`](liveview.md) Overview of liveview specific APIS
# Describing the UI

Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* what we want the UI to look like using RSX.

You have already seen a simple example of RSX syntax in the "hello world" application:

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App() -> Element {
    rsx! {
        div { "Hello, world!" }
    }
}
````

Here, we use the `rsx!` macro to *declare* that we want a `div` element, containing the text `"Hello, world!"`. Dioxus takes the RSX and constructs a UI from it.

## RSX Features

RSX is very similar to HTML in that it describes elements with attributes and children. Here's an empty `button` element in RSX, as well as the resulting HTML:

````rs@rsx_overview.rs
rsx! {
    button {
        // attributes / listeners
        // children
        "Hello, World!"
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Button {}
}
````

### Attributes

Attributes (and [event handlers](event_handlers.md)) modify the behavior or appearance of the element they are attached to. They are specified inside the `{}` brackets, using the `name: value` syntax. You can provide the value as a literal in the RSX:

````rs@rsx_overview.rs
rsx! {
    img {
        src: "https://avatars.githubusercontent.com/u/79236386?s=200&v=4",
        class: "primary_button",
        width: "10px",
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Attributes {}
}
````

Some attributes, such as the `type` attribute for `input` elements won't work on their own in Rust. This is because `type` is a reserved Rust keyword. To get around this, Dioxus uses the `r#` specifier:

````rs@rsx_overview.rs
rsx! {
    input { r#type: "text", color: "red" }
}
````

 > 
 > Note: All attributes defined in `dioxus-html` follow the snake_case naming convention. They transform their `snake_case` names to HTML's `camelCase` attributes.

 > 
 > Note: Styles can be used directly outside of the `style:` attribute. In the above example, `color: "red"` is turned into `style="color: red"`.

#### Conditional Attributes

You can also conditionally include attributes by using an if statement without an else branch. This is useful for adding an attribute only if a certain condition is met:

````rs@rsx_overview.rs
let large_font = true;
rsx! {
    div { class: if large_font { "text-xl" }, "Hello, World!" }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::ConditionalAttributes {}
}
````

Repeating an attribute joins the values with a space. This makes it easy to add values like classes conditionally:

````rs@rsx_overview.rs
let large_font = true;
rsx! {
    div {
        class: "base-class another-class",
        class: if large_font { "text-xl" },
        "Hello, World!"
    }
}
````

#### Custom Attributes

Dioxus has a pre-configured set of attributes that you can use. RSX is validated at compile time to make sure you didn't specify an invalid attribute. If you want to override this behavior with a custom attribute name, specify the attribute in quotes:

````rs@rsx_overview.rs
rsx! {
    div { "style": "width: 20px; height: 20px; background-color: red;" }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::CustomAttributes {}
}
````

### Special Attributes

While most attributes are simply passed on to the HTML, some have special behaviors.

#### The HTML Escape Hatch

If you're working with pre-rendered assets, output from templates, or output from a JS library, then you might want to pass HTML directly instead of going through Dioxus. In these instances, reach for `dangerous_inner_html`.

For example, shipping a markdown-to-Dioxus converter might significantly bloat your final application size. Instead, you'll want to pre-render your markdown to HTML and then include the HTML directly in your output. We use this approach for the [Dioxus homepage](https://dioxuslabs.com):

````rs@dangerous_inner_html.rs
// this should come from a trusted source
let contents = "live <b>dangerously</b>";

rsx! {
    div { dangerous_inner_html: "{contents}" }
}
````

````inject-dioxus
DemoFrame {
	dangerous_inner_html::App {}
}
````

 > 
 > Note! This attribute is called "dangerous_inner_html" because it is **dangerous** to pass it data you don't trust. If you're not careful, you can easily expose [cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks to your users.
 > 
 > If you're handling untrusted input, make sure to sanitize your HTML before passing it into `dangerous_inner_html` â€“ or just pass it to a Text Element to escape any HTML tags.

#### Boolean Attributes

Most attributes, when rendered, will be rendered exactly as the input you provided. However, some attributes are considered "boolean" attributes and just their presence determines whether they affect the output. For these attributes, a provided value of `"false"` will cause them to be removed from the target element.

So this RSX wouldn't actually render the `hidden` attribute:

````rs@boolean_attribute.rs
rsx! {
    div { hidden: false, "hello" }
}
````

````inject-dioxus
DemoFrame {
	boolean_attribute::App {}
}
````

Not all attributes work like this however. *Only the following attributes* have this behavior:

* `allowfullscreen`
* `allowpaymentrequest`
* `async`
* `autofocus`
* `autoplay`
* `checked`
* `controls`
* `default`
* `defer`
* `disabled`
* `formnovalidate`
* `hidden`
* `ismap`
* `itemscope`
* `loop`
* `multiple`
* `muted`
* `nomodule`
* `novalidate`
* `open`
* `playsinline`
* `readonly`
* `required`
* `reversed`
* `selected`
* `truespeed`

For any other attributes, a value of `"false"` will be sent directly to the DOM.

### Interpolation

Similarly to how you can [format](https://doc.rust-lang.org/rust-by-example/hello/print/fmt.html) Rust strings, you can also interpolate in RSX text. Use `{variable}` to Display the value of a variable in a string, or `{variable:?}` to use the Debug representation:

````rs@rsx_overview.rs
let coordinates = (42, 0);
let country = "es";
rsx! {
    div {
        class: "country-{country}",
        left: "{coordinates.0:?}",
        top: "{coordinates.1:?}",
        // arbitrary expressions are allowed,
        // as long as they don't contain `{}`
        div { "{country.to_uppercase()}" }
        div { "{7*6}" }
        // {} can be escaped with {{}}
        div { "{{}}" }
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Formatting {}
}
````

### Children

To add children to an element, put them inside the `{}` brackets after all attributes and listeners in the element. They can be other elements, text, or [components](components.md). For example, you could have an `ol` (ordered list) element, containing 3 `li` (list item) elements, each of which contains some text:

````rs@rsx_overview.rs
rsx! {
    ol {
        li { "First Item" }
        li { "Second Item" }
        li { "Third Item" }
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Children {}
}
````

### Fragments

You can render multiple elements at the top level of `rsx!` and they will be automatically grouped.

````rs@rsx_overview.rs
rsx! {
    p { "First Item" }
    p { "Second Item" }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::ManyRoots {}
}
````

### Expressions

You can include arbitrary Rust expressions as children within RSX by surrounding your expression with `{}`s. Any expression that implements [IntoDynNode](https://docs.rs/dioxus-core/0.3/dioxus_core/trait.IntoDynNode.html) can be used within rsx. This is useful for displaying data from an [iterator](https://doc.rust-lang.org/stable/book/ch13-02-iterators.html#processing-a-series-of-items-with-iterators):

````rs@rsx_overview.rs
let text = "Dioxus";
rsx! {
    span {
        {text.to_uppercase()}
        // create a list of text from 0 to 9
        {(0..10).map(|i| rsx! {
        "{i}"
        })}
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Expression {}
}
````

### Loops

In addition to iterators you can also use for loops directly within RSX:

````rs@rsx_overview.rs
rsx! {
    // use a for loop where the body itself is RSX
    div {
        // create a list of text from 0 to 9
        for i in 0..3 {
            // NOTE: the body of the loop is RSX not a rust statement
            div { "{i}" }
        }
    }
    // iterator equivalent
    div {
        {(0..3).map(|i| rsx! {
            div { "{i}" }
        })}
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::Loops {}
}
````

### If statements

You can also use if statements without an else branch within RSX:

````rs@rsx_overview.rs
rsx! {
    // use if statements without an else
    if true {
        div { "true" }
    }
}
````

````inject-dioxus
DemoFrame {
	rsx_overview::IfStatements {}
}
````
# Components

Just like you wouldn't want to write a complex program in a single, long, `main` function, you shouldn't build a complex UI in a single `App` function. Instead, you should break down the functionality of an app in logical parts called components.

A component is a Rust function, named in UpperCamelCase, that either takes no parameters or a properties struct and returns an `Element` describing the UI it wants to render.

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App() -> Element {
    rsx! {
        div { "Hello, world!" }
    }
}
````

 > 
 > You'll probably want to add `#![allow(non_snake_case)]` to the top of your crate to avoid warnings about UpperCamelCase component names

A Component is responsible for some rendering task â€“ typically, rendering an isolated part of the user interface. For example, you could have an `About` component that renders a short description of Dioxus Labs:

````rs@components.rs
pub fn About() -> Element {
    rsx! {
        p {
            b { "Dioxus Labs" }
            " An Open Source project dedicated to making Rust UI wonderful."
        }
    }
}
````

````inject-dioxus
DemoFrame {
	components::About {}
}
````

Then, you can render your component in another component, similarly to how elements are rendered:

````rs@components.rs
pub fn App() -> Element {
    rsx! {
        About {}
        About {}
    }
}
````

````inject-dioxus
DemoFrame {
	components::App {}
}
````

 > 
 > At this point, it might seem like components are nothing more than functions. However, as you learn more about the features of Dioxus, you'll see that they are actually more powerful!
# Component Props

Just like you can pass arguments to a function or attributes to an element, you can pass props to a component that customize its behavior! The components we've seen so far didn't accept any props â€“ so let's write some components that do.

## derive(Props)

Component props are a single struct annotated with `#[derive(PartialEq, Clone, Props)]`. For a component to accept props, the type of its argument must be `YourPropsStruct`.

Example:

````rs@component_owned_props.rs
#[derive(PartialEq, Props, Clone)]
struct LikesProps {
    score: i32,
}

fn Likes(props: LikesProps) -> Element {
    rsx! {
        div {
            "This post has "
            b { "{props.score}" }
            " likes"
        }
    }
}
````

You can then pass prop values to the component the same way you would pass attributes to an element:

````rs@component_owned_props.rs
pub fn App() -> Element {
    rsx! { Likes { score: 42 } }
}
````

````inject-dioxus
DemoFrame {
    component_owned_props::App {}
}
````

## Prop Options

The `#[derive(Props)]` macro has some features that let you customize the behavior of props.

### Optional Props

You can create optional fields by using the `Option<â€¦>` type for a field:

````rs@component_props_options.rs
#[derive(PartialEq, Clone, Props)]
struct OptionalProps {
    title: String,
    subtitle: Option<String>,
}

fn Title(props: OptionalProps) -> Element {
    rsx! {
        h1 { "{props.title}: ", {props.subtitle.unwrap_or_else(|| "No subtitle provided".to_string())} }
    }
}
````

Then, you can choose to either provide them or not:

````rs@component_props_options.rs
Title { title: "Some Title" }
Title { title: "Some Title", subtitle: "Some Subtitle" }
// Providing an Option explicitly won't compile though:
// Title {
//     title: "Some Title",
//     subtitle: None,
// },
````

### Explicitly Required Option

If you want to explicitly require an `Option`, and not an optional prop, you can annotate it with `#[props(!optional)]`:

````rs@component_props_options.rs
#[derive(PartialEq, Clone, Props)]
struct ExplicitOptionProps {
    title: String,
    #[props(!optional)]
    subtitle: Option<String>,
}

fn ExplicitOption(props: ExplicitOptionProps) -> Element {
    rsx! {
        h1 { "{props.title}: ", {props.subtitle.unwrap_or_else(|| "No subtitle provided".to_string())} }
    }
}
````

Then, you have to explicitly pass either `Some("str")` or `None`:

````rs@component_props_options.rs
ExplicitOption { title: "Some Title", subtitle: None }
ExplicitOption { title: "Some Title", subtitle: Some("Some Title".to_string()) }
// This won't compile:
// ExplicitOption {
//     title: "Some Title",
// },
````

### Default Props

You can use `#[props(default = 42)]` to make a field optional and specify its default value:

````rs@component_props_options.rs
#[derive(PartialEq, Props, Clone)]
struct DefaultProps {
    // default to 42 when not provided
    #[props(default = 42)]
    number: i64,
}

fn DefaultComponent(props: DefaultProps) -> Element {
    rsx! { h1 { "{props.number}" } }
}
````

Then, similarly to optional props, you don't have to provide it:

````rs@component_props_options.rs
DefaultComponent { number: 5 }
DefaultComponent {}
````

### Automatic Conversion with into

It is common for Rust functions to accept `impl Into<SomeType>` rather than just `SomeType` to support a wider range of parameters. If you want similar functionality with props, you can use `#[props(into)]`. For example, you could add it on a `String` prop â€“ and `&str` will also be automatically accepted, as it can be converted into `String`:

````rs@component_props_options.rs
#[derive(PartialEq, Props, Clone)]
struct IntoProps {
    #[props(into)]
    string: String,
}

fn IntoComponent(props: IntoProps) -> Element {
    rsx! { h1 { "{props.string}" } }
}
````

Then, you can use it so:

````rs@component_props_options.rs
IntoComponent { string: "some &str" }
````

## The component macro

So far, every Component function we've seen had a corresponding ComponentProps struct to pass in props. This was quite verbose... Wouldn't it be nice to have props as simple function arguments? Then we wouldn't need to define a Props struct, and instead of typing `props.whatever`, we could just use `whatever` directly!

`component` allows you to do just that. Instead of typing the "full" version:

````rust, no_run
#[derive(Props, Clone, PartialEq)]
struct TitleCardProps {
    title: String,
}

fn TitleCard(props: TitleCardProps) -> Element {
    rsx!{
        h1 { "{props.title}" }
    }
}
````

...you can define a function that accepts props as arguments. Then, just annotate it with `#[component]`, and the macro will turn it into a regular Component for you:

````rust, no_run
#[component]
fn TitleCard(title: String) -> Element {
    rsx!{
        h1 { "{title}" }
    }
}
````

 > 
 > While the new Component is shorter and easier to read, this macro should not be used by library authors since you have less control over Prop documentation.

## Component Children

In some cases, you may wish to create a component that acts as a container for some other content, without the component needing to know what that content is. To achieve this, create a prop of type `Element`:

````rs@component_element_props.rs
#[derive(PartialEq, Clone, Props)]
struct ClickableProps {
    href: String,
    body: Element,
}

fn Clickable(props: ClickableProps) -> Element {
    rsx! {
        a { href: "{props.href}", class: "fancy-button", {props.body} }
    }
}
````

Then, when rendering the component, you can pass in the output of `rsx!{...}`:

````rs@component_element_props.rs
rsx! {
    Clickable {
        href: "https://www.youtube.com/watch?v=C-M2hs3sXGo",
        body: rsx! {
            "How to " i { "not" } " be seen"
        }
    }
}
````

 > 
 > Warning: While it may compile, do not include the same `Element` more than once in the RSX. The resulting behavior is unspecified.

### The children field

Rather than passing the RSX through a regular prop, you may wish to accept children similarly to how elements can have children. The "magic" `children` prop lets you achieve this:

````rs@component_children.rs
#[derive(PartialEq, Clone, Props)]
struct ClickableProps {
    href: String,
    children: Element,
}

fn Clickable(props: ClickableProps) -> Element {
    rsx! {
        a { href: "{props.href}", class: "fancy-button", {props.children} }
    }
}
````

This makes using the component much simpler: simply put the RSX inside the `{}` brackets â€“ and there is no need for a `render` call or another macro!

````rs@component_children.rs
rsx! {
    Clickable { href: "https://www.youtube.com/watch?v=C-M2hs3sXGo",
        "How to "
        i { "not" }
        " be seen"
    }
}
````

````inject-dioxus
DemoFrame {
    component_children::App {}
}
````
# Event Handlers

Event handlers are used to respond to user actions. For example, an event handler could be triggered when the user clicks, scrolls, moves the mouse, or types a character.

Event handlers are attached to elements. For example, we usually don't care about all the clicks that happen within an app, only those on a particular button.

Event handlers are similar to regular attributes, but their name usually starts with `on`- and they accept closures as values. The closure will be called whenever the event it listens for is triggered and will be passed that event.

For example, to handle clicks on an element, we can specify an `onclick` handler:

````rs@event_click.rs
rsx! {
    button { width: "100%", height: "100%",
        // This event handler will be called when the button is clicked
        onclick: move |event| log!("Clicked! Event: {event:#?}"),
        "click me!"
    }
}
````

````inject-dioxus
DemoFrame {
    event_click::App {}
}
````

## The Event object

Event handlers receive an [`Event`](https://docs.rs/dioxus-core/latest/dioxus_core/struct.Event.html) object containing information about the event. Different types of events contain different types of data. For example, mouse-related events contain [`MouseData`](https://docs.rs/dioxus/latest/dioxus/events/struct.MouseData.html), which tells you things like where the mouse was clicked and what mouse buttons were used.

In the example above, this event data was logged to the terminal:

````
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
````

To learn what the different event types for HTML provide, read the [events module docs](https://docs.rs/dioxus-html/latest/dioxus_html/events/index.html).

### Event propagation

Some events will trigger first on the element the event originated at upward. For example, a click event on a `button` inside a `div` would first trigger the button's event listener and then the div's event listener.

 > 
 > For more information about event propagation see [the mdn docs on event bubbling](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling)

If you want to prevent this behavior, you can call `stop_propagation()` on the event:

````rs@event_nested.rs
rsx! {
    div { onclick: move |_event| {},
        "outer"
        button {
            onclick: move |event| {
                event.stop_propagation();
            },
            "inner"
        }
    }
}
````

## Prevent Default

Some events have a default behavior. For keyboard events, this might be entering the typed character. For mouse events, this might be selecting some text.

In some instances, might want to avoid this default behavior. For this, you can add the `prevent_default` attribute with the name of the handler whose default behavior you want to stop. This attribute can be used for multiple handlers using their name separated by spaces:

````rs@event_prevent_default.rs
rsx! {
    a {
        href: "https://example.com",
        prevent_default: "onclick",
        "example.com"
    }
}
````

````inject-dioxus
DemoFrame {
    event_prevent_default::App {}
}
````

Any event handlers will still be called.

 > 
 > Normally, in React or JavaScript, you'd call "preventDefault" on the event in the callback. Dioxus does *not* currently support this behavior. Note: this means you cannot conditionally prevent default behavior based on the data in the event.

## Handler Props

Sometimes, you might want to make a component that accepts an event handler. A simple example would be a `FancyButton` component, which accepts an `onclick` handler:

````rs@event_handler_prop.rs
#[derive(PartialEq, Clone, Props)]
pub struct FancyButtonProps {
    onclick: EventHandler<MouseEvent>,
}

pub fn FancyButton(props: FancyButtonProps) -> Element {
    rsx! {
        button {
            class: "fancy-button",
            onclick: move |evt| props.onclick.call(evt),
            "click me pls."
        }
    }
}
````

Then, you can use it like any other handler:

````rs@event_handler_prop.rs
rsx! {
    FancyButton {
        onclick: move |event| println!("Clicked! {event:?}"),
    }
}
````

 > 
 > Note: just like any other attribute, you can name the handlers anything you want! Any closure you pass in will automatically be turned into an `EventHandler`.

#### Async Event Handlers

Passing `EventHandler`s as props does not support passing a closure that returns an async block. Instead, you must manually call `spawn` to do async operations:

````rs@event_handler_prop.rs
rsx! {
    FancyButton {
        // This does not work!
        // onclick: move |event| async move {
        //      println!("Clicked! {event:?}");
        // },

        // This does work!
        onclick: move |event| {
            spawn(async move {
                println!("Clicked! {event:?}");
            });
        },
    }
}
````

This is only the case for custom event handlers as props.

## Custom Data

Event Handlers are generic over any type, so you can pass in any data you want to them, e.g:

````rs@event_handler_prop.rs
struct ComplexData(i32);

#[derive(PartialEq, Clone, Props)]
pub struct CustomFancyButtonProps {
    onclick: EventHandler<ComplexData>,
}

pub fn CustomFancyButton(props: CustomFancyButtonProps) -> Element {
    rsx! {
        button {
            class: "fancy-button",
            onclick: move |_| props.onclick.call(ComplexData(0)),
            "click me pls."
        }
    }
}
````
# Hooks and component state

So far, our components have had no state like a normal Rust function. However, in a UI component, it is often useful to have stateful functionality to build user interactions. For example, you might want to track whether the user has opened a drop-down and render different things accordingly.

Hooks allow us to create state in our components. Hooks are Rust functions you call in a constant order in a component that add additional functionality to the component.

Dioxus provides many built-in hooks, but if those hooks don't fit your specific use case, you also can [create your own hook](../cookbook/state/custom_hooks/index.md)

## use_signal hook

[`use_signal`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_signal.html) is one of the simplest hooks.

* You provide a closure that determines the initial value: `let mut count = use_signal(|| 0);`
* `use_signal` gives you the current value, and a way to write to the value
* When the value updates, `use_signal` makes the component re-render (along with any other component that references it), and then provides you with the new value.

For example, you might have seen the counter example, in which state (a number) is tracked using the `use_signal` hook:

````rs@hooks_counter.rs
pub fn App() -> Element {
    // count will be initialized to 0 the first time the component is rendered
    let mut count = use_signal(|| 0);

    rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    }
}
````

````inject-dioxus
DemoFrame {
   hooks_counter::App {}
}
````

Every time the component's state changes, it re-renders, and the component function is called, so you can describe what you want the new UI to look like. You don't have to worry about "changing" anything â€“ describe what you want in terms of the state, and Dioxus will take care of the rest!

 > 
 > `use_signal` returns your value wrapped in a smart pointer of type [`Signal`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.Signal.html) that is `Copy`. This is why you can both read the value and update it, even within an event handler.

You can use multiple hooks in the same component if you want:

````rs@hooks_counter_two_state.rs
pub fn App() -> Element {
    let mut count_a = use_signal(|| 0);
    let mut count_b = use_signal(|| 0);

    rsx! {
        h1 { "Counter_a: {count_a}" }
        button { onclick: move |_| count_a += 1, "a++" }
        button { onclick: move |_| count_a -= 1, "a--" }
        h1 { "Counter_b: {count_b}" }
        button { onclick: move |_| count_b += 1, "b++" }
        button { onclick: move |_| count_b -= 1, "b--" }
    }
}
````

````inject-dioxus
DemoFrame {
  hooks_counter_two_state::App {}
}
````

You can also use `use_signal` to store more complex state, like a Vec. You can read and write to the state with the `read` and `write` methods:

````rs@hooks_use_signal.rs
pub fn App() -> Element {
    let mut list = use_signal(Vec::new);

    rsx! {
        p { "Current list: {list:?}" }
        button {
            onclick: move |event| {
                let list_len = list.len();
                list.push(list_len);
                list.push(list_len);
            },
            "Add two elements!"
        }
    }
}
````

````inject-dioxus
DemoFrame {
  hooks_use_signal::App {}
}
````

## Rules of hooks

The above example might seem a bit magic since Rust functions are typically not associated with state. Dioxus allows hooks to maintain state across renders through a hidden scope that is associated with the component.

But how can Dioxus differentiate between multiple hooks in the same component? As you saw in the second example, both `use_signal` functions were called with the same parameters, so how come they can return different things when the counters are different?

````rs@hooks_counter_two_state.rs
let mut count_a = use_signal(|| 0);
let mut count_b = use_signal(|| 0);
````

This is only possible because the two hooks are always called in the same order, so Dioxus knows which is which. Because the order you call hooks matters, you must follow certain rules when using hooks:

1. Hooks may be only used in components or other hooks (we'll get to that later).
1. On every call to a component function.
1. The same hooks must be called (except in the case of early returns, as explained later in the [Error Handling chapter](../cookbook/error_handling.md)).
1. In the same order.
1. Hook names should start with `use_` so you don't accidentally confuse them with regular
   functions (`use_signal()`, `use_effect()`, `use_resource()`, etc...).

These rules mean that there are certain things you can't do with hooks:

### No hooks in conditionals

````rs@hooks_bad.rs
// âŒ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy && you_know_it {
    let something = use_signal(|| "hands");
    println!("clap your {something}")
}

// âœ… instead, *always* call use_signal
// You can put other stuff in the conditional though
let something = use_signal(|| "hands");
if you_are_happy && you_know_it {
    println!("clap your {something}")
}
````

### No hooks in closures

````rs@hooks_bad.rs
// âŒ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
    let b = use_signal(|| 0);
    b()
};

// âœ… instead, move hook `b` outside
let b = use_signal(|| 0);
let _a = || b();
````

### No hooks in loops

````rs@hooks_bad.rs
// `names` is a Vec<&str>

// âŒ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &names {
    let is_selected = use_signal(|| false);
    println!("selected: {is_selected}");
}

// âœ… Instead, use a hashmap with use_signal
let selection_map = use_signal(HashMap::<&str, bool>::new);

for name in &names {
    let is_selected = selection_map.read()[name];
    println!("selected: {is_selected}");
}
````

## Additional resources

* [dioxus_hooks API docs](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/)
* [dioxus_hooks source code](https://github.com/DioxusLabs/dioxus/tree/v0.5/packages/hooks)
# User Input

Interfaces often need to provide a way to input data: e.g. text, numbers, checkboxes, etc. In Dioxus, there are two ways you can work with user input.

## Controlled Inputs

With controlled inputs, you are directly in charge of the state of the input. This gives you a lot of flexibility, and makes it easy to keep things in sync. For example, this is how you would create a controlled text input:

````rs@input_controlled.rs
pub fn App() -> Element {
    let mut name = use_signal(|| "bob".to_string());

    rsx! {
        input {
            // we tell the component what to render
            value: "{name().to_ascii_uppercase()}",
            // and what to do when the value changes
            oninput: move |event| name.set(event.value())
        }
    }
}
````

````inject-dioxus
DemoFrame {
    input_controlled::App {}
}
````

Notice the flexibility â€“ you can:

* Also display the same contents in another element, and they will be in sync
* Transform the input every time it is modified (e.g. to make sure it is upper case)
* Validate the input every time it changes
* Have custom logic happening when the input changes (e.g. network request for autocompletion)
* Programmatically change the value (e.g. a "randomize" button that fills the input with nonsense)

## Uncontrolled Inputs

As an alternative to controlled inputs, you can simply let the platform keep track of the input values. If we don't tell a HTML input what content it should have, it will be editable anyway (this is built into the browser). This approach can be more performant, but less flexible. For example, it's harder to keep the input in sync with another element.

Since you don't necessarily have the current value of the uncontrolled input in state, you can access it either by listening to `oninput` events (similarly to controlled components), or, if the input is part of a form, you can access the form data in the form events (e.g. `oninput` or `onsubmit`):

````rs@input_uncontrolled.rs
pub fn App() -> Element {
    rsx! {
        form { onsubmit: move |event| { tracing::info!("Submitted! {event:?}") },
            input { name: "name" }
            input { name: "age" }
            input { name: "date" }
            input { r#type: "submit" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    input_uncontrolled::App {}
}
````

````
Submitted! UiEvent { data: FormData { value: "", values: {"age": "very old", "date": "1966", "name": "Fred"} } }
````

## Handling files

You can insert a file picker by using an input element of type `file`. This element supports the `multiple` attribute, to let you pick more files at the same time. You can select a folder by adding the `directory` attribute: Dioxus will map this attribute to browser specific attributes, because there is no standardized way to allow a directory to be selected.

`type` is a Rust keyword, so when specifying the type of the input field, you have to write it as `r#type:"file"`.

Extracting the selected files is a bit different from what you may typically use in Javascript.

The `FormData` event contains a `files` field with data about the uploaded files. This field contains a `FileEngine` struct which lets you fetch the filenames selected by the user. This example saves the filenames of the selected files to a `Vec`:

````rs@input_fileengine.rs
pub fn App() -> Element {
    let mut filenames: Signal<Vec<String>> = use_signal(Vec::new);
    rsx! {
        input {
            // tell the input to pick a file
            type: "file",
            // list the accepted extensions
            accept: ".txt,.rs",
            // pick multiple files
            multiple: true,
            onchange: move |evt| {
                for file in evt.files() {
                    filenames.write().push(file.name());
                }
            }
        }
    }
}
````

If you're planning to read the file content, you need to do it asynchronously, to keep the rest of the UI interactive. This example event handler loads the content of the selected files in an async closure:

````rs@input_fileengine_async.rs
onchange: move |evt| {
    async move {
        for file in evt.files() {
            if let Ok(file) = file.read_string().await {
                files_uploaded.write().push(file);
            }
        }
    }
}
````

Lastly, this example shows you how to select a folder, by setting the `directory` attribute to `true`.

````rs@input_fileengine_folder.rs
input {
    type: "file",
    // Select a folder by setting the directory attribute
    directory: true,
    onchange: move |evt| {
        for file in evt.files() {
            println!("{}", file.name());
        }
    }
}
````
# Sharing State

Often, multiple components need to access the same state. Depending on your needs, there are several ways to implement this.

## Lifting State

One approach to share state between components is to "lift" it up to the nearest common ancestor. This means putting the `use_signal` hook in a parent component, and passing the needed values down as props.

Suppose we want to build a meme editor. We want to have an input to edit the meme caption, but also a preview of the meme with the caption. Logically, the meme and the input are 2 separate components, but they need access to the same state (the current caption).

 > 
 > Of course, in this simple example, we could write everything in one component â€“ but it is better to split everything out in smaller components to make the code more reusable, maintainable, and performant (this is even more important for larger, complex apps).

We start with a `Meme` component, responsible for rendering a meme with a given caption:

````rs@meme_editor.rs
#[component]
fn Meme(caption: String) -> Element {
    let container_style = r#"
        position: relative;
        width: fit-content;
    "#;

    let caption_container_style = r#"
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 16px 8px;
    "#;

    let caption_style = r"
        font-size: 32px;
        margin: 0;
        color: white;
        text-align: center;
    ";

    rsx! {
        div { style: "{container_style}",
            img { src: "https://i.imgflip.com/2zh47r.jpg", height: "500px" }
            div { style: "{caption_container_style}", p { style: "{caption_style}", "{caption}" } }
        }
    }
}
````

 > 
 > Note that the `Meme` component is unaware where the caption is coming from â€“ it could be stored in `use_signal`, or a constant. This ensures that it is very reusable â€“ the same component can be used for a meme gallery without any changes!

We also create a caption editor, completely decoupled from the meme. The caption editor must not store the caption itself â€“ otherwise, how will we provide it to the `Meme` component? Instead, it should accept the current caption as a prop, as well as an event handler to delegate input events to:

````rs@meme_editor.rs
#[component]
fn CaptionEditor(caption: String, oninput: EventHandler<FormEvent>) -> Element {
    let input_style = r"
        border: none;
        background: cornflowerblue;
        padding: 8px 16px;
        margin: 0;
        border-radius: 4px;
        color: white;
    ";

    rsx! {
        input {
            style: "{input_style}",
            value: "{caption}",
            oninput: move |event| oninput.call(event)
        }
    }
}
````

Finally, a third component will render the other two as children. It will be responsible for keeping the state and passing down the relevant props.

````rs@meme_editor.rs
fn MemeEditor() -> Element {
    let container_style = r"
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin: 0 auto;
        width: fit-content;
    ";

    let mut caption = use_signal(|| "me waiting for my rust code to compile".to_string());

    rsx! {
        div { style: "{container_style}",
            h1 { "Meme Editor" }
            Meme { caption: caption }
            CaptionEditor { caption: caption, oninput: move |event: FormEvent| caption.set(event.value()) }
        }
    }
}
````

![Meme Editor Screenshot: An old plastic skeleton sitting on a park bench. Caption: "me waiting for a language feature"](/assets/static/meme_editor_screenshot.png)

## Using Shared State

Sometimes, some state needs to be shared between multiple components far down the tree, and passing it down through props is very inconvenient.

Suppose now that we want to implement a dark mode toggle for our app. To achieve this, we will make every component select styling depending on whether dark mode is enabled or not.

 > 
 > Note: we're choosing this approach for the sake of an example. There are better ways to implement dark mode (e.g. using CSS variables). Let's pretend CSS variables don't exist â€“ welcome to 2013!

Now, we could write another `use_signal` in the top component, and pass `is_dark_mode` down to every component through props. But think about what will happen as the app grows in complexity â€“ almost every component that renders any CSS is going to need to know if dark mode is enabled or not â€“ so they'll all need the same dark mode prop. And every parent component will need to pass it down to them. Imagine how messy and verbose that would get, especially if we had components several levels deep!

Dioxus offers a better solution than this "prop drilling" â€“ providing context. The [`use_context_provider`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context_provider.html) hook provides any Clone context (including Signals!) to any child components. Child components can use the [`use_context`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context.html) hook to get that context and if it is a Signal, they can read and write to it.

First, we have to create a struct for our dark mode configuration:

````rs@meme_editor_dark_mode.rs
#[derive(Clone, Copy)]
struct DarkMode(bool);
````

Now, in a top-level component (like `App`), we can provide the `DarkMode` context to all children components:

````rs@meme_editor_dark_mode.rs
use_context_provider(|| Signal::new(DarkMode(false)));
````

As a result, any child component of `App` (direct or not), can access the `DarkMode` context.

````rs@meme_editor_dark_mode.rs
let dark_mode_context = use_context::<Signal<DarkMode>>();
````

 > 
 > `use_context` returns `Signal<DarkMode>` here, because the Signal was provided by the parent. If the context hadn't been provided `use_context` would have panicked.

If you have a component where the context might or not be provided, you might want to use `try_consume_context`instead, so you can handle the `None` case. The drawback of this method is that it will not memoize the value between renders, so it won't be as as efficient as `use_context`, you could do it yourself with `use_hook` though.

For example, here's how we would implement the dark mode toggle, which both reads the context (to determine what color it should render) and writes to it (to toggle dark mode):

````rs@meme_editor_dark_mode.rs
pub fn DarkModeToggle() -> Element {
    let mut dark_mode = use_context::<Signal<DarkMode>>();

    let style = if dark_mode().0 { "color:white" } else { "" };

    rsx! {
        label { style: "{style}",
            "Dark Mode"
            input {
                r#type: "checkbox",
                oninput: move |event| {
                    let is_enabled = event.value() == "true";
                    dark_mode.write().0 = is_enabled;
                }
            }
        }
    }
}
````
# Dynamic Rendering

Sometimes you want to render different things depending on the state/props. With Dioxus, just describe what you want to see using Rust control flow â€“ the framework will take care of making the necessary changes on the fly if the state or props change!

## Conditional Rendering

To render different elements based on a condition, you could use an `if-else` statement:

````rs@conditional_rendering.rs
if is_logged_in {
    rsx! {
        "Welcome!"
        button { onclick: move |_| log_out.call(()), "Log Out" }
    }
} else {
    rsx! {
        button { onclick: move |_| log_in.call(()), "Log In" }
    }
}
````

````inject-dioxus
DemoFrame {
  conditional_rendering::App {}
}
````

 > 
 > You could also use `match` statements, or any Rust function to conditionally render different things.

### Improving the `if-else` Example

You may have noticed some repeated code in the `if-else` example above. Repeating code like this is both bad for maintainability and performance. Dioxus will skip diffing static elements like the button, but when switching between multiple `rsx` calls it cannot perform this optimization. For this example either approach is fine, but for components with large parts that are reused between conditionals, it can be more of an issue.

We can improve this example by splitting up the dynamic parts and inserting them where they are needed.

````rs@conditional_rendering.rs
rsx! {
    // We only render the welcome message if we are logged in
    // You can use if statements in the middle of a render block to conditionally render elements
    if is_logged_in {
        // Notice the body of this if statement is rsx code, not an expression
        "Welcome!"
    }
    button {
        // depending on the value of `is_logged_in`, we will call a different event handler
        onclick: move |_| if is_logged_in { log_out.call(()) } else { log_in.call(()) },
        if is_logged_in {
            // if we are logged in, the button should say "Log Out"
            "Log Out"
        } else {
            // if we are not logged in, the button should say "Log In"
            "Log In"
        }
    }
}
````

````inject-dioxus
DemoFrame {
  conditional_rendering::LogInImprovedApp {}
}
````

### Inspecting `Element` props

Since `Element` is a `Option<VNode>`, components accepting `Element` as a prop can inspect its contents, and render different things based on that. Example:

````rs@component_children_inspect.rs
fn Clickable(props: ClickableProps) -> Element {
    match props.children {
        Some(VNode { .. }) => {
            todo!("render some stuff")
        }
        _ => {
            todo!("render some other stuff")
        }
    }
}
````

You can't mutate the `Element`, but if you need a modified version of it, you can construct a new one based on its attributes/children/etc.

## Rendering Nothing

To render nothing, you can return `None` from a component. This is useful if you want to conditionally hide something:

````rs@conditional_rendering.rs
if is_logged_in {
    return rsx!();
}

rsx! {
    p { "You must be logged in to comment" }
}
````

````inject-dioxus
DemoFrame {
  conditional_rendering::LogInWarningApp {}
}
````

This works because the `Element` type is just an alias for `Option<VNode>`

 > 
 > Again, you may use a different method to conditionally return `None`. For example the boolean's [`then()`](https://doc.rust-lang.org/std/primitive.bool.html#method.then) function could be used.

## Rendering Lists

Often, you'll want to render a collection of components. For example, you might want to render a list of all comments on a post.

For this, Dioxus accepts iterators that produce `Element`s. So we need to:

* Get an iterator over all of our items (e.g., if you have a `Vec` of comments, iterate over it with `iter()`)
* `.map` the iterator to convert each item into a `LazyNode` using `rsx!{...}`
  * Add a unique `key` attribute to each iterator item
* Include this iterator in the final RSX (or use it inline)

Example: suppose you have a list of comments you want to render. Then, you can render them like this:

````rs@rendering_lists.rs
let mut comment_field = use_signal(String::new);
let mut next_id = use_signal(|| 0);
let mut comments = use_signal(Vec::<CommentData>::new);

let comments_lock = comments.read();
let comments_rendered = comments_lock.iter().map(|comment| {
    rsx! { Comment { comment: comment.clone() } }
});

rsx! {
    form {
        onsubmit: move |_| {
            comments
                .write()
                .push(CommentData {
                    content: comment_field(),
                    id: next_id(),
                });
            next_id += 1;
            comment_field.set(String::new());
        },
        input {
            value: "{comment_field}",
            oninput: move |event| comment_field.set(event.value())
        }
        input { r#type: "submit" }
    }
    {comments_rendered}
}
````

````inject-dioxus
DemoFrame {
  rendering_lists::App {}
}
````

### Inline for loops

Because of how common it is to render a list of items, Dioxus provides a shorthand for this. Instead of using `.iter`, `.map`, and `rsx`, you can use a `for` loop with a body of rsx code:

````rs@rendering_lists.rs
let mut comment_field = use_signal(String::new);
let mut next_id = use_signal(|| 0);
let mut comments = use_signal(Vec::<CommentData>::new);

rsx! {
    form {
        onsubmit: move |_| {
            comments
                .write()
                .push(CommentData {
                    content: comment_field(),
                    id: next_id(),
                });
            next_id += 1;
            comment_field.set(String::new());
        },
        input {
            value: "{comment_field}",
            oninput: move |event| comment_field.set(event.value())
        }
        input { r#type: "submit" }
    }
    for comment in comments() {
        // Notice the body of this for loop is rsx code, not an expression
        Comment { comment }
    }
}
````

````inject-dioxus
DemoFrame {
  rendering_lists::AppForLoop {}
}
````

### The key Attribute

Every time you re-render your list, Dioxus needs to keep track of which items go where to determine what updates need to be made to the UI.

For example, suppose the `CommentComponent` had some state â€“ e.g. a field where the user typed in a reply. If the order of comments suddenly changes, Dioxus needs to correctly associate that state with the same comment â€“ otherwise, the user will end up replying to a different comment!

To help Dioxus keep track of list items, we need to associate each item with a unique key. In the example above, we dynamically generated the unique key. In real applications, it's more likely that the key will come from e.g. a database ID. It doesn't matter where you get the key from, as long as it meets the requirements:

* Keys must be unique in a list
* The same item should always get associated with the same key
* Keys should be relatively small (i.e. converting the entire Comment structure to a String would be a pretty bad key) so they can be compared efficiently

You might be tempted to use an item's index in the list as its key. Thatâ€™s what Dioxus will use if you donâ€™t specify a key at all. This is only acceptable if you can guarantee that the list is constant â€“ i.e., no re-ordering, additions, or deletions.

 > 
 > Note that if you pass the key to a component you've made, it won't receive the key as a prop. Itâ€™s only used as a hint by Dioxus itself. If your component needs an ID, you have to pass it as a separate prop.
# Router

In many of your apps, you'll want to have different "scenes". For a webpage, these scenes might be the different webpages with their own content. For a desktop app, these scenes might be different views in your app.

To unify these platforms, Dioxus provides a first-party solution for scene management called Dioxus Router.

## What is it?

For an app like the Dioxus landing page (https://dioxuslabs.com), we want to have several different scenes:

* Homepage
* Blog

Each of these scenes is independent â€“ we don't want to render both the homepage and blog at the same time.

The Dioxus router makes it easy to create these scenes. To make sure we're using the router, add the `router` feature to your `dioxus` dependency:

````shell
cargo add dioxus@0.5.0 --features router
````

## Using the router

Unlike other routers in the Rust ecosystem, our router is built declaratively at compile time. This makes it possible to compose our app layout simply by defining an enum.

````rs@router_reference.rs
// All of our routes will be a variant of this Route enum
#[derive(Routable, PartialEq, Clone)]
enum Route {
    // if the current location is "/home", render the Home component
    #[route("/home")]
    Home {},
    // if the current location is "/blog", render the Blog component
    #[route("/blog")]
    Blog {},
}

fn Home() -> Element {
    todo!()
}

fn Blog() -> Element {
    todo!()
}
````

Whenever we visit this app, we will get either the Home component or the Blog component rendered depending on which route we enter at. If neither of these routes match the current location, then nothing will render.

We can fix this one of two ways:

* A fallback 404 page

````rs@router_reference.rs
// All of our routes will be a variant of this Route enum
#[derive(Routable, PartialEq, Clone)]
enum Route {
    #[route("/home")]
    Home {},
    #[route("/blog")]
    Blog {},
    //  if the current location doesn't match any of the above routes, render the NotFound component
    #[route("/:..segments")]
    NotFound { segments: Vec<String> },
}

fn Home() -> Element {
    todo!()
}

fn Blog() -> Element {
    todo!()
}

#[component]
fn NotFound(segments: Vec<String>) -> Element {
    todo!()
}
````

* Redirect 404 to home

````rs@router_reference.rs
// All of our routes will be a variant of this Route enum
#[derive(Routable, PartialEq, Clone)]
enum Route {
    #[route("/home")]
    //  if the current location doesn't match any of the other routes, redirect to "/home"
    #[redirect("/:..segments", |segments: Vec<String>| Route::Home {})]
    Home {},
    #[route("/blog")]
    Blog {},
}
````

## Links

For our app to navigate these routes, we can provide clickable elements called Links. These simply wrap `<a>` elements that, when clicked, navigate the app to the given location. Because our route is an enum of valid routes, if you try to link to a page that doesn't exist, you will get a compiler error.

````rs@router_reference.rs
rsx! {
    Link { to: Route::Home {}, "Go home!" }
}
````

## More reading

This page is just a very brief overview of the router. For more information, check out the [router book](../router/index.md) or some of the [router examples](https://github.com/DioxusLabs/dioxus/blob/master/examples/router.rs).
# Resource

[`use_resource`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_resource.html) lets you run an async closure, and provides you with its result.

For example, we can make an API request (using [reqwest](https://docs.rs/reqwest/latest/reqwest/index.html)) inside `use_resource`:

````rs@use_resource.rs
let mut future = use_resource(|| async move {
    reqwest::get("https://dog.ceo/api/breeds/image/random")
        .await
        .unwrap()
        .json::<ApiResponse>()
        .await
});
````

The code inside `use_resource` will be submitted to the Dioxus scheduler once the component has rendered.

We can use `.read()` to get the result of the future. On the first run, since there's no data ready when the component loads, its value will be `None`. However, once the future is finished, the component will be re-rendered and the value will now be `Some(...)`, containing the return value of the closure.

We can then render that result:

````rs@use_resource.rs
match &*future.read_unchecked() {
    Some(Ok(response)) => rsx! {
        button { onclick: move |_| future.restart(), "Click to fetch another doggo" }
        div {
            img {
                max_width: "500px",
                max_height: "500px",
                src: "{response.image_url}",
            }
        }
    },
    Some(Err(_)) => rsx! {
        div { "Loading dogs failed" }
    },
    None => rsx! {
        div { "Loading dogs..." }
    },
}
````

````inject-dioxus
DemoFrame {
    use_resource::App {}
}
````

## Restarting the Future

The `Resource` handle provides a `restart` method. It can be used to execute the future again, producing a new value.

## Dependencies

Often, you will need to run the future again every time some value (e.g. a state) changes. Rather than calling `restart` manually, you can read a signal inside of the future. It will automatically re-run the future when any of the states you read inside the future change. Example:

````rs@use_resource.rs
let future = use_resource(move || async move {
    reqwest::get(format!("https://dog.ceo/api/breed/{breed}/images/random"))
        .await
        .unwrap()
        .json::<ApiResponse>()
        .await
});

// You can also add non-reactive state to the resource hook with the use_reactive method
let non_reactive_state = "poodle";
use_resource(use_reactive!(|(non_reactive_state,)| async move {
    reqwest::get(format!(
        "https://dog.ceo/api/breed/{non_reactive_state}/images/random"
    ))
    .await
    .unwrap()
    .json::<ApiResponse>()
    .await
}));
````
# Coroutines

Another tool in your async toolbox are coroutines. Coroutines are futures that can have values sent to them.

Like regular futures, code in a coroutine will run until the next `await` point before yielding. This low-level control over asynchronous tasks is quite powerful, allowing for infinitely looping tasks like WebSocket polling, background timers, and other periodic actions.

## use_coroutine

The `use_coroutine` hook allows you to create a coroutine. Most coroutines we write will be polling loops using await.

````rs@use_coroutine_reference.rs
use futures_util::StreamExt;

fn app() {
    let ws: Coroutine<()> = use_coroutine(|rx| async move {
        // Connect to some sort of service
        let mut conn = connect_to_ws_server().await;

        // Wait for data on the service
        while let Some(msg) = conn.next().await {
            // handle messages
        }
    });
}
````

For many services, a simple async loop will handle the majority of use cases.

## Yielding Values

To yield values from a coroutine, simply bring in a `Signal` handle and set the value whenever your coroutine completes its work.

The future must be `'static` â€“ so any values captured by the task cannot carry any references to `cx`, such as a `Signal`.

You can use [to_owned](https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned) to create a clone of the hook handle which can be moved into the async closure.

````rs@use_coroutine_reference.rs
let sync_status = use_signal(|| Status::Launching);
let sync_task = use_coroutine(|rx: UnboundedReceiver<SyncAction>| {
    let mut sync_status = sync_status.to_owned();
    async move {
        loop {
            tokio::time::sleep(Duration::from_secs(1)).await;
            sync_status.set(Status::Working);
        }
    }
});
````

To make this a bit less verbose, Dioxus exports the `to_owned!` macro which will create a binding as shown above, which can be quite helpful when dealing with many values.

````rs@use_coroutine_reference.rs
let sync_status = use_signal(|| Status::Launching);
let load_status = use_signal(|| Status::Launching);
let sync_task = use_coroutine(|rx: UnboundedReceiver<SyncAction>| {
    async move {
        // ...
    }
});
````

## Sending Values

You might've noticed the `use_coroutine` closure takes an argument called `rx`. What is that? Well, a common pattern in complex apps is to handle a bunch of async code at once. With libraries like Redux Toolkit, managing multiple promises at once can be challenging and a common source of bugs.

With Coroutines, we can centralize our async logic. The `rx` parameter is an Channel that allows code external to the coroutine to send data *into* the coroutine. Instead of looping on an external service, we can loop on the channel itself, processing messages from within our app without needing to spawn a new future. To send data into the coroutine, we would call "send" on the handle.

````rs@use_coroutine_reference.rs
use futures_util::StreamExt;

enum ProfileUpdate {
    SetUsername(String),
    SetAge(i32),
}

let profile = use_coroutine(|mut rx: UnboundedReceiver<ProfileUpdate>| async move {
    let mut server = connect_to_server().await;

    while let Some(msg) = rx.next().await {
        match msg {
            ProfileUpdate::SetUsername(name) => server.update_username(name).await,
            ProfileUpdate::SetAge(age) => server.update_age(age).await,
        }
    }
});

rsx! {
    button { onclick: move |_| profile.send(ProfileUpdate::SetUsername("Bob".to_string())),
        "Update username"
    }
}
````

 > 
 > Note: In order to use/run the `rx.next().await` statement you will need to extend the \[`Stream`\] trait (used by \[`UnboundedReceiver`\]) by adding 'futures_util' as a dependency to your project and adding the `use futures_util::stream::StreamExt;`.

For sufficiently complex apps, we could build a bunch of different useful "services" that loop on channels to update the app.

````rs@use_coroutine_reference.rs
let profile = use_coroutine(profile_service);
let editor = use_coroutine(editor_service);
let sync = use_coroutine(sync_service);

async fn profile_service(rx: UnboundedReceiver<ProfileCommand>) {
    // do stuff
}

async fn sync_service(rx: UnboundedReceiver<SyncCommand>) {
    // do stuff
}

async fn editor_service(rx: UnboundedReceiver<EditorCommand>) {
    // do stuff
}
````

We can combine coroutines with Global State to emulate Redux Toolkit's Thunk system with much less headache. This lets us store all of our app's state *within* a task and then simply update the "view" values stored in Atoms. It cannot be understated how powerful this technique is: we get all the perks of native Rust tasks with the optimizations and ergonomics of global state. This means your *actual* state does not need to be tied up in a system like `Signal::global` or Redux â€“ the only Atoms that need to exist are those that are used to drive the display/UI.

````rs@use_coroutine_reference.rs
static USERNAME: GlobalSignal<String> = Signal::global(|| "default".to_string());

fn app() -> Element {
    use_coroutine(sync_service);

    rsx! { Banner {} }
}

fn Banner() -> Element {
    rsx! { h1 { "Welcome back, {USERNAME}" } }
}
````

Now, in our sync service, we can structure our state however we want. We only need to update the view values when ready.

````rs@use_coroutine_reference.rs
use futures_util::StreamExt;

static USERNAME: GlobalSignal<String> = Signal::global(|| "default".to_string());
static ERRORS: GlobalSignal<Vec<String>> = Signal::global(|| Vec::new());

enum SyncAction {
    SetUsername(String),
}

async fn sync_service(mut rx: UnboundedReceiver<SyncAction>) {
    while let Some(msg) = rx.next().await {
        match msg {
            SyncAction::SetUsername(name) => {
                if set_name_on_server(&name).await.is_ok() {
                    *USERNAME.write() = name;
                } else {
                    *ERRORS.write() = vec!["Failed to set username".to_string()];
                }
            }
        }
    }
}
````

## Automatic injection into the Context API

Coroutine handles are automatically injected through the context API. You can use the `use_coroutine_handle` hook with the message type as a generic to fetch a handle.

````rs@use_coroutine_reference.rs
fn Child() -> Element {
    let sync_task = use_coroutine_handle::<SyncAction>();

    sync_task.send(SyncAction::SetUsername);

    todo!()
}
````
# Spawning Futures

The `use_resource` and `use_coroutine` hooks are useful if you want to unconditionally spawn the future. Sometimes, though, you'll want to only spawn a future in response to an event, such as a mouse click. For example, suppose you need to send a request when the user clicks a "log in" button. For this, you can use `spawn`:

````rs@spawn.rs
let mut response = use_signal(|| String::from("..."));

let log_in = move |_| {
    spawn(async move {
        let resp = reqwest::Client::new()
            .get("https://dioxuslabs.com")
            .send()
            .await;

        match resp {
            Ok(_data) => {
                log::info!("dioxuslabs.com responded!");
                response.set("dioxuslabs.com responded!".into());
            }
            Err(err) => {
                log::info!("Request failed with error: {err:?}")
            }
        }
    });
};

rsx! {
    button { onclick: log_in, "Response: {response}" }
}
````

````inject-dioxus
DemoFrame {
    spawn::App {}
}
````

 > 
 > Note: `spawn` will always spawn a *new* future. You most likely don't want to call it on every render.

Calling `spawn` will give you a `JoinHandle` which lets you cancel or pause the future.

## Spawning Tokio Tasks

Sometimes, you might want to spawn a background task that needs multiple threads or talk to hardware that might block your app code. In these cases, we can directly spawn a Tokio task from our future. For Dioxus-Desktop, your task will be spawned onto Tokio's Multithreaded runtime:

````rs@spawn.rs
spawn(async {
    let _ = tokio::spawn(async {}).await;

    let _ = tokio::task::spawn_local(async {
        // some !Send work
    })
    .await;
});
````
# Assets

 > 
 > âš ï¸ Support: Manganis is currently in alpha. API changes are planned and bugs are more likely

Assets are files that are included in the final build of the application. They can be images, fonts, stylesheets, or any other file that is not a source file. Dioxus includes first class support for assets, and provides a simple way to include them in your application and automatically optimize them for production.

Assets in dioxus are also compatible with libraries! If you are building a library, you can include assets in your library and they will be automatically included in the final build of any application that uses your library.

First, you need to add the `manganis` crate to your `Cargo.toml` file:

````sh
cargo add manganis
````

## Including images

To include an asset in your application, you can simply wrap the path to the asset in a `mg!` call. For example, to include an image in your application, you can use the following code:

````rs@assets.rs
use dioxus::prelude::*;

fn App() -> Element {
    // You can link to assets that are relative to the package root or even link to an asset from a url
    // These assets will automatically be picked up by the dioxus cli, optimized, and bundled with your final applications
    const ASSET: Asset = asset!("/assets/static/ferrous_wave.png");

    rsx! {
        img { src: "{ASSET}" }
    }
}
````

You can also optimize, resize, and preload images using the `mg!` macro. Choosing an optimized file type (like WebP) and a reasonable quality setting can significantly reduce the size of your images which helps your application load faster. For example, you can use the following code to include an optimized image in your application:

````rs@assets.rs
pub const ENUM_ROUTER_IMG: Asset = asset!("/assets/static/enum_router.png");

fn EnumRouter() -> Element {
    rsx! {
        img { src: "{ENUM_ROUTER_IMG}" }
    }
}
````

## Including arbitrary files

In dioxus desktop, you may want to include a file with data for your application. You can use the `file` function to include arbitrary files in your application. For example, you can use the following code to include a file in your application:

````rs@assets.rs
// You can also collect arbitrary files. Relative paths are resolved relative to the package root
const PATH_TO_BUNDLED_CARGO_TOML: &str = manganis::mg!(file("./Cargo.toml"));
````

These files will be automatically included in the final build of your application, and you can use them in your application as you would any other file.

## Including stylesheets

You can include stylesheets in your application using the `mg!` macro. For example, you can use the following code to include a stylesheet in your application:

````rs@assets.rs
// You can also bundle stylesheets with your application
// Any files that end with .css will be minified and bundled with your application even if you don't explicitly include them in your <head>
const _: &str = manganis::mg!(file("./tailwind.css"));
````

 > 
 > The [tailwind guide](../cookbook/tailwind.md) has more information on how to use tailwind with dioxus.

## Conclusion

Dioxus provides first class support for assets, and makes it easy to include them in your application. You can include images, arbitrary files, and stylesheets in your application, and dioxus will automatically optimize them for production. This makes it easy to include assets in your application and ensure that they are optimized for production.

You can read more about assets and all the options available to optimize your assets in the [manganis documentation](https://docs.rs/manganis/0.2.2/manganis/).
# Choosing a web renderer

Dioxus has three different renderers that target the web:

* [dioxus-web](web/index.md) allows you to render your application to HTML with [WebAssembly](https://rustwasm.github.io/docs/book/) on the client
* [dioxus-liveview](liveview.md) allows you to run your application on the server and render it to HTML on the client with a websocket
* [dioxus-fullstack](fullstack/index.md) allows you to initially render static HTML on the server and then update that HTML from the client with [WebAssembly](https://rustwasm.github.io/docs/book/)

Each approach has its tradeoffs:

### Dioxus Liveview

* Liveview rendering communicates with the server over a WebSocket connection. It essentially moves all of the work that Client-side rendering does to the server.

* This makes it **easy to communicate with the server, but more difficult to communicate with the client/browser APIS**.

* Each interaction also requires a message to be sent to the server and back which can cause **issues with latency**.

* Because Liveview uses a websocket to render, the page will be blank until the WebSocket connection has been established and the first renderer has been sent from the websocket. Just like with client side rendering, this can make the page **less SEO-friendly**.

* Because the page is rendered on the server and the page is sent to the client piece by piece, you never need to send the entire application to the client. The initial load time can be faster than client-side rendering with large applications because Liveview only needs to send a constant small websocket script regardless of the size of the application.

 > 
 > Liveview is a good fit for applications that already need to communicate with the server frequently (like real time collaborative apps), but don't need to communicate with as many client/browser APIs.

[![](https://mermaid.ink/img/pako:eNplULFOw0AM_RXLc7Mw3sBQVUIMRYgKdcli5ZzkRHIuPl8QqvrvXJICRXiy3nt-9-6dsRHP6DAZGe8CdUpjNd3VEcpsVT4SK1TVPRxYJ1YHL_yeOdkqWMGF3w4U32Y6nSQmXvknMQYNXW8g7bfk2JPBg0g3MCTmdH1rJhenx2is1FiYri43wJ8or3O2H1Liv0w3hw724kMb2MMzdcUYNziyjhR8-f15Pq3Reh65RldWzy3lwWqs46VIKZscPmODzjTzBvPJ__aFrqUhFZR9MNH92uhS7OULYSF1lw?type=png)](https://mermaid.live/edit#pako:eNplULFOw0AM_RXLc7Mw3sBQVUIMRYgKdcli5ZzkRHIuPl8QqvrvXJICRXiy3nt-9-6dsRHP6DAZGe8CdUpjNd3VEcpsVT4SK1TVPRxYJ1YHL_yeOdkqWMGF3w4U32Y6nSQmXvknMQYNXW8g7bfk2JPBg0g3MCTmdH1rJhenx2is1FiYri43wJ8or3O2H1Liv0w3hw724kMb2MMzdcUYNziyjhR8-f15Pq3Reh65RldWzy3lwWqs46VIKZscPmODzjTzBvPJ__aFrqUhFZR9MNH92uhS7OULYSF1lw)

### Dioxus Web

* With Client side rendering, you send your application to the client, and then the client generates all of the HTML of the page dynamically.

* This means that the page will be blank until the JavaScript bundle has loaded and the application has initialized. This can result in **slower first render times and poor SEO performance**.

 > 
 > SEO stands for Search Engine Optimization. It refers to the practice of making your website more likely to appear in search engine results. Search engines like Google and Bing use web crawlers to index the content of websites. Most of these crawlers are not able to run JavaScript, so they will not be able to index the content of your page if it is rendered client-side.

* Client-side rendered applications need to use **weakly typed requests to communicate with the server**.

 > 
 > Client-side rendering is a good starting point for most applications. It is well supported and makes it easy to communicate with the client/browser APIs.

[![](https://mermaid.ink/img/pako:eNpVkDFPwzAQhf-KdXOzMHpgqJAQAwytEIsXK35JLBJfez4Xoar_HSemQtzke9_z2e-u1HMAWcrqFU_Rj-KX7vLgkqm1F_7KENN1j-YIuUCsOeBckLUZmrjx_ezT54rziVNG42-sMBLHSQ0Pd8vH5NU8M48zTAby71sr3CYdkAIEoen37h-y5n3910tSiO81cqIdLZDFx1DDXNerjnTCAke2HgMGX2Z15NKtWn1RPn6nnqxKwY7KKfzFJzv4OVcVISrLa1vQtqfbDzd0ZKY?type=png)](https://mermaid.live/edit#pako:eNpVkDFPwzAQhf-KdXOzMHpgqJAQAwytEIsXK35JLBJfez4Xoar_HSemQtzke9_z2e-u1HMAWcrqFU_Rj-KX7vLgkqm1F_7KENN1j-YIuUCsOeBckLUZmrjx_ezT54rziVNG42-sMBLHSQ0Pd8vH5NU8M48zTAby71sr3CYdkAIEoen37h-y5n3910tSiO81cqIdLZDFx1DDXNerjnTCAke2HgMGX2Z15NKtWn1RPn6nnqxKwY7KKfzFJzv4OVcVISrLa1vQtqfbDzd0ZKY)

### Dioxus Fullstack

Fullstack rendering happens in two parts:

1. The page is rendered on the server. This can include fetching any data you need to render the page.
1. The page is hydrated on the client. (Hydration is taking the HTML page from the server and adding all of the event listeners Dioxus needs on the client). Any updates to the page happen on the client after this point.

Because the page is initially rendered on the server, the page will be fully rendered when it is sent to the client. This results in a faster first render time and makes the page more SEO-friendly.

* **Fast initial render**
* **Works well with SEO**
* **Type safe easy communication with the server**
* **Access to the client/browser APIs**
* **Fast interactivity**

Finally, we can use [server functions](../reference/fullstack/server_functions.md) to communicate with the server in a type-safe way.

This approach uses both the dioxus-web and dioxus-ssr crates. To integrate those two packages Dioxus provides the `dioxus-fullstack` crate.

There can be more complexity with fullstack applications because your code runs in two different places. Dioxus tries to mitigate this with server functions and other helpers.

[![](https://mermaid.ink/img/pako:eNpdkL1uwzAMhF9F4BwvHTV0KAIUHdohQdFFi2CdbQG2mFCUiyDIu9e2-hOUE3H34UDelVoOIEtZvWIffS9-auYHl8wyT8KfGWKa5tEcITPEmgPOBVkrUMXNPyAFCMJK5BOnjIq8scJI7Ac13N1RH4NX88zcjzAZyJX-8bfIl6QQ32qcv7PuhP-ANe_rpb8KJ9rRBJl8DMt71zXAkQ6Y4Mgua0Dny6iOXLotqC_Kx0tqyaoU7Kicwl8hZDs_5kVFiMryWivbmrt9AacxbGg?type=png)](https://mermaid.live/edit#pako:eNpdkL1uwzAMhF9F4BwvHTV0KAIUHdohQdFFi2CdbQG2mFCUiyDIu9e2-hOUE3H34UDelVoOIEtZvWIffS9-auYHl8wyT8KfGWKa5tEcITPEmgPOBVkrUMXNPyAFCMJK5BOnjIq8scJI7Ac13N1RH4NX88zcjzAZyJX-8bfIl6QQ32qcv7PuhP-ANe_rpb8KJ9rRBJl8DMt71zXAkQ6Y4Mgua0Dny6iOXLotqC_Kx0tqyaoU7Kicwl8hZDs_5kVFiMryWivbmrt9AacxbGg)
# Desktop

This guide will cover concepts specific to the Dioxus desktop renderer.

Apps built with Dioxus desktop use the system WebView to render the page. This makes the final size of application much smaller than other WebView renderers (typically under 5MB).

Although desktop apps are rendered in a WebView, your Rust code runs natively. This means that browser APIs are *not* available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs *are* accessible, so streaming, WebSockets, filesystem, etc are all easily accessible though system APIs.

Dioxus desktop is built off [Tauri](https://tauri.app/). Right now there are limited Dioxus abstractions over the menubar, event handling, etc. In some places you may need to leverage Tauri directly â€“ through [Wry](http://github.com/tauri-apps/wry/) and [Tao](http://github.com/tauri-apps/tao).

 > 
 > In the future, we plan to move to a custom web renderer-based DOM renderer with WGPU integrations ([Blitz](https://github.com/DioxusLabs/blitz)).

## Examples

* [File Explorer](https://github.com/DioxusLabs/dioxus/tree/main/examples/file-explorer)
* [Tailwind App](https://github.com/DioxusLabs/dioxus/tree/v0.5/examples/tailwind)

[![Tailwind App screenshot](/assets/static/tailwind_desktop_app.png)](https://github.com/DioxusLabs/dioxus/tree/v0.5/examples/tailwind)

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus desktop exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    // You can create as many eval instances as you want
    let mut eval = eval(
        r#"
        // You can send messages from JavaScript to Rust with the dioxus.send function
        dioxus.send("Hi from JS!");
        // You can receive messages from Rust to JavaScript with the dioxus.recv function
        let msg = await dioxus.recv();
        console.log(msg);
        "#,
    );

    // You can send messages to JavaScript with the send method
    eval.send("Hi from Rust!".into()).unwrap();

    let future = use_resource(move || {
        to_owned![eval];
        async move {
            // You can receive any message from JavaScript with the recv method
            eval.recv().await.unwrap()
        }
    });

    match future.read_unchecked().as_ref() {
        Some(v) => rsx! {
            p { "{v}" }
        },
        _ => rsx! {
            p { "hello" }
        },
    }
}

````

## Custom Assets

You can link to local assets in dioxus desktop instead of using a url:

````rs@custom_assets.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    rsx! {
        div {
            img { src: "/public/static/scanner.png" }
        }
    }
}

````

You can read more about assets in the [assets](../assets.md) reference.

## Integrating with Wry

In cases where you need more low level control over your window, you can use wry APIs exposed through the [Desktop Config](https://docs.rs/dioxus-desktop/0.5.0/dioxus_desktop/struct.Config.html) and the [use_window hook](https://docs.rs/dioxus-desktop/0.5.0/dioxus_desktop/fn.use_window.html)
# Mobile App

Build a mobile app with Dioxus!

Example: [Mobile Demo](https://github.com/DioxusLabs/dioxus/tree/v0.5/examples/mobile_demo)

## Support

Mobile is currently the least-supported renderer target for Dioxus. Mobile apps are rendered with either the platform's WebView or experimentally with [WGPU](https://github.com/DioxusLabs/blitz). WebView doesn't support animations, transparency, and native widgets.

Mobile support is currently best suited for CRUD-style apps, ideally for internal teams who need to develop quickly but don't care much about animations or native widgets.

## Getting Set up

Getting set up with mobile can be quite challenging. The tooling here isn't great (yet) and might take some hacking around to get things working.

### Setting up dependencies

#### Android Dependencies

First, install the rust Android targets:

````sh
rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android
````

To develop on Android, you will need to [install Android Studio](https://developer.android.com/studio).

Once you have installed Android Studio, you will need to install the Android SDK and NDK:

1. Create a blank Android project
1. Select `Tools > SDK manager`
1. Navigate to the `SDK tools` window:

![NDK install window](/assets/static/android_ndk_install.png)

Then select:

* The SDK
* The SDK Command line tools
* The NDK (side by side)
* CMAKE

4. Select `apply` and follow the prompts

 > 
 > More details that could be useful for debugging any errors you encounter are available [in the official android docs](https://developer.android.com/studio/intro/update#sdk-manager)

Next set the Java, Android and NDK home variables:

Mac:

````sh
export JAVA_HOME="/Applications/Android Studio.app/Contents/jbr/Contents/Home"
export ANDROID_HOME="$HOME/Library/Android/sdk"
export NDK_HOME="$ANDROID_HOME/ndk/25.2.9519653"
````

Windows:

````powershell
[System.Environment]::SetEnvironmentVariable("JAVA_HOME", "C:\Program Files\Android\Android Studio\jbr", "User")
[System.Environment]::SetEnvironmentVariable("ANDROID_HOME", "$env:LocalAppData\Android\Sdk", "User")
[System.Environment]::SetEnvironmentVariable("NDK_HOME", "$env:LocalAppData\Android\Sdk\ndk\25.2.9519653", "User")
````

 > 
 > The NDK version in the paths should match the version you installed in the last step

#### IOS Dependencies

First, install the rust IOS targets:

````sh
rustup target add aarch64-apple-ios x86_64-apple-ios aarch64-apple-ios-sim
````

To develop on IOS, you will need to [install XCode](https://apps.apple.com/us/app/xcode/id497799835).

 > 
 > Note: On Apple silicon you must run Xcode on rosetta. Goto Application > Right Click Xcode > Get Info > Open in Rosetta.
 > If you are using M1, you will have to run `cargo build --target x86_64-apple-ios` instead of `cargo apple build` if you want to run in simulator.

### Setting up your project

First, we need to create a rust project:

````sh
cargo new dioxus-mobile-test --lib
cd dioxus-mobile-test
````

Next, we can use `cargo-mobile2` to create a project for mobile:

````shell
cargo install --git https://github.com/tauri-apps/cargo-mobile2
cargo mobile init
````

When you run `cargo mobile init`, you will be asked a series of questions about your project. One of those questions is what template you should use. Dioxus currently doesn't have a template in Tauri mobile, instead you can use the `wry` template.

 > 
 > You may also be asked to input your team ID for IOS. You can find your team id [here](https://developer.apple.com/help/account/manage-your-team/locate-your-team-id/) or create a team id by creating a developer account [here](https://developer.apple.com/help/account/get-started/about-your-developer-account)

Next, we need to modify our dependencies to include dioxus and ensure the right version of wry is installed. Change the `[dependencies]` section of your `Cargo.toml`:

````toml
[dependencies]
anyhow = "1.0.56"
log = "0.4.11"
dioxus = { version = "0.5", features = ["mobile"] }
wry = "0.35.0"
tao = "0.25.0"
````

Finally, we need to add a component to renderer. Replace the wry template in your `lib.rs` file with this code:

````rust
use anyhow::Result;
use dioxus::prelude::*;

#[cfg(target_os = "android")]
fn init_logging() {
    android_logger::init_once(
        android_logger::Config::default()
            .with_max_level(log::LevelFilter::Trace)
    );
}

#[cfg(not(target_os = "android"))]
fn init_logging() {
    env_logger::init();
}

#[cfg(any(target_os = "android", target_os = "ios"))]
fn stop_unwind<F: FnOnce() -> T, T>(f: F) -> T {
    match std::panic::catch_unwind(std::panic::AssertUnwindSafe(f)) {
        Ok(t) => t,
        Err(err) => {
            eprintln!("attempt to unwind out of `rust` with err: {:?}", err);
            std::process::abort()
        }
    }
}

#[no_mangle]
#[inline(never)]
#[cfg(any(target_os = "android", target_os = "ios"))]
pub extern "C" fn start_app() {
    fn _start_app() {
        stop_unwind(|| main().unwrap());
    }

    #[cfg(target_os = "android")]
    {
        tao::android_binding!(
            com_example,
            dioxus_mobile_test,
            WryActivity,
            wry::android_setup, // pass the wry::android_setup function to tao which will invoke when the event loop is created
            _start_app
        );
        wry::android_binding!(com_example, dioxus_mobile_test);
    }
    #[cfg(target_os = "ios")]
    _start_app()
}

pub fn main() -> Result<()> {
    init_logging();

    launch(app);

    Ok(())
}

fn app() -> Element {
    let mut items = use_signal(|| vec![1, 2, 3]);

    log::debug!("Hello from the app");

    rsx! {
        div {
            h1 { "Hello, Mobile"}
            div { margin_left: "auto", margin_right: "auto", width: "200px", padding: "10px", border: "1px solid black",
                button {
                    onclick: move|_| {
                        println!("Clicked!");
                        let mut items_mut = items.write();
                        let new_item = items_mut.len() + 1;
                        items_mut.push(new_item);
                        println!("Requested update");
                    },
                    "Add item"
                }
                for item in items.read().iter() {
                    div { "- {item}" }
                }
            }
        }
    }
}
````

## Running

From there, you'll want to get a build of the crate using whichever platform you're targeting (simulator or actual hardware). For now, we'll just stick with the simulator.

First, you need to make sure that the build variant is correct in Android Studio:

1. Click "Build" in the top menu bar.
1. Click "Select Build Variant..." in the dropdown.
1. Find the "Build Variants" panel and use the dropdown to change the selected build variant.

![android studio build dropdown](/assets/static/as-build-dropdown.png)
![android studio build variants](/assets/static/as-build-variant-menu.png)

### Android

To build your project on Android you can run:

````sh
cargo android build
````

Next, open Android studio:

````sh
cargo android open
````

This will open an android studio project for this application.

Next we need to create a simulator in Android studio to run our app in. To create a simulator click on the phone icon in the top right of Android studio:

![android studio manage devices](/assets/static/android-studio-simulator.png)

Then click the `create a virtual device` button and follow the prompts:

![android studio devices](/assets/static/android-studio-devices.png)

Finally, launch your device by clicking the play button on the device you created:

![android studio device](/assets/static/android-studio-device.png)

Now you can start your application from your terminal by running:

````sh
cargo android run
````

![android_demo](/assets/static/Android-Dioxus-demo.png)

 > 
 > More information is available in the Android docs:
 > 
 > * https://developer.android.com/ndk/guides
 > * https://developer.android.com/studio/projects/install-ndk
 > * https://source.android.com/docs/setup/build/rust/building-rust-modules/overview

### IOS

To build your project for IOS, you can run:

````sh
cargo build --target aarch64-apple-ios-sim
````

Next, open XCode (this might take awhile if you've never opened XCode before):

````sh
cargo apple open
````

This will open XCode with this particular project.

From there, just click the "play" button with the right target and the app should be running!

![ios_demo](/assets/static/IOS-dioxus-demo.png)

Note that clicking play doesn't cause a new build, so you'll need to keep rebuilding the app between changes. The tooling here is very young, so please be patient. If you want to contribute to make things easier, please do! We'll be happy to help.
# Mobile

This guide will cover concepts specific to the Dioxus mobile renderer.

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus desktop exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    // You can create as many eval instances as you want
    let mut eval = eval(
        r#"
        // You can send messages from JavaScript to Rust with the dioxus.send function
        dioxus.send("Hi from JS!");
        // You can receive messages from Rust to JavaScript with the dioxus.recv function
        let msg = await dioxus.recv();
        console.log(msg);
        "#,
    );

    // You can send messages to JavaScript with the send method
    eval.send("Hi from Rust!".into()).unwrap();

    let future = use_resource(move || {
        to_owned![eval];
        async move {
            // You can receive any message from JavaScript with the recv method
            eval.recv().await.unwrap()
        }
    });

    match future.read_unchecked().as_ref() {
        Some(v) => rsx! {
            p { "{v}" }
        },
        _ => rsx! {
            p { "hello" }
        },
    }
}

````

## Custom Assets

You can link to local assets in dioxus mobile instead of using a url:

````rs@custom_assets.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    rsx! {
        div {
            img { src: "/public/static/scanner.png" }
        }
    }
}

````

## Integrating with Wry

In cases where you need more low level control over your window, you can use wry APIs exposed through the [Desktop Config](https://docs.rs/dioxus-desktop/0.5.0/dioxus_desktop/struct.Config.html) and the [use_window hook](https://docs.rs/dioxus-desktop/0.5.0/dioxus_desktop/struct.DesktopContext.html)
# Web

To run on the Web, your app must be compiled to WebAssembly and depend on the `dioxus` and `dioxus-web` crates.

A build of Dioxus for the web will be roughly equivalent to the size of a React build (70kb vs 65kb) but it will load significantly faster because [WebAssembly can be compiled as it is streamed](https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/).

Examples:

* [TodoMVC](https://github.com/DioxusLabs/dioxus/blob/main/examples/todomvc.rs)
* [Tailwind App](https://github.com/DioxusLabs/dioxus/tree/v0.5/examples/tailwind)

[![TodoMVC example](https://github.com/DioxusLabs/example-projects/raw/master/todomvc/example.png)](https://github.com/DioxusLabs/dioxus/blob/main/examples/todomvc.rs)

 > 
 > Note: Because of the limitations of Wasm, [not every crate will work](https://rustwasm.github.io/docs/book/reference/which-crates-work-with-wasm.html) with your web apps, so you'll need to make sure that your crates work without native system calls (timers, IO, etc).

## Support

The Web is the best-supported target platform for Dioxus.

* Because your app will be compiled to WASM you have access to browser APIs through [wasm-bindgen](https://rustwasm.github.io/docs/wasm-bindgen/introduction.html).
* Dioxus provides hydration to resume apps that are rendered on the server. See the [fullstack](../fullstack/index.md) reference for more information.

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus web exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    // You can create as many eval instances as you want
    let mut eval = eval(
        r#"
        // You can send messages from JavaScript to Rust with the dioxus.send function
        dioxus.send("Hi from JS!");
        // You can receive messages from Rust to JavaScript with the dioxus.recv function
        let msg = await dioxus.recv();
        console.log(msg);
        "#,
    );

    // You can send messages to JavaScript with the send method
    eval.send("Hi from Rust!".into()).unwrap();

    let future = use_resource(move || {
        to_owned![eval];
        async move {
            // You can receive any message from JavaScript with the recv method
            eval.recv().await.unwrap()
        }
    });

    match future.read_unchecked().as_ref() {
        Some(v) => rsx! {
            p { "{v}" }
        },
        _ => rsx! {
            p { "hello" }
        },
    }
}

````

If you are targeting web, but don't plan on targeting any other Dioxus renderer you can also use the generated wrappers in the [web-sys](https://rustwasm.github.io/wasm-bindgen/web-sys/index.html) and [gloo](https://gloo-rs.web.app/) crates.

## Customizing Index Template

Dioxus supports providing custom index.html templates. The index.html must include a `div` with the id `main` to be used. Hot Reload is still supported. An example
is provided in the [PWA-Example](https://github.com/DioxusLabs/dioxus/blob/main/examples/PWA-example/index.html).
# Server-Side Rendering

For lower-level control over the rendering process, you can use the `dioxus-ssr` crate directly. This can be useful when integrating with a web framework that `dioxus-fullstack` does not support, or pre-rendering pages.

## Setup

For this guide, we're going to show how to use Dioxus SSR with [Axum](https://docs.rs/axum/latest/axum/).

Make sure you have Rust and Cargo installed, and then create a new project:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the ssr renderer as dependencies:

````shell
cargo add dioxus@0.5.0
cargo add dioxus-ssr@0.5.0
````

Next, add all the Axum dependencies. This will be different if you're using a different Web Framework

````
cargo add tokio --features full
cargo add axum
````

Your dependencies should look roughly like this:

````toml
[dependencies]
axum = "0.7"
dioxus = { version = "*" }
dioxus-ssr = { version = "*" }
tokio = { version = "1.15.0", features = ["full"] }
````

Now, set up your Axum app to respond on an endpoint.

````rs@ssr.rs
use axum::{response::Html, routing::get, Router};
use dioxus::prelude::*;

#[tokio::main]
async fn main() {
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();

    println!("listening on http://127.0.0.1:3000");

    axum::serve(
        listener,
        Router::new()
            .route("/", get(app_endpoint))
            .into_make_service(),
    )
    .await
    .unwrap();
}
````

And then add our endpoint. We can either render `rsx!` directly:

````rs@ssr.rs
async fn app_endpoint() -> Html<String> {
    // render the rsx! macro to HTML
    Html(dioxus_ssr::render_element(rsx! { div { "hello world!" } }))
}
````

Or we can render VirtualDoms.

````rs@ssr.rs
async fn app_endpoint() -> Html<String> {
    // create a component that renders a div with the text "hello world"
    fn app() -> Element {
        rsx! { div { "hello world" } }
    }
    // create a VirtualDom with the app component
    let mut app = VirtualDom::new(app);
    // rebuild the VirtualDom before rendering
    app.rebuild_in_place();

    // render the VirtualDom to HTML
    Html(dioxus_ssr::render(&app))
}
````

Finally, you can run it using `cargo run` rather than `dx serve`.

## Multithreaded Support

The Dioxus VirtualDom, sadly, is not currently `Send`. Internally, we use quite a bit of interior mutability which is not thread-safe.
When working with web frameworks that require `Send`, it is possible to render a VirtualDom immediately to a String â€“ but you cannot hold the VirtualDom across an await point. For retained-state SSR (essentially LiveView), you'll need to spawn a VirtualDom on its own thread and communicate with it via channels or create a pool of VirtualDoms.
You might notice that you cannot hold the VirtualDom across an await point. Because Dioxus is currently not ThreadSafe, it *must* remain on the thread it started. We are working on loosening this requirement.
# Liveview

Liveview allows apps to *run* on the server and *render* in the browser. It uses WebSockets to communicate between the server and the browser.

Examples:

* [Simple Example](https://github.com/DioxusLabs/dioxus/tree/v0.5/packages/liveview/examples/axum.rs)

## Support

Dioxus liveview will be migrated to [dioxus-fullstack](./fullstack/index.md) in a future release. Once this migration occurs, you may need to update your code. We plan for this migration to be minimal.

Liveview is currently limited in capability when compared to the Web platform. Liveview apps run on the server in a native thread. This means that browser APIs are not available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs are accessible, so streaming, WebSockets, filesystem, etc are all viable APIs.

## Router Integration

Currently, the Dioxus router does not integrate with the browser history in the liveview renderer. If you are interested in contributing this feature to Dioxus this issue is tracked [here](https://github.com/DioxusLabs/dioxus/issues/1038).

## Managing Latency

Liveview makes it incredibly convenient to talk to your server from the client, but there are some downsides. Mainly in Dioxus Liveview every interaction goes through the server by default.

Because of this, with the liveview renderer you need to be very deliberate about managing latency. Events that would be fast enough on other renderers like [controlled inputs](../reference/user_input.md), can be frustrating to use in the liveview renderer.

To get around this issue you can inject bits of javascript in your liveview application. If you use a raw attribute as a listener, you can inject some javascript that will be run when the event is triggered:

````rust
rsx! {
    div {
        input {
            "oninput": "console.log('input changed!')"
        }
    }
}
````
# Fullstack development

Dioxus Fullstack contains helpers for:

* Incremental, static, and server side rendering
* Hydrating your application on the Client
* Communicating between a server and a client

This guide will teach you everything you need to know about how to use the utilities in Dioxus fullstack to create amazing fullstack applications.

 > 
 > In addition to this guide, you can find more examples of full-stack apps and information about how to integrate with other frameworks and desktop renderers in the [dioxus-fullstack examples directory](https://github.com/DioxusLabs/dioxus/tree/v0.5/packages/fullstack/examples).
# Communicating with the server

`dioxus-fullstack` provides server functions that allow you to call an automatically generated API on the server from the client as if it were a local function.

To make a server function, simply add the `#[server(YourUniqueType)]` attribute to a function. The function must:

* Be an async function
* Have arguments and a return type that both implement serialize and deserialize (with [serde](https://serde.rs/)).
* Return a `Result` with an error type of ServerFnError

 > 
 > If you are targeting WASM on the server with WASI, you must call `register` on the type you passed into the server macro in your main function before starting your server to tell Dioxus about the server function. For all other targets, the server function will be registered automatically.

Let's continue building on the app we made in the [getting started](../../getting_started/index.md) guide. We will add a server function to our app that allows us to double the count on the server.

First, add serde as a dependency:

````shell
cargo add serde
````

Next, add the server function to your `main.rs`:

````rs@server_function.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;

fn main() {
    launch(App)
}

fn App() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
        button {
            onclick: move |_| {
                async move {
                    if let Ok(new_count) = double_server(count()).await {
                        count.set(new_count);
                    }
                }
            },
            "Double"
        }
    }
}

#[server]
async fn double_server(number: i32) -> Result<i32, ServerFnError> {
    // Perform some expensive computation or access a database on the server
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    let result = number * 2;
    println!("server calculated {result}");
    Ok(result)
}

````

Now, build your client-side bundle with `dx build --features web` and run your server with `cargo run --features ssr`. You should see a new button that multiplies the count by 2.

## Cached data fetching

One common use case for server functions is fetching data from the server:

````rs@server_data_fetch.rs
use dioxus::prelude::*;

fn main() {
    dioxus::launch(app)
}

fn app() -> Element {
    let mut count = use_resource(get_server_data);

    rsx! { "server data is {count.value():?}" }
}

#[server]
async fn get_server_data() -> Result<String, ServerFnError> {
    // Access a database
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    Ok("Hello from the server!".to_string())
}

````

If you navigate to the site above, you will first see `server data is None`, then after the `WASM` has loaded and the request to the server has finished, you will see `server data is Some(Ok("Hello from the server!"))`.

This approach works, but it can be slow. Instead of waiting for the client to load and send a request to the server, what if we could get all of the data we needed for the page on the server and send it down to the client with the initial HTML page?

This is exactly what the `use_server_future` hook allows us to do! `use_server_future` is similar to the `use_resource` hook, but it allows you to wait for a future on the server and send the result of the future down to the client.

Let's change our data fetching to use `use_server_future`:

````rs@server_data_prefetch.rs
#![allow(non_snake_case, unused)]

use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    let mut count = use_server_future(get_server_data)?;

    rsx! { "server data is {count.value():?}" }
}

#[server]
async fn get_server_data() -> Result<String, ServerFnError> {
    // Access a database
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    Ok("Hello from the server!".to_string())
}

````

 > 
 > Notice the `?` after `use_server_future`. This is what tells Dioxus fullstack to wait for the future to resolve before continuing rendering. If you want to not wait for a specific future, you can just remove the ? and deal with the `Option` manually.

Now when you load the page, you should see `server data is Ok("Hello from the server!")`. No need to wait for the `WASM` to load or wait for the request to finish!

````inject-dioxus
SandBoxFrame {
	url: "https://codesandbox.io/p/sandbox/dioxus-fullstack-server-future-qwpp4p?file=/src/main.rs:3,24"
}
````

## Running the client with dioxus-desktop

The project presented so far makes a web browser interact with the server, but it is also possible to make a desktop program interact with the server in a similar fashion. (The full example code is available in the [Dioxus repo](https://github.com/DioxusLabs/dioxus/tree/v0.5/packages/fullstack/examples/axum-desktop))

First, we need to make two binary targets, one for the desktop program (the `client.rs` file), one for the server (the `server.rs` file). The client app and the server functions are written in a shared `lib.rs` file.

The desktop and server targets have slightly different build configuration to enable additional dependencies or features.
The Cargo.toml in the full example has more information, but the main points are:

* the client.rs has to be run with the `desktop` feature, so that the optional `dioxus-desktop` dependency is included
* the server.rs has to be run with the `ssr` features; this will generate the server part of the server functions and will run our backend server.

Once you create your project, you can run the server executable with:

````bash
cargo run --bin server --features ssr
````

and the client desktop executable with:

````bash
cargo run --bin client --features desktop
````

### Client code

The client file is pretty straightforward. You only need to set the server url in the client code, so it knows where to send the network requests. Then, dioxus_desktop launches the app.

For development, the example project runs the server on `localhost:8080`. **Before you release remember to update the url to your production url.**

### Server code

In the server code, first you have to set the network address and port where the server will listen to.

````rs@server_function_desktop_client.rs
let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
    .await
    .unwrap();
println!("listening on http://127.0.0.1:3000");
````

Then, you have to register the types declared in the server function macros into the server.
For example, consider this server function:

````rs@server_function_desktop_client.rs
#[server(GetServerData)]
async fn get_server_data() -> Result<String, ServerFnError> {
    Ok("Hello from the server!".to_string())
}
````
# Extractors

Server functions are an ergonomic way to call a function on the server. Server function work by registering an endpoint on the server and using requests on the client. Most of the time, you shouldn't need to worry about how server functions operate, but there are some times when you need to get some value from the request other than the data passed in the server function.

For example, requests contain information about the user's browser (called the [user agent](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent)). We can use an extractor to retrieve that information.

You can use the `extract` method within a server function to extract something from the request. You can extract any type that implements `FromServerContext` (or when axum is enabled, you can use axum extractors directly):

````rs@server_function_extract.rs
#[server]
pub async fn log_headers() -> Result<(), ServerFnError> {
    let headers: http::HeaderMap = extract().await?;
    log::info!("{:?}", headers[http::header::USER_AGENT]);
    Ok(())
}
````
# Middleware

Extractors allow you to wrap your server function in some code that changes either the request or the response. Dioxus fullstack integrates with [Tower](https://docs.rs/tower/latest/tower/index.html) to allow you to wrap your server functions in middleware.

You can use the `#[middleware]` attribute to add a layer of middleware to your server function. Let's add a timeout middleware to a server function. This middleware will stop running the server function if it reaches a certain timeout:

````rs@server_function_middleware.rs
#[server]
// Add a timeout middleware to the server function that will return an error if the function takes longer than 1 second to execute
#[middleware(tower_http::timeout::TimeoutLayer::new(std::time::Duration::from_secs(1)))]
pub async fn timeout() -> Result<(), ServerFnError> {
    tokio::time::sleep(std::time::Duration::from_secs(2)).await;
    Ok(())
}
````
# Authentication

You can use [extractors](./extractors) to integrate auth with your Fullstack application.

You can create a custom extractors that extracts the auth session from the request. From that auth session, you can check if the user has the required privileges before returning the private data.

A [full auth example](https://github.com/DioxusLabs/dioxus/blob/v0.5/packages/fullstack/examples/axum-auth/src/main.rs) with the complete implementation is available in the fullstack examples.
# Routing

You can easily integrate your fullstack application with a client side router using Dioxus Router. This allows you to create different scenes in your app and navigate between them. You can read more about the router in the [router reference](../router.md)

````rs@server_router.rs
#![allow(non_snake_case)]

use axum::Router;
use dioxus::prelude::*;

use serde::{Deserialize, Serialize};

fn main() {
    launch(|| rsx! { Router::<Route> {} });
}

#[derive(Clone, Routable, Debug, PartialEq, Serialize, Deserialize)]
enum Route {
    #[route("/")]
    Home {},
    #[route("/blog/:id")]
    Blog { id: i32 },
}

#[component]
fn Blog(id: i32) -> Element {
    rsx! {
        Link { to: Route::Home {}, "Go to counter" }
        table {
            tbody {
                for _ in 0..id {
                    tr {
                        for _ in 0..id {
                            td { "hello world!" }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn Home() -> Element {
    let mut count = use_signal(|| 0);
    let mut text = use_signal(|| "...".to_string());

    rsx! {
        Link { to: Route::Blog { id: count() }, "Go to blog" }
        div {
            h1 { "High-Five counter: {count}" }
            button { onclick: move |_| count += 1, "Up high!" }
            button { onclick: move |_| count -= 1, "Down low!" }
            button {
                onclick: move |_| {
                    async move {
                        if let Ok(data) = get_server_data().await {
                            println!("Client received: {}", data);
                            text.set(data.clone());
                            post_server_data(data).await.unwrap();
                        }
                    }
                },
                "Run server function!"
            }
            "Server said: {text}"
        }
    }
}

#[server(PostServerData)]
async fn post_server_data(data: String) -> Result<(), ServerFnError> {
    println!("Server received: {}", data);

    Ok(())
}

#[server(GetServerData)]
async fn get_server_data() -> Result<String, ServerFnError> {
    Ok("Hello from the server!".to_string())
}

````

````inject-dioxus
SandBoxFrame {
	url: "https://codesandbox.io/p/sandbox/dioxus-fullstack-router-s75v5q?file=%2Fsrc%2Fmain.rs%3A7%2C1"
}
````
# Introduction

 > 
 > If you are not familiar with Dioxus itself, check out the [Dioxus guide](../guide/index.md) first.

Whether you are building a website, desktop app, or mobile app, splitting your app's views into "pages" can be an effective method for organization and maintainability.

For this purpose, Dioxus provides a router. Use the `cargo add` command to add the dependency:

````sh
cargo add dioxus@0.5.0 --features router
````

Then, add this to your `Dioxus.toml` (learn more about configuration [here](../CLI/configure)):

````toml
[web.watcher]
index_on_404 = true
````

 > 
 > This configuration only works when using `dx serve`. If you host your app in a different way (which you most likely do in production), you need to find out how to add a fallback 404 page to your app, and make it a copy of the generated `dist/index.html`.

This will instruct `dx serve` to redirect any unknown route to the index, to then be resolved by the router.
The router works on the client. If we connect through the index route (e.g., `localhost:8080`, then click a link to go to `localhost:8080/contact`), the app renders the new route without reloading.
However, when we go to a route *before* going to the index (go straight to `localhost:8080/contact`), we are trying to access a static route from the server, but the only static route on our server is the index (because the Dioxus frontend is a Single Page Application) and it will fail unless we redirect all missing routes to the index.

This book is intended to get you up to speed with Dioxus Router. It is split
into two sections:

1. The [reference](reference/index.md) section explains individual features in
   depth. You can read it from start to finish, or you can read individual chapters
   in whatever order you want.
1. If you prefer a learning-by-doing approach, you can check out the
   *[example project](example/index.md)*. It guides you through
   creating a dioxus app, setting up the router, and using some of its
   functionality.

 > 
 > Please note that this is not the only documentation for the Dioxus Router. You
 > can also check out the [API Docs](https://docs.rs/dioxus-router/).
# Overview

In this guide, you'll learn to effectively use Dioxus Router whether you're
building a small todo app or the next FAANG company. We will create a small
website with a blog, homepage, and more!

 > 
 > To follow along with the router example, you'll need a working Dioxus app.
 > Check out the [Dioxus book](https://dioxuslabs.com/learn/0.5/getting_started) to get started.

 > 
 > Make sure to add Dioxus Router as a dependency, as explained in the
 > [introduction](../index.md).

## You'll learn how to

* Create routes and render "pages".
* Utilize nested routes, create a navigation bar, and render content for a
  set of routes.
* Parse URL parameters to dynamically display content.
* Redirect visitors to different routes.

 > 
 > **Disclaimer**
 > 
 > The example will only display the features of Dioxus Router. It will not
 > include any actual functionality. To keep things simple we will only be using
 > a single file, this is not the recommended way of doing things with a real
 > application.

You can find the complete application in the [full code](full-code.md) chapter.
# Creating Our First Route

In this chapter, we will start utilizing Dioxus Router and add a homepage and a
404 page to our project.

## Fundamentals

The core of the Dioxus Router is the [`Routable`] macro and the [`Router`] component.

Routable is a trait for anything that can:

* Be parsed from a URL
* Be turned into a URL
* Be rendered as to a Element

Let's create a new router. First, we need an actual page to route to! Let's add a homepage component:

````rs@first_route.rs
#[component]
fn Home() -> Element {
    rsx! { h1 { "Welcome to the Dioxus Blog!" } }
}
````

## Creating Routes

We want to use Dioxus Router to separate our application into different "pages".
Dioxus Router will then determine which page to render based on the URL path.

To start using Dioxus Router, we need to use the [`Routable`] macro.

The [`Routable`] macro takes an enum with all of the possible routes in our application. Each variant of the enum represents a route and must be annotated with the `#[route(path)]` attribute.

````rs@first_route.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route("/")]
    Home {},
}
````

The [`Router`] component will provide a router context for all the inner components and hooks to use. You usually will want to place this at the top of your components tree.

````rs@first_route.rs
fn App() -> Element {
    rsx! { Router::<Route> {} }
}
````

If you head to your application's browser tab, you should now see the text
`Welcome to Dioxus Blog!` when on the root URL (`http://localhost:8080/`). If
you enter a different path for the URL, nothing should be displayed.

This is because we told Dioxus Router to render the `Home` component only when
the URL path is `/`.

## Fallback Route

In our example, when a route doesn't exist Dioxus Router doesn't render anything. Many sites also have a "404" page when a path does not exist. Let's add one to our site.

First, we create a new `PageNotFound` component.

````rs@catch_all.rs
#[component]
fn PageNotFound(route: Vec<String>) -> Element {
    rsx! {
        h1 { "Page not found" }
        p { "We are terribly sorry, but the page you requested doesn't exist." }
        pre { color: "red", "log:\nattemped to navigate to: {route:?}" }
    }
}
````

Next, register the route in the Route enum to match if all other routes fail.

````rs@catch_all.rs
#[derive(Routable, Clone)]
enum Route {
    #[route("/")]
    Home {},
    // PageNotFound is a catch all route that will match any route and placing the matched segments in the route field
    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}
````

Now when you go to a route that doesn't exist, you should see the page not found
text.

## Conclusion

In this chapter, we learned how to create a route and tell Dioxus Router what
component to render when the URL path is `/`. We also created a 404 page to
handle when a route doesn't exist. Next, we'll create the blog portion of our
site. We will utilize nested routes and URL parameters.
# Building a Nest

In this chapter, we will begin to build the blog portion of our site which will
include links, nested routes, and route parameters.

## Site Navigation

Our site visitors won't know all the available pages and blogs on our site so we
should provide a navigation bar for them. Our navbar will be a list of links going between our pages.

We want our navbar component to be rendered on several different pages on our site. Instead of duplicating the code, we can create a component that wraps all children routes. This is called a layout component. To tell the router where to render the child routes, we use the [`Outlet`](https://docs.rs/dioxus-router/latest/dioxus_router/components/fn.Outlet.html) component.

Let's create a new `NavBar` component:

````rs@nested_routes.rs
#[component]
fn NavBar() -> Element {
    rsx! {
        nav {
            ul { li { "links" } }
        }
        // The Outlet component will render child routes (In this case just the Home component) inside the Outlet component
        Outlet::<Route> {}
    }
}
````

Next, let's add our `NavBar` component as a layout to our Route enum:

````rs@nested_routes.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // All routes under the NavBar layout will be rendered inside of the NavBar Outlet
    #[layout(NavBar)]
        #[route("/")]
        Home {},
    #[end_layout]
    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}
````

To add links to our `NavBar`, we could always use an HTML anchor element but that has two issues:

1. It causes a full-page reload
1. We can accidentally link to a page that doesn't exist

Instead, we want to use the [`Link`] component provided by Dioxus Router.

The [`Link`] is similar to a regular `<a>` tag. It takes a target and children.

Unlike a regular `<a>` tag, we can pass in our Route enum as the target. Because we annotated our routes with the `#[route(path)]` attribute, the [`Link`] will know how to generate the correct URL. If we use the Route enum, the rust compiler will prevent us from linking to a page that doesn't exist.

Let's add our links:

````rs@links.rs
#[component]
fn NavBar() -> Element {
    rsx! {
        nav {
            Link { to: Route::Home {}, "Home" }
        }
        Outlet::<Route> {}
    }
}
````

 > 
 > Using this method, the [`Link`] component only works for links within our
 > application. To learn more about navigation targets see
 > [here](./navigation-targets.md).

Now you should see a list of links near the top of your page. Click on one and
you should seamlessly travel between pages.

## URL Parameters and Nested Routes

Many websites such as GitHub put parameters in their URL. For example,
`https://github.com/DioxusLabs` utilizes the text after the domain to
dynamically search and display content about an organization.

We want to store our blogs in a database and load them as needed. We also
want our users to be able to send people a link to a specific blog post.
Instead of listing all of the blog titles at compile time, we can make a dynamic route.

We could utilize a search page that loads a blog when clicked but then our users
won't be able to share our blogs easily. This is where URL parameters come in.

The path to our blog will look like `/blog/myBlogPage`, `myBlogPage` being the
URL parameter.

First, let's create a layout component (similar to the navbar) that wraps the blog content. This allows us to add a heading that tells the user they are on the blog.

````rs@dynamic_route.rs
#[component]
fn Blog() -> Element {
    rsx! {
        h1 { "Blog" }
        Outlet::<Route> {}
    }
}
````

Now we'll create another index component, that'll be displayed when no blog post
is selected:

````rs@dynamic_route.rs
#[component]
fn BlogList() -> Element {
    rsx! {
        h2 { "Choose a post" }
        ul {
            li {
                Link {
                    to: Route::BlogPost {
                        name: "Blog post 1".into(),
                    },
                    "Read the first blog post"
                }
            }
            li {
                Link {
                    to: Route::BlogPost {
                        name: "Blog post 2".into(),
                    },
                    "Read the second blog post"
                }
            }
        }
    }
}
````

We also need to create a component that displays an actual blog post. This component will accept the URL parameters as props:

````rs@dynamic_route.rs
// The name prop comes from the /:name route segment
#[component]
fn BlogPost(name: String) -> Element {
    rsx! { h2 { "Blog Post: {name}" } }
}
````

Finally, let's tell our router about those components:

````rs@dynamic_route.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
            #[route("/")]
            BlogList {},
            #[route("/post/:name")]
            BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
````

That's it! If you head to `/blog/1` you should see our sample post.

## Conclusion

In this chapter, we utilized Dioxus Router's Link, and Route Parameter
functionality to build the blog portion of our application. In the next chapter,
we will go over how navigation targets (like the one we passed to our links)
work.
# Navigation Targets

In the previous chapter, we learned how to create links to pages within our app.
We told them where to go using the `target` property. This property takes something that can be converted to a [`NavigationTarget`].

## What is a navigation target?

A [`NavigationTarget`] is similar to the `href` of an HTML anchor element. It
tells the router where to navigate to. The Dioxus Router knows two kinds of
navigation targets:

* [`Internal`]: We used internal links in the previous chapter. It's a link to a page within our
  app represented as a Route enum.
* [`External`]: This works exactly like an HTML anchors' `href`. Don't use this for in-app
  navigation as it will trigger a page reload by the browser.

## External navigation

If we need a link to an external page we can do it like this:

````rs@external_link.rs
fn GoToDioxus() -> Element {
    rsx! {
        Link { to: "https://dioxuslabs.com", "ExternalTarget target" }
    }
}
````
# Redirection Perfection

You're well on your way to becoming a routing master!

In this chapter, we will cover creating redirects

## Creating Redirects

A redirect is very simple. When dioxus encounters a redirect while finding out
what components to render, it will redirect the user to the target of the
redirect.

As a simple example, let's say you want user to still land on your blog, even
if they used the path `/myblog` or `/myblog/:name`.

Redirects are special attributes in the router enum that accept a route and a closure
with the route parameters. The closure should return a route to redirect to.

Let's add a redirect to our router enum:

````rs@full_example.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
                #[route("/")]
                BlogList {},
                #[route("/post/:name")]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest("/myblog")]
        #[redirect("/", || Route::BlogList {})]
        #[redirect("/:name", |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
````

That's it! Now your users will be redirected to the blog.

### Conclusion

Well done! You've completed the Dioxus Router guide. You've built a small
application and learned about the many things you can do with Dioxus Router.
To continue your journey, you attempt a challenge listed below, look at the [router examples](https://github.com/DioxusLabs/dioxus/tree/v0.5/packages/router/examples), or
the [API reference](https://docs.rs/dioxus-router/).

### Challenges

* Organize your components into separate files for better maintainability.
* Give your app some style if you haven't already.
* Build an about page so your visitors know who you are.
* Add a user system that uses URL parameters.
* Create a simple admin system to create, delete, and edit blogs.
* If you want to go to the max, hook up your application to a rest API and database.
# Full Code

````rs@full_example.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;

// ANCHOR: router
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
                #[route("/")]
                BlogList {},
                #[route("/post/:name")]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest("/myblog")]
        #[redirect("/", || Route::BlogList {})]
        #[redirect("/:name", |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
// ANCHOR_END: router

pub fn App() -> Element {
    rsx! {
        Router::<Route> {}
    }
}

#[component]
fn NavBar() -> Element {
    rsx! {
        nav {
            Link { to: Route::Home {}, "Home" }
            Link { to: Route::BlogList {}, "Blog" }
        }
        Outlet::<Route> {}
    }
}

#[component]
fn Home() -> Element {
    rsx! {
        h1 { "Welcome to the Dioxus Blog!" }
    }
}

#[component]
fn Blog() -> Element {
    rsx! {
        h1 { "Blog" }
        Outlet::<Route> {}
    }
}

#[component]
fn BlogList() -> Element {
    rsx! {
        h2 { "Choose a post" }
        ul {
            li {
                Link {
                    to: Route::BlogPost {
                        name: "Blog post 1".into(),
                    },
                    "Read the first blog post"
                }
            }
            li {
                Link {
                    to: Route::BlogPost {
                        name: "Blog post 2".into(),
                    },
                    "Read the second blog post"
                }
            }
        }
    }
}

#[component]
fn BlogPost(name: String) -> Element {
    rsx! {
        h2 { "Blog Post: {name}" }
    }
}

#[component]
fn PageNotFound(route: Vec<String>) -> Element {
    rsx! {
        h1 { "Page not found" }
        p { "We are terribly sorry, but the page you requested doesn't exist." }
        pre { color: "red", "log:\nattemped to navigate to: {route:?}" }
    }
}

````
# Adding the router to your application

In this chapter, we will learn how to add the router to our app. By itself, this
is not very useful. However, it is a prerequisite for all the functionality
described in the other chapters.

 > 
 > Make sure you added the `dioxus-router` dependency as explained in the
 > [introduction](../index.md).

In most cases, we want to add the router to the root component of our app. This
way, we can ensure that we have access to all its functionality everywhere.

First, we define the router with the router macro:

````rs@first_route.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route("/")]
    Home {},
}
````

Then we render the router with the \[`Router`\] component.

````rs@first_route.rs
fn App() -> Element {
    rsx! { Router::<Route> {} }
}
````
# Defining Routes

When creating a \[`Routable`\] enum, we can define routes for our application using the `route("path")` attribute.

## Route Segments

Each route is made up of segments. Most segments are separated by `/` characters in the path.

There are four fundamental types of segments:

1. [Static segments](#static-segments) are fixed strings that must be present in the path.
1. [Dynamic segments](#dynamic-segments) are types that can be parsed from a segment.
1. [Catch-all segments](#catch-all-segments) are types that can be parsed from multiple segments.
1. [Query segments](#query-segments) are types that can be parsed from the query string.

Routes are matched:

* First, from most specific to least specific (Static then Dynamic then Catch All) (Query is always matched)
* Then, if multiple routes match the same path, the order in which they are defined in the enum is followed.

## Static segments

Fixed routes match a specific path. For example, the route `#[route("/about")]` will match the path `/about`.

````rs@static_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // Routes always start with a slash
    #[route("/")]
    Home {},
    // You can have multiple segments in a route
    #[route("/hello/world")]
    HelloWorld {},
}

#[component]
fn Home() -> Element {
    todo!()
}

#[component]
fn HelloWorld() -> Element {
    todo!()
}
````

## Dynamic Segments

Dynamic segments are in the form of `:name` where `name` is
the name of the field in the route variant. If the segment is parsed
successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromStr`.

````rs@dynamic_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with : are dynamic segments
    #[route("/post/:name")]
    BlogPost {
        // You must include dynamic segments in child variants
        name: String,
    },

    #[route("/document/:id")]
    Document {
        // You can use any type that implements FromStr
        // If the segment can't be parsed, the route will not match
        id: usize,
    },
}

// Components must contain the same dynamic segments as their corresponding variant
#[component]
fn BlogPost(name: String) -> Element {
    todo!()
}

#[component]
fn Document(id: usize) -> Element {
    todo!()
}
````

## Catch All Segments

Catch All segments are in the form of `:..name` where `name` is the name of the field in the route variant. If the segments are parsed successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromSegments`. (`Vec<String>` implements this by default)

Catch All segments must be the *last route segment* in the path (query segments are not counted) and cannot be included in nests.

````rs@catch_all_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with :.. are catch all segments
    #[route("/blog/:..segments")]
    BlogPost {
        // You must include catch all segment in child variants
        segments: Vec<String>,
    },
}

// Components must contain the same catch all segments as their corresponding variant
#[component]
fn BlogPost(segments: Vec<String>) -> Element {
    todo!()
}
````

## Query Segments

Query segments are in the form of `?:name&:othername` where `name` and `othername` are the names of fields in the route variant.

Unlike [Dynamic Segments](#dynamic-segments) and [Catch All Segments](#catch-all-segments), parsing a Query segment must not fail.

The segment can be of any type that implements `FromQueryArgument`.

Query segments must be the *after all route segments* and cannot be included in nests.

````rs@query_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with ?: are query segments
    #[route("/blog?:name&:surname")]
    BlogPost {
        // You must include query segments in child variants
        name: String,
        surname: String,
    },
}

#[component]
fn BlogPost(name: String, surname: String) -> Element {
    rsx! {
        div { "This is your blogpost with a query segment:" }
        div { "Name: {name}" }
        div { "Surname: {surname}" }
    }
}
````
# Nested Routes

When developing bigger applications we often want to nest routes within each
other. As an example, we might want to organize a settings menu using this
pattern:

````plain
â”” Settings
  â”œ General Settings (displayed when opening the settings)
  â”œ Change Password
  â”” Privacy Settings
````

We might want to map this structure to these paths and components:

````plain
/settings		  -> Settings { GeneralSettings }
/settings/password -> Settings { PWSettings }
/settings/privacy  -> Settings { PrivacySettings }
````

Nested routes allow us to do this without repeating /settings in every route.

## Nesting

To nest routes, we use the `#[nest("path")]` and `#[end_nest]` attributes.

The path in nest must not:

1. Contain a [Catch All Segment](index.md#catch-all-segments)
1. Contain a [Query Segment](index.md#query-segments)

If you define a dynamic segment in a nest, it will be available to all child routes and layouts.

To finish a nest, we use the `#[end_nest]` attribute or the end of the enum.

````rs@nest.rs
#[derive(Routable, Clone)]
// Skipping formatting allows you to indent nests
#[rustfmt::skip]
enum Route {
    // Start the /blog nest
    #[nest("/blog")]
        // You can nest as many times as you want
        #[nest("/:id")]
            #[route("/post")]
            PostId {
                // You must include parent dynamic segments in child variants
                id: usize,
            },
        // End nests manually with #[end_nest]
        #[end_nest]
        #[route("/:id")]
        // The absolute route of BlogPost is /blog/:name
        BlogPost {
            id: usize,
        },
    // Or nests are ended automatically at the end of the enum
}

#[component]
fn BlogPost(id: usize) -> Element {
    todo!()
}

#[component]
fn PostId(id: usize) -> Element {
    todo!()
}
````
# Layouts

Layouts allow you to wrap all child routes in a component. This can be useful when creating something like a header that will be used in many different routes.

[`Outlet`] tells the router where to render content in layouts. In the following example,
the Index will be rendered within the [`Outlet`].

This page is built with Dioxus. It uses Layouts in several different places. Here is an outline of how layouts are used on the current page:

````inject-dioxus
LayoutsExplanation {}
````

Here is a more complete example of a layout wrapping the body of a page.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/")]
        Index {},
}

#[component]
fn Wrapper() -> Element {
    rsx! {
        header { "header" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index() -> Element {
    rsx! { h1 { "Index" } }
}
````

The example above will output the following HTML (line breaks added for
readability):

````html
<header>header</header>
<h1>Index</h1>
<footer>footer</footer>
````

## Layouts with dynamic segments

You can combine layouts with [nested routes](./routes/nested.md) to create dynamic layouts with content that changes based on the current route.

Just like routes, layouts components must accept a prop for each dynamic segment in the route. For example, if you have a route with a dynamic segment like `/:name`, your layout component must accept a `name` prop:

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[nest("/:name")]
        #[layout(Wrapper)]
            #[route("/")]
            Index {
                name: String,
            },
}

#[component]
fn Wrapper(name: String) -> Element {
    rsx! {
        header { "Welcome {name}!" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index(name: String) -> Element {
    rsx! { h1 { "This is a homepage for {name}" } }
}
````

Or to get the full route, you can use the `use_route` hook.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/:name")]
        Index {
            name: String,
        },
}

#[component]
fn Wrapper() -> Element {
    let full_route = use_route::<Route>();
    rsx! {
        header { "Welcome to {full_route}!" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index(name: String) -> Element {
    rsx! { h1 { "This is a homepage for {name}" } }
}
````
# Links & Navigation

When we split our app into pages, we need to provide our users with a way to
navigate between them. On regular web pages, we'd use an anchor element for that,
like this:

````html
<a href="/other">Link to an other page</a>
````

However, we cannot do that when using the router for three reasons:

1. Anchor tags make the browser load a new page from the server. This takes a
   lot of time, and it is much faster to let the router handle the navigation
   client-side.
1. Navigation using anchor tags only works when the app is running inside a
   browser. This means we cannot use them inside apps using Dioxus Desktop.
1. Anchor tags cannot check if the target page exists. This means we cannot
   prevent accidentally linking to non-existent pages.

To solve these problems, the router provides us with a \[`Link`\] component we can
use like this:

````rs@links.rs
#[component]
fn NavBar() -> Element {
    rsx! {
        nav {
            Link { to: Route::Home {}, "Home" }
        }
        Outlet::<Route> {}
    }
}
````

The `target` in the example above is similar to the `href` of a regular anchor
element. However, it tells the router more about what kind of navigation it
should perform. It accepts something that can be converted into a
\[`NavigationTarget`\]:

* The example uses a Internal route. This is the most common type of navigation.
  It tells the router to navigate to a page within our app by passing a variant of a \[`Routable`\] enum. This type of navigation can never fail if the link component is used inside a router component.
* \[`External`\] allows us to navigate to URLs outside of our app. This is useful
  for links to external websites. NavigationTarget::External accepts an URL to navigate to. This type of navigation can fail if the URL is invalid.

 > 
 > The \[`Link`\] accepts several props that modify its behavior. See the API docs
 > for more details.
# Programmatic Navigation

Sometimes we want our application to navigate to another page without having the
user click on a link. This is called programmatic navigation.

## Using a Navigator

We can get a navigator with the [`navigator`] function which returns a [`Navigator`].

We can use the [`Navigator`] to trigger four different kinds of navigation:

* `push` will navigate to the target. It works like a regular anchor tag.
* `replace` works like `push`, except that it replaces the current history entry
  instead of adding a new one. This means the prior page cannot be restored with the browser's back button.
* `Go back` works like the browser's back button.
* `Go forward` works like the browser's forward button.

````rs@navigator.rs
#[component]
fn Home() -> Element {
    let nav = navigator();

    // push
    nav.push(Route::PageNotFound { route: vec![] });

    // replace
    nav.replace(Route::Home {});

    // go back
    nav.go_back();

    // go forward
    nav.go_forward();

    rsx! { h1 { "Welcome to the Dioxus Blog!" } }
}
````

You might have noticed that, like [`Link`], the [`Navigator`]s `push` and
`replace` functions take a [`NavigationTarget`]. This means we can use either
`Internal`, or `External` targets.

## External Navigation Targets

Unlike a [`Link`], the [`Navigator`] cannot rely on the browser (or webview) to
handle navigation to external targets via a generated anchor element.

This means, that under certain conditions, navigation to external targets can
fail.
# History Providers

\[`HistoryProvider`\]s are used by the router to keep track of the navigation history
and update any external state (e.g. the browser's URL).

The router provides two \[`HistoryProvider`\]s, but you can also create your own.
The two default implementations are:

* The \[`MemoryHistory`\] is a custom implementation that works in memory.
* The \[`LiveviewHistory`\] is a custom implementation that works with the liveview renderer.
* The \[`WebHistory`\] integrates with the browser's URL.

By default, the router uses the \[`MemoryHistory`\]. It might be changed to use
\[`WebHistory`\] when the `web` feature is active, but that is not guaranteed.

You can override the default history:

````rs@history_provider.rs
#[component]
fn App() -> Element {
    rsx! {Router::<Route> { config: || RouterConfig::default().history(WebHistory::default()) }}
}
````
# History Buttons

Some platforms, like web browsers, provide users with an easy way to navigate
through an app's history. They have UI elements or integrate with the OS.

However, native platforms usually don't provide such amenities, which means that
apps wanting users to have access to them, need to implement them. For this
reason, the router comes with two components, which emulate a browser's back and
forward buttons:

* [`GoBackButton`]
* [`GoForwardButton`]

 > 
 > If you want to navigate through the history programmatically, take a look at
 > [`programmatic navigation`](./navigation/programmatic.md).

````rs@history_buttons.rs
fn HistoryNavigation() -> Element {
    rsx! {
        GoBackButton { "Back to the Past" }
        GoForwardButton { "Back to the Future" }
    }
}
````

As you might know, browsers usually disable the back and forward buttons if
there is no history to navigate to. The router's history buttons try to do that
too, but depending on the \[history provider\] that might not be possible.

Importantly, neither `WebHistory` supports that feature.
This is due to limitations of the browser History API.

However, in both cases, the router will just ignore button presses, if there is
no history to navigate to.

Also, when using `WebHistory`, the history buttons might
navigate a user to a history entry outside your app.
# Routing Update Callback

In some cases, we might want to run custom code when the current route changes. For this reason, the [`RouterConfig`] exposes an `on_update` field.

## How does the callback behave?

The `on_update` is called whenever the current routing information changes. It is called after the router updated its internal state, but before dependent components and hooks are updated.

If the callback returns a [`NavigationTarget`], the router will replace the current location with the specified target. It will not call the `on_update` again.

If at any point the router encounters a navigation failure, it will go to the appropriate state without calling the `on_update`. It doesn't matter if the invalid target initiated the navigation, was found as a redirect target, or was returned by the `on_update` itself.

## Code Example

````rs@routing_update.rs
#[derive(Routable, Clone, PartialEq)]
enum Route {
    #[route("/")]
    Index {},
    #[route("/home")]
    Home {},
}

#[component]
fn Home() -> Element {
    rsx! {
        p { "Home" }
    }
}

#[component]
fn Index() -> Element {
    rsx! {
        p { "Index" }
    }
}

fn app() -> Element {
    rsx! {
        Router::<Route> {
            config: || {
                RouterConfig::default()
                    .on_update(|state| {
                        (state.current() == Route::Index {})
                            .then_some(NavigationTarget::Internal(Route::Home {}))
                    })
            },
        }
    }
}
````
# Cookbook

The cookbook contains common recipes for different patterns within Dioxus.

There are a few different sections in the cookbook:

* [Publishing](publishing.md) will teach you how to present your app in a variety of delicious forms.
* Explore the [Anti-patterns](antipatterns.md) section to discover what ingredients to avoid when preparing your application.
* Within [Error Handling](error_handling.md), we'll master the fine art of managing spoiled ingredients in Dioxus.
* Take a culinary journey through [State management](state/index.md), where we'll explore the world of handling local, global, and external state in Dioxus.
* [Integrations](integrations/index.md) will guide you how to seamlessly blend external libraries into your Dioxus culinary creations.
* [Testing](testing.md) explains how to examine the unique flavor of Dioxus-specific features, like components.
* [Tailwind](tailwind.md) reveals the secrets of combining your Tailwind and Dioxus ingredients into a complete meal. You will also learn about using other NPM ingredients (packages) with Dioxus.
* In the [Custom Renderer](custom_renderer.md) section, we embark on a cooking adventure, inventing new ways to cook with Dioxus!
* [Optimizing](optimizing.md) will show you how to maximize the quality of your ingredients.
# Publishing

After you have build your application, you will need to publish it somewhere. This reference will outline different methods of publishing your desktop or web application.

## Web: Publishing with GitHub Pages

Edit your `Dioxus.toml` to point your `out_dir` to the `docs` folder and the `base_path` to the name of your repo:

````toml
[application]
# ...
out_dir = "docs"

[web.app]
base_path = "your_repo"
````

Then build your app and publish it to Github:

* Make sure GitHub Pages is set up for your repo to publish any static files in the docs directory
* Build your app with:

````sh
dx build --release
````

* Make a copy of your `docs/index.html` file and rename the copy to `docs/404.html` so that your app will work with client-side routing
* Add and commit with git
* Push to GitHub

## Desktop: Creating an installer

Dioxus desktop app uses your operating system's WebView library, so it's portable to be distributed for other platforms.

In this section, we'll cover how to bundle your app for macOS, Windows, and Linux.

## Preparing your application for bundling

Depending on your platform, you may need to add some additional code to your `main.rs` file to make sure your app is ready for bundling. On Windows, you'll need to add the `#![windows_subsystem = "windows"]` attribute to your `main.rs` file to hide the terminal window that pops up when you run your app. **If you're developing on Windows, only use this when bundling.** It will disable the terminal, so you will not get logs of any kind. You can gate it behind a feature, like so:

````toml
# Cargo.toml
[features]
bundle = []
````

And then your `main.rs`:

````rust
#![cfg_attr(feature = "bundle", windows_subsystem = "windows")]
````

## Adding assets to your application

If you want to bundle assets with your application, you can either use them with the `manganis` crate (covered more in the [assets](../reference/assets.md) page), or you can include them in your `Dioxus.toml` file:

````toml
[bundle]
# The list of files to include in the bundle. These can contain globs.
resources = ["main.css", "header.svg", "**/*.png"]
````

## Install `dioxus CLI`

The first thing we'll do is install the [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/v0.5/packages/cli). This extension to cargo will make it very easy to package our app for the various platforms.

To install, simply run

`cargo install dioxus-cli`

## Building

To bundle your application you can simply run `dx bundle --release` (also add `--features bundle` if you're using that, see the [this](#preparing-your-application-for-bundling) for more) to produce a final app with all the optimizations and assets builtin.

Once you've ran the command, your app should be accessible in `dist/bundle/`.

For example, a macOS app would look like this:

![Published App](/assets/static/publish.png)

Nice! And it's only 4.8 Mb â€“ extremely lean!! Because Dioxus leverages your platform's native WebView, Dioxus apps are extremely memory efficient and won't waste your battery.

 > 
 > Note: not all CSS works the same on all platforms. Make sure to view your app's CSS on each platform â€“ or web browser (Firefox, Chrome, Safari) before publishing.
# Antipatterns

This example shows what not to do and provides a reason why a given pattern is considered an "AntiPattern". Most anti-patterns are considered wrong for performance or code re-usability reasons.

## Unnecessarily Nested Fragments

Fragments don't mount a physical element to the DOM immediately, so Dioxus must recurse into its children to find a physical DOM node. This process is called "normalization". This means that deeply nested fragments make Dioxus perform unnecessary work. Prefer one or two levels of fragments / nested components until presenting a true DOM element.

Only Component and Fragment nodes are susceptible to this issue. Dioxus mitigates this with components by providing an API for registering shared state without the Context Provider pattern.

````rs@anti_patterns.rs
// âŒ Don't unnecessarily nest fragments
let _ = rsx! {
    Fragment {
        Fragment {
            Fragment {
                Fragment {
                    Fragment { div { "Finally have a real node!" } }
                }
            }
        }
    }
};

// âœ… Render shallow structures
rsx! { div { "Finally have a real node!" } }
````

## Incorrect Iterator Keys

As described in the [dynamic rendering chapter](../reference/dynamic_rendering#the-key-attribute), list items must have unique keys that are associated with the same items across renders. This helps Dioxus associate state with the contained components and ensures good diffing performance. Do not omit keys, unless you know that the list will never change.

````rs@anti_patterns.rs
let data: &HashMap<_, _> = &props.data;

// âŒ No keys
rsx! {
    ul {
        for value in data.values() {
            li { "List item: {value}" }
        }
    }
};

// âŒ Using index as keys
rsx! {
    ul {
        for (index , value) in data.values().enumerate() {
            li { key: "{index}", "List item: {value}" }
        }
    }
};

// âœ… Using unique IDs as keys:
rsx! {
    ul {
        for (key , value) in props.data.iter() {
            li { key: "{key}", "List item: {value}" }
        }
    }
}
````

## Avoid Interior Mutability in Props

While it is technically acceptable to have a `Mutex` or a `RwLock` in the props, they will be difficult to use.

Suppose you have a struct `User` containing the field `username: String`. If you pass a `Mutex<User>` prop to a `UserComponent` component, that component may wish to write to the `username` field. However, when it does, the parent component will not be aware of the change, and the component will not re-render which causes the UI to be out of sync with the state. Instead, consider passing down a reactive value like a `Signal` or immutable data.

````rs@anti_patterns.rs
// âŒ Mutex/RwLock/RefCell in props
#[derive(Props, Clone)]
struct AntipatternInteriorMutability {
    map: Rc<RefCell<HashMap<u32, String>>>,
}

impl PartialEq for AntipatternInteriorMutability {
    fn eq(&self, other: &Self) -> bool {
        std::rc::Rc::ptr_eq(&self.map, &other.map)
    }
}

fn AntipatternInteriorMutability(map: Rc<RefCell<HashMap<u32, String>>>) -> Element {
    rsx! {
        button {
            onclick: {
                let map = map.clone();
                move |_| {
                    // Writing to map will not rerun any components
                    map.borrow_mut().insert(0, "Hello".to_string());
                }
            },
            "Mutate map"
        }
        // Since writing to map will not rerun any components, this will get out of date
        "{map.borrow().get(&0).unwrap()}"
    }
}

// âœ… Use a signal to pass mutable state
#[component]
fn AntipatternInteriorMutabilitySignal(map: Signal<HashMap<u32, String>>) -> Element {
    rsx! {
        button {
            onclick: move |_| {
                // Writing to map will rerun any components that read the map
                map.write().insert(0, "Hello".to_string());
            },
            "Mutate map"
        }
        // Since writing to map will rerun subscribers, this will get updated
        "{map.read().get(&0).unwrap()}"
    }
}
````

## Avoid Updating State During Render

Every time you update the state, Dioxus needs to re-render the component â€“ this is inefficient! Consider refactoring your code to avoid this.

Also, if you unconditionally update the state during render, it will be re-rendered in an infinite loop.

````rs@anti_patterns.rs
// âŒ Updating state in render
let first_signal = use_signal(|| 0);
let mut second_signal = use_signal(|| 0);

// Updating the state during a render can easily lead to infinite loops
if first_signal() + 1 != second_signal() {
    second_signal.set(first_signal() + 1);
}

// âœ… Update state in an effect
let first_signal = use_signal(|| 0);
let mut second_signal = use_signal(|| 0);

// The closure you pass to use_effect will be rerun whenever any of the dependencies change without re-rendering the component
use_effect(move || {
    if first_signal() + 1 != second_signal() {
        second_signal.set(first_signal() + 1);
    }
});

// âœ… Deriving state with use_memo
let first_signal = use_signal(|| 0);
// Memos are specifically designed for derived state. If your state fits this pattern, use it.
let second_signal = use_memo(move || first_signal() + 1);
````

## Avoid Large Groups of State

It can be tempting to have a single large state struct that contains all of your application's state. However, this can lead to issues:

* It can be easy to accidentally mutate the state in a way that causes an infinite loop
* It can be difficult to reason about when and how the state is updated
* It can lead to performance issues because many components will need to re-render when the state changes

Instead, consider breaking your state into smaller, more manageable pieces. This will make it easier to reason about the state, avoid update loops, and improve performance.

````rs@anti_patterns.rs
fn app() -> Element {
    // âŒ Large state struct
    #[derive(Props, Clone, PartialEq)]
    struct LargeState {
        users: Vec<User>,
        logged_in: bool,
        warnings: Vec<String>,
    }

    #[derive(Props, Clone, PartialEq)]
    struct User {
        name: String,
        email: String,
    }

    let mut all_my_state = use_signal(|| LargeState {
        users: vec![User {
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        }],
        logged_in: true,
        warnings: vec![],
    });

    use_effect(move || {
        // It is very easy to accidentally read and write to the state object if it contains all your state
        let read = all_my_state.read();
        let logged_in = read.logged_in;
        if !logged_in {
            all_my_state
                .write_unchecked()
                .warnings
                .push("You are not logged in".to_string());
        }
    });

    // âœ… Use multiple signals to manage state
    let users = use_signal(|| {
        vec![User {
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        }]
    });
    let logged_in = use_signal(|| true);
    let mut warnings = use_signal(|| vec![]);

    use_effect(move || {
        // Now you can read and write to separate signals which will not cause issues
        if !logged_in() {
            warnings.write().push("You are not logged in".to_string());
        }
    });

    // âœ… Use memos to create derived state when larger states are unavoidable
    // Notice we didn't split everything into separate signals. Users still make sense as a vec of data
    let users = use_signal(|| {
        vec![User {
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        }]
    });
    let logged_in = use_signal(|| true);
    let warnings: Signal<Vec<String>> = use_signal(|| vec![]);

    // In child components, you can use the memo to create derived that will only update when a specific part of the state changes
    // This will help you avoid unnecessary re-renders and infinite loops
    #[component]
    fn FirstUser(users: Signal<Vec<User>>) -> Element {
        let first_user = use_memo(move || users.read().first().unwrap().clone());

        rsx! {
            div {
                "First user: {first_user().name}"
            }
        }
    }

    rsx! {
        FirstUser {
            users
        }
    }
}
````

## Running Non-Deterministic Code in the Body of a Component

If you have a component that contains non-deterministic code, that code should generally not be run in the body of the component. If it is put in the body of the component, it will be executed every time the component is re-rendered which can lead to performance issues.

Instead, consider moving the non-deterministic code into a hook that only runs when the component is first created or an effect that reruns when dependencies change.

````rs@anti_patterns.rs
// âŒ Non-deterministic code in the body of a component
#[component]
fn NonDeterministic(name: String) -> Element {
    let my_random_id = rand::random::<u64>();

    rsx! {
        div {
            // Id will change every single time the component is re-rendered
            id: "{my_random_id}",
            "Hello {name}"
        }
    }
}

// âœ… Use a hook to run non-deterministic code
fn NonDeterministicHook(name: String) -> Element {
    // If you store the result of the non-deterministic code in a hook, it will stay the same between renders
    let my_random_id = use_hook(|| rand::random::<u64>());

    rsx! {
        div {
            id: "{my_random_id}",
            "Hello {name}"
        }
    }
}
````

## Overly Permissive PartialEq for Props

You may have noticed that `Props` requires a `PartialEq` implementation. That `PartialEq` is very important for Dioxus to work correctly. It is used to determine if a component should re-render or not when the parent component re-renders.

If you cannot derive `PartialEq` for your `Props`, you will need to implement it yourself. If you do implement `PartialEq`, make sure to return `false` any time the props change in a way that would cause the UI in the child component to change.

In general, returning `false` from `PartialEq` if you aren't sure if the props have changed or not is better than returning `true`. This will help you avoid out of date UI in your child components.

````rs@anti_patterns.rs
// âŒ Permissive PartialEq for Props
#[derive(Props, Clone)]
struct PermissivePartialEqProps {
    name: String,
}

// This will cause the component to **never** re-render when the parent component re-renders
impl PartialEq for PermissivePartialEqProps {
    fn eq(&self, _: &Self) -> bool {
        true
    }
}

fn PermissivePartialEq(name: PermissivePartialEqProps) -> Element {
    rsx! {
        div {
            "Hello {name.name}"
        }
    }
}

#[component]
fn PermissivePartialEqParent() -> Element {
    let name = use_signal(|| "Alice".to_string());

    rsx! {
        PermissivePartialEq {
            // The PermissivePartialEq component will not get the updated value of name because the PartialEq implementation says that the props are the same
            name: name()
        }
    }
}

// âœ… Derive PartialEq for Props
#[derive(Props, Clone, PartialEq)]
struct DerivePartialEqProps {
    name: String,
}

fn DerivePartialEq(name: DerivePartialEqProps) -> Element {
    rsx! {
        div {
            "Hello {name.name}"
        }
    }
}

#[component]
fn DerivePartialEqParent() -> Element {
    let name = use_signal(|| "Alice".to_string());

    rsx! {
        DerivePartialEq {
            name: name()
        }
    }
}

// âœ… Return false from PartialEq if you are unsure if the props have changed
#[derive(Debug)]
struct NonPartialEq;

#[derive(Props, Clone)]
struct RcPartialEqProps {
    name: Rc<NonPartialEq>,
}

impl PartialEq for RcPartialEqProps {
    fn eq(&self, other: &Self) -> bool {
        // This will almost always return false because the Rc will likely point to a different value
        // Implementing PartialEq for NonPartialEq would be better, but if it is controlled by another library, it may not be possible
        // **Always** return false if you are unsure if the props have changed
        std::rc::Rc::ptr_eq(&self.name, &other.name)
    }
}

fn RcPartialEq(name: RcPartialEqProps) -> Element {
    rsx! {
        div {
            "Hello {name.name:?}"
        }
    }
}

fn RcPartialEqParent() -> Element {
    let name = use_signal(|| Rc::new(NonPartialEq));

    rsx! {
        RcPartialEq {
            // Generally, RcPartialEq will rerun even if the value of name hasn't actually changed because the Rc will point to a different value
            name: name()
        }
    }
}
````
# Error handling

A selling point of Rust for web development is the reliability of always knowing where errors can occur and being forced to handle them

However, we haven't talked about error handling at all in this guide! In this chapter, we'll cover some strategies in handling errors to ensure your app never crashes.

## The simplest â€“ returning None

Astute observers might have noticed that `Element` is actually a type alias for `Option<VNode>`. You don't need to know what a `VNode` is, but it's important to recognize that we could actually return nothing at all:

````rs@error_handling.rs
fn App() -> Element {
    None
}
````

This lets us add in some syntactic sugar for operations we think *shouldn't* fail, but we're still not confident enough to "unwrap" on.

 > 
 > The nature of `Option<VNode>` might change in the future as the `try` trait gets upgraded.

````rs@error_handling.rs
fn App() -> Element {
    // immediately return "None"
    let name = use_hook(|| Some("hi"))?;

    todo!()
}
````

## Early return on result

Because Rust can't accept both Options and Results with the existing try infrastructure, you'll need to manually handle Results. This can be done by converting them into Options or by explicitly handling them. If you choose to convert your Result into an Option and bubble it with a `?`, keep in mind that if you do hit an error you will lose error information and nothing will be rendered for that component.

````rs@error_handling.rs
fn App() -> Element {
    // Convert Result to Option
    let name: i32 = use_hook(|| "1.234").parse().ok()?;

    // Early return
    let count = use_hook(|| "1.234");
    let val: i32 = match count.parse() {
        Ok(val) => val,
        Err(err) => return rsx! {"Parsing failed"},
    };

    todo!()
}
````

Notice that while hooks in Dioxus do not like being called in conditionals or loops, they *are* okay with early returns. Returning an error state early is a completely valid way of handling errors.

## Match results

The next "best" way of handling errors in Dioxus is to match on the error locally. This is the most robust way of handling errors, but it doesn't scale to architectures beyond a single component.

To do this, we simply have an error state built into our component:

````rs@error_handling.rs
let mut error = use_signal(|| None);
````

Whenever we perform an action that generates an error, we'll set that error state. We can then match on the error in a number of ways (early return, return Element, etc).

````rs@error_handling.rs
fn Commandline() -> Element {
    let mut error = use_signal(|| None);

    match error() {
        Some(error) => rsx! { h1 { "An error occurred" } },
        None => rsx! { input { oninput: move |_| error.set(Some("bad thing happened!")) } },
    }
}
````

## Passing error states through components

If you're dealing with a handful of components with minimal nesting, you can just pass the error handle into child components.

````rs@error_handling.rs
fn Commandline() -> Element {
    let error = use_signal(|| None);

    if let Some(error) = error() {
        return rsx! {"An error occurred"};
    }

    rsx! {
        Child { error }
        Child { error }
        Child { error }
        Child { error }
    }
}

#[component]
fn Child(error: Signal<Option<&'static str>>) -> Element {
    rsx! { input { oninput: move |_| error.set(Some("bad thing happened!")) } }
}
````

Much like before, our child components can manually set the error during their own actions. The advantage to this pattern is that we can easily isolate error states to a few components at a time, making our app more predictable and robust.

## Throwing errors

Dioxus provides a much easier way to handle errors: throwing them. Throwing errors combines the best parts of an error state and early return: you can easily throw and error with `?`, but you keep information about the error so that you can handle it in a parent component.

You can call `throw` on any `Result` type that implements `Debug` to turn it into an error state and then use `?` to return early if you do hit an error. You can capture the error state with an `ErrorBoundary` component that will render the a different component if an error is thrown in any of its children.

````rs@error_handling.rs
fn Parent() -> Element {
    rsx! {
        ErrorBoundary {
            handle_error: |error| {
                rsx! {
                    "Oops, we encountered an error. Please report {error} to the developer of this application"
                }
            },
            ThrowsError {}
        }
    }
}

fn ThrowsError() -> Element {
    let name: i32 = use_hook(|| "1.234").parse().throw()?;

    todo!()
}
````

You can even nest `ErrorBoundary` components to capture errors at different levels of your app.

````rs@error_handling.rs
fn App() -> Element {
    rsx! {
        ErrorBoundary {
            handle_error: |error| {
                rsx! {
                    "Hmm, something went wrong. Please report {error} to the developer of this application"
                }
            },
            Parent {}
        }
    }
}

fn Parent() -> Element {
    rsx! {
        ErrorBoundary {
            handle_error: |error| {
                rsx! {
                    "The child component encountered an error: {error}"
                }
            },
            ThrowsError {}
        }
    }
}

fn ThrowsError() -> Element {
    let name: i32 = use_hook(|| "1.234").parse().throw()?;

    todo!()
}
````

This pattern is particularly helpful whenever your code generates a non-recoverable error. You can gracefully capture these "global" error states without panicking or handling state for each error yourself.
This section of the guide provides getting started guides for common tools used with Dioxus.

* [Logging](./logging.md)
* [Internationalization](./internationalization.md)
# Logging

Dioxus has a wide range of supported platforms, each with their own logging requirements. We'll discuss the different options available for your projects.

#### The Tracing Crate

The [Tracing](https://crates.io/crates/tracing) crate is the logging interface that the Dioxus library uses. It is not required to use the Tracing crate, but you will not recieve logs from the Dioxus library.

The Tracing crate provides a variety of simple `println`-like macros with varying levels of severity.
The available macros are as follows with the highest severity on the bottom:

````rs
fn main() {
    tracing::trace!("trace");
    tracing::debug!("debug");
    tracing::info!("info");
    tracing::warn!("warn");
    tracing::error!("error");
}
````

All the loggers provided on this page are, besides configuration and initialization, interfaced using these macros. Often you will also utilize the Tracing crate's `Level` enum. This enum usually represents the maximum log severity you want your application to emit and can be loaded from a variety of sources such as configuration file, environment variable, and more.

For more information, visit the Tracing crate's [docs](https://docs.rs/tracing/latest/tracing/).

## Dioxus Logger

[Dioxus Logger](https://crates.io/crates/dioxus-logger) is a logging utility that will start the appropriate logger for the platform. Currently every platform except mobile is supported.

To use Dioxus Logger, call the `init()` function:

````rs
use tracing::Level;

fn main() {
    // Init logger
    dioxus_logger::init(Level::INFO).expect("failed to init logger");
    // Dioxus launch code
}
````

The `dioxus_logger::init()` function initializes Dioxus Logger with the appropriate tracing logger using the default configuration and provided `Level`.

#### Platform Intricacies

On web, Dioxus Logger will use [tracing-wasm](https://crates.io/crates/tracing-wasm). On Desktop and server-based targets, Dioxus Logger will use [tracing-subscriber](https://crates.io/crates/tracing-subscriber)'s `FmtSubscriber`.

#### Final Notes

Dioxus Logger is the preferred logger to use with Dioxus if it suites your needs. There are more features to come and Dioxus Logger is planned to become an integral part of Dioxus. If there are any feature suggestions or issues with Dioxus Logger, feel free to reach out on the [Dioxus Discord Server](https://discord.gg/XgGxMSkvUM)!

For more information, visit Dioxus Logger's [docs](https://docs.rs/dioxus-logger/latest/dioxus_logger/).

## Desktop and Server

For Dioxus' desktop and server targets, you can generally use the logger of your choice.

Some popular options are:

* [tracing-subscriber](https://crates.io/crates/tracing-subscriber)'s `FmtSubscriber` for console output.
* [tracing-appender](https://crates.io/crates/tracing-appender) for logging to files.
* [tracing-bunyan-formatter](https://crates.io/crates/tracing-bunyan-formatter) for the Bunyan format.

To keep this guide short, we will not be covering the usage of these crates.

For a full list of popular tracing-based logging crates, visit [this](https://docs.rs/tracing/latest/tracing/#related-crates) list in the Tracing crate's docs.

## Web

[tracing-wasm](https://crates.io/crates/tracing-wasm) is a logging interface that can be used with Dioxus' web platform.

The easiest way to use WASM Logger is with the `set_as_global_default` function:

````rs
fn main() {
    // Init logger
    tracing_wasm::set_as_global_default();
    // Dioxus code
}
````

This starts tracing with a `Level` of `Trace`.

Using a custom `level` is a little trickier. We need to use the `WasmLayerConfigBuilder` and start the logger with `set_as_global_default_with_config()`:

````rs
use tracing::Level;

fn main() {
    // Init logger
    let tracing_config = tracing_wasm::WASMLayerConfigBuilder::new().set_max_level(Level::INFO).build();
    tracing_wasm::set_as_global_default_with_config(tracing_config);
    // Dioxus code
}
````

# Mobile

Unfortunately there are no tracing crates that work with mobile targets. As an alternative you can use the [log](https://crates.io/crates/log) crate.

## Android

[Android Logger](https://crates.io/crates/android_logger) is a logging interface that can be used when targeting Android. Android Logger runs whenever an event `native_activity_create` is called by the Android system:

````rs
use log::LevelFilter;
use android_logger::Config;

fn native_activity_create() {
    android_logger::init_once(
        Config::default()
            .with_max_level(LevelFilter::Info)
            .with_tag("myapp");
    );
}
````

The `with_tag()` is what your app's logs will show as.

#### Viewing Android Logs

Android logs are sent to logcat. To use logcat through the Android debugger, run:

````cmd
adb -d logcat
````

Your Android device will need developer options/usb debugging enabled.

For more information, visit android_logger's [docs](https://docs.rs/android_logger/latest/android_logger/).

## iOS

The current option for iOS is the [oslog](https://crates.io/crates/oslog) crate.

````rs
fn main() {
    // Init logger
    OsLogger::new("com.example.test")
        .level_filter(LevelFilter::Debug)
        .init()
        .expect("failed to init logger");
    // Dioxus code
}
````

#### Viewing IOS Logs

You can view the emitted logs in Xcode.

For more information, visit [oslog](https://crates.io/crates/oslog).
# Internationalization

If your application supports multiple languages, the [Dioxus SDK](https://github.com/DioxusLabs/sdk) crate contains helpers to make working with translations in your application easier.

## The full code for internationalization

````rs@i18n.rs
use dioxus::prelude::*;
use dioxus_sdk::i18n::*;
use dioxus_sdk::translate;
use std::str::FromStr;

fn main() {
    launch(app);
}

static EN_US: &str = r#"{
    "id": "en-US",
    "texts": {
        "messages": {
            "hello_world": "Hello World!"
        },
        "messages.hello": "Hello {name}"
    }
}"#;
static ES_ES: &str = r#"{
    "id": "es-ES",
    "texts": {
        "messages": {
            "hello_world": "Hola Mundo!"
        },
        "messages.hello": "Hola {name}"
    }
}"#;

#[allow(non_snake_case)]
fn Body() -> Element {
    let mut i18 = use_i18();

    let change_to_english = move |_| i18.set_language("en-US".parse().unwrap());
    let change_to_spanish = move |_| i18.set_language("es-ES".parse().unwrap());

    rsx! {
        button { onclick: change_to_english, label { "English" } }
        button { onclick: change_to_spanish, label { "Spanish" } }
        p { {translate!(i18, "messages.hello_world")} }
        p { {translate!(i18, "messages.hello", name: "Dioxus")} }
    }
}

fn app() -> Element {
    use_init_i18n("en-US".parse().unwrap(), "en-US".parse().unwrap(), || {
        let en_us = Language::from_str(EN_US).unwrap();
        let es_es = Language::from_str(ES_ES).unwrap();
        vec![en_us, es_es]
    });

    rsx! { Body {} }
}

````
# State Cookbook

* [External State](external/index.md)
* [Custom Hook](custom_hooks/index.md)
# Working with External State

This guide will help you integrate your Dioxus application with some external state like a different thread or a websocket connection.

## Working with non-reactive State

[Coroutines](../../../reference/use_coroutine.md) are great tool for dealing with non-reactive (state you don't render directly) state within your application.

You can store your state inside the coroutine async block and communicate with the coroutine with messages from any child components.

````rs@use_coroutine.rs
// import futures::StreamExt to use the next() method
use futures::StreamExt;
let mut response_state = use_signal(|| None);
let tx = use_coroutine(move |mut rx| async move {
    // Define your state before the loop
    let mut state = reqwest::Client::new();
    let mut cache: HashMap<String, String> = HashMap::new();
    loop {
        // Loop and wait for the next message
        if let Some(request) = rx.next().await {
            // Resolve the message
            let response = if let Some(response) = cache.get(&request) {
                response.clone()
            } else {
                let response = state
                    .get(&request)
                    .send()
                    .await
                    .unwrap()
                    .text()
                    .await
                    .unwrap();
                cache.insert(request, response.clone());
                response
            };
            response_state.set(Some(response));
        } else {
            break;
        }
    }
});
// Send a message to the coroutine
tx.send("https://example.com".to_string());
// Get the current state of the coroutine
let response = response_state.read();
````

## Making Reactive State External

If you have some reactive state (state that is rendered), that you want to modify from another thread, you can use a signal that is sync. Signals take an optional second generic value with information about syncness. Sync signals have a slightly higher overhead than thread local signals, but they can be used in a multithreaded environment.

````rs@sync_signal.rs
use dioxus::prelude::*;

fn main() {
    launch(app);
}

fn app() -> Element {
    let mut signal = use_signal_sync(|| 0);

    use_hook(|| {
        std::thread::spawn(move || loop {
            std::thread::sleep(std::time::Duration::from_secs(1));
            // You can easily update the signal from a different thread
            signal += 1;
        });
    });

    rsx! {
        button { onclick: move |_| signal += 1, "Increase" }
        "{signal}"
    }
}

````
# Custom Hooks

Hooks are a great way to encapsulate business logic. If none of the existing hooks work for your problem, you can write your own.

When writing your hook, you can make a function that starts with `use_` and takes any arguments you need. You can then use the `use_hook` method to create a hook that will be called the first time the component is rendered.

## Composing Hooks

To avoid repetition, you can encapsulate business logic based on existing hooks to create a new hook.

For example, if many components need to access an `AppSettings` struct, you can create a "shortcut" hook:

````rs@hooks_composed.rs
fn use_settings() -> Signal<AppSettings> {
    consume_context()
}
````

Or if you want to wrap a hook that persists reloads with the storage API, you can build on top of the use_signal hook to work with mutable state:

````rs@hooks_composed.rs
use gloo_storage::{LocalStorage, Storage};
use serde::{de::DeserializeOwned, Serialize};

/// A persistent storage hook that can be used to store data across application reloads.
#[allow(clippy::needless_return)]
pub fn use_persistent<T: Serialize + DeserializeOwned + Default + 'static>(
    // A unique key for the storage entry
    key: impl ToString,
    // A function that returns the initial value if the storage entry is empty
    init: impl FnOnce() -> T,
) -> UsePersistent<T> {
    // Use the use_signal hook to create a mutable state for the storage entry
    let state = use_signal(move || {
        // This closure will run when the hook is created
        let key = key.to_string();
        let value = LocalStorage::get(key.as_str()).ok().unwrap_or_else(init);
        StorageEntry { key, value }
    });

    // Wrap the state in a new struct with a custom API
    UsePersistent { inner: state }
}

struct StorageEntry<T> {
    key: String,
    value: T,
}

/// Storage that persists across application reloads
pub struct UsePersistent<T: 'static> {
    inner: Signal<StorageEntry<T>>,
}

impl<T> Clone for UsePersistent<T> {
    fn clone(&self) -> Self {
        *self
    }
}

impl<T> Copy for UsePersistent<T> {}

impl<T: Serialize + DeserializeOwned + Clone + 'static> UsePersistent<T> {
    /// Returns a reference to the value
    pub fn get(&self) -> T {
        self.inner.read().value.clone()
    }

    /// Sets the value
    pub fn set(&mut self, value: T) {
        let mut inner = self.inner.write();
        // Write the new value to local storage
        LocalStorage::set(inner.key.as_str(), &value);
        inner.value = value;
    }
}
````

## Custom Hook Logic

You can use [`use_hook`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_hook.html) to build your own hooks. In fact, this is what all the standard hooks are built on!

`use_hook` accepts a single closure for initializing the hook. It will be only run the first time the component is rendered. The return value of that closure will be used as the value of the hook â€“ Dioxus will take it, and store it for as long as the component is alive. On every render (not just the first one!), you will get a reference to this value.

 > 
 > Note: You can use the `use_on_destroy` hook to clean up any resources the hook uses when the component is destroyed.

Inside the initialization closure, you will typically make calls to other `cx` methods. For example:

* The `use_signal` hook tracks state in the hook value, and uses [`schedule_update`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.schedule_update.html) to make Dioxus re-render the component whenever it changes.

Here is a simplified implementation of the `use_signal` hook:

````rs@hooks_custom_logic.rs
use std::cell::RefCell;
use std::rc::Rc;
use std::sync::Arc;

struct Signal<T> {
    value: Rc<RefCell<T>>,
    update: Arc<dyn Fn()>,
}

impl<T> Clone for Signal<T> {
    fn clone(&self) -> Self {
        Self {
            value: self.value.clone(),
            update: self.update.clone(),
        }
    }
}

fn my_use_signal<T: 'static>(init: impl FnOnce() -> T) -> Signal<T> {
    use_hook(|| {
        // The update function will trigger a re-render in the component cx is attached to
        let update = schedule_update();
        // Create the initial state
        let value = Rc::new(RefCell::new(init()));

        Signal { value, update }
    })
}

impl<T: Clone> Signal<T> {
    fn get(&self) -> T {
        self.value.borrow().clone()
    }

    fn set(&self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render on the component the state is from
        (self.update)();
    }
}
````

* The `use_context` hook calls [`consume_context`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.consume_context.html) (which would be expensive to call on every render) to get some context from the component

Here is an implementation of the `use_context` and `use_context_provider` hooks:

````rs@hooks_custom_logic.rs
pub fn use_context<T: 'static + Clone>() -> T {
    use_hook(|| consume_context())
}

pub fn use_context_provider<T: 'static + Clone>(f: impl FnOnce() -> T) -> T {
    use_hook(|| {
        let val = f();
        // Provide the context state to the component
        provide_context(val.clone());
        val
    })
}

````
# Testing

When building application or libraries with Dioxus, you may want to include some tests to check the behavior of parts of your application. This guide will teach you how to test different parts of your Dioxus application.

## Component Testing

You can use a combination of [pretty-assertions](https://docs.rs/pretty_assertions/latest/pretty_assertions/) and [dioxus-ssr](https://docs.rs/dioxus-ssr/latest/dioxus_ssr/) to check that two snippets of rsx are equal:

````rs@component_test.rs
use futures::FutureExt;
use std::{cell::RefCell, sync::Arc};

use dioxus::prelude::*;

#[test]
fn test() {
    assert_rsx_eq(
        rsx! {
            div { "Hello world" }
            div { "Hello world" }
        },
        rsx! {
            for _ in 0..2 {
                div { "Hello world" }
            }
        },
    )
}

fn assert_rsx_eq(first: Element, second: Element) {
    let first = dioxus_ssr::render_element(first);
    let second = dioxus_ssr::render_element(second);
    pretty_assertions::assert_str_eq!(first, second);
}

````

## Hook Testing

When creating libraries around Dioxus, it can be helpful to make tests for your [custom hooks](./state/custom_hooks/index.md).

Dioxus does not currently have a full hook testing library, but you can build a bespoke testing framework by manually driving the virtual dom.

````rs@hook_test.rs
use futures::FutureExt;
use std::{cell::RefCell, rc::Rc, sync::Arc, thread::Scope};

use dioxus::{dioxus_core::NoOpMutations, prelude::*};

#[test]
fn test() {
    test_hook(
        || use_signal(|| 0),
        |mut value, mut proxy| match proxy.generation {
            0 => {
                value.set(1);
            }
            1 => {
                assert_eq!(*value.read(), 1);
                value.set(2);
            }
            2 => {
                proxy.rerun();
            }
            3 => {}
            _ => todo!(),
        },
        |proxy| assert_eq!(proxy.generation, 4),
    );
}

fn test_hook<V: 'static>(
    initialize: impl FnMut() -> V + 'static,
    check: impl FnMut(V, MockProxy) + 'static,
    mut final_check: impl FnMut(MockProxy) + 'static,
) {
    #[derive(Props)]
    struct MockAppComponent<I: 'static, C: 'static> {
        hook: Rc<RefCell<I>>,
        check: Rc<RefCell<C>>,
    }

    impl<I, C> PartialEq for MockAppComponent<I, C> {
        fn eq(&self, _: &Self) -> bool {
            true
        }
    }

    impl<I, C> Clone for MockAppComponent<I, C> {
        fn clone(&self) -> Self {
            Self {
                hook: self.hook.clone(),
                check: self.check.clone(),
            }
        }
    }

    fn mock_app<I: FnMut() -> V, C: FnMut(V, MockProxy), V>(
        props: MockAppComponent<I, C>,
    ) -> Element {
        let value = props.hook.borrow_mut()();

        props.check.borrow_mut()(value, MockProxy::new());

        rsx! {
            div {}
        }
    }

    let mut vdom = VirtualDom::new_with_props(
        mock_app,
        MockAppComponent {
            hook: Rc::new(RefCell::new(initialize)),
            check: Rc::new(RefCell::new(check)),
        },
    );

    vdom.rebuild_in_place();

    while vdom.wait_for_work().now_or_never().is_some() {
        vdom.render_immediate(&mut NoOpMutations);
    }

    vdom.in_scope(ScopeId::ROOT, || {
        final_check(MockProxy::new());
    })
}

struct MockProxy {
    rerender: Arc<dyn Fn()>,
    pub generation: usize,
}

impl MockProxy {
    fn new() -> Self {
        let generation = dioxus::core::generation();
        let rerender = dioxus::core::schedule_update();

        Self {
            rerender,
            generation,
        }
    }

    pub fn rerun(&mut self) {
        (self.rerender)();
    }
}

````

## End to End Testing

You can use [Playwright](https://playwright.dev/) to create end to end tests for your dioxus application.

In your `playwright.config.js`, you will need to run cargo run or dx serve instead of the default build command. Here is a snippet from the end to end web example:

````js
//...
webServer: [
    {
        cwd: path.join(process.cwd(), 'playwright-tests', 'web'),
        command: 'dx serve',
        port: 8080,
        timeout: 10 * 60 * 1000,
        reuseExistingServer: !process.env.CI,
        stdout: "pipe",
    },
],
````

* [Web example](https://github.com/DioxusLabs/dioxus/tree/v0.5/playwright-tests/web)
* [Liveview example](https://github.com/DioxusLabs/dioxus/tree/v0.5/playwright-tests/liveview)
* [Fullstack example](https://github.com/DioxusLabs/dioxus/tree/v0.5/playwright-tests/fullstack)
# Tailwind

You can style your Dioxus application with whatever CSS framework you choose, or just write vanilla CSS.

One popular option for styling your Dioxus application is [Tailwind](https://tailwindcss.com/). Tailwind allows you to style your elements with CSS utility classes. This guide will show you how to setup tailwind CSS with your Dioxus application.

## Setup

1. Install the Dioxus CLI:

````bash
cargo install dioxus-cli
````

2. Install npm: [https://docs.npmjs.com/downloading-and-installing-node-js-and-npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)
2. Install the tailwind css cli: [https://tailwindcss.com/docs/installation](https://tailwindcss.com/docs/installation)
2. Initialize the tailwind css project:

````bash
npx tailwindcss init
````

This should create a `tailwind.config.js` file in the root of the project.

5. Edit the `tailwind.config.js` file to include rust files:

````js
module.exports = {
    mode: "all",
    content: [
        // include all rust, html and css files in the src directory
        "./src/**/*.{rs,html,css}",
        // include all html files in the output (dist) directory
        "./dist/**/*.html",
    ],
    theme: {
        extend: {},
    },
    plugins: [],
}
````

6. Create a `input.css` file in the root of your project with the following content:

````css
@tailwind base;
@tailwind components;
@tailwind utilities;
````

7. Add [Manganis](https://github.com/DioxusLabs/manganis) to your project to handle asset collection.

````sh
cargo add manganis
````

8. Create a link to the `tailwind.css` file using manganis somewhere in your rust code:

````rs@tailwind.rs
// Urls are relative to your Cargo.toml file
const _TAILWIND_URL: &str = manganis::mg!(file("public/tailwind.css"));

````

### Bonus Steps

1. Install the tailwind css vs code extension
1. Go to the settings for the extension and find the experimental regex support section. Edit the setting.json file to look like this:

````json
"tailwindCSS.experimental.classRegex": ["class\\s*:\\s*\"([^\"]*)"],
"tailwindCSS.includeLanguages": {
    "rust": "html"
},
````

## Development

* Run the following command in the root of the project to start the tailwind css compiler:

````bash
npx tailwindcss -i ./input.css -o ./public/tailwind.css --watch
````

### Web

* Run the following command in the root of the project to start the dioxus dev server:

````bash
dx serve
````

* Open the browser to [http://localhost:8080](http://localhost:8080).

### Desktop

* Launch the dioxus desktop app:

````bash
dx serve --platform desktop
````
# Custom Renderer

Dioxus is an incredibly portable framework for UI development. The lessons, knowledge, hooks, and components you acquire over time can always be used for future projects. However, sometimes those projects cannot leverage a supported renderer or you need to implement your own better renderer.

Great news: the design of the renderer is entirely up to you! We provide suggestions and inspiration with the 1st party renderers, but only really require processing `Mutations` and sending `UserEvents`.

## The specifics:

Implementing the renderer is fairly straightforward. The renderer needs to:

1. Handle the stream of edits generated by updates to the virtual DOM
1. Register listeners and pass events into the virtual DOM's event system

Essentially, your renderer needs to process edits and generate events to update the VirtualDOM. From there, you'll have everything needed to render the VirtualDOM to the screen.

Internally, Dioxus handles the tree relationship, diffing, memory management, and the event system, leaving as little as possible required for renderers to implement themselves.

For reference, check out the [javascript interpreter](https://github.com/DioxusLabs/dioxus/tree/v0.5/packages/interpreter) or [tui renderer](https://github.com/DioxusLabs/blitz/tree/master/packages/dioxus-tui) as a starting point for your custom renderer.

## Templates

Dioxus is built around the concept of [Templates](https://docs.rs/dioxus-core/latest/dioxus_core/prelude/struct.Template.html). Templates describe a UI tree known at compile time with dynamic parts filled at runtime. This is useful internally to make skip diffing static nodes, but it is also useful for the renderer to reuse parts of the UI tree. This can be useful for things like a list of items. Each item could contain some static parts and some dynamic parts. The renderer can use the template to create a static part of the UI once, clone it for each element in the list, and then fill in the dynamic parts.

## Mutations

The `Mutation` type is a serialized enum that represents an operation that should be applied to update the UI. The variants roughly follow this set:

````rust
enum Mutation {
	AppendChildren,
	AssignId,
	CreatePlaceholder,
	CreateTextNode,
	HydrateText,
	LoadTemplate,
	ReplaceWith,
	ReplacePlaceholder,
	InsertAfter,
	InsertBefore,
	SetAttribute,
	SetText,
	NewEventListener,
	RemoveEventListener,
	Remove,
	PushRoot,
}
````

The Dioxus diffing mechanism operates as a [stack machine](https://en.wikipedia.org/wiki/Stack_machine) where the [LoadTemplate](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.LoadTemplate), [CreatePlaceholder](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.CreatePlaceholder), and [CreateTextNode](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.CreateTextNode) mutations pushes a new "real" DOM node onto the stack and [AppendChildren](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.AppendChildren), [InsertAfter](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.InsertAfter), [InsertBefore](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.InsertBefore), [ReplacePlaceholder](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.ReplacePlaceholder), and [ReplaceWith](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.ReplaceWith) all remove nodes from the stack.

## Node storage

Dioxus saves and loads elements with IDs. Inside the VirtualDOM, this is just tracked as as a u64.

Whenever a `CreateElement` edit is generated during diffing, Dioxus increments its node counter and assigns that new element its current NodeCount. The RealDom is responsible for remembering this ID and pushing the correct node when id is used in a mutation. Dioxus reclaims the IDs of elements when removed. To stay in sync with Dioxus you can use a sparse Vec (Vec\<Option<T>\>) with possibly unoccupied items. You can use the ids as indexes into the Vec for elements, and grow the Vec when an id does not exist.

### An Example

For the sake of understanding, let's consider this example â€“ a very simple UI declaration:

````rust
rsx! {
	h1 { "count: {x}" }
}
````

#### Building Templates

The above rsx will create a template that contains one static h1 tag and a placeholder for a dynamic text node. The template contains the static parts of the UI, and ids for the dynamic parts along with the paths to access them.

The template will look something like this:

````rust
Template {
	// Some id that is unique for the entire project
	name: "main.rs:1:1:0",
	// The root nodes of the template
	roots: &[
		TemplateNode::Element {
			tag: "h1",
			namespace: None,
			attrs: &[],
			children: &[
				TemplateNode::DynamicText {
					id: 0
				},
			],
		}
	],
	// the path to each of the dynamic nodes
	node_paths: &[
		// the path to dynamic node with a id of 0
		&[
			// on the first root node
			0,
			// the first child of the root node
			0,
		]
	],
	// the path to each of the dynamic attributes
	attr_paths: &'a [&'a [u8]],
}
````

 > 
 > For more detailed docs about the structure of templates see the [Template api docs](https://docs.rs/dioxus-core/latest/dioxus_core/prelude/struct.Template.html)

This template will be sent to the renderer in the [list of templates](https://docs.rs/dioxus-core/latest/dioxus_core/struct.Mutations.html#structfield.templates) supplied with the mutations the first time it is used. Any time the renderer encounters a [LoadTemplate](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.LoadTemplate) mutation after this, it should clone the template and store it in the given id.

For dynamic nodes and dynamic text nodes, a placeholder node should be created and inserted into the UI so that the node can be modified later.

In HTML renderers, this template could look like this:

````html
<h1>""</h1>
````

#### Applying Mutations

After the renderer has created all of the new templates, it can begin to process the mutations.

When the renderer starts, it should contain the Root node on the stack and store the Root node with an id of 0. The Root node is the top-level node of the UI. In HTML, this is the `<div id="main">` element.

````rust
instructions: []
stack: [
	RootNode,
]
nodes: [
	RootNode,
]
````

The first mutation is a `LoadTemplate` mutation. This tells the renderer to load a root from the template with the given id. The renderer will then push the root node of the template onto the stack and store it with an id for later. In this case, the root node is an h1 element.

````rust
instructions: [
	LoadTemplate {
		// the id of the template
		name: "main.rs:1:1:0",
		// the index of the root node in the template
		index: 0,
		// the id to store
		id: ElementId(1),
	}
]
stack: [
	RootNode,
	<h1>""</h1>,
]
nodes: [
	RootNode,
	<h1>""</h1>,
]
````

Next, Dioxus will create the dynamic text node. The diff algorithm decides that this node needs to be created, so Dioxus will generate the Mutation `HydrateText`. When the renderer receives this instruction, it will navigate to the placeholder text node in the template and replace it with the new text.

````rust
instructions: [
	LoadTemplate {
		name: "main.rs:1:1:0",
		index: 0,
		id: ElementId(1),
	},
	HydrateText {
		// the id to store the text node
		id: ElementId(2),
		// the text to set
		text: "count: 0",
	}
]
stack: [
	RootNode,
	<h1>"count: 0"</h1>,
]
nodes: [
	RootNode,
	<h1>"count: 0"</h1>,
	"count: 0",
]
````

Remember, the h1 node is not attached to anything (it is unmounted) so Dioxus needs to generate an Edit that connects the h1 node to the Root. It depends on the situation, but in this case, we use `AppendChildren`. This pops the text node off the stack, leaving the Root element as the next element on the stack.

````rust
instructions: [
	LoadTemplate {
		name: "main.rs:1:1:0",
		index: 0,
		id: ElementId(1),
	},
	HydrateText {
		id: ElementId(2),
		text: "count: 0",
	},
	AppendChildren {
		// the id of the parent node
		id: ElementId(0),
		// the number of nodes to pop off the stack and append
		m: 1
	}
]
stack: [
	RootNode,
]
nodes: [
	RootNode,
	<h1>"count: 0"</h1>,
	"count: 0",
]
````

Over time, our stack looked like this:

````rust
[Root]
[Root, <h1>""</h1>]
[Root, <h1>"count: 0"</h1>]
[Root]
````

Conveniently, this approach completely separates the Virtual DOM and the Real DOM. Additionally, these edits are serializable, meaning we can even manage UIs across a network connection. This little stack machine and serialized edits make Dioxus independent of platform specifics.

Dioxus is also really fast. Because Dioxus splits the diff and patch phase, it's able to make all the edits to the RealDOM in a very short amount of time (less than a single frame) making rendering very snappy. It also allows Dioxus to cancel large diffing operations if higher priority work comes in while it's diffing.

This little demo serves to show exactly how a Renderer would need to process a mutation stream to build UIs.

## Event loop

Like most GUIs, Dioxus relies on an event loop to progress the VirtualDOM. The VirtualDOM itself can produce events as well, so it's important for your custom renderer can handle those too.

The code for the WebSys implementation is straightforward, so we'll add it here to demonstrate how simple an event loop is:

````rust, ignore
pub async fn run(&mut self) -> dioxus_core::error::Result<()> {
	// Push the body element onto the WebsysDom's stack machine
	let mut websys_dom = crate::new::WebsysDom::new(prepare_websys_dom());
	websys_dom.stack.push(root_node);

	// Rebuild or hydrate the virtualdom
	let mutations = self.internal_dom.rebuild();
	websys_dom.apply_mutations(mutations);

	// Wait for updates from the real dom and progress the virtual dom
	loop {
		let user_input_future = websys_dom.wait_for_event();
		let internal_event_future = self.internal_dom.wait_for_work();

		match select(user_input_future, internal_event_future).await {
			Either::Left((_, _)) => {
				let mutations = self.internal_dom.work_with_deadline(|| false);
				websys_dom.apply_mutations(mutations);
			},
			Either::Right((event, _)) => websys_dom.handle_event(event),
		}

		// render
	}
}
````

It's important to decode what the real events are for your event system into Dioxus' synthetic event system (synthetic meaning abstracted). This simply means matching your event type and creating a Dioxus `UserEvent` type. Right now, the virtual event system is modeled almost entirely around the HTML spec, but we are interested in slimming it down.

````rust, ignore
fn virtual_event_from_websys_event(event: &web_sys::Event) -> VirtualEvent {
	match event.type_().as_str() {
		"keydown" => {
			let event: web_sys::KeyboardEvent = event.clone().dyn_into().unwrap();
			UserEvent::KeyboardEvent(UserEvent {
				scope_id: None,
				priority: EventPriority::Medium,
				name: "keydown",
				// This should be whatever element is focused
				element: Some(ElementId(0)),
				data: Arc::new(KeyboardData{
					char_code: event.char_code(),
					key: event.key(),
					key_code: event.key_code(),
					alt_key: event.alt_key(),
					ctrl_key: event.ctrl_key(),
					meta_key: event.meta_key(),
					shift_key: event.shift_key(),
					location: event.location(),
					repeat: event.repeat(),
					which: event.which(),
				})
			})
		}
		_ => todo!()
	}
}
````

## Custom raw elements

If you need to go as far as relying on custom elements/attributes for your renderer â€“ you totally can. This still enables you to use Dioxus' reactive nature, component system, shared state, and other features, but will ultimately generate different nodes. All attributes and listeners for the HTML and SVG namespace are shuttled through helper structs that essentially compile away. You can drop in your elements any time you want, with little hassle. However, you must be sure your renderer can handle the new namespace.

For more examples and information on how to create custom namespaces, see the [`dioxus_html` crate](https://github.com/DioxusLabs/dioxus/blob/main/packages/html/README.md#how-to-extend-it).

# Native Core

If you are creating a renderer in rust, the [native-core](https://github.com/DioxusLabs/blitz/tree/master/packages/native-core) crate provides some utilities to implement a renderer. It provides an abstraction over Mutations and Templates and contains helpers that can handle the layout and text editing for you.

## The RealDom

The `RealDom` is a higher-level abstraction over updating the Dom. It uses an entity component system to manage the state of nodes. This system allows you to modify insert and modify arbitrary components on nodes. On top of this, the RealDom provides a way to manage a tree of nodes, and the State trait provides a way to automatically add and update these components when the tree is modified. It also provides a way to apply `Mutations` to the RealDom.

### Example

Let's build a toy renderer with borders, size, and text color.
Before we start let's take a look at an example element we can render:

````rust
rsx!{
	div{
		color: "red",
		p{
			border: "1px solid black",
			"hello world"
		}
	}
}
````

In this tree, the color depends on the parent's color. The layout depends on the children's layout, the current text, and the text size. The border depends on only the current node.

In the following diagram arrows represent dataflow:

[![](https://mermaid.ink/img/pako:eNqllV1vgjAUhv8K6W4wkQVa2QdLdrHsdlfukmSptEhjoaSWqTH-9xVwONAKst70g5739JzzlO5BJAgFAYi52EQJlsr6fAszS7d1sVhKnCdWJDJFt6peLVs5-9owohK7HFrVcFJ_pxnpmK8VVvRkTJikkWIiaxy1dhP23bUwW1WW5WbPrrqJ4ziR4EJ6dtVN2ls5y1ZztePUcrWZFCvqVEcPPDffvlyS1XoLIQnVgnVvVPR6FU9Zc-6dV453ojjOPbuetRJ57gIeXQR3cez7rjtteZyZQ2j5MqmjqwE0ZW0VKx9RKtgpFewp1aw3sXXFy6TWgiYlv8mfq1scD8ofbBCAfQg8_AMBOAyBxzEIwA4CxgQ99QbQkjnD2KT7_CfxGF8_9WXQEsq5sDZCcjICOXRCri4h6r3NA38Q6Jdi1EOx5w3DGDYYI6MUvJFjM3VoGHUeGoMd6mBnDmh2E3fo7O4Yhf0x4OkBmIKUyhQzol_GfbkcApXQlIYg0EOC5SoEYXbQ-3ChxHyXRSBQsqBTUOREx_7OsAY3BUGM-VqvUsKUkB_1U6vf05gtweEHTk4_HQ?type=png)](https://mermaid.live/edit#pako:eNqllV1vgjAUhv8K6W4wkQVa2QdLdrHsdlfukmSptEhjoaSWqTH-9xVwONAKst70g5739JzzlO5BJAgFAYi52EQJlsr6fAszS7d1sVhKnCdWJDJFt6peLVs5-9owohK7HFrVcFJ_pxnpmK8VVvRkTJikkWIiaxy1dhP23bUwW1WW5WbPrrqJ4ziR4EJ6dtVN2ls5y1ZztePUcrWZFCvqVEcPPDffvlyS1XoLIQnVgnVvVPR6FU9Zc-6dV453ojjOPbuetRJ57gIeXQR3cez7rjtteZyZQ2j5MqmjqwE0ZW0VKx9RKtgpFewp1aw3sXXFy6TWgiYlv8mfq1scD8ofbBCAfQg8_AMBOAyBxzEIwA4CxgQ99QbQkjnD2KT7_CfxGF8_9WXQEsq5sDZCcjICOXRCri4h6r3NA38Q6Jdi1EOx5w3DGDYYI6MUvJFjM3VoGHUeGoMd6mBnDmh2E3fo7O4Yhf0x4OkBmIKUyhQzol_GfbkcApXQlIYg0EOC5SoEYXbQ-3ChxHyXRSBQsqBTUOREx_7OsAY3BUGM-VqvUsKUkB_1U6vf05gtweEHTk4_HQ)

To help in building a Dom, native-core provides the State trait and a RealDom struct. The State trait provides a way to describe how states in a node depend on other states in its relatives. By describing how to update a single node from its relations, native-core will derive a way to update the states of all nodes for you. Once you have a state you can provide it as a generic to RealDom. RealDom provides all of the methods to interact and update your new dom.

Native Core cannot create all of the required methods for the State trait, but it can derive some of them. To implement the State trait, you must implement the following methods and let the `#[partial_derive_state]` macro handle the rest:

````rs@custom_renderer.rs

````

Lets take a look at how to implement the State trait for a simple renderer.

````rs@custom_renderer.rs

````

Now that we have our state, we can put it to use in our RealDom. We can update the RealDom with apply_mutations to update the structure of the dom (adding, removing, and changing properties of nodes) and then update_state to update the States for each of the nodes that changed.

````rs@custom_renderer.rs

````

## Layout

For most platforms, the layout of the Elements will stay the same. The [layout_attributes](https://docs.rs/dioxus-native-core/latest/dioxus_native_core/layout_attributes/index.html) module provides a way to apply HTML attributes a [Taffy](https://docs.rs/taffy/latest/taffy/index.html) layout style.

## Text Editing

To make it easier to implement text editing in rust renderers, `native-core` also contains a renderer-agnostic cursor system. The cursor can handle text editing, selection, and movement with common keyboard shortcuts integrated.

````rs@custom_renderer.rs

````

## Conclusion

That should be it! You should have nearly all the knowledge required on how to implement your renderer. We're super interested in seeing Dioxus apps brought to custom desktop renderers, mobile renderers, video game UI, and even augmented reality! If you're interested in contributing to any of these projects, don't be afraid to reach out or join the [community](https://discord.gg/XgGxMSkvUM).
# Optimizing

*Note: This is written primarily for the web, but the main optimizations will work on other platforms too.*

You might have noticed that Dioxus binaries are pretty big.
The WASM binary of a [TodoMVC app](https://github.com/tigerros/dioxus-todo-app) weighs in at 2.36mb!
Don't worry; we can get it down to a much more manageable 234kb.
This will get obviously lower over time.
With nightly features, you can even reduce the binary size of a hello world app to less than 100kb!

We will also discuss ways to optimize your app for increased speed.

However, certain optimizations will sacrifice speed for decreased binary size or the other way around.
That's what you need to figure out yourself. Does your app perform performance-intensive tasks, such as graphical processing or tons of DOM manipulations?
You could go for increased speed. In most cases, though, decreased binary size is the better choice, especially because Dioxus WASM binaries are quite large.

To test binary sizes, we will use [this](https://github.com/tigerros/dioxus-todo-app) repository as a sample app.
The `no-optimizations` package will serve as the base, which weighs 2.36mb as of right now.

Additional resources:

* [WASM book - Shrinking `.wasm` code size](https://rustwasm.github.io/docs/book/reference/code-size.html)
* [min-sized-rust](https://github.com/johnthagen/min-sized-rust)

## Building in release mode

This is the best way to optimize. In fact, the 2.36mb figure at the start of the guide is with release mode.
In debug mode, it's actually a whopping 32mb! It also increases the speed of your app.

Thankfully, no matter what tool you're using to build your app, it will probably have a `--release` flag to do this.

Using the [Dioxus CLI](https://dioxuslabs.com/learn/0.5/CLI) or [Trunk](https://trunkrs.dev/):

* Dioxus CLI: `dx build --release`
* Trunk: `trunk build --release`

## UPX

If you're not targeting web, you can use the [UPX](https://github.com/upx/upx) CLI tool to compress your executables.

Setup:

* Download a [release](https://github.com/upx/upx/releases) and extract the directory inside to a sensible location.
* Add the executable located in the directory to your path variable.

You can run `upx --help` to get the CLI options, but you should also view `upx-doc.html` for more detailed information.
It's included in the extracted directory.

An example command might be: `upx --best -o target/release/compressed.exe target/release/your-executable.exe`.

## Build configuration

*Note: Settings defined in `.cargo/config.toml` will override settings in `Cargo.toml`.*

Other than the `--release` flag, this is the easiest way to optimize your projects, and also the most effective way,
at least in terms of reducing binary size.

### Stable

This configuration is 100% stable and decreases the binary size from 2.36mb to 310kb.
Add this to your `.cargo/config.toml`:

````toml
[profile.release]
opt-level = "z"
debug = false
lto = true
codegen-units = 1
panic = "abort"
strip = true
incremental = false
````

Links to the documentation of each value:

* [`opt-level`](https://doc.rust-lang.org/rustc/codegen-options/index.html#opt-level)
* [`debug`](https://doc.rust-lang.org/rustc/codegen-options/index.html#debuginfo)
* [`lto`](https://doc.rust-lang.org/rustc/codegen-options/index.html#lto)
* [`codegen-units`](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units)
* [`panic`](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic)
* [`strip`](https://doc.rust-lang.org/rustc/codegen-options/index.html#strip)
* [`incremental`](https://doc.rust-lang.org/rustc/codegen-options/index.html#incremental)

### Unstable

This configuration contains some unstable features, but it should work just fine.
It decreases the binary size from 310kb to 234kb.
Add this to your `.cargo/config.toml`:

````toml
[unstable]
build-std = ["std", "panic_abort", "core", "alloc"]
build-std-features = ["panic_immediate_abort"]

[build]
rustflags = [
    "-Clto",
    "-Zvirtual-function-elimination",
    "-Zlocation-detail=none"
]

# Same as in the Stable section
[profile.release]
opt-level = "z"
debug = false
lto = true
codegen-units = 1
panic = "abort"
strip = true
incremental = false
````

*Note: The omitted space in each flag (e.g., `-C<no space here>lto`) is intentional. It is not a typo.*

The values in `[profile.release]` are documented in the [Stable](#stable) section. Links to the documentation of each value:

* [`[build.rustflags]`](https://doc.rust-lang.org/cargo/reference/config.html#buildrustflags)
* [`-C lto`](https://doc.rust-lang.org/rustc/codegen-options/index.html#lto)
* [`-Z virtual-function-elimination`](https://doc.rust-lang.org/stable/unstable-book/compiler-flags/virtual-function-elimination.html)
* [`-Z location-detail`](https://doc.rust-lang.org/stable/unstable-book/compiler-flags/location-detail.html)

## wasm-opt

*Note: In the future, `wasm-opt` will be supported natively through the [Dioxus CLI](https://crates.io/crates/dioxus-cli).*

`wasm-opt` is a tool from the [binaryen](https://github.com/WebAssembly/binaryen) library that optimizes your WASM files.
To use it, install a [binaryen release](https://github.com/WebAssembly/binaryen/releases) and run this command from the package directory:

````
wasm-opt dist/assets/dioxus/APP_NAME_bg.wasm -o dist/assets/dioxus/APP_NAME_bg.wasm -Oz
````

The `-Oz` flag specifies that `wasm-opt` should optimize for size. For speed, use `-O4`.

## Improving Dioxus code

Let's talk about how you can improve your Dioxus code to be more performant.

It's important to minimize the number of dynamic parts in your `rsx`, like conditional rendering.
When Dioxus is rendering your component, it will skip parts that are the same as the last render.
That means that if you keep dynamic rendering to a minimum, your app will speed up, and quite a bit if it's not just hello world.
To see an example of this, check out [Dynamic Rendering](../reference/dynamic_rendering.md).

Also check out [Anti-patterns](antipatterns.md) for patterns that you should avoid.
Obviously, not all of them are just about performance, but some of them are.

## Optimizing the size of assets

Assets can be a significant part of your app's size. Dioxus includes alpha support for first party [assets](../reference/assets.md). Any assets you include with the `mg!` macro will be optimized for production in release builds.
# Introduction

The âœ¨**Dioxus CLI**âœ¨ is a tool to get Dioxus projects off the ground.

There's no documentation for commands here, but you can see all commands using `dx --help` once you've installed the CLI! Furthermore, you can run `dx <command> --help` to get help with a specific command.

## Features

* Build and pack a Dioxus project.
* Format `rsx` code.
* Hot Reload.
* Create a Dioxus project from a template repository.
* And more!
# Create a Project

Once you have the Dioxus CLI installed, you can use it to create your own project!

## Initializing a project

First, run the `dx new` command to create a new project.

 > 
 > It clones this [template](https://github.com/DioxusLabs/dioxus-template), which is used to create dioxus apps.
 > 
 > You can create your project from a different template by passing the `template` argument:
 > 
 > ````
 > dx new --template gh:dioxuslabs/dioxus-template
 > ````

Next, navigate into your new project using `cd project-name`, or simply opening it in an IDE.

 > 
 > Make sure the WASM target is installed before running the projects.
 > You can install the WASM target for rust using rustup:
 > 
 > ````
 > rustup target add wasm32-unknown-unknown
 > ````

Finally, serve your project with `dx serve`! The CLI will tell you the address it is serving on, along with additional
info such as code warnings.
# Configure Project

This chapter will teach you how to configure the CLI with the `Dioxus.toml` file. There's an [example](#config-example) which has comments to describe individual keys. You can copy that or view this documentation for a more complete learning experience.

"ðŸ”’" indicates a mandatory item. Some headers are mandatory, but none of the keys inside them are. In that case, you only need to include the header, but no keys. It might look weird, but it's normal.

## Structure

Each header has its TOML form directly under it.

### Application ðŸ”’

````toml
[application]
````

Application-wide configuration. Applies to both web and desktop.

* **name** ðŸ”’ - Project name & title.
  ````toml
  name = "my_project"
  ````

* **default_platform** ðŸ”’ - The platform this project targets
  ````toml
  # Currently supported platforms: web, desktop
  default_platform = "web"
  ````

* **out_dir** - The directory to place the build artifacts from `dx build` or `dx serve` into. This is also where the `assets` directory will be copied into.
  ````toml
  out_dir = "dist"
  ````

* **asset_dir** - The directory with your static assets. The CLI will automatically copy these assets into the **out_dir** after a build/serve.
  ````toml
  asset_dir = "public"
  ````

* **sub_package** - The sub package in the workspace to build by default.
  ````toml
  sub_package = "my-crate"
  ````

### Web.App ðŸ”’

````toml
[web.app]
````

Web-specific configuration.

* **title** - The title of the web page.
  ````toml
  # HTML title tag content
  title = "project_name"
  ````

* **base_path** - The base path to build the application for serving at. This can be useful when serving your application in a subdirectory under a domain. For example, when building a site to be served on GitHub Pages.
  ````toml
  # The application will be served at domain.com/my_application/, so we need to modify the base_path to the path where the application will be served
  base_path = "my_application"
  ````

### Web.Watcher ðŸ”’

````toml
[web.watcher]
````

Development server configuration.

* **reload_html** - If this is true, the cli will rebuild the index.html file every time the application is rebuilt
  
  ````toml
  reload_html = true
  ````

* **watch_path** - The files & directories to monitor for changes
  
  ````toml
  watch_path = ["src", "public"]
  ````

* **index_on_404** - If enabled, Dioxus will serve the root page when a route is not found.
  *This is needed when serving an application that uses the router*. However, when serving your app using something else than Dioxus (e.g. GitHub Pages), you will have to check how to configure it on that platform. In GitHub Pages, you can make a copy of `index.html` named `404.html` in the same directory.
  
  ````toml
  index_on_404 = true
  ````

### Web.Resource ðŸ”’

````toml
[web.resource]
````

Static resource configuration.

* **style** - CSS files to include in your application.
  
  ````toml
  style = [
     # Include from public_dir.
     "./assets/style.css",
     # Or some asset from online cdn.
     "https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.css"
  ]
  ````

* **script** - JavaScript files to include in your application.
  
  ````toml
  script = [
      # Include from asset_dir.
      "./public/index.js",
      # Or from an online CDN.
      "https://cdn.jsdelivr.net/npm/bootstrap/dist/js/bootstrap.js"
  ]
  ````

### Web.Resource.Dev ðŸ”’

````toml
[web.resource.dev]
````

This is the same as [`[web.resource]`](#webresource-), but it only works in development servers. For example, if you want to include a file in a `dx serve` server, but not a `dx serve --release` server, put it here.

### Web.Proxy

````toml
[[web.proxy]]
````

Configuration related to any proxies your application requires during development. Proxies will forward requests to a new service.

* **backend** - The URL to the server to proxy. The CLI will forward any requests under the backend relative route to the backend instead of returning 404
  ````toml
  backend = "http://localhost:8000/api/"
  ````
  
  This will cause any requests made to the dev server with prefix /api/ to be redirected to the backend server at http://localhost:8000. The path and query parameters will be passed on as-is (path rewriting is currently not supported).

## Config example

This includes all fields, mandatory or not.

````toml
[application]

# App name
name = "project_name"

# The Dioxus platform to default to
default_platform = "web"

# `build` & `serve` output path
out_dir = "dist"

# The static resource path
asset_dir = "public"

[web.app]

# HTML title tag content
title = "project_name"

[web.watcher]

# When watcher is triggered, regenerate the `index.html`
reload_html = true

# Which files or dirs will be monitored
watch_path = ["src", "public"]

# Include style or script assets
[web.resource]

# CSS style file
style = []

# Javascript code file
script = []

[web.resource.dev]

# Same as [web.resource], but for development servers

# CSS style file
style = []

# JavaScript files
script = []

[[web.proxy]]
backend = "http://localhost:8000/api/"
````
# Translating existing HTML

Dioxus uses a custom format called RSX to represent the HTML because it is more concise and looks more like Rust code. However, it can be a pain to convert existing HTML to RSX. That's why Dioxus comes with a tool called `dx translate` that can automatically convert HTML to RSX!

Dx translate can make converting large chunks of HTML to RSX much easier! Lets try translating some of the HTML from the Dioxus homepage:

````sh
dx translate --raw  "<div class=\"relative w-full mx-4 sm:mx-auto text-gray-600\"><div class=\"text-[3em] md:text-[5em] font-semibold dark:text-white text-ghdarkmetal font-sans py-12 flex flex-col\"><span>Fullstack, crossplatform,</span><span>lightning fast, fully typed.</span></div><h3 class=\"text-[2em] dark:text-white font-extralight text-ghdarkmetal pt-4 max-w-screen-md mx-auto\">Dioxus is a Rust library for building apps that run on desktop, web, mobile, and more.</h3><div class=\"pt-12 text-white text-[1.2em] font-sans font-bold flex flex-row justify-center space-x-4\"><a href=\"/learn/0.5/getting_started\" dioxus-prevent-default=\"onclick\" class=\"bg-red-600 py-2 px-8 hover:-translate-y-2 transition-transform duration-300\" data-dioxus-id=\"216\">Quickstart</a><a href=\"/learn/0.5/reference\" dioxus-prevent-default=\"onclick\" class=\"bg-blue-500 py-2 px-8 hover:-translate-y-2 transition-transform duration-300\" data-dioxus-id=\"214\">Read the docs</a></div><div class=\"max-w-screen-2xl mx-auto pt-36\"><h1 class=\"text-md\">Trusted by top companies</h1><div class=\"pt-4 flex flex-row flex-wrap justify-center\"><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/futurewei_bw.png\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/airbuslogo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/ESA_logo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/yclogo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/satellite.webp\"></div></div></div></div>"
````

We get the following RSX you can easily copy and paste into your code:

````rs
div { class: "relative w-full mx-4 sm:mx-auto text-gray-600",
   div { class: "text-[3em] md:text-[5em] font-semibold dark:text-white text-ghdarkmetal font-sans py-12 flex flex-col",
      span { "Fullstack, crossplatform," }
      span { "lightning fast, fully typed." }
   }
   h3 { class: "text-[2em] dark:text-white font-extralight text-ghdarkmetal pt-4 max-w-screen-md mx-auto",
      "Dioxus is a Rust library for building apps that run on desktop, web, mobile, and more."
   }
   div { class: "pt-12 text-white text-[1.2em] font-sans font-bold flex flex-row justify-center space-x-4",
      a {
         href: "/learn/0.5/getting_started",
         data_dioxus_id: "216",
         dioxus_prevent_default: "onclick",
         class: "bg-red-600 py-2 px-8 hover:-translate-y-2 transition-transform duration-300",
         "Quickstart"
      }
      a {
         dioxus_prevent_default: "onclick",
         href: "/learn/0.5/reference",
         data_dioxus_id: "214",
         class: "bg-blue-500 py-2 px-8 hover:-translate-y-2 transition-transform duration-300",
         "Read the docs"
      }
   }
   div { class: "max-w-screen-2xl mx-auto pt-36",
      h1 { class: "text-md", "Trusted by top companies" }
      div { class: "pt-4 flex flex-row flex-wrap justify-center",
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "static/futurewei_bw.png" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "static/airbuslogo.svg" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "static/ESA_logo.svg" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "static/yclogo.svg" }
         }
         div { class: "h-12 w-40 p-2 m-4 flex justify-center items-center",
            img { src: "static/satellite.webp" }
         }
      }
   }
}
````

## Usage

The `dx translate` command has several flags you can use to control your html input and rsx output.

You can use the `--file` flag to translate an HTML file to RSX:

````sh
dx translate --file index.html
````

Or you can use the `--raw` flag to translate a string of HTML to RSX:

````sh
dx translate --raw "<div>Hello world</div>"
````

Both of those commands will output the following RSX:

````rs
div { "Hello world" }
````

The `dx translate` command will output the RSX to stdout. You can use the `--output` flag to write the RSX to a file instead.

````sh
dx translate --raw "<div>Hello world</div>" --output index.rs
````

You can automatically create a component with the `--component` flag.

````sh
dx translate --raw "<div>Hello world</div>" --component
````

This will output the following component:

````rs
fn component() -> Element {
   rsx! {
      div { "Hello world" }
   }
}
````

To learn more about the different flags `dx translate` supports, run `dx translate --help`.
# Contributing

Development happens in the [Dioxus GitHub repository](https://github.com/DioxusLabs/dioxus). If you've found a bug or have an idea for a feature, please submit an issue (but first check if someone hasn't [done it already](https://github.com/DioxusLabs/dioxus/issues)).

[GitHub discussions](https://github.com/DioxusLabs/dioxus/discussions) can be used as a place to ask for help or talk about features. You can also join [our Discord channel](https://discord.gg/XgGxMSkvUM) where some development discussion happens.

## Improving Docs

If you'd like to improve the docs, PRs are welcome! The Rust docs ([source](https://github.com/DioxusLabs/dioxus/tree/main/packages)) and this guide ([source](https://github.com/DioxusLabs/docsite/tree/main/docs-src/0.5/en)) can be found in their respective GitHub repos.

## Working on the Ecosystem

Part of what makes React great is the rich ecosystem. We'd like the same for Dioxus! So if you have a library in mind that you'd like to write and many people would benefit from, it will be appreciated. You can [browse npm.js](https://www.npmjs.com/search?q=keywords:react-component) for inspiration. Once you are done, add your library to the [awesome dioxus](https://github.com/DioxusLabs/awesome-dioxus) list or share it in the `#I-made-a-thing` channel on [Discord](https://discord.gg/XgGxMSkvUM).

## Bugs & Features

If you've fixed [an open issue](https://github.com/DioxusLabs/dioxus/issues), feel free to submit a PR! You can also take a look at [the roadmap](./roadmap.md) and work on something in there. Consider [reaching out](https://discord.gg/XgGxMSkvUM) to the team first to make sure everyone's on the same page, and you don't do useless work!

All pull requests (including those made by a team member) must be approved by at least one other team member.
Larger, more nuanced decisions about design, architecture, breaking changes, trade-offs, etc. are made by team consensus.

## Before you contribute

You might be surprised that a lot of checks fail when making your first PR.
That's why you should first run these commands before contributing, and it will save you *lots* of time, because the
GitHub CI is much slower at executing all of these than your PC.

* Format code with [rustfmt](https://github.com/rust-lang/rustfmt):

````sh
cargo fmt -- src/**/**.rs
````

* You might need to install some packages on Linux (Ubuntu/deb) before the following commands will complete successfully (there is also a Nix flake in the repo root):

````sh
sudo apt install libgdk3.0-cil libatk1.0-dev libcairo2-dev libpango1.0-dev libgdk-pixbuf2.0-dev libsoup-3.0-dev libjavascriptcoregtk-4.1-dev libwebkit2gtk-4.1-dev
````

* Check all code [cargo check](https://doc.rust-lang.org/cargo/commands/cargo-check.html):

````sh
cargo check --workspace --examples --tests
````

* Check if [Clippy](https://doc.rust-lang.org/clippy/) generates any warnings. Please fix these!

````sh
cargo clippy --workspace --examples --tests -- -D warnings
````

* Test all code with [cargo-test](https://doc.rust-lang.org/cargo/commands/cargo-test.html):

````sh
cargo test --all --tests
````

* More tests, this time with [cargo-make](https://sagiegurari.github.io/cargo-make/). Here are all steps, including installation:

````sh
cargo install --force cargo-make
cargo make tests
````

* Test unsafe crates with [MIRI](https://github.com/rust-lang/miri). Currently, this is used for the two MIRI tests in `dioxus-core` and `dioxus-native-core`:

````sh
cargo miri test --package dioxus-core --test miri_stress
cargo miri test --package dioxus-native-core --test miri_native
````

* Test with Playwright. This tests the UI itself, right in a browser. Here are all steps, including installation:
  **Disclaimer: This might inexplicably fail on your machine without it being your fault.** Make that PR anyway!

````sh
cd playwright-tests
npm ci
npm install -D @playwright/test
npx playwright install --with-deps
npx playwright test
````

## How to test dioxus with local crate

If you are developing a feature, you should test it in your local setup before raising a PR. This process makes sure you are aware of your code functionality before being reviewed by peers.

* Fork the following github repo (DioxusLabs/dioxus):

`https://github.com/DioxusLabs/dioxus`

* Create a new or use an existing rust crate (ignore this step if you will use an existing rust crate):
  This is where we will be testing the features of the forked

````sh
cargo new --bin demo
````

* Add the dioxus dependency to your rust crate (new/existing) in Cargo.toml:

````toml
dioxus = { path = "<path to forked dioxus project>/dioxus/packages/dioxus", features = ["web", "router"] }
````

This above example is for dioxus-web, with dioxus-router. To know about the dependencies for different renderer visit [here](https://dioxuslabs.com/learn/0.5/getting_started).

* Run and test your feature

````sh
dx serve
````

If this is your first time with dioxus, please read [the guide](https://dioxuslabs.com/learn/0.5/guide) to get familiar with dioxus.
# Project Structure

There are many packages in the Dioxus organization. This document will help you understand the purpose of each package and how they fit together.

## Renderers

* [Desktop](https://github.com/DioxusLabs/dioxus/tree/main/packages/desktop): A Render that Runs Dioxus applications natively, but renders them with the system webview
* [Mobile](https://github.com/DioxusLabs/dioxus/tree/main/packages/mobile): A Render that Runs Dioxus applications natively, but renders them with the system webview. This is currently a copy of the desktop render
* [Web](https://github.com/DioxusLabs/dioxus/tree/main/packages/web): Renders Dioxus applications in the browser by compiling to WASM and manipulating the DOM
* [Liveview](https://github.com/DioxusLabs/dioxus/tree/main/packages/liveview): A Render that Runs on the server, and renders using a websocket proxy in the browser
* [Plasmo](https://github.com/DioxusLabs/blitz/tree/master/packages/plasmo): A Renderer that renders a HTML-like tree into a terminal
* [TUI](https://github.com/DioxusLabs/blitz/tree/master/packages/dioxus-tui): A Renderer that uses Plasmo to render a Dioxus application in a terminal
* [Blitz-Core](https://github.com/DioxusLabs/blitz/tree/master/packages/blitz-core): An experimental native renderer that renders a HTML-like tree using WGPU.
* [Blitz](https://github.com/DioxusLabs/blitz): An experimental native renderer that uses Blitz-Core to render a Dioxus application using WGPU.
* [SSR](https://github.com/DioxusLabs/dioxus/tree/main/packages/ssr): A Render that Runs Dioxus applications on the server, and renders them to HTML

## State Management/Hooks

* [Hooks](https://github.com/DioxusLabs/dioxus/tree/main/packages/hooks): A collection of common hooks for Dioxus applications
* [Signals](https://github.com/DioxusLabs/dioxus/tree/main/packages/signals): A experimental state management library for Dioxus applications. This currently contains a `Copy` version of Signal
* [SDK](https://github.com/DioxusLabs/sdk): A collection of platform agnostic hooks to interact with system interfaces (The clipboard, camera, etc.).
* [Fermi](https://github.com/DioxusLabs/dioxus/tree/main/packages/fermi): A global state management library for Dioxus applications.
* [Router](https://github.com/DioxusLabs/dioxus/tree/main/packages/router): A client-side router for Dioxus applications

## Core utilities

* [core](https://github.com/DioxusLabs/dioxus/tree/main/packages/core): The core virtual dom implementation every Dioxus application uses
  * You can read more about the architecture of the core [in this blog post](https://dioxuslabs.com/blog/templates-diffing/) and the [custom renderer section of the guide](../cookbook/custom_renderer.md)
* [RSX](https://github.com/DioxusLabs/dioxus/tree/main/packages/rsx): The core parsing for RSX used for hot reloading, autoformatting, and the macro
* [core-macro](https://github.com/DioxusLabs/dioxus/tree/main/packages/core-macro): The rsx! macro used to write Dioxus applications. (This is a wrapper over the RSX crate)
* [HTML macro](https://github.com/DioxusLabs/dioxus-html-macro): A html-like alternative to the RSX macro

## Native Renderer Utilities

* [native-core](https://github.com/DioxusLabs/blitz/tree/main/packages/native-core): Incrementally computed tree of states (mostly styles)
  * You can read more about how native-core can help you build native renderers in the [custom renderer section of the guide](../cookbook/custom_renderer.md#native-core)
* [native-core-macro](https://github.com/DioxusLabs/blitz/tree/main/packages/native-core-macro): A helper macro for native core
* [Taffy](https://github.com/DioxusLabs/taffy): Layout engine powering Blitz-Core, Plasmo, and Bevy UI

## Web renderer tooling

* [HTML](https://github.com/DioxusLabs/dioxus/tree/main/packages/html): defines html specific elements, events, and attributes
* [Interpreter](https://github.com/DioxusLabs/dioxus/tree/main/packages/interpreter): defines browser bindings used by the web and desktop renderers

## Developer tooling

* [hot-reload](https://github.com/DioxusLabs/dioxus/tree/main/packages/hot-reload): Macro that uses the RSX crate to hot reload static parts of any rsx! macro. This macro works with any non-web renderer with an [integration](https://crates.io/crates/dioxus-hot-reload)
* [autofmt](https://github.com/DioxusLabs/dioxus/tree/main/packages/autofmt): Formats RSX code
* [rsx-rosetta](https://github.com/DioxusLabs/dioxus/tree/main/packages/rsx-rosetta): Handles conversion between HTML and RSX
* [CLI](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli): A Command Line Interface and VSCode extension to assist with Dioxus usage
# Overall Goals

This document outlines some of the overall goals for Dioxus. These goals are not set in stone, but they represent general guidelines for the project.

The goal of Dioxus is to make it easy to build **cross-platform applications that scale**.

## Cross-Platform

Dioxus is designed to be cross-platform by default. This means that it should be easy to build applications that run on the web, desktop, and mobile. However, Dioxus should also be flexible enough to allow users to opt into platform-specific features when needed. The `use_eval` is one example of this. By default, Dioxus does not assume that the platform supports JavaScript, but it does provide a hook that allows users to opt into JavaScript when needed.

## Performance

As Dioxus applications grow, they should remain relatively performant without the need for manual optimizations. There will be cases where manual optimizations are needed, but Dioxus should try to make these cases as rare as possible.

One of the benefits of the core architecture of Dioxus is that it delivers reasonable performance even when components are rerendered often. It is based on a Virtual Dom which performs diffing which should prevent unnecessary re-renders even when large parts of the component tree are rerun. On top of this, Dioxus groups static parts of the RSX tree together to skip diffing them entirely.

## Type Safety

As teams grow, the Type safety of Rust is a huge advantage. Dioxus should leverage this advantage to make it easy to build applications with large teams.

To take full advantage of Rust's type system, Dioxus should try to avoid exposing public `Any` types and string-ly typed APIs where possible.

## Developer Experience

Dioxus should be easy to learn and ergonomic to use.

* The API of Dioxus attempts to remain close to React's API where possible. This makes it easier for people to learn Dioxus if they already know React

* We can avoid the tradeoff between simplicity and flexibility by providing multiple layers of API: One for the very common use case, one for low-level control
  
  * Hooks: the hooks crate has the most common use cases, but `use_hook` provides a way to access the underlying persistent value if needed.
  * The builder pattern in platform Configs: The builder pattern is used to default to the most common use case, but users can change the defaults if needed.
* Documentation:
  
  * All public APIs should have rust documentation
  * Examples should be provided for all public features. These examples both serve as documentation and testing. They are checked by CI to ensure that they continue to compile
  * The most common workflows should be documented in the guide
# Roadmap & Feature-set

This feature set and roadmap can help you decide if what Dioxus can do today works for you.

If a feature that you need doesn't exist or you want to contribute to projects on the roadmap, feel free to get involved by [joining the discord](https://discord.gg/XgGxMSkvUM).

Generally, here's the status of each platform:

* **Web**: Dioxus is a great choice for pure web-apps â€“ especially for CRUD/complex apps. However, it does lack the ecosystem of React, so you might be missing a component library or some useful hook.

* **SSR**: Dioxus is a great choice for pre-rendering, hydration, and rendering HTML on a web endpoint. Be warned â€“ the VirtualDom is not (currently) `Send + Sync`.

* **Desktop**: You can build very competent single-window desktop apps right now. However, multi-window apps require support from Dioxus core and are not ready.

* **Mobile**: Mobile support is very young. You'll be figuring things out as you go and there are not many support crates for peripherals.

* **LiveView**: LiveView support is very young. You'll be figuring things out as you go. Thankfully, none of it is too hard and any work can be upstreamed into Dioxus.

## Features

---

|Feature|Status|Description|
|-------|------|-----------|
|Conditional Rendering|x|if/then to hide/show component|
|Map, Iterator|x|map/filter/reduce to produce rsx!|
|Keyed Components|x|advanced diffing with keys|
|Web|x|renderer for web browser|
|Desktop (webview)|x|renderer for desktop|
|Shared State (Context)|x|share state through the tree|
|Hooks|x|memory cells in components|
|SSR|x|render directly to string|
|Component Children|x|cx.children() as a list of nodes|
|Headless components|x|components that don't return real elements|
|Fragments|x|multiple elements without a real root|
|Manual Props|x|Manually pass in props with spread syntax|
|Controlled Inputs|x|stateful wrappers around inputs|
|CSS/Inline Styles|x|syntax for inline styles/attribute groups|
|Custom elements|x|Define new element primitives|
|Suspense|x|schedule future render from future/promise|
|Integrated error handling|x|Gracefully handle errors with ? syntax|
|NodeRef|x|gain direct access to nodes|
|Re-hydration|x|Pre-render to HTML to speed up first contentful paint|
|Jank-Free Rendering|x|Large diffs are segmented across frames for silky-smooth transitions|
|Effects|x|Run effects after a component has been committed to render|
|Portals|\*|Render nodes outside of the traditional tree structure|
|Cooperative Scheduling|\*|Prioritize important events over non-important events|
|Server Components|\*|Hybrid components for SPA and Server|
|Bundle Splitting|i|Efficiently and asynchronously load the app|
|Lazy Components|i|Dynamically load the new components as the page is loaded|
|1st class global state|x|redux/recoil/mobx on top of context|
|Runs natively|x|runs as a portable binary w/o a runtime (Node)|
|Subtree Memoization|x|skip diffing static element subtrees|
|High-efficiency templates|x|rsx! calls are translated to templates on the DOM's side|
|Compile-time correct|x|Throw errors on invalid template layouts|
|Heuristic Engine|x|track component memory usage to minimize future allocations|
|Fine-grained reactivity|i|Skip diffing for fine-grain updates|

* x = implemented and working
* \* = actively being worked on
* i = not yet implemented or being worked on

## Roadmap

These Features are planned for the future of Dioxus:

### Core

* [x] Release of Dioxus Core
* [x] Upgrade documentation to include more theory and be more comprehensive
* [x] Support for HTML-side templates for lightning-fast dom manipulation
* [ ] Support for multiple renderers for same virtualdom (subtrees)
* [ ] Support for ThreadSafe (Send + Sync)
* [ ] Support for Portals

### SSR

* [x] SSR Support + Hydration
* [x] Integrated suspense support for SSR

### Desktop

* [ ] Declarative window management
* [ ] Templates for building/bundling
* [ ] Access to Canvas/WebGL context natively

### Mobile

* [ ] Mobile standard library
  * [ ] GPS
  * [ ] Camera
  * [ ] filesystem
  * [ ] Biometrics
  * [ ] WiFi
  * [ ] Bluetooth
  * [ ] Notifications
  * [ ] Clipboard
* [ ] Animations

### Bundling (CLI)

* [x] Translation from HTML into RSX
* [x] Dev server
* [x] Live reload
* [x] Translation from JSX into RSX
* [ ] Hot module replacement
* [ ] Code splitting
* [x] Asset macros
* [x] Css pipeline
* [x] Image pipeline

### Essential hooks

* [x] Router
* [x] Global state management
* [ ] Resize observer

## Work in Progress

### Build Tool

We are currently working on our own build tool called [Dioxus CLI](https://github.com/DioxusLabs/dioxus/tree/main/packages/cli) which will support:

* an interactive TUI
* on-the-fly reconfiguration
* hot CSS reloading
* two-way data binding between browser and source code
* an interpreter for `rsx!`
* ability to publish to github/netlify/vercel
* bundling for iOS/Desktop/etc

### Server Component Support

While not currently fully implemented, the expectation is that LiveView apps can be a hybrid between Wasm and server-rendered where only portions of a page are "live" and the rest of the page is either server-rendered, statically generated, or handled by the host SPA.

### Native rendering

We are currently working on a native renderer for Dioxus using WGPU called [Blitz](https://github.com/DioxusLabs/blitz/). This will allow you to build apps that are rendered natively for iOS, Android, and Desktop.
# How to Upgrade to Dioxus 0.5

This guide will outline the API changes between the `0.4` and `0.5` releases.

`0.5` has includes significant changes to hooks, props, and global state.

## Cheat Sheet

Here is a quick cheat sheet for the changes:

### Scope

Dioxus 0.4:

````rust
fn app(cx: Scope) -> Element {
    cx.use_hook(|| {
        /*...*/
    });
    cx.provide_context({
        /*...*/
    });
    cx.spawn(async move {
        /*...*/
    });
    cx.render(rsx! {
        /*...*/
    })
}
````

Dioxus 0.5:

````rs@migration.rs
use dioxus::prelude::*;

// In dioxus 0.5, the scope is no longer passed as an argument to the function
fn app() -> Element {
    // Hooks, context, and spawn are now called directly
    use_hook(|| { /*...*/ });
    provide_context({ /*...*/ });
    spawn(async move { /*...*/ });
    rsx! {
        /*...*/
    }
}
````

### Props

Dioxus 0.4:

````rust
#[component]
fn Comp(cx: Scope, name: String) -> Element {
    // You pass in an owned prop, but inside the component, it is borrowed (name is the type &String inside the function)
    let owned_name: String = name.clone();

    cx.render(rsx! {
        "Hello {owned_name}"
        BorrowedComp {
            "{name}"
        }
        ManualPropsComponent {
            name: name
        }
    })
}

#[component]
fn BorrowedComp<'a>(cx: Scope<'a>, name: &'a str) -> Element<'a> {
    cx.render(rsx! {
        "Hello {name}"
    })
}

#[derive(Props, PartialEq)]
struct ManualProps {
    name: String
}

fn ManualPropsComponent(cx: Scope<ManualProps>) -> Element {
    cx.render(rsx! {
        "Hello {cx.props.name}"
    })
}
````

Dioxus 0.5:

````rs@migration.rs
use dioxus::prelude::*;

// In dioxus 0.5, props are always owned. You pass in owned props and you get owned props in the body of the component
#[component]
fn Comp(name: String) -> Element {
    // Name is owned here already (name is the type String inside the function)
    let owned_name: String = name;

    rsx! {
        "Hello {owned_name}"
        BorrowedComp {
            name: "other name"
        }
        ManualPropsComponent {
            name: "other name 2"
        }
    }
}

// Borrowed props are removed in dioxus 0.5. Mapped signals can act similarly to borrowed props if your props are borrowed from state
// ReadOnlySignal is a copy wrapper over a state that will be automatically converted to
#[component]
fn BorrowedComp(name: ReadOnlySignal<String>) -> Element {
    rsx! {
        "Hello {name}"
    }
}

// In dioxus 0.5, props need to implement Props, Clone, and PartialEq
#[derive(Props, Clone, PartialEq)]
struct ManualProps {
    name: String,
}

// Functions accept the props directly instead of the scope
fn ManualPropsComponent(props: ManualProps) -> Element {
    rsx! {
        "Hello {props.name}"
    }
}
````

You can read more about the new props API in the [Props Migration](props.md) guide.

### Futures

Dioxus 0.4:

````rust
use_future((dependency1, dependency2,), move |(dependency1, dependency2,)| async move {
	/*use dependency1 and dependency2*/
});
````

Dioxus 0.5:

````rs@migration.rs
// dependency1 and dependency2 must be Signal-like types like Signal, ReadOnlySignal, GlobalSignal, or another Resource
use_resource(|| async move { /*use dependency1 and dependency2*/ });

let non_reactive_state = 0;
// You can also add non-reactive state to the resource hook with the use_reactive macro
use_resource(use_reactive!(|(non_reactive_state,)| async move {
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    non_reactive_state + 1
}));
````

Read more about the `use_resource` hook in the [Hook Migration](hooks.md) guide.

### State Hooks

Dioxus 0.4:

````rust
let copy_state = use_state(cx, || 0);
let clone_local_state = use_ref(cx, || String::from("Hello"));
use_shared_state_provider(cx, || String::from("Hello"));
let clone_shared_state = use_shared_state::<String>(cx);

let copy_state_value = **copy_state;
let clone_local_state_value = clone_local_state.read();
let clone_shared_state_value = clone_shared_state.read();

cx.render(rsx!{
	"{copy_state_value}"
	"{clone_shared_state_value}"
	"{clone_local_state_value}"
	button {
		onclick: move |_| {
			copy_state.set(1);
			*clone_local_state.write() = "World".to_string();
			*clone_shared_state.write() = "World".to_string();
		},
		"Set State"
	}
})
````

Dioxus 0.5:

````rs@migration.rs
// You can now use signals for local copy state, local clone state, and shared state with the same API
let mut copy_state = use_signal(|| 0);
let mut clone_shared_state = use_context_provider(|| Signal::new(String::from("Hello")));
let mut clone_local_state = use_signal(|| String::from("Hello"));

// Call the signal like a function to clone the current value
let copy_state_value = copy_state();
// Or use the read method to borrow the current value
let clone_local_state_value = clone_local_state.read();
let clone_shared_state_value = clone_shared_state.read();

rsx! {
    "{copy_state_value}"
    "{clone_shared_state_value}"
    "{clone_local_state_value}"
    button {
        onclick: move |_| {
            // All three states have the same API for updating the state
            copy_state.set(1);
            clone_shared_state.set("World".to_string());
            clone_local_state.set("World".to_string());
        },
        "Set State"
    }
}
````

Read more about the `use_signal` hook in the [State Migration](state.md) guide.

### Fermi

Dioxus 0.4:

````rust
use dioxus::prelude::*;
use fermi::*;

static NAME: Atom<String> = Atom(|_| "world".to_string());

fn app(cx: Scope) -> Element {
    use_init_atom_root(cx);
    let name = use_read(cx, &NAME);

    cx.render(rsx! {
        div { "hello {name}!" }
        Child {}
        ChildWithRef {}
    })
}

fn Child(cx: Scope) -> Element {
    let set_name = use_set(cx, &NAME);

    cx.render(rsx! {
        button {
            onclick: move |_| set_name("dioxus".to_string()),
            "reset name"
        }
    })
}

static NAMES: AtomRef<Vec<String>> = AtomRef(|_| vec!["world".to_string()]);

fn ChildWithRef(cx: Scope) -> Element {
    let names = use_atom_ref(cx, &NAMES);

    cx.render(rsx! {
        div {
            ul {
                names.read().iter().map(|f| rsx!{
                    li { "hello: {f}" }
                })
            }
            button {
                onclick: move |_| {
                    let names = names.clone();
                    cx.spawn(async move {
                        names.write().push("asd".to_string());
                    })
                },
                "Add name"
            }
        }
    })
}
````

Dioxus 0.5:

````rs@migration.rs
use dioxus::prelude::*;

// Atoms and AtomRefs have been replaced with GlobalSignals
static NAME: GlobalSignal<String> = Signal::global(|| "world".to_string());

fn app() -> Element {
    rsx! {
        // You can use global state directly without the use_read or use_set hooks
        div { "hello {NAME}!" }
        Child {}
        ChildWithRef {}
    }
}

fn Child() -> Element {
    rsx! {
        button {
            onclick: move |_| *NAME.write() = "dioxus".to_string(),
            "reset name"
        }
    }
}

// Atoms and AtomRefs have been replaced with GlobalSignals
static NAMES: GlobalSignal<Vec<String>> = Signal::global(|| vec!["world".to_string()]);

fn ChildWithRef() -> Element {
    rsx! {
        div {
            ul {
                for name in NAMES.read().iter() {
                    li { "hello: {name}" }
                }
            }
            button {
                onclick: move |_| {
                    // No need to clone the signal into futures, you can use it directly
                    async move {
                        NAMES.write().push("asd".to_string());
                    }
                },
                "Add name"
            }
        }
    }
}
````

You can read more about global signals in the [Fermi migration guide](fermi.md).
# Hooks

Dioxus now uses signals as the backing for its state management. Signals are a smarter, more flexible version of the `use_ref` hook. Signals now back many hooks in dioxus to provide a more consistent and flexible API.

### State Hooks

State hooks are now backed by signals. `use_state`, `use_ref`, and `use_shared_state` have been replaced with the `use_signal` hook. The `use_signal` hook is a more flexible and powerful version of the `use_ref` hook with smarter scopes that only subscribe to a signal if that signal is read within the scope. You can read more about the `use_signal` hook in the [State Migration](state.md) guide.

### Async Hooks

The `use_future` hook has been replaced with the `use_resource` hook. `use_resource` automatically subscribes to any signals that are read within the closure instead of using a tuple of dependencies.

Dioxus 0.4:

````rust
fn MyComponent(cx: Scope) -> Element {
	let state = use_state(cx, || 0);
	let my_resource = use_future(cx, (**state,), |(state,)| async move {
		// start a request that depends on the state
		println!("{state}");
	});
	render! {
		"{state}"
	}
}
````

Dioxus 0.5:

````rs@migration_hooks.rs
fn MyComponent() -> Element {
    let state = use_signal(|| 0);
    // No need to manually set the dependencies, the use_resource hook will automatically detect signal dependencies
    let my_resource = use_resource(move || async move {
        // start a request that depends on the state
        // Because we read from the state signal, this future will be re-run whenever the state changes
        println!("{state}");
    });
    rsx! {"{state}"}
}
````

### Dependencies

Some hooks including `use_effect` and `use_resource` now take a single closure with automatic subscriptions instead of a tuple of dependencies. You can read more about the `use_resource` hook in the [Hook Migration](hooks.md) guide.

Dioxus 0.4:

````rust
fn HasDependencies(cx: Scope) -> Element {
	let state = use_state(cx, || 0);
	let my_resource = use_resource(cx, (**state,), |(state,)| async move {
		println!("{state}");
	});
	let state_plus_one = use_memo(cx, (**state,), |(state,)| {
		state() + 1
	});
	render! {
		"{state_plus_one}"
	}
}
````

Dioxus 0.5:

````rs@migration_hooks.rs
fn HasDependencies() -> Element {
    let state = use_signal(|| 0);
    // No need to manually set the dependencies, the use_resource hook will automatically detect signal dependencies
    let my_resource = use_resource(move || async move {
        // Because we read from the state signal, this future will be re-run whenever the state changes
        println!("{state}");
    });
    let state_plus_one = use_memo(move || {
        // Because we read from the state signal, this future will be re-run whenever the state changes
        state() + 1
    });
    rsx! {"{state_plus_one}"}
}
````
# State Migration

The `use_state` and `use_ref` hooks have been replaced with the `use_signal` hook. The `use_signal` hook is a more flexible and powerful version of the `use_ref` hook with smarter scopes that only subscribe to a signal if that signal is read within the scope.

With `use_state`, if you had this code:

````rust
fn Parent(cx: Scope) -> Element {
	let state = use_state(cx, || 0);

	render! {
		Child {
			state: state.clone()
		}
	}
}

#[component]
fn Child(cx: Scope, state: UseState<i32>) -> Element {
	render! {
		"{state}"
	}
}
````

Parent would re-render every time the state changed even though only the child component was using the state. With the new `use_signal` hook, the parent would only re-render if the state was changed within the parent component:

````rs@migration_state.rs
fn Parent() -> Element {
    let state = use_signal(|| 0);

    rsx! { Child { state } }
}

#[component]
fn Child(state: Signal<i32>) -> Element {
    rsx! {"{state}"}
}
````

Only the child component will re-render when the state changes because only the child component is reading the state.

## Context Based State

The `use_shared_state_provider` and `use_shared_state` hooks have been replaced with using the `use_context_provider` and `use_context` hooks with a `Signal`:

````rs@migration_state.rs
fn Parent() -> Element {
    // Create a new signal and provide it to the context API
    let state = use_context_provider(|| Signal::new(0));

    rsx! { Child {} }
}

fn Child() -> Element {
    // Get the state from the context API
    let state = use_context::<Signal<i32>>();

    rsx! {"{state}"}
}
````

Signals are smart enough to handle subscribing to the right scopes without a special shared state hook.

## Opting Out of Subscriptions

Some state hooks including `use_shared_state` and `use_ref` hooks had a function called `write_silent` in `0.4`. This function allowed you to update the state without triggering a re-render any subscribers. This function has been removed in `0.5`.

Instead, you can use the `peek` function to read the current value of a signal without subscribing to it. This inverts the subscription model so that you can opt out of subscribing to a signal instead of opting all subscribers out of updates:

````rs@migration_state.rs
fn Parent() -> Element {
    let state = use_signal(|| 0);

    // Even though we are reading the state, we don't need to subscribe to it
    let read_without_subscribing = state.peek();
    println!("{}", state.peek());

    rsx! { Child { state } }
}

#[component]
fn Child(state: Signal<i32>) -> Element {
    rsx! {
        button { onclick: move |_| {
                state += 1;
            }, "count is {state}" }
    }
}
````

`peek` gives you more fine-grained control over when you want to subscribe to a signal. This can be useful for performance optimizations and for updating state without re-rendering components.

## Global State

In `0.4`, the fermi crate provided a separate global state API called atoms. In `0.5`, the `Signal` type has been extended to provide a global state API. You can use the `Signal::global` function to create a global signal:

````rs@migration_state.rs
static COUNT: GlobalSignal<i32> = Signal::global(|| 0);

fn Parent() -> Element {
    rsx! {
        div { "{COUNT}" }
        button {
            onclick: move |_| {
                *COUNT.write() += 1;
            },
            "Increment"
        }
    }
}
````

You can read more about global signals in the [Fermi migration guide](fermi.md).
# Fermi

In dioxus 0.5, fermi atoms have been replaced with global signals and included in the main dioxus library.

The new global signals can be used directly without hooks and include additional functionality like global memos.

Dioxus 0.4:

````rust
use dioxus::prelude::*;
use fermi::*;

static NAME: Atom<String> = Atom(|_| "world".to_string());
static NAMES: AtomRef<Vec<String>> = AtomRef(|_| vec!["world".to_string()]);

fn app(cx: Scope) -> Element {
    use_init_atom_root(cx);
    let set_name = use_set(cx, &NAME);
	let names = use_atom_ref(cx, &NAMES);

    cx.render(rsx! {
        button {
			onclick: move |_| set_name("dioxus".to_string()),
			"reset name"
		}
		"{names.read():?}"
    })
}
````

Dioxus 0.5:

````rs@migration_fermi.rs
use dioxus::prelude::*;

static NAME: GlobalSignal<String> = Signal::global(|| "world".to_string());
// Global signals work for copy and clone types in the same way
static NAMES: GlobalSignal<Vec<String>> = Signal::global(|| vec!["world".to_string()]);

fn app() -> Element {
    // No need to use use_init_atom_root, use_set, or use_atom_ref. Just use the global signal directly
    rsx! {
        button { onclick: move |_| *NAME.write() = "reset name".to_string(), "reset name" }
        "{NAMES:?}"
    }
}
````

## Memos

Dioxus 0.5 introduces global memos which can be used to store computed values globally.

````rs@migration_fermi.rs
static COUNT: GlobalSignal<u32> = Signal::global(|| 0);
static MEMO: GlobalMemo<u32> = Signal::global_memo(|| COUNT() + 1);

fn GlobalMemo() -> Element {
    rsx! {
        button { onclick: move |_| *COUNT.write() += 1, "increment" }
        // Global memos can be used like signals
        "{MEMO}"
    }
}
````
# Props Migration

In dioxus 0.4, props are passed into the component through the scope. In dioxus 0.5, props are passed into the component through the props struct directly.

## Owned Props

The props were borrowed with the lifetime from the scope. The props are cloned every render, and passed into the component as an owned value.

Dioxus 0.4:

````rust
#[component]
fn Comp(cx: Scope, name: String) -> Element {
    // You pass in an owned prop, but inside the component, it is borrowed (name is the type &String inside the function)
    let owned_name: String = name.clone();

    cx.render(rsx! {
        "Hello {owned_name}"
    })
}
````

Dioxus 0.5:

````rs@migration_props.rs
// In dioxus 0.5, props are always owned. You pass in owned props and you get owned props in the body of the component
#[component]
fn Comp(name: String) -> Element {
    // Name is owned here already (name is the type String inside the function)
    let owned_name: String = name;

    rsx! {"Hello {owned_name}"}
}
````

Because props are cloned every render, making props Copy is recommended. You can easily make a field Copy by accepting `ReadOnlySignal<T>` instead of `T` in the props struct:

````rs@migration_props.rs
// In dioxus 0.5, props are always owned. You pass in owned props and you get owned props in the body of the component
#[component]
fn CopyPropsComp(name: ReadOnlySignal<String>) -> Element {
    rsx! {
        button {
            // You can easily copy the value of a signal into a closure
            onclick: move |_| {
                println!("Hello {name}");
                async move {
                    println!("Hello {name}");
                }
            },
            "Click me"
        }
    }
}

fn CopyPropsCompParent() -> Element {
    rsx! { CopyPropsComp { name: "World" } }
}
````

## Borrowed Props

Borrowed props are removed in dioxus 0.5. Mapped signals can act similarly to borrowed props if your props are borrowed from state.

Dioxus 0.4:

````rust
fn Parent(cx: Scope) -> Element {
    let state = use_state(cx, || (1, "World".to_string()));
    rsx! {
        BorrowedComp {
            name: &state.get().1
        }
    }
}

#[component]
fn BorrowedComp<'a>(cx: Scope<'a>, name: &'a str) -> Element<'a> {
    rsx! {
        "Hello {name}"
    }
}
````

Dioxus 0.5:

````rs@migration_props.rs
fn Parent() -> Element {
    let state = use_signal(|| (1, "World".to_string()));

    rsx! { BorrowedComp { name: state.map(|s| &s.1) } }
}

#[component]
fn BorrowedComp(name: MappedSignal<String>) -> Element {
    rsx! {"Hello {name}"}
}
````

## Manual Props

Manual prop structs in dioxus 0.5 need to derive `Clone` in addition to `Props` and `PartialEq`:

Dioxus 0.4:

````rust
#[derive(Props, PartialEq)]
struct ManualProps {
    name: String,
}

// Functions accept the props directly instead of the scope
fn ManualPropsComponent(cx: Scope<ManualProps>) -> Element {
    render! {
        "Hello {cx.props.name}"
    }
}
````

Dioxus 0.5:

````rs@migration_props.rs
#[derive(Props, Clone, PartialEq)]
struct ManualProps {
    name: String,
}

// Functions accept the props directly instead of the component
fn ManualPropsComponent(props: ManualProps) -> Element {
    rsx! {"Hello {props.name}"}
}
````
# Introduction

Dioxus is a portable, performant, and ergonomic framework for building cross-platform user interfaces in Rust. This guide will help you get started with writing Dioxus apps for the Web, Desktop, Mobile, and more.

````rs@readme.rs
use dioxus::prelude::*;

pub fn App(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    })
}

````

````inject-dioxus
DemoFrame {
    readme::App {}
}
````

Dioxus is heavily inspired by React. If you know React, getting started with Dioxus will be a breeze.

 > 
 > This guide assumes you already know some [Rust](https://www.rust-lang.org/)! If not, we recommend reading [*the book*](https://doc.rust-lang.org/book/ch01-00-getting-started.html) to learn Rust first.

## Features

* Desktop apps running natively (no Electron!) in less than 10 lines of code.
* Incredibly ergonomic and powerful state management.
* Comprehensive inline documentation â€“ hover and guides for all HTML elements, listeners, and events.
* Extremely memory efficient â€“ 0 global allocations for steady-state components.
* Multi-channel asynchronous scheduler for first-class async support.
* And more! Read the [full release post](https://dioxuslabs.com/blog/introducing-dioxus/).

### Multiplatform

Dioxus is a *portable* toolkit, meaning the Core implementation can run anywhere with no platform-dependent linking. Unlike many other Rust frontend toolkits, Dioxus is not intrinsically linked to WebSys. In fact, every element and event listener can be swapped out at compile time. By default, Dioxus ships with the `html` feature enabled, but this can be disabled depending on your target renderer.

Right now, we have several 1st-party renderers:

* WebSys (for WASM): Great support
* Tao/Tokio (for Desktop apps): Good support
* Tao/Tokio (for Mobile apps): Poor support
* SSR (for generating static markup)
* TUI/Rink (for terminal-based apps): Experimental

## Stability

Dioxus has not reached a stable release yet.

Web: Since the web is a fairly mature platform, we expect there to be very little API churn for web-based features.

Desktop: APIs will likely be in flux as we figure out better patterns than our ElectronJS counterpart.

SSR: We don't expect the SSR API to change drastically in the future.
# Getting Started

This section will help you set up your Dioxus project!

## Prerequisites

### An Editor

Dioxus integrates very well with the [Rust-Analyzer LSP plugin](https://rust-analyzer.github.io) which will provide appropriate syntax highlighting, code navigation, folding, and more.

### Rust

Head over to [https://rust-lang.org](http://rust-lang.org) and install the Rust compiler.

We strongly recommend going through the [official Rust book](https://doc.rust-lang.org/book/ch01-00-getting-started.html) *completely*. However, we hope that a Dioxus app can serve as a great first Rust project. With Dioxus, you'll learn about:

* Error handling
* Structs, Functions, Enums
* Closures
* Macros

We've put a lot of care into making Dioxus syntax familiar and easy to understand, so you won't need deep knowledge of async, lifetimes, or smart pointers until you start building complex Dioxus apps.

## Setup Guides

Dioxus supports multiple platforms. Choose the platform you want to target below to get platform-specific setup instructions:

* [Choosing a Web Renderer](choosing_a_web_renderer.md)
* [Client Side](wasm.md): runs in the browser through WebAssembly
* [Liveview](liveview.md): runs on the server, renders in the browser using WebSockets
* [Fullstack](fullstack.md): renders to HTML text on the server and hydrates it on the client
* [Desktop](desktop.md): runs in a web view on desktop
* [Mobile](mobile.md): runs in a web view on mobile
* [Terminal UI](tui.md): renders text-based graphics in the terminal

 > 
 > More information on any platform you choose is available in the section of the same name in the [Reference](../reference/index.md)
# Choosing a web renderer

Dioxus has three different renderers that target the web:

* [dioxus-web](wasm.md) allows you to render your application to HTML with [WebAssembly](https://rustwasm.github.io/docs/book/) on the client
* [dioxus-liveview](liveview.md) allows you to run your application on the server and render it to HTML on the client with a websocket
* [dioxus-fullstack](fullstack.md) allows you to initially render static HTML on the server and then update that HTML from the client with [WebAssembly](https://rustwasm.github.io/docs/book/)

Each approach has its tradeoffs:

### Dioxus Liveview

* Liveview rendering communicates with the server over a WebSocket connection. It essentially moves all of the work that Client-side rendering does to the server.

* This makes it **easy to communicate with the server, but more difficult to communicate with the client/browser APIS**.

* Each interaction also requires a message to be sent to the server and back which can cause **issues with latency**.

* Because Liveview uses a websocket to render, the page will be blank until the WebSocket connection has been established and the first renderer has been sent from the websocket. Just like with client side rendering, this can make the page **less SEO-friendly**.

* Because the page is rendered on the server and the page is sent to the client piece by piece, you never need to send the entire application to the client. The initial load time can be faster than client-side rendering with large applications because Liveview only needs to send a constant small websocket script regardless of the size of the application.

 > 
 > Liveview is a good fit for applications that already need to communicate with the server frequently (like real time collaborative apps), but don't need to communicate with as many client/browser APIs.

[![](https://mermaid.ink/img/pako:eNplULFOw0AM_RXLc7Mw3sBQVUIMRYgKdcli5ZzkRHIuPl8QqvrvXJICRXiy3nt-9-6dsRHP6DAZGe8CdUpjNd3VEcpsVT4SK1TVPRxYJ1YHL_yeOdkqWMGF3w4U32Y6nSQmXvknMQYNXW8g7bfk2JPBg0g3MCTmdH1rJhenx2is1FiYri43wJ8or3O2H1Liv0w3hw724kMb2MMzdcUYNziyjhR8-f15Pq3Reh65RldWzy3lwWqs46VIKZscPmODzjTzBvPJ__aFrqUhFZR9MNH92uhS7OULYSF1lw?type=png)](https://mermaid.live/edit#pako:eNplULFOw0AM_RXLc7Mw3sBQVUIMRYgKdcli5ZzkRHIuPl8QqvrvXJICRXiy3nt-9-6dsRHP6DAZGe8CdUpjNd3VEcpsVT4SK1TVPRxYJ1YHL_yeOdkqWMGF3w4U32Y6nSQmXvknMQYNXW8g7bfk2JPBg0g3MCTmdH1rJhenx2is1FiYri43wJ8or3O2H1Liv0w3hw724kMb2MMzdcUYNziyjhR8-f15Pq3Reh65RldWzy3lwWqs46VIKZscPmODzjTzBvPJ__aFrqUhFZR9MNH92uhS7OULYSF1lw)

### Dioxus Web

* With Client side rendering, you send your application to the client, and then the client generates all of the HTML of the page dynamically.

* This means that the page will be blank until the JavaScript bundle has loaded and the application has initialized. This can result in **slower first render times and poor SEO performance**.

 > 
 > SEO stands for Search Engine Optimization. It refers to the practice of making your website more likely to appear in search engine results. Search engines like Google and Bing use web crawlers to index the content of websites. Most of these crawlers are not able to run JavaScript, so they will not be able to index the content of your page if it is rendered client-side.

* Client-side rendered applications need to use **weakly typed requests to communicate with the server**.

 > 
 > Client-side rendering is a good starting point for most applications. It is well supported and makes it easy to communicate with the client/browser APIs.

[![](https://mermaid.ink/img/pako:eNpVkDFPwzAQhf-KdXOzMHpgqJAQAwytEIsXK35JLBJfez4Xoar_HSemQtzke9_z2e-u1HMAWcrqFU_Rj-KX7vLgkqm1F_7KENN1j-YIuUCsOeBckLUZmrjx_ezT54rziVNG42-sMBLHSQ0Pd8vH5NU8M48zTAby71sr3CYdkAIEoen37h-y5n3910tSiO81cqIdLZDFx1DDXNerjnTCAke2HgMGX2Z15NKtWn1RPn6nnqxKwY7KKfzFJzv4OVcVISrLa1vQtqfbDzd0ZKY?type=png)](https://mermaid.live/edit#pako:eNpVkDFPwzAQhf-KdXOzMHpgqJAQAwytEIsXK35JLBJfez4Xoar_HSemQtzke9_z2e-u1HMAWcrqFU_Rj-KX7vLgkqm1F_7KENN1j-YIuUCsOeBckLUZmrjx_ezT54rziVNG42-sMBLHSQ0Pd8vH5NU8M48zTAby71sr3CYdkAIEoen37h-y5n3910tSiO81cqIdLZDFx1DDXNerjnTCAke2HgMGX2Z15NKtWn1RPn6nnqxKwY7KKfzFJzv4OVcVISrLa1vQtqfbDzd0ZKY)

### Dioxus Fullstack

Fullstack rendering happens in two parts:

1. The page is rendered on the server. This can include fetching any data you need to render the page.
1. The page is hydrated on the client. (Hydration is taking the HTML page from the server and adding all of the event listeners Dioxus needs on the client). Any updates to the page happen on the client after this point.

Because the page is initially rendered on the server, the page will be fully rendered when it is sent to the client. This results in a faster first render time and makes the page more SEO-friendly.

* **Fast initial render**
* **Works well with SEO**
* **Type safe easy communication with the server**
* **Access to the client/browser APIs**
* **Fast interactivity**

Finally, we can use [server functions](../reference/fullstack/server_functions.md) to communicate with the server in a type-safe way.

This approach uses both the dioxus-web and dioxus-ssr crates. To integrate those two packages and `axum`, `warp`, or `salvo`, Dioxus provides the `dioxus-fullstack` crate.

There can be more complexity with fullstack applications because your code runs in two different places. Dioxus tries to mitigate this with server functions and other helpers.

[![](https://mermaid.ink/img/pako:eNpdkL1uwzAMhF9F4BwvHTV0KAIUHdohQdFFi2CdbQG2mFCUiyDIu9e2-hOUE3H34UDelVoOIEtZvWIffS9-auYHl8wyT8KfGWKa5tEcITPEmgPOBVkrUMXNPyAFCMJK5BOnjIq8scJI7Ac13N1RH4NX88zcjzAZyJX-8bfIl6QQ32qcv7PuhP-ANe_rpb8KJ9rRBJl8DMt71zXAkQ6Y4Mgua0Dny6iOXLotqC_Kx0tqyaoU7Kicwl8hZDs_5kVFiMryWivbmrt9AacxbGg?type=png)](https://mermaid.live/edit#pako:eNpdkL1uwzAMhF9F4BwvHTV0KAIUHdohQdFFi2CdbQG2mFCUiyDIu9e2-hOUE3H34UDelVoOIEtZvWIffS9-auYHl8wyT8KfGWKa5tEcITPEmgPOBVkrUMXNPyAFCMJK5BOnjIq8scJI7Ac13N1RH4NX88zcjzAZyJX-8bfIl6QQ32qcv7PuhP-ANe_rpb8KJ9rRBJl8DMt71zXAkQ6Y4Mgua0Dny6iOXLotqC_Kx0tqyaoU7Kicwl8hZDs_5kVFiMryWivbmrt9AacxbGg)
# Web

Build single-page applications that run in the browser with Dioxus. To run on the Web, your app must be compiled to WebAssembly and depend on the `dioxus` and `dioxus-web` crates.

A build of Dioxus for the web will be roughly equivalent to the size of a React build (70kb vs 65kb) but it will load significantly faster because [WebAssembly can be compiled as it is streamed](https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/).

Examples:

* [TodoMVC](https://github.com/DioxusLabs/example-projects/tree/master/todomvc)
* [ECommerce](https://github.com/DioxusLabs/example-projects/tree/master/ecommerce-site)

[![TodoMVC example](https://github.com/DioxusLabs/example-projects/raw/master/todomvc/example.png)](https://github.com/DioxusLabs/example-projects/blob/master/todomvc)

 > 
 > Note: Because of the limitations of Wasm, [not every crate will work](https://rustwasm.github.io/docs/book/reference/which-crates-work-with-wasm.html) with your web apps, so you'll need to make sure that your crates work without native system calls (timers, IO, etc).

## Support

The Web is the best-supported target platform for Dioxus.

* Because your app will be compiled to WASM you have access to browser APIs through [wasm-bindgen](https://rustwasm.github.io/docs/wasm-bindgen/introduction.html).
* Dioxus provides hydration to resume apps that are rendered on the server. See the [fullstack](fullstack.md) getting started guide for more information.

## Tooling

To develop your Dioxus app for the web, you'll need a tool to build and serve your assets. We recommend using [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli) which includes a build system, Wasm optimization, a dev server, and support hot reloading:

````shell
cargo install dioxus-cli
````

Make sure the `wasm32-unknown-unknown` target for rust is installed:

````shell
rustup target add wasm32-unknown-unknown
````

## Creating a Project

Create a new crate:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the web renderer as dependencies (this will edit your `Cargo.toml`):

````bash
cargo add dioxus
cargo add dioxus-web
````

Edit your `main.rs`:

````rs@hello_world_web.rs
#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the web app
    dioxus_web::launch(App);
}

// create a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}

````

And to serve our app:

````bash
dx serve
````

If you open the browser and navigate to `127.0.0.1` you should see an app that looks like this:

````inject-dioxus
DemoFrame {
    hello_world::HelloWorldCounter {}
}
````

## Hot Reload

1. Hot reloading allows much faster iteration times inside of rsx calls by interpreting them and streaming the edits.
1. It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.

For the web renderer, you can use the dioxus cli to serve your application with hot reloading enabled.

### Setup

Install [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli).

### Usage

1. Run:

````bash
dx serve --hot-reload
````

2. Change some code within a rsx or render macro
2. Open your localhost in a browser
2. Save and watch the style change without recompiling

### Limitations

1. The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the rsx call, it will require a full recompile to capture the expression.
1. Components, Iterators, and some attributes can contain arbitrary rust code and will trigger a full recompile when changed.
# Liveview

Liveview allows apps to *run* on the server and *render* in the browser. It uses WebSockets to communicate between the server and the browser.

Examples:

* [Axum Example](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/axum.rs)
* [Salvo Example](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/salvo.rs)
* [Warp Example](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/warp.rs)

## Support

Liveview is currently limited in capability when compared to the Web platform. Liveview apps run on the server in a native thread. This means that browser APIs are not available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs are accessible, so streaming, WebSockets, filesystem, etc are all viable APIs.

## Setup

For this guide, we're going to show how to use Dioxus Liveview with [Axum](https://docs.rs/axum/latest/axum/).

Make sure you have Rust and Cargo installed, and then create a new project:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the liveview renderer with the Axum feature as dependencies:

````shell
cargo add dioxus
cargo add dioxus-liveview --features axum
````

Next, add all the Axum dependencies. This will be different if you're using a different Web Framework

````
cargo add tokio --features full
cargo add axum
````

Your dependencies should look roughly like this:

````toml
[dependencies]
axum = "0.4.5"
dioxus = { version = "*" }
dioxus-liveview = { version = "*", features = ["axum"] }
tokio = { version = "1.15.0", features = ["full"] }
````

Now, set up your Axum app to respond on an endpoint.

````rs@hello_world_liveview.rs
use axum::{extract::ws::WebSocketUpgrade, response::Html, routing::get, Router};
use dioxus::prelude::*;

#[tokio::main]
async fn main() {
    let addr: std::net::SocketAddr = ([127, 0, 0, 1], 3030).into();

    let view = dioxus_liveview::LiveViewPool::new();

    let app = Router::new()
        // The root route contains the glue code to connect to the WebSocket
        .route(
            "/",
            get(move || async move {
                Html(format!(
                    r#"
                <!DOCTYPE html>
                <html>
                <head> <title>Dioxus LiveView with Axum</title>  </head>
                <body> <div id="main"></div> </body>
                {glue}
                </html>
                "#,
                    // Create the glue code to connect to the WebSocket on the "/ws" route
                    glue = dioxus_liveview::interpreter_glue(&format!("ws://{addr}/ws"))
                ))
            }),
        )
        // The WebSocket route is what Dioxus uses to communicate with the browser
        .route(
            "/ws",
            get(move |ws: WebSocketUpgrade| async move {
                ws.on_upgrade(move |socket| async move {
                    // When the WebSocket is upgraded, launch the LiveView with the app component
                    _ = view.launch(dioxus_liveview::axum_socket(socket), app).await;
                })
            }),
        );

    println!("Listening on http://{addr}");

    axum::Server::bind(&addr.to_string().parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}
````

And then add our app component:

````rs@hello_world_liveview.rs
fn app(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

And that's it!

## Hot Reload

1. Hot reloading allows much faster iteration times inside of rsx calls by interpreting them and streaming the edits.
1. It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.

### Hot Reload Setup

Install [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli).

### Usage

1. Run:

````bash
dx serve --hot-reload --platform desktop
````

2. Change some code within `rsx` or `render` macro
2. Save and watch the style change without recompiling

### Limitations

1. The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the rsx call, it will require a full recompile to capture the expression.
1. Components, Iterators, and some attributes can contain arbitrary rust code and will trigger a full recompile when changed.
# Fullstack

 > 
 > This guide assumes you read the [Web](wasm.md) getting started guide and installed the [Dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli)

# Getting Started

## Setup

For this guide, we're going to show how to use Dioxus with [Axum](https://docs.rs/axum/latest/axum/), but `dioxus-fullstack` also integrates with the [Warp](https://docs.rs/warp/latest/warp/) and [Salvo](https://docs.rs/salvo/latest/salvo/) web frameworks.

Make sure you have Rust and Cargo installed, and then create a new project:

````shell
cargo new --bin demo
cd demo
````

Add `dioxus` and `dioxus-fullstack` as dependencies:

````shell
cargo add dioxus
cargo add dioxus-fullstack
````

Next, set up features for the server (`ssr`) and the client (`web`):

````toml
[features]
default = []
ssr = ["dioxus-fullstack/axum"]
web = ["dioxus-fullstack/web"]
````

Your dependencies should look roughly like this:

````toml
[dependencies]
dioxus = { version = "*" }
dioxus-fullstack = { version = "*" }

[features]
default = []
ssr = ["dioxus-fullstack/axum"]
web = ["dioxus-fullstack/web"]
````

Now, set up your Axum app to serve the Dioxus app.

````rs@server_basic.rs
#![allow(non_snake_case, unused)]
use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;

fn main() {
    LaunchBuilder::new(app).launch();
}

fn app(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    })
}

````

Now, run your app with:

````
dx build --features web --release
cargo run --features ssr --release
````

Finally, open `http://localhost:8080` in your browser. You should see a server-side rendered page with a counter.

````inject-dioxus
SandBoxFrame {
	url: "https://codesandbox.io/p/sandbox/dioxus-fullstack-2nwsrz?file=%2Fsrc%2Fmain.rs%3A5%2C1"
}
````

## Hot Reload

1. Hot reloading allows much faster iteration times inside of rsx calls by interpreting them and streaming the edits.
1. It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.

### Usage

1. Run:

````bash
dx build --features web
dx serve --features ssr --hot-reload --platform desktop
````

2. Change some code within a rsx or render macro
2. Save and watch the style change without recompiling

### Limitations

1. The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the rsx call, it will require a full recompile to capture the expression.
1. Components, Iterators, and some attributes can contain arbitrary rust code and will trigger a full recompile when changed.
# Desktop overview

Build a standalone native desktop app that looks and feels the same across operating systems.

Apps built with Dioxus desktop use the system WebView to render the page. This makes the final size of application much smaller than other WebView renderers (typically under 5MB).

Although desktop apps are rendered in a WebView, your Rust code runs natively. This means that browser APIs are *not* available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs *are* accessible, so streaming, WebSockets, filesystem, etc are all easily accessible though system APIs.

Dioxus desktop is built off [Tauri](https://tauri.app/). Right now there are limited Dioxus abstractions over the menubar, event handling, etc. In some places you may need to leverage Tauri directly â€“ through [Wry](http://github.com/tauri-apps/wry/) and [Tao](http://github.com/tauri-apps/tao).

 > 
 > In the future, we plan to move to a custom web renderer-based DOM renderer with WGPU integrations ([Blitz](https://github.com/DioxusLabs/blitz)).

## Examples

* [File Explorer](https://github.com/DioxusLabs/example-projects/blob/master/file-explorer)
* [WiFi Scanner](https://github.com/DioxusLabs/example-projects/blob/master/wifi-scanner)

[![File Explorer screenshot](https://github.com/DioxusLabs/example-projects/raw/master/file-explorer/assets/image.png)](https://github.com/DioxusLabs/example-projects/tree/master/file-explorer)

Here's a [query](https://github.com/search?q=repo%3ADioxusLabs%2Fdioxus+path%3A%2F%5Eexamples%5C%2F%2F+%22use+dioxus_desktop%22&type=code) for the main repo to find examples which use `dioxus_desktop` (might not be 100% acurrate).

# Getting started

## Platform-specific dependencies

Dioxus desktop renders through a WebView. Depending on your platform, you might need to install some dependencies.

### Windows

Windows apps depend on WebView2 â€“ a library that should be installed in all modern Windows distributions. If you have Edge installed, then Dioxus will work fine. If you *don't* have WebView2, [then you can install it through Microsoft](https://developer.microsoft.com/en-us/microsoft-edge/webview2/). MS provides 3 options:

1. A tiny "evergreen" *bootstrapper* that fetches an installer from Microsoft's CDN.
1. A tiny *installer* that fetches WebView2 from Microsoft's CDN.
1. A statically linked version of WebView2 in your final binary for offline users.

For development purposes, use Option 1.

### Linux

WebView Linux apps require WebkitGtk. When distributing, this can be part of your dependency tree in your `.rpm` or `.deb`. However, likely, your users will already have WebkitGtk.

````bash
sudo apt install libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev
````

When using Debian/bullseye `libappindicator3-dev` is no longer available but replaced by `libayatana-appindicator3-dev`.

````bash
# on Debian/bullseye use:
sudo apt install libwebkit2gtk-4.1-dev libgtk-3-dev libayatana-appindicator3-dev
````

If you run into issues, make sure you have all the basics installed, as outlined in the [Tauri docs](https://beta.tauri.app/guides/prerequisites/).

### MacOS

Currently â€“ everything for macOS is built right in! However, you might run into an issue if you're using nightly Rust due to some permissions issues in our Tao dependency (which have been resolved but not published).

## Creating a Project

Create a new crate:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the desktop renderer as dependencies (this will edit your `Cargo.toml`):

````shell
cargo add dioxus
cargo add dioxus-desktop
````

Edit your `main.rs`:

````rs@hello_world_desktop.rs
#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the dioxus app in a webview
    dioxus_desktop::launch(App);
}

// define a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

## Hot Reload

1. Hot reloading allows much faster iteration times inside of RSX calls by interpreting them and streaming the edits.
1. It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.

### Setup

Install [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli).

### Usage

1. Run:

````bash
dx serve --hot-reload --platform desktop
````

2. Change some code within a `rsx` or `render` macro.
2. Save and watch the style change without recompiling.

### Limitations

1. The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the RSX call, it will require a full recompile to capture the expression.
1. Components, Iterators, and some attributes can contain arbitrary rust code and will trigger a full recompile when changed.
# Mobile App

Build a mobile app with Dioxus!

Example: [Todo App](https://github.com/DioxusLabs/example-projects/blob/master/ios_demo)

## Support

Mobile is currently the least-supported renderer target for Dioxus. Mobile apps are rendered with either the platform's WebView or experimentally with [WGPU](https://github.com/DioxusLabs/blitz). WebView doesn't support animations, transparency, and native widgets.

Mobile support is currently best suited for CRUD-style apps, ideally for internal teams who need to develop quickly but don't care much about animations or native widgets.

## Getting Set up

Getting set up with mobile can be quite challenging. The tooling here isn't great (yet) and might take some hacking around to get things working.

### Setting up dependencies

#### Android Dependencies

First, install the rust Android targets:

````sh
rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android
````

To develop on Android, you will need to [install Android Studio](https://developer.android.com/studio).

Once you have installed Android Studio, you will need to install the Android SDK and NDK:

1. Create a blank Android project
1. Select `Tools > SDK manager`
1. Navigate to the `SDK tools` window:

![NDK install window](/assets/static/android_ndk_install.png)

Then select:

* The SDK
* The SDK Command line tools
* The NDK (side by side)
* CMAKE

4. Select `apply` and follow the prompts

 > 
 > More details that could be useful for debugging any errors you encounter are available [in the official android docs](https://developer.android.com/studio/intro/update#sdk-manager)

Next set the Java, Android and NDK home variables:

Mac:

````sh
export JAVA_HOME="/Applications/Android Studio.app/Contents/jbr/Contents/Home"
export ANDROID_HOME="$HOME/Library/Android/sdk"
export NDK_HOME="$ANDROID_HOME/ndk/25.2.9519653"
````

Windows:

````powershell
[System.Environment]::SetEnvironmentVariable("JAVA_HOME", "C:\Program Files\Android\Android Studio\jbr", "User")
[System.Environment]::SetEnvironmentVariable("ANDROID_HOME", "$env:LocalAppData\Android\Sdk", "User")
[System.Environment]::SetEnvironmentVariable("NDK_HOME", "$env:LocalAppData\Android\Sdk\ndk\25.2.9519653", "User")
````

 > 
 > The NDK version in the paths should match the version you installed in the last step

#### IOS Dependencies

First, install the rust IOS targets:

````sh
rustup target add aarch64-apple-ios x86_64-apple-ios aarch64-apple-ios-sim
````

To develop on IOS, you will need to [install XCode](https://apps.apple.com/us/app/xcode/id497799835).

 > 
 > Note: On Apple silicon you must run Xcode on rosetta. Goto Application > Right Click Xcode > Get Info > Open in Rosetta.
 > If you are using M1, you will have to run `cargo build --target x86_64-apple-ios` instead of `cargo apple build` if you want to run in simulator.

### Setting up your project

First, we need to create a rust project:

````sh
cargo new dioxus-mobile-test
cd dioxus-mobile-test
````

Next, we can use `cargo-mobile2` to create a project for mobile:

````shell
cargo install --git https://github.com/tauri-apps/cargo-mobile2
cargo mobile init
````

When you run `cargo mobile init`, you will be asked a series of questions about your project. One of those questions is what template you should use. Dioxus currently doesn't have a template in Tauri mobile, instead you can use the `wry` template.

 > 
 > You may also be asked to input your team ID for IOS. You can find your team id [here](https://developer.apple.com/help/account/manage-your-team/locate-your-team-id/) or create a team id by creating a developer account [here](https://developer.apple.com/help/account/get-started/about-your-developer-account)

Next, we need to modify our dependencies to include dioxus:

````sh
cargo add dioxus
cargo add dioxus-desktop --no-default-features --features tokio_runtime
````

Finally, we need to add a component to renderer. Modify your main function:

````rust
use dioxus::prelude::*;

pub fn main() -> Result<()> {
    // Right now we're going through dioxus-desktop but we'd like to go through dioxus-mobile
    // That will seed the index.html with some fixes that prevent the page from scrolling/zooming etc
    dioxus_desktop::launch_cfg(
        app,
        // Note that we have to disable the viewport goofiness of the browser.
        // Dioxus_mobile should do this for us
        dioxus_desktop::Config::default().with_custom_index(r#"<!DOCTYPE html>
        <html>
          <head>
            <title>Dioxus app</title>
            <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
            <!-- CUSTOM HEAD -->
          </head>
          <body>
            <div id="main"></div>
            <!-- MODULE LOADER -->
          </body>
        </html>
       "#.into()),
    );

    Ok(())
}

fn app(cx: Scope) -> Element {
    let items = cx.use_hook(|| vec![1, 2, 3]);

    log::debug!("Hello from the app");

    render! {
        div {
            h1 { "Hello, Mobile"}
            div { margin_left: "auto", margin_right: "auto", width: "200px", padding: "10px", border: "1px solid black",
                button {
                    onclick: move|_| {
                        println!("Clicked!");
                        items.push(items.len());
                        cx.needs_update_any(ScopeId(0));
                        println!("Requested update");
                    },
                    "Add item"
                }
                for item in items.iter() {
                    div { "- {item}" }
                }
            }
        }
    }
}
````

## Running

From there, you'll want to get a build of the crate using whichever platform you're targeting (simulator or actual hardware). For now, we'll just stick with the simulator

### IOS

To build your project for IOS, you can run:

````sh
cargo build --target aarch64-apple-ios-sim
````

Next, open XCode (this might take awhile if you've never opened XCode before):

````sh
cargo apple open
````

This will open XCode with this particular project.

From there, just click the "play" button with the right target and the app should be running!

![ios_demo](/assets/static/IOS-dioxus-demo.png)

Note that clicking play doesn't cause a new build, so you'll need to keep rebuilding the app between changes. The tooling here is very young, so please be patient. If you want to contribute to make things easier, please do! We'll be happy to help.

### Android

To build your project on Android you can run:
`cargo android build`

Next, open Android studio:

````sh
cargo android open
````

This will open an android studio project for this application.

Next we need to create a simulator in Android studio to run our app in. To create a simulator click on the phone icon in the top right of Android studio:

![android studio manage devices](/assets/static/android-studio-simulator.png)

Then click the `create a virtual device` button and follow the prompts:

![android studio devices](/assets/static/android-studio-devices.png)

Finally, launch your device by clicking the play button on the device you created:

![android studio device](/assets/static/android-studio-device.png)

Now you can start your application from your terminal by running:

````sh
cargo android run
````

![android_demo](/assets/static/Android-Dioxus-demo.png)

 > 
 > More information is available in the Android docs:
 > 
 > * https://developer.android.com/ndk/guides
 > * https://developer.android.com/studio/projects/install-ndk
 > * https://source.android.com/docs/setup/build/rust/building-rust-modules/overview
# Terminal UI

You can build a text-based interface that will run in the terminal using Dioxus.

![Hello World screenshot](https://github.com/DioxusLabs/rink/raw/master/examples/example.png)

 > 
 > Note: this book was written with HTML-based platforms in mind. You might be able to follow along with TUI, but you'll have to adapt a bit.

## Support

TUI support is currently quite experimental. But, if you're willing to venture into the realm of the unknown, this guide will get you started.

* It uses flexbox for the layout
* It only supports a subset of the attributes and elements
* Regular widgets will not work in the tui render, but the tui renderer has its own widget components that start with a capital letter. See the [widgets example](https://github.com/DioxusLabs/dioxus/blob/master/packages/dioxus-tui/examples/widgets.rs)
* 1px is one character line height. Your regular CSS px does not translate
* If your app panics, your terminal is wrecked. This will be fixed eventually

## Getting Set up

Start by making a new package and adding Dioxus and the TUI renderer as dependencies.

````shell
cargo new --bin demo
cd demo
cargo add dioxus
cargo add dioxus-tui
````

Then, edit your `main.rs` with the basic template.

````rs@hello_world_tui.rs
#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the app in the terminal
    dioxus_tui::launch(App);
}

// create a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}

````

To run our app:

````shell
cargo run
````

Press "ctrl-c" to close the app. To switch from "ctrl-c" to just "q" to quit you can launch the app with a configuration to disable the default quit and use the root TuiContext to quit on your own.

````rs@hello_world_tui_no_ctrl_c.rs
// todo remove deprecated
#![allow(non_snake_case, deprecated)]

use dioxus::events::{KeyCode, KeyboardEvent};
use dioxus::prelude::*;
use dioxus_tui::TuiContext;

fn main() {
    dioxus_tui::launch_cfg(
        App,
        dioxus_tui::Config::new()
            .without_ctrl_c_quit()
            // Some older terminals only support 16 colors or ANSI colors
            // If your terminal is one of these, change this to BaseColors or ANSI
            .with_rendering_mode(dioxus_tui::RenderingMode::Rgb),
    );
}

fn App(cx: Scope) -> Element {
    let tui_ctx: TuiContext = cx.consume_context().unwrap();

    cx.render(rsx! {
        div {
            width: "100%",
            height: "10px",
            background_color: "red",
            justify_content: "center",
            align_items: "center",
            onkeydown: move |k: KeyboardEvent| if let KeyCode::Q = k.key_code {
                tui_ctx.quit();
            },

            "Hello world!"
        }
    })
}

````

## Hot Reload

1. Hot reloading allows much faster iteration times inside of rsx calls by interpreting them and streaming the edits.
1. It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.

### Setup

Install [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli).

### Usage

1. Run:

````bash
dx serve --hot-reload --platform desktop
````

2. Change some code within a rsx or render macro
2. Save and watch the style change without recompiling

### Limitations

1. The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the rsx call, it will require a full recompile to capture the expression.
1. Components, Iterators, and some attributes can contain arbitrary rust code and will trigger a full recompile when changed.
In this guide, you'll learn to use Dioxus to build user interfaces that run anywhere. We will recreate the hackernews homepage in Dioxus:

````inject-dioxus
DemoFrame {
    hackernews_complete::App {}
}
````

This guide serves a very brief overview of Dioxus. Throughout the guide, there will be links to the [reference](../reference/index.md) with more details about specific concepts.

First, lets setup our dependencies. In addition to the dependencies you added in the [getting started](../getting_started/index.md) guide for your platform, we need to set up a few more dependencies to work with the hacker news API:

````sh
cargo add chrono --features serde
cargo add futures
cargo add reqwest --features json
cargo add serde --features derive
cargo add serde_json
cargo add async_recursion
````
# Your First Component

This chapter will teach you how to create a [Component](../reference/components.md) that displays a link to a post on hackernews.

First, let's define how to display a post. Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* how we want the UI to look.

To declare what you want your UI to look like, you will need to use the `rsx` macro. Let's modify the rsx macro in the `App` function from the [getting started](../getting_started/index.md) to show information about our story:

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    render! {
        "story"
    }
}
````

If you run your application you should see something like this:

````inject-dioxus
DemoFrame {
	hackernews_post::story_v1::App {}
}
````

 > 
 > RSX mirrors HTML. Because of this you will need to know some html to use Dioxus.
 > 
 > Here are some resources to help get you started learning HTML:
 > 
 > * [MDN HTML Guide](https://developer.mozilla.org/en-US/docs/Learn/HTML)
 > * [W3 Schools HTML Tutorial](https://www.w3schools.com/html/default.asp)
 > 
 > In addition to HTML, Dioxus uses CSS to style applications. You can either use traditional CSS (what this guide uses) or use a tool like [tailwind CSS](https://tailwindcss.com/docs/installation):
 > 
 > * [MDN Traditional CSS Guide](https://developer.mozilla.org/en-US/docs/Learn/HTML)
 > * [W3 Schools Traditional CSS Tutorial](https://www.w3schools.com/css/default.asp)
 > * [Tailwind tutorial](https://tailwindcss.com/docs/installation) (used with the [Tailwind setup example](https://github.com/DioxusLabs/dioxus/tree/master/examples/tailwind))
 > 
 > If you have existing html code, you can use the [translate](../CLI/translate.md) command to convert it to RSX. Or if you prefer to write html, you can use the [html! macro](https://github.com/DioxusLabs/dioxus-html-macro) to write html directly in your code.

## Dynamic Text

Let's expand our `App` component to include the story title, author, score, time posted, and number of comments. We can insert dynamic text in the render macro by inserting variables inside `{}`s (this works similarly to the formatting in the [println!](https://doc.rust-lang.org/std/macro.println.html) macro):

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    render! {
        "{title} by {by} ({score}) {time} {comments}"
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v2::App {}
}
````

## Creating Elements

Next, let's wrap our post description in a [`div`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div). You can create HTML elements in Dioxus by putting a `{` after the element name and a `}` after the last child of the element:

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    render! {
        div {
            "{title} by {by} ({score}) {time} {comments}"
        }
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v3::App {}
}
````

 > 
 > You can read more about elements in the [rsx reference](../reference/rsx.md).

## Setting Attributes

Next, let's add some padding around our post listing with an attribute.

Attributes (and [listeners](../reference/event_handlers.md)) modify the behavior or appearance of the element they are attached to. They are specified inside the `{}` brackets before any children, using the `name: value` syntax. You can format the text in the attribute as you would with a text node:

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    render! {
        div {
            padding: "0.5rem",
            position: "relative",
            "{title} by {by} ({score}) {time} {comments}"
        }
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v4::App {}
}
````

 > 
 > Note: All attributes defined in [`dioxus-html`](https://docs.rs/dioxus-html/latest/dioxus_html/) follow the snake_case naming convention. They transform their `snake_case` names to HTML's `camelCase` attributes.

 > 
 > Note: Styles can be used directly outside of the `style:` attribute. In the above example, `color: "red"` is turned into `style="color: red"`.

 > 
 > You can read more about elements in the [attribute reference](../reference/rsx.md)

## Creating a Component

Just like you wouldn't want to write a complex program in a single, long, `main` function, you shouldn't build a complex UI in a single `App` function. Instead, you should break down the functionality of an app in logical parts called components.

A component is a Rust function, named in UpperCamelCase, that takes a `Scope` parameter and returns an `Element` describing the UI it wants to render. In fact, our `App` function is a component!

Let's pull our story description into a new component:

````rs@hackernews_post.rs
fn StoryListing(cx: Scope) -> Element {
    let title = "title";
    let by = "author";
    let score = 0;
    let time = chrono::Utc::now();
    let comments = "comments";

    render! {
        div {
            padding: "0.5rem",
            position: "relative",
            "{title} by {by} ({score}) {time} {comments}"
        }
    }
}
````

We can render our component like we would an element by putting `{}`s after the component name. Let's modify our `App` component to render our new StoryListing component:

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    render! {
        StoryListing {

        }
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v5::App {}
}
````

 > 
 > You can read more about elements in the [component reference](../reference/components.md)

## Creating Props

Just like you can pass arguments to a function or attributes to an element, you can pass props to a component that customize its behavior!

We can define arguments that components can take when they are rendered (called `Props`) by adding the `#[component]` macro before our function definition and adding extra function arguments.

Currently, our `StoryListing` component always renders the same story. We can modify it to accept a story to render as a prop.

We will also define what a post is and include information for how to transform our post to and from a different format using [serde](https://serde.rs). This will be used with the hackernews API in a later chapter:

````rs@hackernews_post.rs
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

// Define the Hackernews types
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryPageData {
    #[serde(flatten)]
    pub item: StoryItem,
    #[serde(default)]
    pub comments: Vec<Comment>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Comment {
    pub id: i64,
    /// there will be no by field if the comment was deleted
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub text: String,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    #[serde(default)]
    pub sub_comments: Vec<Comment>,
    pub r#type: String,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryItem {
    pub id: i64,
    pub title: String,
    pub url: Option<String>,
    pub text: Option<String>,
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub score: i64,
    #[serde(default)]
    pub descendants: i64,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    pub r#type: String,
}

#[component]
fn StoryListing(cx: Scope, story: StoryItem) -> Element {
    let StoryItem {
        title,
        by,
        score,
        time,
        kids,
        ..
    } = story;

    let comments = kids.len();

    render! {
        div {
            padding: "0.5rem",
            position: "relative",
            "{title} by {by} ({score}) {time} {comments}"
        }
    }
}
````

Now, let's modify the `App` component to pass the story to our `StoryListing` component like we would set an attribute on an element:

````rs@hackernews_post.rs
pub fn App(cx: Scope) -> Element {
    render! {
        StoryListing {
            story: StoryItem {
                id: 0,
                title: "hello hackernews".to_string(),
                url: None,
                text: None,
                by: "Author".to_string(),
                score: 0,
                descendants: 0,
                time: chrono::Utc::now(),
                kids: vec![],
                r#type: "".to_string(),
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_v6::App {}
}
````

 > 
 > You can read more about Props in the [Props reference](../reference/component_props.md)

## Cleaning Up Our Interface

Finally, by combining elements and attributes, we can make our post listing much more appealing:

Full code up to this point:

````rs@hackernews_post.rs
use dioxus::prelude::*;

// Define the Hackernews types
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryPageData {
    #[serde(flatten)]
    pub item: StoryItem,
    #[serde(default)]
    pub comments: Vec<Comment>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Comment {
    pub id: i64,
    /// there will be no by field if the comment was deleted
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub text: String,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    #[serde(default)]
    pub sub_comments: Vec<Comment>,
    pub r#type: String,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryItem {
    pub id: i64,
    pub title: String,
    pub url: Option<String>,
    pub text: Option<String>,
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub score: i64,
    #[serde(default)]
    pub descendants: i64,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    pub r#type: String,
}

pub fn App(cx: Scope) -> Element {
    render! {
        StoryListing {
            story: StoryItem {
                id: 0,
                title: "hello hackernews".to_string(),
                url: None,
                text: None,
                by: "Author".to_string(),
                score: 0,
                descendants: 0,
                time: Utc::now(),
                kids: vec![],
                r#type: "".to_string(),
            }
        }
    }
}

#[component]
fn StoryListing(cx: Scope, story: StoryItem) -> Element {
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        id,
        ..
    } = story;

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} {}", if *score == 1 { " point" } else { " points" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    cx.render(rsx! {
        div {
            padding: "0.5rem",
            position: "relative",
            div {
                font_size: "1.5rem",
                a {
                    href: url,
                    "{title}"
                }
                a {
                    color: "gray",
                    href: "https://news.ycombinator.com/from?site={hostname}",
                    text_decoration: "none",
                    " ({hostname})"
                }
            }
            div {
                display: "flex",
                flex_direction: "row",
                color: "gray",
                div {
                    "{score}"
                }
                div {
                    padding_left: "0.5rem",
                    "by {by}"
                }
                div {
                    padding_left: "0.5rem",
                    "{time}"
                }
                div {
                    padding_left: "0.5rem",
                    "{comments}"
                }
            }
        }
    })
}
````

````inject-dioxus
DemoFrame {
	hackernews_post::story_final::App {}
}
````
# Interactivity

In this chapter, we will add a preview for articles you hover over or links you focus on.

## Creating a Preview

First, let's split our app into a Stories component on the left side of the screen, and a preview component on the right side of the screen:

````rs@hackernews_state.rs
pub fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            width: "100%",
            div {
                width: "50%",
                Stories {}
            }
            div {
                width: "50%",
                Preview {}
            }
        }
    })
}

// New
fn Stories(cx: Scope) -> Element {
    render! {
        StoryListing {
            story: StoryItem {
                id: 0,
                title: "hello hackernews".to_string(),
                url: None,
                text: None,
                by: "Author".to_string(),
                score: 0,
                descendants: 0,
                time: chrono::Utc::now(),
                kids: vec![],
                r#type: "".to_string(),
            }
        }
    }
}

// New
#[derive(Clone, Debug)]
enum PreviewState {
    Unset,
    Loading,
    Loaded(StoryPageData),
}

// New
fn Preview(cx: Scope) -> Element {
    let preview_state = PreviewState::Unset;
    match preview_state {
        PreviewState::Unset => render! {
            "Hover over a story to preview it here"
        },
        PreviewState::Loading => render! {
            "Loading..."
        },
        PreviewState::Loaded(story) => {
            let title = &story.item.title;
            let url = story.item.url.as_deref().unwrap_or_default();
            let text = story.item.text.as_deref().unwrap_or_default();
            render! {
                div {
                    padding: "0.5rem",
                    div {
                        font_size: "1.5rem",
                        a {
                            href: "{url}",
                            "{title}"
                        }
                    }
                    div {
                        dangerous_inner_html: "{text}",
                    }
                    for comment in &story.comments {
                        Comment { comment: comment.clone() }
                    }
                }
            }
        }
    }
}

// NEW
#[component]
fn Comment(cx: Scope, comment: Comment) -> Element<'a> {
    render! {
        div {
            padding: "0.5rem",
            div {
                color: "gray",
                "by {comment.by}"
            }
            div {
                dangerous_inner_html: "{comment.text}"
            }
            for kid in &comment.sub_comments {
                Comment { comment: kid.clone() }
            }
        }
    }
}

````

````inject-dioxus
DemoFrame {
    hackernews_state::app_v1::App {}
}
````

## Event Handlers

Next, we need to detect when the user hovers over a section or focuses a link. We can use an [event listener](../reference/event_handlers.md) to listen for the hover and focus events.

Event handlers are similar to regular attributes, but their name usually starts with `on`- and they accept closures as values. The closure will be called whenever the event it listens for is triggered. When an event is triggered, information about the event is passed to the closure though the [Event](https://docs.rs/dioxus/latest/dioxus/prelude/struct.Event.html) structure.

Let's create a [`onmouseenter`](https://docs.rs/dioxus/latest/dioxus/events/fn.onmouseenter.html) event listener in the `StoryListing` component:

````rs@hackernews_state.rs
cx.render(rsx! {
    div {
        padding: "0.5rem",
        position: "relative",
        onmouseenter: move |_| {
            // NEW
        },
        div {
            font_size: "1.5rem",
            a {
                href: url,
                onfocus: move |_event| {
                    // NEW
                },
                "{title}"
            }
            a {
                color: "gray",
                href: "https://news.ycombinator.com/from?site={hostname}",
                text_decoration: "none",
                " ({hostname})"
            }
        }
        div {
            display: "flex",
            flex_direction: "row",
            color: "gray",
            div {
                "{score}"
            }
            div {
                padding_left: "0.5rem",
                "by {by}"
            }
            div {
                padding_left: "0.5rem",
                "{time}"
            }
            div {
                padding_left: "0.5rem",
                "{comments}"
            }
        }
    }
})
````

 > 
 > You can read more about Event Handlers in the [Event Handler reference](../reference/event_handlers.md)

## State

So far our components have had no state like normal rust functions. To make our application change when we hover over a link we need state to store the currently hovered link in the root of the application.

You can create state in dioxus using hooks. Hooks are Rust functions that take a reference to `ScopeState` (in a component, you can pass `cx`), and provide you with functionality and state.

In this case, we will use the `use_shared_state_provider` and `use_shared_state` hooks:

* You can provide a closure to `use_shared_state_provider` that determines the initial value of the shared state and provides the value to all child components
* You can then use the `use_shared_state` hook to read and modify that state in the `Preview` and `StoryListing` components
* When the value updates, `use_shared_state` will make the component re-render, and provides you with the new value

 > 
 > Note: You should prefer local state hooks like use_state or use_ref when you only use state in one component. Because we use state in multiple components, we can use a [global state pattern](../reference/context.md)

````rs@hackernews_state.rs
pub fn App(cx: Scope) -> Element {
    use_shared_state_provider(cx, || PreviewState::Unset);
````

````rs@hackernews_state.rs
#[component]
fn StoryListing(cx: Scope, story: StoryItem) -> Element {
    // New
    let preview_state = use_shared_state::<PreviewState>(cx).unwrap();
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        ..
    } = story;

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} {}", if *score == 1 { " point" } else { " points" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    cx.render(rsx! {
        div {
            padding: "0.5rem",
            position: "relative",
            onmouseenter: move |_event| {
                // NEW
                // set the preview state to this story
                *preview_state.write() = PreviewState::Loaded(StoryPageData {
                    item: story.clone(),
                    comments: vec![],
                });
            },
            div {
                font_size: "1.5rem",
                a {
                    href: url,
                    onfocus: move |_event| {
                        // NEW
                        // set the preview state to this story
                        *preview_state.write() = PreviewState::Loaded(StoryPageData {
                            item: story.clone(),
                            comments: vec![],
                        });
                    },
````

````rs@hackernews_state.rs
fn Preview(cx: Scope) -> Element {
    // New
    let preview_state = use_shared_state::<PreviewState>(cx)?;

    // New
    match &*preview_state.read() {
````

````inject-dioxus
DemoFrame {
    hackernews_state::App {}
}
````

 > 
 > You can read more about Hooks in the [Hooks reference](../reference/hooks.md)

### The Rules of Hooks

Hooks are a powerful way to manage state in Dioxus, but there are some rules you need to follow to insure they work as expected. Dioxus uses the order you call hooks to differentiate between hooks. Because the order you call hooks matters, you must follow these rules:

1. Hooks may be only used in components or other hooks (we'll get to that later)
1. On every call to the component function
   1. The same hooks must be called
   1. In the same order
1. Hooks name's should start with `use_` so you don't accidentally confuse them with regular functions

These rules mean that there are certain things you can't do with hooks:

#### No Hooks in Conditionals

````rs@hooks_bad.rs
// âŒ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy && you_know_it {
    let something = use_state(cx, || "hands");
    println!("clap your {something}")
}

// âœ… instead, *always* call use_state
// You can put other stuff in the conditional though
let something = use_state(cx, || "hands");
if you_are_happy && you_know_it {
    println!("clap your {something}")
}
````

#### No Hooks in Closures

````rs@hooks_bad.rs
// âŒ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
    let b = use_state(cx, || 0);
    b.get()
};

// âœ… instead, move hook `b` outside
let b = use_state(cx, || 0);
let _a = || b.get();
````

#### No Hooks in Loops

````rs@hooks_bad.rs
// `names` is a Vec<&str>

// âŒ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &names {
    let is_selected = use_state(cx, || false);
    println!("selected: {is_selected}");
}

// âœ… Instead, use a hashmap with use_ref
let selection_map = use_ref(cx, HashMap::<&str, bool>::new);

for name in &names {
    let is_selected = selection_map.read()[name];
    println!("selected: {is_selected}");
}
````
# Fetching Data

In this chapter, we will fetch data from the hacker news API and use it to render the list of top posts in our application.

## Defining the API

First we need to create some utilities to fetch data from the hackernews API using [reqwest](https://docs.rs/reqwest/latest/reqwest/index.html):

````rs@hackernews_async.rs
// Define the Hackernews API
use futures::future::join_all;

pub static BASE_API_URL: &str = "https://hacker-news.firebaseio.com/v0/";
pub static ITEM_API: &str = "item/";
pub static USER_API: &str = "user/";
const COMMENT_DEPTH: i64 = 2;

pub async fn get_story_preview(id: i64) -> Result<StoryItem, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    reqwest::get(&url).await?.json().await
}

pub async fn get_stories(count: usize) -> Result<Vec<StoryItem>, reqwest::Error> {
    let url = format!("{}topstories.json", BASE_API_URL);
    let stories_ids = &reqwest::get(&url).await?.json::<Vec<i64>>().await?[..count];

    let story_futures = stories_ids[..usize::min(stories_ids.len(), count)]
        .iter()
        .map(|&story_id| get_story_preview(story_id));
    let stories = join_all(story_futures)
        .await
        .into_iter()
        .filter_map(|story| story.ok())
        .collect();
    Ok(stories)
}

pub async fn get_story(id: i64) -> Result<StoryPageData, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut story = reqwest::get(&url).await?.json::<StoryPageData>().await?;
    let comment_futures = story.item.kids.iter().map(|&id| get_comment(id));
    let comments = join_all(comment_futures)
        .await
        .into_iter()
        .filter_map(|c| c.ok())
        .collect();

    story.comments = comments;
    Ok(story)
}

#[async_recursion::async_recursion(?Send)]
pub async fn get_comment_with_depth(id: i64, depth: i64) -> Result<Comment, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut comment = reqwest::get(&url).await?.json::<Comment>().await?;
    if depth > 0 {
        let sub_comments_futures = comment
            .kids
            .iter()
            .map(|story_id| get_comment_with_depth(*story_id, depth - 1));
        comment.sub_comments = join_all(sub_comments_futures)
            .await
            .into_iter()
            .filter_map(|c| c.ok())
            .collect();
    }
    Ok(comment)
}

pub async fn get_comment(comment_id: i64) -> Result<Comment, reqwest::Error> {
    let comment = get_comment_with_depth(comment_id, COMMENT_DEPTH).await?;
    Ok(comment)
}
````

## Working with Async

[`use_future`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_future.html) is a [hook](./state.md) that lets you run an async closure, and provides you with its result.

For example, we can make an API request (using [reqwest](https://docs.rs/reqwest/latest/reqwest/index.html)) inside `use_future`:

````rs@hackernews_async.rs
fn Stories(cx: Scope) -> Element {
    // Fetch the top 10 stories on Hackernews
    let stories = use_future(cx, (), |_| get_stories(10));

    // check if the future is resolved
    match stories.value() {
        Some(Ok(list)) => {
            // if it is, render the stories
            render! {
                div {
                    // iterate over the stories with a for loop
                    for story in list {
                        // render every story with the StoryListing component
                        StoryListing { story: story.clone() }
                    }
                }
            }
        }
        Some(Err(err)) => {
            // if there was an error, render the error
            render! {"An error occurred while fetching stories {err}"}
        }
        None => {
            // if the future is not resolved yet, render a loading message
            render! {"Loading items"}
        }
    }
}
````

The code inside `use_future` will be submitted to the Dioxus scheduler once the component has rendered.

We can use `.value()` to get the result of the future. On the first run, since there's no data ready when the component loads, its value will be `None`.  However, once the future is finished, the component will be re-rendered and the value will now be `Some(...)`, containing the return value of the closure.

We can then render the result by looping over each of the posts and rendering them with the `StoryListing` component.

````inject-dioxus
DemoFrame {
	hackernews_async::fetch::App {}
}
````

 > 
 > You can read more about working with Async in Dioxus in the [Async reference](../reference/index.md)

## Lazily Fetching Data

Finally, we will lazily fetch the comments on each post as the user hovers over the post.

We need to revisit the code that handles hovering over an item. Instead of passing an empty list of comments, we can fetch all the related comments when the user hovers over the item.

We will cache the list of comments with a [use_ref](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_ref.html) hook. This hook allows you to store some state in a single component. When the user triggers fetching the comments we will check if the response has already been cached before fetching the data from the hackernews API.

````rs@hackernews_async.rs
// New
async fn resolve_story(
    full_story: UseRef<Option<StoryPageData>>,
    preview_state: UseSharedState<PreviewState>,
    story_id: i64,
) {
    if let Some(cached) = &*full_story.read() {
        *preview_state.write() = PreviewState::Loaded(cached.clone());
        return;
    }

    *preview_state.write() = PreviewState::Loading;
    if let Ok(story) = get_story(story_id).await {
        *preview_state.write() = PreviewState::Loaded(story.clone());
        *full_story.write() = Some(story);
    }
}

#[component]
fn StoryListing(cx: Scope, story: StoryItem) -> Element {
    let preview_state = use_shared_state::<PreviewState>(cx).unwrap();
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        id,
        ..
    } = story;
    // New
    let full_story = use_ref(cx, || None);

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} {}", if *score == 1 { " point" } else { " points" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    cx.render(rsx! {
        div {
            padding: "0.5rem",
            position: "relative",
            onmouseenter: move |_event| {
                // New
                // If you return a future from an event handler, it will be run automatically
                resolve_story(full_story.clone(), preview_state.clone(), *id)
            },
            div {
                font_size: "1.5rem",
                a {
                    href: url,
                    onfocus: move |_event| {
                        // New
                        resolve_story(full_story.clone(), preview_state.clone(), *id)
                    },
                    // ...

````

````inject-dioxus
DemoFrame {
	hackernews_async::App {}
}
````
# Conclusion

Well done! You've completed the Dioxus guide and built a hackernews application in Dioxus.

To continue your journey, you can attempt a challenge listed below, or look at the [Dioxus reference](../reference/index.md).

## Challenges

* Organize your components into separate files for better maintainability.
* Give your app some style if you haven't already.
* Integrate your application with the [Dioxus router](../router/index.md).

## The full code for the hacker news project

````rs@hackernews_complete.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

pub fn App(cx: Scope) -> Element {
    use_shared_state_provider(cx, || PreviewState::Unset);

    cx.render(rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            width: "100%",
            div {
                width: "50%",
                Stories {}
            }
            div {
                width: "50%",
                Preview {}
            }
        }
    })
}

fn Stories(cx: Scope) -> Element {
    let story = use_future(cx, (), |_| get_stories(10));

    match story.value() {
        Some(Ok(list)) => render! {
            div {
                for story in list {
                    StoryListing { story: story.clone() }
                }
            }
        },
        Some(Err(err)) => render! {"An error occurred while fetching stories {err}"},
        None => render! {"Loading items"},
    }
}

async fn resolve_story(
    full_story: UseRef<Option<StoryPageData>>,
    preview_state: UseSharedState<PreviewState>,
    story_id: i64,
) {
    if let Some(cached) = &*full_story.read() {
        *preview_state.write() = PreviewState::Loaded(cached.clone());
        return;
    }

    *preview_state.write() = PreviewState::Loading;
    if let Ok(story) = get_story(story_id).await {
        *preview_state.write() = PreviewState::Loaded(story.clone());
        *full_story.write() = Some(story);
    }
}

#[component]
fn StoryListing(cx: Scope, story: StoryItem) -> Element {
    let preview_state = use_shared_state::<PreviewState>(cx).unwrap();
    let StoryItem {
        title,
        url,
        by,
        score,
        time,
        kids,
        id,
        ..
    } = story;
    let full_story = use_ref(cx, || None);

    let url = url.as_deref().unwrap_or_default();
    let hostname = url
        .trim_start_matches("https://")
        .trim_start_matches("http://")
        .trim_start_matches("www.");
    let score = format!("{score} {}", if *score == 1 { " point" } else { " points" });
    let comments = format!(
        "{} {}",
        kids.len(),
        if kids.len() == 1 {
            " comment"
        } else {
            " comments"
        }
    );
    let time = time.format("%D %l:%M %p");

    cx.render(rsx! {
        div {
            padding: "0.5rem",
            position: "relative",
            onmouseenter: move |_event| {
                resolve_story(full_story.clone(), preview_state.clone(), *id)
            },
            div {
                font_size: "1.5rem",
                a {
                    href: url,
                    onfocus: move |_event| {
                        resolve_story(full_story.clone(), preview_state.clone(), *id)
                    },
                    "{title}"
                }
                a {
                    color: "gray",
                    href: "https://news.ycombinator.com/from?site={hostname}",
                    text_decoration: "none",
                    " ({hostname})"
                }
            }
            div {
                display: "flex",
                flex_direction: "row",
                color: "gray",
                div {
                    "{score}"
                }
                div {
                    padding_left: "0.5rem",
                    "by {by}"
                }
                div {
                    padding_left: "0.5rem",
                    "{time}"
                }
                div {
                    padding_left: "0.5rem",
                    "{comments}"
                }
            }
        }
    })
}

#[derive(Clone, Debug)]
enum PreviewState {
    Unset,
    Loading,
    Loaded(StoryPageData),
}

fn Preview(cx: Scope) -> Element {
    let preview_state = use_shared_state::<PreviewState>(cx)?;

    match &*preview_state.read() {
        PreviewState::Unset => render! {
            "Hover over a story to preview it here"
        },
        PreviewState::Loading => render! {
            "Loading..."
        },
        PreviewState::Loaded(story) => {
            let title = &story.item.title;
            let url = story.item.url.as_deref().unwrap_or_default();
            let text = story.item.text.as_deref().unwrap_or_default();
            render! {
                div {
                    padding: "0.5rem",
                    div {
                        font_size: "1.5rem",
                        a {
                            href: "{url}",
                            "{title}"
                        }
                    }
                    div {
                        dangerous_inner_html: "{text}",
                    }
                    for comment in &story.comments {
                        Comment { comment: comment.clone() }
                    }
                }
            }
        }
    }
}

#[component]
fn Comment(cx: Scope, comment: Comment) -> Element<'a> {
    render! {
        div {
            padding: "0.5rem",
            div {
                color: "gray",
                "by {comment.by}"
            }
            div {
                dangerous_inner_html: "{comment.text}"
            }
            for kid in &comment.sub_comments {
                Comment { comment: kid.clone() }
            }
        }
    }
}

// Define the Hackernews API and types
use chrono::{DateTime, Utc};
use futures::future::join_all;
use serde::{Deserialize, Serialize};

pub static BASE_API_URL: &str = "https://hacker-news.firebaseio.com/v0/";
pub static ITEM_API: &str = "item/";
pub static USER_API: &str = "user/";
const COMMENT_DEPTH: i64 = 2;

pub async fn get_story_preview(id: i64) -> Result<StoryItem, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    reqwest::get(&url).await?.json().await
}

pub async fn get_stories(count: usize) -> Result<Vec<StoryItem>, reqwest::Error> {
    let url = format!("{}topstories.json", BASE_API_URL);
    let stories_ids = &reqwest::get(&url).await?.json::<Vec<i64>>().await?[..count];

    let story_futures = stories_ids[..usize::min(stories_ids.len(), count)]
        .iter()
        .map(|&story_id| get_story_preview(story_id));
    Ok(join_all(story_futures)
        .await
        .into_iter()
        .filter_map(|story| story.ok())
        .collect())
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryPageData {
    #[serde(flatten)]
    pub item: StoryItem,
    #[serde(default)]
    pub comments: Vec<Comment>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Comment {
    pub id: i64,
    /// there will be no by field if the comment was deleted
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub text: String,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    #[serde(default)]
    pub sub_comments: Vec<Comment>,
    pub r#type: String,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct StoryItem {
    pub id: i64,
    pub title: String,
    pub url: Option<String>,
    pub text: Option<String>,
    #[serde(default)]
    pub by: String,
    #[serde(default)]
    pub score: i64,
    #[serde(default)]
    pub descendants: i64,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub time: DateTime<Utc>,
    #[serde(default)]
    pub kids: Vec<i64>,
    pub r#type: String,
}

pub async fn get_story(id: i64) -> Result<StoryPageData, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut story = reqwest::get(&url).await?.json::<StoryPageData>().await?;
    let comment_futures = story.item.kids.iter().map(|&id| get_comment(id));
    let comments = join_all(comment_futures)
        .await
        .into_iter()
        .filter_map(|c| c.ok())
        .collect();

    story.comments = comments;
    Ok(story)
}

#[async_recursion::async_recursion(?Send)]
pub async fn get_comment_with_depth(id: i64, depth: i64) -> Result<Comment, reqwest::Error> {
    let url = format!("{}{}{}.json", BASE_API_URL, ITEM_API, id);
    let mut comment = reqwest::get(&url).await?.json::<Comment>().await?;
    if depth > 0 {
        let sub_comments_futures = comment
            .kids
            .iter()
            .map(|story_id| get_comment_with_depth(*story_id, depth - 1));
        comment.sub_comments = join_all(sub_comments_futures)
            .await
            .into_iter()
            .filter_map(|c| c.ok())
            .collect();
    }
    Ok(comment)
}

pub async fn get_comment(comment_id: i64) -> Result<Comment, reqwest::Error> {
    get_comment_with_depth(comment_id, COMMENT_DEPTH).await
}

````
# Dioxus Reference

This Reference contains more detailed explanations for all concepts covered in the [guide](../guide/index.md) and more.

## Rendering

* [`RSX`](rsx.md) Rsx is a HTML-like macro that allows you to declare UI
* [`Components`](components.md) Components are the building blocks of UI in Dioxus
* [`Props`](component_props.md) Props allow you pass information to Components
* [`Event Listeners`](event_handlers.md) Event listeners let you respond to user input
* [`User Input`](user_input.md) How to handle User input in Dioxus
* [`Dynamic Rendering`](dynamic_rendering.md) How to dynamically render data in Dioxus

## State

* [`Hooks`](hooks.md): Hooks allow you to create components state
* [`Context`](context.md): Context allows you to create state in a parent and consume it in children
* [`Routing`](router.md): The router helps you manage the URL state
* [`UseFuture`](use_future.md): Use future allows you to create an async task and monitor it's state
* [`UseCoroutine`](use_coroutine.md): Use coroutine helps you manage external state
* [`Spawn`](spawn.md): Spawn creates an async task

## Platforms

* [`Desktop`](desktop/index.md): Overview of desktop specific APIS
* [`Web`](web/index.md): Overview of web specific APIS
* [`SSR`](ssr.md): Overview of the SSR renderer
* [`Liveview`](liveview.md): Overview of liveview specific APIS
* [`Fullstack`](fullstack/index.md): Overview of Fullstack specific APIS
  * [`Server Functions`](fullstack/server_functions.md): Server functions make it easy to communicate between your server and client
  * [`Extractors`](fullstack/extractors.md): Extractors allow you to get extra information out of the headers of a request
  * [`Middleware`](fullstack/middleware.md): Middleware allows you to wrap a server function request or response
  * [`Authentication`](fullstack/authentication.md): An overview of how to handle authentication with server functions
  * [`Routing`](fullstack/routing.md): An overview of how to work with the router in the fullstack renderer
# Describing the UI

Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* what we want the UI to look like using RSX.

You have already seen a simple example of RSX syntax in the "hello world" application:

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

Here, we use the `rsx!` macro to *declare* that we want a `div` element, containing the text `"Hello, world!"`. Dioxus takes the RSX and constructs a UI from it.

## RSX Features

RSX is very similar to HTML in that it describes elements with attributes and children. Here's an empty `div` element in RSX, as well as the resulting HTML:

````rs@rsx_overview.rs
cx.render(rsx!(div {
    // attributes / listeners
    // children
}))
````

````inject-dioxus
DemoFrame {
	// old: rsx_overview::Empty {}
	__interactive_04::Empty {}
}
````

### Attributes

Attributes (and [event handlers](event_handlers.md)) modify the behavior or appearance of the element they are attached to. They are specified inside the `{}` brackets, using the `name: value` syntax. You can provide the value as a literal in the RSX:

````rs@rsx_overview.rs
cx.render(rsx!(img {
    src: "https://avatars.githubusercontent.com/u/79236386?s=200&v=4",
    class: "primary_button",
    width: "10px"
}))
````

````inject-dioxus
DemoFrame {
	rsx_overview::Attributes {}
}
````

 > 
 > Note: All attributes defined in `dioxus-html` follow the snake_case naming convention. They transform their `snake_case` names to HTML's `camelCase` attributes.

 > 
 > Note: Styles can be used directly outside of the `style:` attribute. In the above example, `color: "red"` is turned into `style="color: red"`.

#### Custom Attributes

Dioxus has a pre-configured set of attributes that you can use. RSX is validated at compile time to make sure you didn't specify an invalid attribute. If you want to override this behavior with a custom attribute name, specify the attribute in quotes:

````rs@rsx_overview.rs
cx.render(rsx!(div {
    "style": "width: 20px; height: 20px; background-color: red;",
}))
````

````inject-dioxus
DemoFrame {
	rsx_overview::CustomAttributes {}
}
````

### Special Attributes

While most attributes are simply passed on to the HTML, some have special behaviors.

#### The HTML Escape Hatch

If you're working with pre-rendered assets, output from templates, or output from a JS library, then you might want to pass HTML directly instead of going through Dioxus. In these instances, reach for `dangerous_inner_html`.

For example, shipping a markdown-to-Dioxus converter might significantly bloat your final application size. Instead, you'll want to pre-render your markdown to HTML and then include the HTML directly in your output. We use this approach for the [Dioxus homepage](https://dioxuslabs.com):

````rs@dangerous_inner_html.rs
// this should come from a trusted source
let contents = "live <b>dangerously</b>";

cx.render(rsx! {
    div {
        dangerous_inner_html: "{contents}",
    }
})
````

````inject-dioxus
DemoFrame {
	dangerous_inner_html::App {}
}
````

 > 
 > Note! This attribute is called "dangerous_inner_html" because it is **dangerous** to pass it data you don't trust. If you're not careful, you can easily expose [cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks to your users.
 > 
 > If you're handling untrusted input, make sure to sanitize your HTML before passing it into `dangerous_inner_html` â€“ or just pass it to a Text Element to escape any HTML tags.

#### Boolean Attributes

Most attributes, when rendered, will be rendered exactly as the input you provided. However, some attributes are considered "boolean" attributes and just their presence determines whether they affect the output. For these attributes, a provided value of `"false"` will cause them to be removed from the target element.

So this RSX wouldn't actually render the `hidden` attribute:

````rs@boolean_attribute.rs
cx.render(rsx! {
    div {
        hidden: false,
        "hello"
    }
})
````

````inject-dioxus
DemoFrame {
	boolean_attribute::App {}
}
````

Not all attributes work like this however. *Only the following attributes* have this behavior:

* `allowfullscreen`
* `allowpaymentrequest`
* `async`
* `autofocus`
* `autoplay`
* `checked`
* `controls`
* `default`
* `defer`
* `disabled`
* `formnovalidate`
* `hidden`
* `ismap`
* `itemscope`
* `loop`
* `multiple`
* `muted`
* `nomodule`
* `novalidate`
* `open`
* `playsinline`
* `readonly`
* `required`
* `reversed`
* `selected`
* `truespeed`

For any other attributes, a value of `"false"` will be sent directly to the DOM.

### Interpolation

Similarly to how you can [format](https://doc.rust-lang.org/rust-by-example/hello/print/fmt.html) Rust strings, you can also interpolate in RSX text. Use `{variable}` to Display the value of a variable in a string, or `{variable:?}` to use the Debug representation:

````rs@rsx_overview.rs
let coordinates = (42, 0);
let country = "es";
cx.render(rsx!(div {
    class: "country-{country}",
    left: "{coordinates.0:?}",
    top: "{coordinates.1:?}",
    // arbitrary expressions are allowed,
    // as long as they don't contain `{}`
    div {
        "{country.to_uppercase()}"
    },
    div {
        "{7*6}"
    },
    // {} can be escaped with {{}}
    div {
        "{{}}"
    },
}))
````

````inject-dioxus
DemoFrame {
	rsx_overview::Formatting {}
}
````

### Children

To add children to an element, put them inside the `{}` brackets after all attributes and listeners in the element. They can be other elements, text, or [components](components.md). For example, you could have an `ol` (ordered list) element, containing 3 `li` (list item) elements, each of which contains some text:

````rs@rsx_overview.rs
cx.render(rsx!(ol {
    li {"First Item"}
    li {"Second Item"}
    li {"Third Item"}
}))
````

````inject-dioxus
DemoFrame {
	rsx_overview::Children {}
}
````

### Fragments

You can render multiple elements at the top level of `rsx!` and they will be automatically grouped.

````rs@rsx_overview.rs
cx.render(rsx!(
    p {"First Item"},
    p {"Second Item"},
))
````

````inject-dioxus
DemoFrame {
	rsx_overview::ManyRoots {}
}
````

### Expressions

You can include arbitrary Rust expressions as children within RSX that implements [IntoDynNode](https://docs.rs/dioxus-core/0.3/dioxus_core/trait.IntoDynNode.html). This is useful for displaying data from an [iterator](https://doc.rust-lang.org/stable/book/ch13-02-iterators.html#processing-a-series-of-items-with-iterators):

````rs@rsx_overview.rs
let text = "Dioxus";
cx.render(rsx!(span {
    text.to_uppercase(),
    // create a list of text from 0 to 9
    (0..10).map(|i| rsx!{ i.to_string() })
}))
````

````inject-dioxus
DemoFrame {
	rsx_overview::Expression {}
}
````

### Loops

In addition to iterators you can also use for loops directly within RSX:

````rs@rsx_overview.rs
cx.render(rsx! {
    // use a for loop where the body itself is RSX
    div {
        // create a list of text from 0 to 9
        for i in 0..3 {
            // NOTE: the body of the loop is RSX not a rust statement
            div {
                "{i}"
            }
        }
    }
    // iterator equivalent
    div {
        (0..3).map(|i| rsx!{ div { "{i}" } })
    }
})
````

````inject-dioxus
DemoFrame {
	rsx_overview::Loops {}
}
````

### If statements

You can also use if statements without an else branch within RSX:

````rs@rsx_overview.rs
cx.render(rsx! {
    // use if statements without an else
    if true {
        rsx!(div { "true" })
    }
})
````

````inject-dioxus
DemoFrame {
	rsx_overview::IfStatements {}
}
````
# Components

Just like you wouldn't want to write a complex program in a single, long, `main` function, you shouldn't build a complex UI in a single `App` function. Instead, you should break down the functionality of an app in logical parts called components.

A component is a Rust function, named in UpperCamelCase, that takes a `Scope` parameter and returns an `Element` describing the UI it wants to render. In fact, our `App` function is a component!

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

 > 
 > You'll probably want to add `#![allow(non_snake_case)]` to the top of your crate to avoid warnings about UpperCamelCase component names

A Component is responsible for some rendering task â€“ typically, rendering an isolated part of the user interface. For example, you could have an `About` component that renders a short description of Dioxus Labs:

````rs@components.rs
pub fn About(cx: Scope) -> Element {
    cx.render(rsx!(p {
        b {"Dioxus Labs"}
        " An Open Source project dedicated to making Rust UI wonderful."
    }))
}
````

````inject-dioxus
DemoFrame {
	components::About {}
}
````

Then, you can render your component in another component, similarly to how elements are rendered:

````rs@components.rs
pub fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        About {},
        About {},
    })
}
````

````inject-dioxus
DemoFrame {
	components::App {}
}
````

 > 
 > At this point, it might seem like components are nothing more than functions. However, as you learn more about the features of Dioxus, you'll see that they are actually more powerful!
# Component Props

Just like you can pass arguments to a function or attributes to an element, you can pass props to a component that customize its behavior! The components we've seen so far didn't accept any props â€“ so let's write some components that do.

## derive(Props)

Component props are a single struct annotated with `#[derive(Props)]`. For a component to accept props, the type of its argument must be `Scope<YourPropsStruct>`. Then, you can access the value of the props using `cx.props`.

There are 2 flavors of Props structs:

* Owned props:
  * Don't have an associated lifetime
  * Implement `PartialEq`, allow for memoization (if the props don't change, Dioxus won't re-render the component)
* Borrowed props:
  * [Borrow](https://doc.rust-lang.org/beta/rust-by-example/scope/borrow.html) from a parent component
  * Cannot be memoized due to lifetime constraints

### Owned Props

Owned Props are very simple â€“ they don't borrow anything. Example:

````rs@component_owned_props.rs
// Remember: Owned props must implement `PartialEq`!
#[derive(PartialEq, Props)]
struct LikesProps {
    score: i32,
}

fn Likes(cx: Scope<LikesProps>) -> Element {
    cx.render(rsx! {
        div {
            "This post has ",
            b { "{cx.props.score}" },
            " likes"
        }
    })
}
````

You can then pass prop values to the component the same way you would pass attributes to an element:

````rs@component_owned_props.rs
pub fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        Likes {
            score: 42,
        },
    })
}
````

````inject-dioxus
DemoFrame {
    component_owned_props::App {}
}
````

### Borrowed Props

Owned props work well if your props are easy to copy around â€“ like a single number. But what if we need to pass a larger data type, like a String from an `App` Component to a `TitleCard` subcomponent? A naive solution might be to [`.clone()`](https://doc.rust-lang.org/std/clone/trait.Clone.html) the String, creating a copy of it for the subcomponent â€“ but this would be inefficient, especially for larger Strings.

Rust allows for something more efficient â€“ borrowing the String as a `&str` â€“ this is what Borrowed Props are for!

````rs@component_borrowed_props.rs
#[derive(Props)]
struct TitleCardProps<'a> {
    title: &'a str,
}

fn TitleCard<'a>(cx: Scope<'a, TitleCardProps<'a>>) -> Element {
    cx.render(rsx! {
        h1 { "{cx.props.title}" }
    })
}
````

We can then use the component like this:

````rs@component_borrowed_props.rs
pub fn App(cx: Scope) -> Element {
    let hello = "Hello Dioxus!";

    cx.render(rsx!(TitleCard { title: hello }))
}
````

````inject-dioxus
DemoFrame {
    // original: component_borrowed_props::App {}
    __interactive_04::component_borrowed_props {}
}
````

Borrowed props can be very useful, but they do not allow for memorization so they will *always* rerun when the parent scope is rerendered. Because of this Borrowed Props should be reserved for components that are cheap to rerun or places where cloning data is an issue. Using Borrowed Props everywhere will result in large parts of your app rerunning every interaction.

## Prop Options

The `#[derive(Props)]` macro has some features that let you customize the behavior of props.

### Optional Props

You can create optional fields by using the `Option<â€¦>` type for a field:

````rs@component_props_options.rs
#[derive(Props)]
struct OptionalProps<'a> {
    title: &'a str,
    subtitle: Option<&'a str>,
}

fn Title<'a>(cx: Scope<'a, OptionalProps>) -> Element<'a> {
    cx.render(rsx!(h1{
        "{cx.props.title}: ",
        cx.props.subtitle.unwrap_or("No subtitle provided"),
    }))
}
````

Then, you can choose to either provide them or not:

````rs@component_props_options.rs
Title {
title: "Some Title",
},
Title {
title: "Some Title",
subtitle: "Some Subtitle",
},
// Providing an Option explicitly won't compile though:
// Title {
//     title: "Some Title",
//     subtitle: None,
// },
````

### Explicitly Required `Option`s

If you want to explicitly require an `Option`, and not an optional prop, you can annotate it with `#[props(!optional)]`:

````rs@component_props_options.rs
#[derive(Props)]
struct ExplicitOptionProps<'a> {
    title: &'a str,
    #[props(!optional)]
    subtitle: Option<&'a str>,
}

fn ExplicitOption<'a>(cx: Scope<'a, ExplicitOptionProps>) -> Element<'a> {
    cx.render(rsx!(h1 {
        "{cx.props.title}: ",
        cx.props.subtitle.unwrap_or("No subtitle provided"),
    }))
}
````

Then, you have to explicitly pass either `Some("str")` or `None`:

````rs@component_props_options.rs
ExplicitOption {
title: "Some Title",
subtitle: None,
},
ExplicitOption {
title: "Some Title",
subtitle: Some("Some Title"),
},
// This won't compile:
// ExplicitOption {
//     title: "Some Title",
// },
````

### Default Props

You can use `#[props(default = 42)]` to make a field optional and specify its default value:

````rs@component_props_options.rs
#[derive(PartialEq, Props)]
struct DefaultProps {
    // default to 42 when not provided
    #[props(default = 42)]
    number: i64,
}

fn DefaultComponent(cx: Scope<DefaultProps>) -> Element {
    cx.render(rsx!(h1 { "{cx.props.number}" }))
}
````

Then, similarly to optional props, you don't have to provide it:

````rs@component_props_options.rs
DefaultComponent {
number: 5,
},
DefaultComponent {},
````

### Automatic Conversion with `.into`

It is common for Rust functions to accept `impl Into<SomeType>` rather than just `SomeType` to support a wider range of parameters. If you want similar functionality with props, you can use `#[props(into)]`. For example, you could add it on a `String` prop â€“ and `&str` will also be automatically accepted, as it can be converted into `String`:

````rs@component_props_options.rs
#[derive(PartialEq, Props)]
struct IntoProps {
    #[props(into)]
    string: String,
}

fn IntoComponent(cx: Scope<IntoProps>) -> Element {
    cx.render(rsx!(h1 { "{cx.props.string}" }))
}
````

Then, you can use it so:

````rs@component_props_options.rs
IntoComponent {
string: "some &str",
},
````

## The component macro

So far, every Component function we've seen had a corresponding ComponentProps struct to pass in props. This was quite verbose... Wouldn't it be nice to have props as simple function arguments? Then we wouldn't need to define a Props struct, and instead of typing `cx.props.whatever`, we could just use `whatever` directly!

`component` allows you to do just that. Instead of typing the "full" version:

````rust, no_run
#[derive(Props, PartialEq)]
struct TitleCardProps {
    title: String,
}

fn TitleCard(cx: Scope<TitleCardProps>) -> Element {
    cx.render(rsx!{
        h1 { "{cx.props.title}" }
    })
}
````

...you can define a function that accepts props as arguments. Then, just annotate it with `#[component]`, and the macro will turn it into a regular Component for you:

````rust, no_run
#[component]
fn TitleCard(cx: Scope, title: String) -> Element {
    cx.render(rsx!{
        h1 { "{title}" }
    })
}
````

 > 
 > While the new Component is shorter and easier to read, this macro should not be used by library authors since you have less control over Prop documentation.

## Component Children

In some cases, you may wish to create a component that acts as a container for some other content, without the component needing to know what that content is. To achieve this, create a prop of type `Element`:

````rs@component_element_props.rs
#[derive(Props)]
struct ClickableProps<'a> {
    href: &'a str,
    body: Element<'a>,
}

fn Clickable<'a>(cx: Scope<'a, ClickableProps<'a>>) -> Element {
    cx.render(rsx!(
        a {
            href: "{cx.props.href}",
            class: "fancy-button",
            &cx.props.body
        }
    ))
}
````

Then, when rendering the component, you can pass in the output of `cx.render(rsx!(...))`:

````rs@component_element_props.rs
cx.render(rsx! {
    Clickable {
        href: "https://www.youtube.com/watch?v=C-M2hs3sXGo",
        body: cx.render(rsx!("How to " i {"not"} " be seen")),
    }
})
````

 > 
 > Note: Since `Element<'a>` is a borrowed prop, there will be no memoization.

 > 
 > Warning: While it may compile, do not include the same `Element` more than once in the RSX. The resulting behavior is unspecified.

### The children field

Rather than passing the RSX through a regular prop, you may wish to accept children similarly to how elements can have children. The "magic" `children` prop lets you achieve this:

````rs@component_children.rs
#[derive(Props)]
struct ClickableProps<'a> {
    href: &'a str,
    children: Element<'a>,
}

fn Clickable<'a>(cx: Scope<'a, ClickableProps<'a>>) -> Element {
    cx.render(rsx!(
        a {
            href: "{cx.props.href}",
            class: "fancy-button",
            &cx.props.children
        }
    ))
}
````

This makes using the component much simpler: simply put the RSX inside the `{}` brackets â€“ and there is no need for a `render` call or another macro!

````rs@component_children.rs
cx.render(rsx! {
    Clickable {
        href: "https://www.youtube.com/watch?v=C-M2hs3sXGo",
        "How to " i {"not"} " be seen"
    }
})
````

````inject-dioxus
DemoFrame {
    component_children::App {}
}
````
# Event Handlers

Event handlers are used to respond to user actions. For example, an event handler could be triggered when the user clicks, scrolls, moves the mouse, or types a character.

Event handlers are attached to elements. For example, we usually don't care about all the clicks that happen within an app, only those on a particular button.

Event handlers are similar to regular attributes, but their name usually starts with `on`- and they accept closures as values. The closure will be called whenever the event it listens for is triggered and will be passed that event.

For example, to handle clicks on an element, we can specify an `onclick` handler:

````rs@event_click.rs
cx.render(rsx! {
    button {
        onclick: move |event| log::info!("Clicked! Event: {event:?}"),
        "click me!"
    }
})
````

````inject-dioxus
DemoFrame {
    event_click::App {}
}
````

## The Event object

Event handlers receive an [`Event`](https://docs.rs/dioxus-core/latest/dioxus_core/struct.Event.html) object containing information about the event. Different types of events contain different types of data. For example, mouse-related events contain [`MouseData`](https://docs.rs/dioxus/latest/dioxus/events/struct.MouseData.html), which tells you things like where the mouse was clicked and what mouse buttons were used.

In the example above, this event data was logged to the terminal:

````
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
````

To learn what the different event types for HTML provide, read the [events module docs](https://docs.rs/dioxus-html/latest/dioxus_html/events/index.html).

### Event propagation

Some events will trigger first on the element the event originated at upward. For example, a click event on a `button` inside a `div` would first trigger the button's event listener and then the div's event listener.

 > 
 > For more information about event propagation see [the mdn docs on event bubbling](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling)

If you want to prevent this behavior, you can call `stop_propagation()` on the event:

````rs@event_nested.rs
cx.render(rsx! {
    div {
        onclick: move |_event| {},
        "outer",
        button {
            onclick: move |event| {
                // now, outer won't be triggered
                event.stop_propagation();
            },
            "inner"
        }
    }
})
````

## Prevent Default

Some events have a default behavior. For keyboard events, this might be entering the typed character. For mouse events, this might be selecting some text.

In some instances, might want to avoid this default behavior. For this, you can add the `prevent_default` attribute with the name of the handler whose default behavior you want to stop. This attribute can be used for multiple handlers using their name separated by spaces:

````rs@event_prevent_default.rs
cx.render(rsx! {
    a {
        href: "https://example.com",
        prevent_default: "onclick",
        onclick: |_| log::info!("link clicked"),
        "example.com",
    }
})
````

````inject-dioxus
DemoFrame {
    event_prevent_default::App {}
}
````

Any event handlers will still be called.

 > 
 > Normally, in React or JavaScript, you'd call "preventDefault" on the event in the callback. Dioxus does *not* currently support this behavior. Note: this means you cannot conditionally prevent default behavior based on the data in the event.

## Handler Props

Sometimes, you might want to make a component that accepts an event handler. A simple example would be a `FancyButton` component, which accepts an `on_click` handler:

````rs@event_handler_prop.rs
#[derive(Props)]
pub struct FancyButtonProps<'a> {
    on_click: EventHandler<'a, MouseEvent>,
}

pub fn FancyButton<'a>(cx: Scope<'a, FancyButtonProps<'a>>) -> Element<'a> {
    cx.render(rsx!(button {
        class: "fancy-button",
        onclick: move |evt| cx.props.on_click.call(evt),
        "click me pls."
    }))
}
````

Then, you can use it like any other handler:

````rs@event_handler_prop.rs
cx.render(rsx! {
    FancyButton {
        on_click: move |event| println!("Clicked! {event:?}")
    }
})
````

 > 
 > Note: just like any other attribute, you can name the handlers anything you want! Though they must start with `on`, for the prop to be automatically turned into an `EventHandler` at the call site.

## Custom Data

Event Handlers are generic over any type, so you can pass in any data you want to them, e.g:

````rs@event_handler_prop.rs
struct ComplexData(i32);

#[derive(Props)]
pub struct CustomFancyButtonProps<'a> {
    on_click: EventHandler<'a, ComplexData>,
}

pub fn CustomFancyButton<'a>(cx: Scope<'a, CustomFancyButtonProps<'a>>) -> Element<'a> {
    cx.render(rsx!(button {
        class: "fancy-button",
        onclick: move |_| cx.props.on_click.call(ComplexData(0)),
        "click me pls."
    }))
}
````
# Hooks and component state

So far, our components have had no state like a normal Rust function. However, in a UI component, it is often useful to have stateful functionality to build user interactions. For example, you might want to track whether the user has opened a drop-down and render different things accordingly.

Hooks allow us to create state in our components. Hooks are Rust functions that take a reference to [`ScopeState`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html) (in a component, you can pass `cx`), and provide you with functionality and state.

Dioxus provides many built-in hooks, but if those hooks don't fit your specific use case, you also can [create your own hook](../cookbook/state/custom_hooks/index.md)

## use_state hook

[`use_state`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_state.html) is one of the simplest hooks.

* You provide a closure that determines the initial value: `let mut count = use_state(cx, || 0);`
* `use_state` gives you the current value, and a way to update it by setting it to something else
* When the value updates, `use_state` makes the component re-render (along with any other component that references it), and then provides you with the new value.

For example, you might have seen the counter example, in which state (a number) is tracked using the `use_state` hook:

````rs@hooks_counter.rs
pub fn App(cx: Scope) -> Element {
    // count will be initialized to 0 the first time the component is rendered
    let mut count = use_state(cx, || 0);

    cx.render(rsx!(
        h1 { "High-Five counter: {count}" }
        button {
            onclick: move |_| {
                // changing the count will cause the component to re-render
                count += 1
            },
            "Up high!"
        }
        button {
            onclick: move |_| {
                // changing the count will cause the component to re-render
                count -= 1
            },
            "Down low!"
        }
    ))
}
````

````inject-dioxus
DemoFrame {
   hooks_counter::App {}
}
````

Every time the component's state changes, it re-renders, and the component function is called, so you can describe what you want the new UI to look like. You don't have to worry about "changing" anything â€“ describe what you want in terms of the state, and Dioxus will take care of the rest!

 > 
 > `use_state` returns your value wrapped in a smart pointer of type [`UseState`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.UseState.html). This is why you can both read the value and update it, even within an event handler.

You can use multiple hooks in the same component if you want:

````rs@hooks_counter_two_state.rs
pub fn App(cx: Scope) -> Element {
    let mut count_a = use_state(cx, || 0);
    let mut count_b = use_state(cx, || 0);

    cx.render(rsx!(
        h1 { "Counter_a: {count_a}" }
        button { onclick: move |_| count_a += 1, "a++" }
        button { onclick: move |_| count_a -= 1, "a--" }
        h1 { "Counter_b: {count_b}" }
        button { onclick: move |_| count_b += 1, "b++" }
        button { onclick: move |_| count_b -= 1, "b--" }
    ))
}
````

````inject-dioxus
DemoFrame {
  hooks_counter_two_state::App {}
}
````

### Out-of-date UseState

The value `UseState` dereferences to is only set when the use_state hook is called every render. This means that if you move the state into a future, or you write to the state and then immediately read the state, it may return an out-of-date value.

````rs@hooks_out_of_date.rs
pub fn App(cx: Scope) -> Element {
    // count will be initialized to 0 the first time the component is rendered
    let mut count = use_state(cx, || 0);
    let first_count_read = use_state(cx, || 0);

    // Increase the count
    if *count == 0 {
        count += 1;
        first_count_read.set(**count);
    }

    cx.render(rsx!(
        // This uses the deref value
        h1 { "High-Five counter: {first_count_read}" }
    ))
}
````

````inject-dioxus
DemoFrame {
   // original: hooks_out_of_date::App {}
   __interactive_04::hooks_out_of_date {}
}
````

Instead of using deref to get the inner value from UseState, you can use the [`current`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.UseState.html#method.current) function. This function will always return the current value of the state.

````rs@hooks_out_of_date.rs
pub fn App(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);
    let first_count_read = use_state(cx, || 0);

    // Increase the count
    if *count == 0 {
        count += 1;
        first_count_read.set(*count.current());
    }

    cx.render(rsx!(
        // Use .current to get the real current value
        h1 { "High-Five counter: {first_count_read}" }
    ))
}
````

````inject-dioxus
DemoFrame {
   // original: hooks_out_of_date::fixed::App {}
   __interactive_04::hooks_out_of_date_fixed {}
}
````

## Rules of hooks

The above example might seem a bit magic since Rust functions are typically not associated with state. Dioxus allows hooks to maintain state across renders through a reference to `ScopeState`, which is why you must pass `&cx` to them.

But how can Dioxus differentiate between multiple hooks in the same component? As you saw in the second example, both `use_state` functions were called with the same parameters, so how come they can return different things when the counters are different?

````rs@hooks_counter_two_state.rs
let mut count_a = use_state(cx, || 0);
let mut count_b = use_state(cx, || 0);
````

This is only possible because the two hooks are always called in the same order, so Dioxus knows which is which. Because the order you call hooks matters, you must follow certain rules when using hooks:

1. Hooks may be only used in components or other hooks (we'll get to that later).
1. On every call to a component function.
1. The same hooks must be called (except in the case of early returns, as explained later in the [Error Handling chapter](../cookbook/error_handling.md)).
1. In the same order.
1. Hook names should start with `use_` so you don't accidentally confuse them with regular
   functions (`use_state()`, `use_ref()`, `use_future()`, etc...).

These rules mean that there are certain things you can't do with hooks:

### No hooks in conditionals

````rs@hooks_bad.rs
// âŒ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy && you_know_it {
    let something = use_state(cx, || "hands");
    println!("clap your {something}")
}

// âœ… instead, *always* call use_state
// You can put other stuff in the conditional though
let something = use_state(cx, || "hands");
if you_are_happy && you_know_it {
    println!("clap your {something}")
}
````

### No hooks in closures

````rs@hooks_bad.rs
// âŒ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
    let b = use_state(cx, || 0);
    b.get()
};

// âœ… instead, move hook `b` outside
let b = use_state(cx, || 0);
let _a = || b.get();
````

### No hooks in loops

````rs@hooks_bad.rs
// `names` is a Vec<&str>

// âŒ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &names {
    let is_selected = use_state(cx, || false);
    println!("selected: {is_selected}");
}

// âœ… Instead, use a hashmap with use_ref
let selection_map = use_ref(cx, HashMap::<&str, bool>::new);

for name in &names {
    let is_selected = selection_map.read()[name];
    println!("selected: {is_selected}");
}
````

## use_ref hook

`use_state` is great for tracking simple values. However, in the [`UseState` API](https://docs.rs/dioxus/latest/dioxus/hooks/struct.UseState.html), you may notice that the only way to modify its value is to replace it with something else (e.g., by calling `set`, or through one of the `+=`, `-=` operators). This works well when it is cheap to construct a value (such as any primitive). But what if you want to maintain more complex data in the component's state?

For example, suppose we want to maintain a `Vec` of values. If we stored it with `use_state`, the
only way to add a new value to the list would be to copy the existing `Vec`, add our value to it,
and then replace the existing `Vec` in the state with it. This is expensive! We want to modify the
existing `Vec` instead.

Thankfully, there is another hook for that, `use_ref`! It is similar to `use_state`, but it lets you get a mutable reference to the contained data.

Here's a simple example that keeps a list of events in a `use_ref`. We can acquire write access to the state with `.with_mut()`, and then just `.push` a new value to the state:

````rs@hooks_use_ref.rs
pub fn App(cx: Scope) -> Element {
    let list = use_ref(cx, Vec::new);

    cx.render(rsx!(
        p { "Current list: {list.read():?}" }
        button {
            onclick: move |event| {
                list.with_mut(|list| list.push(event));
            },
            "Click me!"
        }
    ))
}
````

````inject-dioxus
DemoFrame {
   // original: hooks_use_ref::App {}
   __interactive_04::hooks_use_ref {}
}
````

 > 
 > The return values of `use_state` and `use_ref` (
 > Â [`UseState`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.UseState.html) and
 > Â [`UseRef`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.UseRef.html), respectively) are in
 > Â some ways similar to [`Cell`](https://doc.rust-lang.org/std/cell/) and
 > Â [`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) â€“ they provide interior
 > Â mutability. However, these Dioxus wrappers also ensure that the component gets re-rendered
 > Â whenever you change the state.

## Additional resources

* [dioxus_hooks API docs](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/)
* [dioxus_hooks source code](https://github.com/DioxusLabs/dioxus/tree/master/packages/hooks)
# User Input

Interfaces often need to provide a way to input data: e.g. text, numbers, checkboxes, etc. In Dioxus, there are two ways you can work with user input.

## Controlled Inputs

With controlled inputs, you are directly in charge of the state of the input. This gives you a lot of flexibility, and makes it easy to keep things in sync. For example, this is how you would create a controlled text input:

````rs@input_controlled.rs
pub fn App(cx: Scope) -> Element {
    let name = use_state(cx, || "bob".to_string());

    cx.render(rsx! {
        input {
            // we tell the component what to render
            value: "{name}",
            // and what to do when the value changes
            oninput: move |evt| name.set(evt.value.clone()),
        }
    })
}
````

````inject-dioxus
DemoFrame {
    input_controlled::App {}
}
````

Notice the flexibility â€“ you can:

* Also display the same contents in another element, and they will be in sync
* Transform the input every time it is modified (e.g. to make sure it is upper case)
* Validate the input every time it changes
* Have custom logic happening when the input changes (e.g. network request for autocompletion)
* Programmatically change the value (e.g. a "randomize" button that fills the input with nonsense)

## Uncontrolled Inputs

As an alternative to controlled inputs, you can simply let the platform keep track of the input values. If we don't tell a HTML input what content it should have, it will be editable anyway (this is built into the browser). This approach can be more performant, but less flexible. For example, it's harder to keep the input in sync with another element.

Since you don't necessarily have the current value of the uncontrolled input in state, you can access it either by listening to `oninput` events (similarly to controlled components), or, if the input is part of a form, you can access the form data in the form events (e.g. `oninput` or `onsubmit`):

````rs@input_uncontrolled.rs
pub fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        form {
            onsubmit: move |event| {
                log::info!("Submitted! {event:?}")
            },
            input { name: "name", },
            input { name: "age", },
            input { name: "date", },
            input { r#type: "submit", },
        }
    })
}
````

````inject-dioxus
DemoFrame {
    input_uncontrolled::App {}
}
````

````
Submitted! UiEvent { data: FormData { value: "", values: {"age": "very old", "date": "1966", "name": "Fred"} } }
````

## Handling files

You can insert a file picker by using an input element of type `file`. This element supports the `multiple` attribute, to let you pick more files at the same time. You can select a folder by adding the `directory` attribute: Dioxus will map this attribute to browser specific attributes, because there is no standardized way to allow a directory to be selected.

`type` is a Rust keyword, so when specifying the type of the input field, you have to write it as `r#type:"file"`.

Extracting the selected files is a bit different from what you may typically use in Javascript.

The `FormData` event contains a `files` field with data about the uploaded files. This field contains a `FileEngine` struct which lets you fetch the filenames selected by the user. This example saves the filenames of the selected files to a `Vec`:

````rs@input_fileengine.rs
pub fn App(cx: Scope) -> Element {
    let filenames: &UseRef<Vec<String>> = use_ref(cx, Vec::new);
    cx.render(rsx! {
        input {
            // tell the input to pick a file
            r#type:"file",
            // list the accepted extensions
            accept: ".txt,.rs",
            // pick multiple files
            multiple: true,
            onchange: move |evt| {
                if let Some(file_engine) = &evt.files {
                    let files = file_engine.files();
                    for file_name in files {
                        filenames.write().push(file_name);
                    }
                }
            }
        }
    })
}
````

If you're planning to read the file content, you need to do it asynchronously, to keep the rest of the UI interactive. This example event handler loads the content of the selected files in an async closure:

````rs@input_fileengine_async.rs
onchange: move |evt| {
    // A helper macro to use hooks in async environments
    to_owned![files_uploaded];
    async move {
        if let Some(file_engine) = &evt.files {
            let files = file_engine.files();
            for file_name in &files {
                // Make sure to use async/await when doing heavy I/O operations,
                // to not freeze the interface in the meantime
                if let Some(file) = file_engine.read_file_to_string(file_name).await{
                    files_uploaded.write().push(file);
                }
            }
        }
    }
}
````

Lastly, this example shows you how to select a folder, by setting the `directory` attribute to `true`.

````rs@input_fileengine_folder.rs
input {
    r#type:"file",
    // Select a folder by setting the directory attribute
    directory: true,
    onchange: |evt| {
        if let Some(file_engine) = &evt.files {
            let files = file_engine.files();
            for file_name in files {
                println!("{}", file_name);
                // Do something with the folder path
            }
        }
    }
}
````
# Sharing State

Often, multiple components need to access the same state. Depending on your needs, there are several ways to implement this.

## Lifting State

One approach to share state between components is to "lift" it up to the nearest common ancestor. This means putting the `use_state` hook in a parent component, and passing the needed values down as props.

Suppose we want to build a meme editor. We want to have an input to edit the meme caption, but also a preview of the meme with the caption. Logically, the meme and the input are 2 separate components, but they need access to the same state (the current caption).

 > 
 > Of course, in this simple example, we could write everything in one component â€“ but it is better to split everything out in smaller components to make the code more reusable, maintainable, and performant (this is even more important for larger, complex apps).

We start with a `Meme` component, responsible for rendering a meme with a given caption:

````rs@meme_editor.rs
#[component]
fn Meme<'a>(cx: Scope<'a>, caption: &'a str) -> Element<'a> {
    let container_style = r#"
        position: relative;
        width: fit-content;
    "#;

    let caption_container_style = r#"
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 16px 8px;
    "#;

    let caption_style = r"
        font-size: 32px;
        margin: 0;
        color: white;
        text-align: center;
    ";

    cx.render(rsx!(
        div {
            style: "{container_style}",
            img {
                src: "https://i.imgflip.com/2zh47r.jpg",
                height: "500px",
            },
            div {
                style: "{caption_container_style}",
                p {
                    style: "{caption_style}",
                    "{caption}"
                }
            }
        }
    ))
}
````

 > 
 > Note that the `Meme` component is unaware where the caption is coming from â€“ it could be stored in `use_state`, `use_ref`, or a constant. This ensures that it is very reusable â€“ the same component can be used for a meme gallery without any changes!

We also create a caption editor, completely decoupled from the meme. The caption editor must not store the caption itself â€“ otherwise, how will we provide it to the `Meme` component? Instead, it should accept the current caption as a prop, as well as an event handler to delegate input events to:

````rs@meme_editor.rs
#[component]
fn CaptionEditor<'a>(
    cx: Scope<'a>,
    caption: &'a str,
    on_input: EventHandler<'a, FormEvent>,
) -> Element<'a> {
    let input_style = r"
        border: none;
        background: cornflowerblue;
        padding: 8px 16px;
        margin: 0;
        border-radius: 4px;
        color: white;
    ";

    cx.render(rsx!(input {
        style: "{input_style}",
        value: "{caption}",
        oninput: move |event| on_input.call(event),
    }))
}
````

Finally, a third component will render the other two as children. It will be responsible for keeping the state and passing down the relevant props.

````rs@meme_editor.rs
fn MemeEditor(cx: Scope) -> Element {
    let container_style = r"
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin: 0 auto;
        width: fit-content;
    ";

    let caption = use_state(cx, || "me waiting for my rust code to compile".to_string());

    cx.render(rsx! {
        div {
            style: "{container_style}",
            h1 { "Meme Editor" },
            Meme {
                caption: caption,
            },
            CaptionEditor {
                caption: caption,
                on_input: move |event: FormEvent| {caption.set(event.value.clone());},
            },
        }
    })
}
````

![Meme Editor Screenshot: An old plastic skeleton sitting on a park bench. Caption: "me waiting for a language feature"](/assets/static/meme_editor_screenshot.png)

## Using Shared State

Sometimes, some state needs to be shared between multiple components far down the tree, and passing it down through props is very inconvenient.

Suppose now that we want to implement a dark mode toggle for our app. To achieve this, we will make every component select styling depending on whether dark mode is enabled or not.

 > 
 > Note: we're choosing this approach for the sake of an example. There are better ways to implement dark mode (e.g. using CSS variables). Let's pretend CSS variables don't exist â€“ welcome to 2013!

Now, we could write another `use_state` in the top component, and pass `is_dark_mode` down to every component through props. But think about what will happen as the app grows in complexity â€“ almost every component that renders any CSS is going to need to know if dark mode is enabled or not â€“ so they'll all need the same dark mode prop. And every parent component will need to pass it down to them. Imagine how messy and verbose that would get, especially if we had components several levels deep!

Dioxus offers a better solution than this "prop drilling" â€“ providing context. The [`use_shared_state_provider`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_shared_state_provider.html) hook is similar to `use_ref`, but it makes it available through [`use_shared_state`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_shared_state.html) for all children components.

First, we have to create a struct for our dark mode configuration:

````rs@meme_editor_dark_mode.rs
struct DarkMode(bool);
````

Now, in a top-level component (like `App`), we can provide the `DarkMode` context to all children components:

````rs@meme_editor_dark_mode.rs
use_shared_state_provider(cx, || DarkMode(false));
````

As a result, any child component of `App` (direct or not), can access the `DarkMode` context.

````rs@meme_editor_dark_mode.rs
let dark_mode_context = use_shared_state::<DarkMode>(cx);
````

 > 
 > `use_shared_state` returns `Option<UseSharedState<DarkMode>>` here. If the context has been provided, the value is `Some(UseSharedState<DarkMode>)`, which you can call `.read` or `.write` on, similarly to `UseRef`. Otherwise, the value is `None`.

For example, here's how we would implement the dark mode toggle, which both reads the context (to determine what color it should render) and writes to it (to toggle dark mode):

````rs@meme_editor_dark_mode.rs
pub fn DarkModeToggle(cx: Scope) -> Element {
    let dark_mode = use_shared_state::<DarkMode>(cx).unwrap();

    let style = if dark_mode.read().0 {
        "color:white"
    } else {
        ""
    };

    cx.render(rsx!(label {
        style: "{style}",
        "Dark Mode",
        input {
            r#type: "checkbox",
            oninput: move |event| {
                let is_enabled = event.value == "true";
                dark_mode.write().0 = is_enabled;
            },
        },
    }))
}
````
# Dynamic Rendering

Sometimes you want to render different things depending on the state/props. With Dioxus, just describe what you want to see using Rust control flow â€“ the framework will take care of making the necessary changes on the fly if the state or props change!

## Conditional Rendering

To render different elements based on a condition, you could use an `if-else` statement:

````rs@conditional_rendering.rs
if *is_logged_in {
    cx.render(rsx! {
        "Welcome!"
        button {
            onclick: move |_| on_log_out.call(()),
            "Log Out",
        }
    })
} else {
    cx.render(rsx! {
        button {
            onclick: move |_| on_log_in.call(()),
            "Log In",
        }
    })
}
````

````inject-dioxus
DemoFrame {
  conditional_rendering::App {}
}
````

 > 
 > You could also use `match` statements, or any Rust function to conditionally render different things.

### Improving the `if-else` Example

You may have noticed some repeated code in the `if-else` example above. Repeating code like this is both bad for maintainability and performance. Dioxus will skip diffing static elements like the button, but when switching between multiple `rsx` calls it cannot perform this optimization. For this example either approach is fine, but for components with large parts that are reused between conditionals, it can be more of an issue.

We can improve this example by splitting up the dynamic parts and inserting them where they are needed.

````rs@conditional_rendering.rs
cx.render(rsx! {
    // We only render the welcome message if we are logged in
    // You can use if statements in the middle of a render block to conditionally render elements
    if *is_logged_in {
        // Notice the body of this if statement is rsx code, not an expression
        "Welcome!"
    }
    button {
        // depending on the value of `is_logged_in`, we will call a different event handler
        onclick: move |_| if *is_logged_in {
            on_log_in.call(())
        }
        else{
            on_log_out.call(())
        },
        if *is_logged_in {
            // if we are logged in, the button should say "Log Out"
            "Log Out"
        } else {
            // if we are not logged in, the button should say "Log In"
            "Log In"
        }
    }
})
````

````inject-dioxus
DemoFrame {
  conditional_rendering::LogInImprovedApp {}
}
````

### Inspecting `Element` props

Since `Element` is a `Option<VNode>`, components accepting `Element` as a prop can inspect its contents, and render different things based on that. Example:

````rs@component_children_inspect.rs
fn Clickable<'a>(cx: Scope<'a, ClickableProps<'a>>) -> Element {
    match cx.props.children {
        Some(VNode { dynamic_nodes, .. }) => {
            todo!("render some stuff")
        }
        _ => {
            todo!("render some other stuff")
        }
    }
}
````

You can't mutate the `Element`, but if you need a modified version of it, you can construct a new one based on its attributes/children/etc.

## Rendering Nothing

To render nothing, you can return `None` from a component. This is useful if you want to conditionally hide something:

````rs@conditional_rendering.rs
if *is_logged_in {
    return None;
}

cx.render(rsx! {
    a {
        "You must be logged in to comment"
    }
})
````

````inject-dioxus
DemoFrame {
  conditional_rendering::LogInWarningApp {}
}
````

This works because the `Element` type is just an alias for `Option<VNode>`

 > 
 > Again, you may use a different method to conditionally return `None`. For example the boolean's [`then()`](https://doc.rust-lang.org/std/primitive.bool.html#method.then) function could be used.

## Rendering Lists

Often, you'll want to render a collection of components. For example, you might want to render a list of all comments on a post.

For this, Dioxus accepts iterators that produce `Element`s. So we need to:

* Get an iterator over all of our items (e.g., if you have a `Vec` of comments, iterate over it with `iter()`)
* `.map` the iterator to convert each item into a `LazyNode` using `rsx!(...)`
  * Add a unique `key` attribute to each iterator item
* Include this iterator in the final RSX (or use it inline)

Example: suppose you have a list of comments you want to render. Then, you can render them like this:

````rs@rendering_lists.rs
let comment_field = use_state(cx, String::new);
let mut next_id = use_state(cx, || 0);
let comments = use_ref(cx, Vec::<Comment>::new);

let comments_lock = comments.read();
let comments_rendered = comments_lock.iter().map(|comment| {
    rsx!(CommentComponent {
        key: "{comment.id}",
        comment: comment.clone(),
    })
});

cx.render(rsx!(
    form {
        onsubmit: move |_| {
            comments.write().push(Comment {
                content: comment_field.get().clone(),
                id: *next_id.get(),
            });
            next_id += 1;

            comment_field.set(String::new());
        },
        input {
            value: "{comment_field}",
            oninput: move |event| comment_field.set(event.value.clone()),
        }
        input {
            r#type: "submit",
        }
    },
    comments_rendered,
))
````

````inject-dioxus
DemoFrame {
  rendering_lists::App {}
}
````

### Inline for loops

Because of how common it is to render a list of items, Dioxus provides a shorthand for this. Instead of using `.iter`, `.map`, and `rsx`, you can use a `for` loop with a body of rsx code:

````rs@rendering_lists.rs
let comment_field = use_state(cx, String::new);
let mut next_id = use_state(cx, || 0);
let comments = use_ref(cx, Vec::<Comment>::new);

cx.render(rsx!(
    form {
        onsubmit: move |_| {
            comments.write().push(Comment {
                content: comment_field.get().clone(),
                id: *next_id.get(),
            });
            next_id += 1;

            comment_field.set(String::new());
        },
        input {
            value: "{comment_field}",
            oninput: move |event| comment_field.set(event.value.clone()),
        }
        input {
            r#type: "submit",
        }
    },
    for comment in &*comments.read() {
        // Notice the body of this for loop is rsx code, not an expression
        CommentComponent {
            key: "{comment.id}",
            comment: comment.clone(),
        }
    }
))
````

````inject-dioxus
DemoFrame {
  rendering_lists::AppForLoop {}
}
````

### The key Attribute

Every time you re-render your list, Dioxus needs to keep track of which items go where to determine what updates need to be made to the UI.

For example, suppose the `CommentComponent` had some state â€“ e.g. a field where the user typed in a reply. If the order of comments suddenly changes, Dioxus needs to correctly associate that state with the same comment â€“ otherwise, the user will end up replying to a different comment!

To help Dioxus keep track of list items, we need to associate each item with a unique key. In the example above, we dynamically generated the unique key. In real applications, it's more likely that the key will come from e.g. a database ID. It doesn't matter where you get the key from, as long as it meets the requirements:

* Keys must be unique in a list
* The same item should always get associated with the same key
* Keys should be relatively small (i.e. converting the entire Comment structure to a String would be a pretty bad key) so they can be compared efficiently

You might be tempted to use an item's index in the list as its key. Thatâ€™s what Dioxus will use if you donâ€™t specify a key at all. This is only acceptable if you can guarantee that the list is constant â€“ i.e., no re-ordering, additions, or deletions.

 > 
 > Note that if you pass the key to a component you've made, it won't receive the key as a prop. Itâ€™s only used as a hint by Dioxus itself. If your component needs an ID, you have to pass it as a separate prop.
# Router

In many of your apps, you'll want to have different "scenes". For a webpage, these scenes might be the different webpages with their own content. For a desktop app, these scenes might be different views in your app.

To unify these platforms, Dioxus provides a first-party solution for scene management called Dioxus Router.

## What is it?

For an app like the Dioxus landing page (https://dioxuslabs.com), we want to have several different scenes:

* Homepage
* Blog

Each of these scenes is independent â€“ we don't want to render both the homepage and blog at the same time.

The Dioxus router makes it easy to create these scenes. To make sure we're using the router, add the `dioxus-router` package to your `Cargo.toml`.

````shell
cargo add dioxus-router
````

## Using the router

Unlike other routers in the Rust ecosystem, our router is built declaratively at compile time. This makes it possible to compose our app layout simply by defining an enum.

````rust
// All of our routes will be a variant of this Route enum
enum Route {
	// if the current location is "/home", render the Home component
	#[route("/home")]
	Home {},
	// if the current location is "/blog", render the Blog component
	#[route("/blog")]
	Blog {},
}
````

Whenever we visit this app, we will get either the Home component or the Blog component rendered depending on which route we enter at. If neither of these routes match the current location, then nothing will render.

We can fix this one of two ways:

* A fallback 404 page

````rust
enum Route {
	#[route("/home")]
	Home {},
	#[route("/blog")]
	Blog {},
	//  if the current location doesn't match any of the above routes, render the NotFound component
	#[route("/:..segments")]
	NotFound { segments: Vec<String> },
}
````

* Redirect 404 to home

````rust
enum Route {
	#[route("/home")]
	//  if the current location doesn't match any of the above routes, redirect to "/home"
	#[redirect("/:..segments", |segments: Vec<String>| Route::Home {})]
	Home {},
	#[route("/blog")]
	Blog {},
	//  if the current location doesn't match any of the above routes, render the NotFound component
	#[route("/:..segments")]
	NotFound { segments: Vec<String> },
}
````

## Links

For our app to navigate these routes, we can provide clickable elements called Links. These simply wrap `<a>` elements that, when clicked, navigate the app to the given location. Because our route is an enum of valid routes, if you try to link to a page that doesn't exist, you will get a compiler error.

````rust
rsx! {
	Link {
		to: Route::Home {},
		"Go home!"
	}
}
````

## More reading

This page is just a very brief overview of the router. For more information, check out the [router book](../router/index.md) or some of the [router examples](https://github.com/DioxusLabs/dioxus/blob/master/examples/router.rs).
# UseFuture

[`use_future`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_future.html) lets you run an async closure, and provides you with its result.

For example, we can make an API request (using [reqwest](https://docs.rs/reqwest/latest/reqwest/index.html)) inside `use_future`:

````rs@use_future.rs
let future = use_future(cx, (), |_| async move {
    reqwest::get("https://dog.ceo/api/breeds/image/random")
        .await
        .unwrap()
        .json::<ApiResponse>()
        .await
});
````

The code inside `use_future` will be submitted to the Dioxus scheduler once the component has rendered.

We can use `.value()` to get the result of the future. On the first run, since there's no data ready when the component loads, its value will be `None`. However, once the future is finished, the component will be re-rendered and the value will now be `Some(...)`, containing the return value of the closure.

We can then render that result:

````rs@use_future.rs
cx.render(match future.value() {
    Some(Ok(response)) => rsx! {
        button {
            onclick: move |_| future.restart(),
            "Click to fetch another doggo"
        }
        div {
            img {
                max_width: "500px",
                max_height: "500px",
                src: "{response.image_url}",
            }
        }
    },
    Some(Err(_)) => rsx! { div { "Loading dogs failed" } },
    None => rsx! { div { "Loading dogs..." } },
})
````

````inject-dioxus
DemoFrame {
    // original: use_future::App {}
    __interactive_04::use_future_ {}
}
````

## Restarting the Future

The `UseFuture` handle provides a `restart` method. It can be used to execute the future again, producing a new value.

## Dependencies

Often, you will need to run the future again every time some value (e.g. a prop) changes. Rather than calling `restart` manually, you can provide a tuple of "dependencies" to the hook. It will automatically re-run the future when any of those dependencies change. Example:

````rs@use_future.rs
let future = use_future(cx, (breed,), |(breed,)| async move {
    reqwest::get(format!("https://dog.ceo/api/breed/{breed}/images/random"))
        .await
        .unwrap()
        .json::<ApiResponse>()
        .await
});
````
# Coroutines

Another tool in your async toolbox are coroutines. Coroutines are futures that can have values sent to them.

Like regular futures, code in a coroutine will run until the next `await` point before yielding. This low-level control over asynchronous tasks is quite powerful, allowing for infinitely looping tasks like WebSocket polling, background timers, and other periodic actions.

## use_coroutine

The `use_coroutine` hook allows you to create a coroutine. Most coroutines we write will be polling loops using await.

````rs@use_coroutine_reference.rs
use futures_util::StreamExt;

fn app(cx: Scope) {
    let ws: &Coroutine<()> = use_coroutine(cx, |rx| async move {
        // Connect to some sort of service
        let mut conn = connect_to_ws_server().await;

        // Wait for data on the service
        while let Some(msg) = conn.next().await {
            // handle messages
        }
    });
}
````

For many services, a simple async loop will handle the majority of use cases.

## Yielding Values

To yield values from a coroutine, simply bring in a `UseState` handle and set the value whenever your coroutine completes its work.

The future must be `'static` â€“ so any values captured by the task cannot carry any references to `cx`, such as a `UseState`.

You can use [to_owned](https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned) to create a clone of the hook handle which can be moved into the async closure.

````rs@use_coroutine_reference.rs
let sync_status = use_state(cx, || Status::Launching);
let sync_task = use_coroutine(cx, |rx: UnboundedReceiver<SyncAction>| {
    let sync_status = sync_status.to_owned();
    async move {
        loop {
            tokio::time::sleep(Duration::from_secs(1)).await;
            sync_status.set(Status::Working);
        }
    }
});
````

To make this a bit less verbose, Dioxus exports the `to_owned!` macro which will create a binding as shown above, which can be quite helpful when dealing with many values.

````rs@use_coroutine_reference.rs
let sync_status = use_state(cx, || Status::Launching);
let load_status = use_state(cx, || Status::Launching);
let sync_task = use_coroutine(cx, |rx: UnboundedReceiver<SyncAction>| {
    to_owned![sync_status, load_status];
    async move {
        // ...
    }
});
````

## Sending Values

You might've noticed the `use_coroutine` closure takes an argument called `rx`. What is that? Well, a common pattern in complex apps is to handle a bunch of async code at once. With libraries like Redux Toolkit, managing multiple promises at once can be challenging and a common source of bugs.

With Coroutines, we can centralize our async logic. The `rx` parameter is an Channel that allows code external to the coroutine to send data *into* the coroutine. Instead of looping on an external service, we can loop on the channel itself, processing messages from within our app without needing to spawn a new future. To send data into the coroutine, we would call "send" on the handle.

````rs@use_coroutine_reference.rs
use futures_util::StreamExt;

enum ProfileUpdate {
    SetUsername(String),
    SetAge(i32),
}

let profile = use_coroutine(cx, |mut rx: UnboundedReceiver<ProfileUpdate>| async move {
    let mut server = connect_to_server().await;

    while let Some(msg) = rx.next().await {
        match msg {
            ProfileUpdate::SetUsername(name) => server.update_username(name).await,
            ProfileUpdate::SetAge(age) => server.update_age(age).await,
        }
    }
});

cx.render(rsx! {
    button {
        onclick: move |_| profile.send(ProfileUpdate::SetUsername("Bob".to_string())),
        "Update username"
    }
})
````

 > 
 > Note: In order to use/run the `rx.next().await` statement you will need to extend the \[`Stream`\] trait (used by \[`UnboundedReceiver`\]) by adding 'futures_util' as a dependency to your project and adding the `use futures_util::stream::StreamExt;`.

For sufficiently complex apps, we could build a bunch of different useful "services" that loop on channels to update the app.

````rs@use_coroutine_reference.rs
let profile = use_coroutine(cx, profile_service);
let editor = use_coroutine(cx, editor_service);
let sync = use_coroutine(cx, sync_service);

async fn profile_service(rx: UnboundedReceiver<ProfileCommand>) {
    // do stuff
}

async fn sync_service(rx: UnboundedReceiver<SyncCommand>) {
    // do stuff
}

async fn editor_service(rx: UnboundedReceiver<EditorCommand>) {
    // do stuff
}
````

We can combine coroutines with [Fermi](https://docs.rs/fermi/latest/fermi/index.html) to emulate Redux Toolkit's Thunk system with much less headache. This lets us store all of our app's state *within* a task and then simply update the "view" values stored in Atoms. It cannot be understated how powerful this technique is: we get all the perks of native Rust tasks with the optimizations and ergonomics of global state. This means your *actual* state does not need to be tied up in a system like Fermi or Redux â€“ the only Atoms that need to exist are those that are used to drive the display/UI.

````rs@use_coroutine_reference.rs
static USERNAME: Atom<String> = Atom(|_| "default".to_string());

fn app(cx: Scope) -> Element {
    let atoms = use_atom_root(cx);

    use_coroutine(cx, |rx| sync_service(rx, atoms.clone()));

    cx.render(rsx! {
        Banner {}
    })
}

fn Banner(cx: Scope) -> Element {
    let username = use_read(cx, &USERNAME);

    cx.render(rsx! {
        h1 { "Welcome back, {username}" }
    })
}
````

Now, in our sync service, we can structure our state however we want. We only need to update the view values when ready.

````rs@use_coroutine_reference.rs

````

## Automatic injection into the Context API

Coroutine handles are automatically injected through the context API. You can use the `use_coroutine_handle` hook with the message type as a generic to fetch a handle.

````rs@use_coroutine_reference.rs
fn Child(cx: Scope) -> Element {
    let sync_task = use_coroutine_handle::<SyncAction>(cx).unwrap();

    sync_task.send(SyncAction::SetUsername);

    todo!()
}
````
# Spawning Futures

The `use_future` and `use_coroutine` hooks are useful if you want to unconditionally spawn the future. Sometimes, though, you'll want to only spawn a future in response to an event, such as a mouse click. For example, suppose you need to send a request when the user clicks a "log in" button. For this, you can use `cx.spawn`:

````rs@spawn.rs
let response = use_state(cx, || String::from("..."));

let log_in = move |_| {
    cx.spawn({
        to_owned![response];

        async move {
            let resp = reqwest::Client::new()
                .get("https://dioxuslabs.com")
                .send()
                .await;

            match resp {
                Ok(_data) => {
                    log::info!("dioxuslabs.com responded!");
                    response.set("dioxuslabs.com responded!".into());
                }
                Err(err) => {
                    log::info!("Request failed with error: {err:?}")
                }
            }
        }
    });
};

render! {
    button {
        onclick: log_in,
        "Response: {response}",
    }
}
````

````inject-dioxus
DemoFrame {
    spawn::App {}
}
````

 > 
 > Note: `spawn` will always spawn a *new* future. You most likely don't want to call it on every render.

Calling `spawn` will give you a `JoinHandle` which lets you cancel or pause the future.

## Spawning Tokio Tasks

Sometimes, you might want to spawn a background task that needs multiple threads or talk to hardware that might block your app code. In these cases, we can directly spawn a Tokio task from our future. For Dioxus-Desktop, your task will be spawned onto Tokio's Multithreaded runtime:

````rs@spawn.rs
cx.spawn(async {
    let _ = tokio::spawn(async {}).await;

    let _ = tokio::task::spawn_local(async {
        // some !Send work
    })
    .await;
});
````
# Desktop

This guide will cover concepts specific to the Dioxus desktop renderer.

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus desktop exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -> Element {
    // Use eval returns a function that can spawn eval instances
    let create_eval = use_eval(cx);

    // You can create as many eval instances as you want
    let mut eval = create_eval(
        r#"
        // You can send messages from JavaScript to Rust with the dioxus.send function
        dioxus.send("Hi from JS!");
        // You can receive messages from Rust to JavaScript with the dioxus.recv function
        let msg = await dioxus.recv();
        console.log(msg);
        "#,
    )
    .unwrap();

    // You can send messages to JavaScript with the send method
    eval.send("Hi from Rust!".into()).unwrap();

    let future = use_future(cx, (), |_| {
        to_owned![eval];
        async move {
            // You can receive any message from JavaScript with the recv method
            eval.recv().await.unwrap()
        }
    });

    match future.value() {
        Some(v) => cx.render(rsx!(
            p { "{v}" }
        )),
        _ => cx.render(rsx!(
            p { "hello" }
        )),
    }
}

````

## Custom Assets

You can link to local assets in dioxus desktop instead of using a url:

````rs@custom_assets.rs
use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            img { src: "examples/assets/logo.png" }
        }
    })
}

````

## Integrating with Wry

In cases where you need more low level control over your window, you can use wry APIs exposed through the [Desktop Config](https://docs.rs/dioxus-desktop/0.3.0/dioxus_desktop/struct.Config.html) and the [use_window hook](https://docs.rs/dioxus-desktop/0.4.0/dioxus_desktop/fn.use_window.html)
# Web

This guide will cover concepts specific to the Dioxus web renderer.

## Running Javascript

Dioxus provides some ergonomic wrappers over the browser API, but in some cases you may need to access parts of the browser API Dioxus does not expose.

For these cases, Dioxus desktop exposes the use_eval hook that allows you to run raw Javascript in the webview:

````rs@eval.rs
use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -> Element {
    // Use eval returns a function that can spawn eval instances
    let create_eval = use_eval(cx);

    // You can create as many eval instances as you want
    let mut eval = create_eval(
        r#"
        // You can send messages from JavaScript to Rust with the dioxus.send function
        dioxus.send("Hi from JS!");
        // You can receive messages from Rust to JavaScript with the dioxus.recv function
        let msg = await dioxus.recv();
        console.log(msg);
        "#,
    )
    .unwrap();

    // You can send messages to JavaScript with the send method
    eval.send("Hi from Rust!".into()).unwrap();

    let future = use_future(cx, (), |_| {
        to_owned![eval];
        async move {
            // You can receive any message from JavaScript with the recv method
            eval.recv().await.unwrap()
        }
    });

    match future.value() {
        Some(v) => cx.render(rsx!(
            p { "{v}" }
        )),
        _ => cx.render(rsx!(
            p { "hello" }
        )),
    }
}

````

If you are targeting web, but don't plan on targeting any other Dioxus renderer you can also use the generated wrappers in the [web-sys](https://rustwasm.github.io/wasm-bindgen/web-sys/index.html) and [gloo](https://gloo-rs.web.app/) crates.

## Customizing Index Template

Dioxus supports providing custom index.html templates. The index.html must include a `div` with the id `main` to be used. Hot Reload is still supported. An example
is provided in the [PWA-Example](https://github.com/DioxusLabs/Dioxus/examples/PWA-example/index.html).
# Server-Side Rendering

For lower-level control over the rendering process, you can use the `dioxus-ssr` crate directly. This can be useful when integrating with a web framework that `dioxus-fullstack` does not support, or pre-rendering pages.

## Setup

For this guide, we're going to show how to use Dioxus SSR with [Axum](https://docs.rs/axum/latest/axum/).

Make sure you have Rust and Cargo installed, and then create a new project:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the ssr renderer as dependencies:

````shell
cargo add dioxus
cargo add dioxus-ssr
````

Next, add all the Axum dependencies. This will be different if you're using a different Web Framework

````
cargo add tokio --features full
cargo add axum
````

Your dependencies should look roughly like this:

````toml
[dependencies]
axum = "0.4.5"
dioxus = { version = "*" }
dioxus-ssr = { version = "*" }
tokio = { version = "1.15.0", features = ["full"] }
````

Now, set up your Axum app to respond on an endpoint.

````rust
use axum::{response::Html, routing::get, Router};
use dioxus::prelude::*;

#[tokio::main]
async fn main() {
	let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 3000));
	println!("listening on http://{}", addr);

	axum::Server::bind(&addr)
		.serve(
			Router::new()
				.route("/", get(app_endpoint))
				.into_make_service(),
		)
		.await
		.unwrap();
}
````

And then add our endpoint. We can either render `rsx!` directly:

````rust
async fn app_endpoint() -> Html<String> {
	// render the rsx! macro to HTML
	Html(dioxus_ssr::render_lazy(rsx! {
		div { "hello world!" }
	}))
}
````

Or we can render VirtualDoms.

````rust
async fn app_endpoint() -> Html<String> {
	// create a component that renders a div with the text "hello world"
	fn app(cx: Scope) -> Element {
		cx.render(rsx!(div { "hello world" }))
	}
	// create a VirtualDom with the app component
	let mut app = VirtualDom::new(app);
	// rebuild the VirtualDom before rendering
	let _ = app.rebuild();

	// render the VirtualDom to HTML
	Html(dioxus_ssr::render_vdom(&app))
}
````

## Multithreaded Support

The Dioxus VirtualDom, sadly, is not currently `Send`. Internally, we use quite a bit of interior mutability which is not thread-safe.
When working with web frameworks that require `Send`, it is possible to render a VirtualDom immediately to a String â€“ but you cannot hold the VirtualDom across an await point. For retained-state SSR (essentially LiveView), you'll need to spawn a VirtualDom on its own thread and communicate with it via channels or create a pool of VirtualDoms.
You might notice that you cannot hold the VirtualDom across an await point. Because Dioxus is currently not ThreadSafe, it *must* remain on the thread it started. We are working on loosening this requirement.
# Liveview

This guide will cover concepts specific to the Dioxus liveview renderer.

## Router Integration

Currently, the Dioxus router does not integrate with the browser history in the liveview renderer. If you are interested in contributing this feature to Dioxus this issue is tracked [here](https://github.com/DioxusLabs/dioxus/issues/1038).

## Managing Latency

Liveview makes it incredibly convenient to talk to your server from the client, but there are some downsides. Mainly in Dioxus Liveview every interaction goes through the server by default.

Because of this, with the liveview renderer you need to be very deliberate about managing latency. Events that would be fast enough on other renderers like [controlled inputs](../reference/user_input.md), can be frustrating to use in the liveview renderer.

To get around this issue you can inject bits of javascript in your liveview application. If you use a raw attribute as a listener, you can inject some javascript that will be run when the event is triggered:

````rust
render! {
    div {
        input {
            "oninput": "console.log('input changed!')"
        }
    }
}
````
# Fullstack development

Dioxus Fullstack contains helpers for:

* Incremental, static, and server side rendering
* Hydrating your application on the Client
* Communicating between a server and a client

This guide will teach you everything you need to know about how to use the utilities in Dioxus fullstack to create amazing fullstack applications.

 > 
 > In addition to this guide, you can find more examples of full-stack apps and information about how to integrate with other frameworks and desktop renderers in the [dioxus-fullstack examples directory](https://github.com/DioxusLabs/dioxus/tree/master/packages/fullstack/examples).
# Communicating with the server

`dioxus-fullstack` provides server functions that allow you to call an automatically generated API on the server from the client as if it were a local function.

To make a server function, simply add the `#[server(YourUniqueType)]` attribute to a function. The function must:

* Be an async function
* Have arguments and a return type that both implement serialize and deserialize (with [serde](https://serde.rs/)).
* Return a `Result` with an error type of ServerFnError

You must call `register` on the type you passed into the server macro in your main function before starting your server to tell Dioxus about the server function.

Let's continue building on the app we made in the [getting started](../../getting_started/fullstack.md) guide. We will add a server function to our app that allows us to double the count on the server.

First, add serde as a dependency:

````shell
cargo add serde
````

Next, add the server function to your `main.rs`:

````rs@server_function.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;

fn main() {
    let config = LaunchBuilder::new(App);
    #[cfg(feature = "ssr")]
    let config = config.incremental(
        IncrementalRendererConfig::default().invalidate_after(std::time::Duration::from_secs(120)),
    );

    config.launch();
}

fn App(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
        button {
            onclick: move |_| {
                to_owned![count];
                async move {
                    // Call the server function just like a local async function
                    if let Ok(new_count) = double_server(*count.current()).await {
                        count.set(new_count);
                    }
                }
            },
            "Double"
        }
    })
}

#[server]
async fn double_server(number: i32) -> Result<i32, ServerFnError> {
    // Perform some expensive computation or access a database on the server
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    let result = number * 2;
    println!("server calculated {result}");
    Ok(result)
}

````

Now, build your client-side bundle with `dx build --features web` and run your server with `cargo run --features ssr`. You should see a new button that multiplies the count by 2.

## Cached data fetching

One common use case for server functions is fetching data from the server:

````rs@server_data_fetch.rs
#![allow(non_snake_case, unused)]

use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;

fn main() {
    LaunchBuilder::new(app).launch();
}

fn app(cx: Scope) -> Element {
    let mut count = use_future(cx, (), |_| async { get_server_data().await });

    cx.render(rsx! {
        "server data is {count.value():?}"
    })
}

#[server]
async fn get_server_data() -> Result<String, ServerFnError> {
    // Access a database
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    Ok("Hello from the server!".to_string())
}

````

If you navigate to the site above, you will first see `server data is None`, then after the `WASM` has loaded and the request to the server has finished, you will see `server data is Some(Ok("Hello from the server!"))`.

This approach works, but it can be slow. Instead of waiting for the client to load and send a request to the server, what if we could get all of the data we needed for the page on the server and send it down to the client with the initial HTML page?

This is exactly what the `use_server_future` hook allows us to do! `use_server_future` is similar to the `use_future` hook, but it allows you to wait for a future on the server and send the result of the future down to the client.

Let's change our data fetching to use `use_server_future`:

````rs@server_data_prefetch.rs
#![allow(non_snake_case, unused)]

use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;

fn main() {
    LaunchBuilder::new(app).launch();
}

fn app(cx: Scope) -> Element {
    let mut count = use_server_future(cx, (), |_| async { get_server_data().await })?;

    cx.render(rsx! {
        "server data is {count.value():?}"
    })
}

#[server]
async fn get_server_data() -> Result<String, ServerFnError> {
    // Access a database
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    Ok("Hello from the server!".to_string())
}

````

 > 
 > Notice the `?` after `use_server_future`. This is what tells Dioxus fullstack to wait for the future to resolve before continuing rendering. If you want to not wait for a specific future, you can just remove the ? and deal with the `Option` manually.

Now when you load the page, you should see `server data is Ok("Hello from the server!")`. No need to wait for the `WASM` to load or wait for the request to finish!

````inject-dioxus
SandBoxFrame {
	url: "https://codesandbox.io/p/sandbox/dioxus-fullstack-server-future-qwpp4p?file=/src/main.rs:3,24"
}
````

## Running the client with dioxus-desktop

The project presented so far makes a web browser interact with the server, but it is also possible to make a desktop program interact with the server in a similar fashion. (The full example code is available in the [Dioxus repo](https://github.com/DioxusLabs/dioxus/tree/master/packages/fullstack/examples/axum-desktop))

First, we need to make two binary targets, one for the desktop program (the `client.rs` file), one for the server (the `server.rs` file). The client app and the server functions are written in a shared `lib.rs` file.

The desktop and server targets have slightly different build configuration to enable additional dependencies or features.
The Cargo.toml in the full example has more information, but the main points are:

* the client.rs has to be run with the `desktop` feature, so that the optional `dioxus-desktop` dependency is included
* the server.rs has to be run with the `ssr` features; this will generate the server part of the server functions and will include the `axum` dependency to run as a server.

Once you create your project, you can run the server executable with:

````bash
cargo run --bin server --features ssr
````

and the client desktop executable with:

````bash
cargo run --bin client --features desktop
````

### Client code

The client file is pretty straightforward. You only need to set the server url in the client code, so it knows where to send the network requests. Then, dioxus_desktop launches the app.

For development, the example project runs the server on `localhost:8080`. **Before you release remember to update the url to your production url.**

### Server code

In the server code, first you have to set the network address and port where the server will listen to.

````rs@server_function_desktop_client.rs
let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 8080));
````

Then, you have to register the types declared in the server function macros into the axum server.
For example, consider this server function:

````rs@server_function_desktop_client.rs
#[server(GetServerData)]
async fn get_server_data() -> Result<String, ServerFnError> {
    Ok("Hello from the server!".to_string())
}
````

The `GetServerData` type has to be registered in the axum server, which will add the corresponding route to the server.

````rs@server_function_desktop_client.rs
let _ = GetServerData::register_explicit();
````

Finally, the server is started and it begins responding to requests.
# Extractors

Server functions are an ergonomic way to call a function on the server. Server function work by registering an endpoint on the server and using requests on the client. Most of the time, you shouldn't need to worry about how server functions operate, but there are some times when you need to get some value from the request other than the data passed in the server function.

For example, requests contain information about the user's browser (called the [user agent](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent)). We can use an extractor to retrieve that information.

You can use the `extract` method within a server function to extract something from the request. You can extract any type that implements `FromServerContext` (or when axum is enabled, you can use axum extractors directly):

````rs@server_function_extract.rs
#[server]
pub async fn log_user_agent() -> Result<(), ServerFnError> {
    let axum::TypedHeader(user_agent): axum::TypedHeader<axum::headers::UserAgent> =
        extract().await?;
    log::info!("{:?}", user_agent);
    Ok(())
}
````
# Middleware

Extractors allow you to wrap your server function in some code that changes either the request or the response. Dioxus fullstack integrates with [Tower](https://docs.rs/tower/latest/tower/index.html) to allow you to wrap your server functions in middleware.

You can use the `#[middleware]` attribute to add a layer of middleware to your server function. Let's add a timeout middleware to a server function. This middleware will stop running the server function if it reaches a certain timeout:

````rs@server_function_middleware.rs
#[server]
// Add a timeout middleware to the server function that will return an error if the function takes longer than 1 second to execute
#[middleware(tower_http::timeout::TimeoutLayer::new(std::time::Duration::from_secs(1)))]
pub async fn timeout() -> Result<(), ServerFnError> {
    tokio::time::sleep(std::time::Duration::from_secs(2)).await;
    Ok(())
}
````
# Authentication

You can use [extractors](./extractors.md) to integrate auth with your Fullstack application.

You can create a custom extractors that extracts the auth session from the request. From that auth session, you can check if the user has the required privileges before returning the private data.

A [full auth example](https://github.com/dioxuslabs/dioxus/blob/master/packages/fullstack/examples/axum-auth/src/main.rs) with the complete implementation is available in the fullstack examples.
# Routing

You can easily integrate your fullstack application with a client side router using the `launch_router` macro. The `launch_router` macro works the same as the `launch` macro except it accepts a Router instead of a Component:

````rs@server_router.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;
use dioxus_fullstack::prelude::*;
use serde::{Deserialize, Serialize};

fn main() {
    let config = LaunchBuilder::<FullstackRouterConfig<Route>>::router();
    #[cfg(feature = "ssr")]
    config
        .incremental(
            IncrementalRendererConfig::default()
                .invalidate_after(std::time::Duration::from_secs(120)),
        )
        .launch();

    #[cfg(not(feature = "ssr"))]
    config.launch();
}

#[derive(Clone, Routable, Debug, PartialEq, Serialize, Deserialize)]
enum Route {
    #[route("/")]
    Home {},
    #[route("/blog/:id")]
    Blog { id: i32 },
}

#[component]
fn Blog(cx: Scope, id: i32) -> Element {
    render! {
        Link { to: Route::Home {}, "Go to counter" }
        table {
            tbody {
                for _ in 0..*id {
                    tr {
                        for _ in 0..*id {
                            td { "hello world!" }
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn Home(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);
    let text = use_state(cx, || "...".to_string());

    cx.render(rsx! {
        Link {
            to: Route::Blog {
                id: *count.get()
            },
            "Go to blog"
        }
        div {
            h1 { "High-Five counter: {count}" }
            button { onclick: move |_| count += 1, "Up high!" }
            button { onclick: move |_| count -= 1, "Down low!" }
            button {
                onclick: move |_| {
                    to_owned![text];
                    async move {
                        if let Ok(data) = get_server_data().await {
                            println!("Client received: {}", data);
                            text.set(data.clone());
                            post_server_data(data).await.unwrap();
                        }
                    }
                },
                "Run server function!"
            }
            "Server said: {text}"
        }
    })
}

#[server(PostServerData)]
async fn post_server_data(data: String) -> Result<(), ServerFnError> {
    println!("Server received: {}", data);

    Ok(())
}

#[server(GetServerData)]
async fn get_server_data() -> Result<String, ServerFnError> {
    Ok("Hello from the server!".to_string())
}

````

````inject-dioxus
SandBoxFrame {
	url: "https://codesandbox.io/p/sandbox/dioxus-fullstack-router-s75v5q?file=%2Fsrc%2Fmain.rs%3A7%2C1"
}
````
# Introduction

 > 
 > If you are not familiar with Dioxus itself, check out the [Dioxus guide](../guide/index.md) first.

Whether you are building a website, desktop app, or mobile app, splitting your app's views into "pages" can be an effective method for organization and maintainability.

For this purpose, Dioxus provides a router. Use the `cargo add` command to add the dependency:

````sh
cargo add dioxus-router
````

Then, add this to your `Dioxus.toml` (learn more about configuration [here](../CLI/configure.md)):

````toml
[web.watcher]
index_on_404 = true
````

 > 
 > This configuration only works when using `dx serve`. If you host your app in a different way (which you most likely do in production), you need to find out how to add a fallback 404 page to your app, and make it a copy of the generated `dist/index.html`.

This will instruct `dx serve` to redirect any unknown route to the index, to then be resolved by the router.
The router works on the client. If we connect through the index route (e.g., `localhost:8080`, then click a link to go to `localhost:8080/contact`), the app renders the new route without reloading.
However, when we go to a route *before* going to the index (go straight to `localhost:8080/contact`), we are trying to access a static route from the server, but the only static route on our server is the index (because the Dioxus frontend is a Single Page Application) and it will fail unless we redirect all missing routes to the index.

This book is intended to get you up to speed with Dioxus Router. It is split
into two sections:

1. The [reference](reference/index.md) section explains individual features in
   depth. You can read it from start to finish, or you can read individual chapters
   in whatever order you want.
1. If you prefer a learning-by-doing approach, you can check out the
   *[example project](example/index.md)*. It guides you through
   creating a dioxus app, setting up the router, and using some of its
   functionality.

 > 
 > Please note that this is not the only documentation for the Dioxus Router. You
 > can also check out the [API Docs](https://docs.rs/dioxus-router/).
# Overview

In this guide, you'll learn to effectively use Dioxus Router whether you're
building a small todo app or the next FAANG company. We will create a small
website with a blog, homepage, and more!

 > 
 > To follow along with the router example, you'll need a working Dioxus app.
 > Check out the [Dioxus book](https://dioxuslabs.com/learn/0.4/getting_started) to get started.

 > 
 > Make sure to add Dioxus Router as a dependency, as explained in the
 > [introduction](../index.md).

## You'll learn how to

* Create routes and render "pages".
* Utilize nested routes, create a navigation bar, and render content for a
  set of routes.
* Parse URL parameters to dynamically display content.
* Redirect visitors to different routes.

 > 
 > **Disclaimer**
 > 
 > The example will only display the features of Dioxus Router. It will not
 > include any actual functionality. To keep things simple we will only be using
 > a single file, this is not the recommended way of doing things with a real
 > application.

You can find the complete application in the [full code](full-code.md) chapter.
# Creating Our First Route

In this chapter, we will start utilizing Dioxus Router and add a homepage and a
404 page to our project.

## Fundamentals

The core of the Dioxus Router is the \[`Routable`\] macro and the \[`Router`\] component.

Routable is a trait for anything that can:

* Be parsed from a URL
* Be turned into a URL
* Be rendered as to a Element

Let's create a new router. First, we need an actual page to route to! Let's add a homepage component:

````rs@first_route.rs
#[component]
fn Home(cx: Scope) -> Element {
    render! {
        h1 { "Welcome to the Dioxus Blog!" }
    }
}
````

## Creating Routes

We want to use Dioxus Router to separate our application into different "pages".
Dioxus Router will then determine which page to render based on the URL path.

To start using Dioxus Router, we need to use the \[`Routable`\] macro.

The \[`Routable`\] macro takes an enum with all of the possible routes in our application. Each variant of the enum represents a route and must be annotated with the \[`route(path)`\] attribute.

````rs@first_route.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route("/")]
    // If the name of the component and variant are the same you can omit the component and props name
    // If they are different you can specify them like this:
    // #[route("/", ComponentName, PropsName)]
    Home {},
}
````

All other hooks and components the router provides can only be used as a descendant of a \[`Router`\] component.

If you head to your application's browser tab, you should now see the text
`Welcome to Dioxus Blog!` when on the root URL (`http://localhost:8080/`). If
you enter a different path for the URL, nothing should be displayed.

This is because we told Dioxus Router to render the `Home` component only when
the URL path is `/`.

## Fallback Route

In our example, when a route doesn't exist Dioxus Router doesn't render anything. Many sites also have a "404" page when a path does not exist. Let's add one to our site.

First, we create a new `PageNotFound` component.

````rs@catch_all.rs
#[component]
fn PageNotFound(cx: Scope, route: Vec<String>) -> Element {
    render! {
        h1 { "Page not found" }
        p { "We are terribly sorry, but the page you requested doesn't exist." }
        pre {
            color: "red",
            "log:\nattemped to navigate to: {route:?}"
        }
    }
}
````

Next, register the route in the Route enum to match if all other routes fail.

````rs@catch_all.rs
#[derive(Routable, Clone)]
enum Route {
    #[route("/")]
    Home {},
    // PageNotFound is a catch all route that will match any route and placing the matched segments in the route field
    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}
````

Now when you go to a route that doesn't exist, you should see the page not found
text.

## Conclusion

In this chapter, we learned how to create a route and tell Dioxus Router what
component to render when the URL path is `/`. We also created a 404 page to
handle when a route doesn't exist. Next, we'll create the blog portion of our
site. We will utilize nested routes and URL parameters.
# Building a Nest

In this chapter, we will begin to build the blog portion of our site which will
include links, nested routes, and route parameters.

## Site Navigation

Our site visitors won't know all the available pages and blogs on our site so we
should provide a navigation bar for them. Our navbar will be a list of links going between our pages.

We want our navbar component to be rendered on several different pages on our site. Instead of duplicating the code, we can create a component that wraps all children routes. This is called a layout component. To tell the router where to render the child routes, we use the \[`Outlet`\] component.

Let's create a new `NavBar` component:

````rs@nested_routes.rs
#[component]
fn NavBar(cx: Scope) -> Element {
    render! {
        nav {
            ul {
                li { "links" }
            }
        }
        // The Outlet component will render child routes (In this case just the Home component) inside the Outlet component
        Outlet::<Route> {}
    }
}
````

Next, let's add our `NavBar` component as a layout to our Route enum:

````rs@nested_routes.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // All routes under the NavBar layout will be rendered inside of the NavBar Outlet
    #[layout(NavBar)]
        #[route("/")]
        Home {},
    #[end_layout]
    #[route("/:..route")]
    PageNotFound { route: Vec<String> },
}
````

To add links to our `NavBar`, we could always use an HTML anchor element but that has two issues:

1. It causes a full-page reload
1. We can accidentally link to a page that doesn't exist

Instead, we want to use the [`Link`] component provided by Dioxus Router.

The [`Link`] is similar to a regular `<a>` tag. It takes a target and children.

Unlike a regular `<a>` tag, we can pass in our Route enum as the target. Because we annotated our routes with the \[`route(path)`\] attribute, the [`Link`] will know how to generate the correct URL. If we use the Route enum, the rust compiler will prevent us from linking to a page that doesn't exist.

Let's add our links:

````rs@links.rs
#[component]
fn NavBar(cx: Scope) -> Element {
    render! {
        nav {
            Link {
                // The Link component will navigate to the route specified
                // in the target prop which is checked to exist at compile time
                to: Route::Home {},
                "Home"
            }
        }
        Outlet::<Route> {}
    }
}
````

 > 
 > Using this method, the [`Link`] component only works for links within our
 > application. To learn more about navigation targets see
 > [here](./navigation-targets.md).

Now you should see a list of links near the top of your page. Click on one and
you should seamlessly travel between pages.

## URL Parameters and Nested Routes

Many websites such as GitHub put parameters in their URL. For example,
`https://github.com/DioxusLabs` utilizes the text after the domain to
dynamically search and display content about an organization.

We want to store our blogs in a database and load them as needed. We also
want our users to be able to send people a link to a specific blog post.
Instead of listing all of the blog titles at compile time, we can make a dynamic route.

We could utilize a search page that loads a blog when clicked but then our users
won't be able to share our blogs easily. This is where URL parameters come in.

The path to our blog will look like `/blog/myBlogPage`, `myBlogPage` being the
URL parameter.

First, let's create a layout component (similar to the navbar) that wraps the blog content. This allows us to add a heading that tells the user they are on the blog.

````rs@dynamic_route.rs
#[component]
fn Blog(cx: Scope) -> Element {
    render! {
        h1 { "Blog" }
        Outlet::<Route> {}
    }
}
````

Now we'll create another index component, that'll be displayed when no blog post
is selected:

````rs@dynamic_route.rs
#[component]
fn BlogList(cx: Scope) -> Element {
    render! {
        h2 { "Choose a post" }
        ul {
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 1".into() },
                    "Read the first blog post"
                }
            }
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 2".into() },
                    "Read the second blog post"
                }
            }
        }
    }
}
````

We also need to create a component that displays an actual blog post. This component will accept the URL parameters as props:

````rs@dynamic_route.rs
// The name prop comes from the /:name route segment
#[component]
fn BlogPost(cx: Scope, name: String) -> Element {
    render! {
        h2 { "Blog Post: {name}"}
    }
}
````

Finally, let's tell our router about those components:

````rs@dynamic_route.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
            #[route("/")]
            BlogList {},
            #[route("/post/:name")]
            BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
````

That's it! If you head to `/blog/1` you should see our sample post.

## Conclusion

In this chapter, we utilized Dioxus Router's Link, and Route Parameter
functionality to build the blog portion of our application. In the next chapter,
we will go over how navigation targets (like the one we passed to our links)
work.
# Navigation Targets

In the previous chapter, we learned how to create links to pages within our app.
We told them where to go using the `target` property. This property takes something that can be converted to a [`NavigationTarget`].

## What is a navigation target?

A [`NavigationTarget`] is similar to the `href` of an HTML anchor element. It
tells the router where to navigate to. The Dioxus Router knows two kinds of
navigation targets:

* [`Internal`]: We used internal links in the previous chapter. It's a link to a page within our
  app represented as a Route enum.
* [`External`]: This works exactly like an HTML anchors' `href`. Don't use this for in-app
  navigation as it will trigger a page reload by the browser.

## External navigation

If we need a link to an external page we can do it like this:

````rs@external_link.rs
fn GoToDioxus(cx: Scope) -> Element {
    render! {
        Link {
            to: "https://dioxuslabs.com",
            "ExternalTarget target"
        }
    }
}
````
# Redirection Perfection

You're well on your way to becoming a routing master!

In this chapter, we will cover creating redirects

## Creating Redirects

A redirect is very simple. When dioxus encounters a redirect while finding out
what components to render, it will redirect the user to the target of the
redirect.

As a simple example, let's say you want user to still land on your blog, even
if they used the path `/myblog` or `/myblog/:name`.

Redirects are special attributes in the router enum that accept a route and a closure
with the route parameters. The closure should return a route to redirect to.

Let's add a redirect to our router enum:

````rs@full_example.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
                #[route("/")]
                BlogList {},
                #[route("/post/:name")]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest("/myblog")]
        #[redirect("/", || Route::BlogList {})]
        #[redirect("/:name", |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
````

That's it! Now your users will be redirected to the blog.

### Conclusion

Well done! You've completed the Dioxus Router guide. You've built a small
application and learned about the many things you can do with Dioxus Router.
To continue your journey, you attempt a challenge listed below, look at the [router examples](https://github.com/DioxusLabs/dioxus/tree/master/packages/router/examples), or
can check out the [API reference](https://docs.rs/dioxus-router/).

### Challenges

* Organize your components into separate files for better maintainability.
* Give your app some style if you haven't already.
* Build an about page so your visitors know who you are.
* Add a user system that uses URL parameters.
* Create a simple admin system to create, delete, and edit blogs.
* If you want to go to the max, hook up your application to a rest API and database.
# Full Code

````rs@full_example.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;

// ANCHOR: router
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(NavBar)]
        #[route("/")]
        Home {},
        #[nest("/blog")]
            #[layout(Blog)]
                #[route("/")]
                BlogList {},
                #[route("/post/:name")]
                BlogPost { name: String },
            #[end_layout]
        #[end_nest]
    #[end_layout]
    #[nest("/myblog")]
        #[redirect("/", || Route::BlogList {})]
        #[redirect("/:name", |name: String| Route::BlogPost { name })]
    #[end_nest]
    #[route("/:..route")]
    PageNotFound {
        route: Vec<String>,
    },
}
// ANCHOR_END: router

pub fn App(cx: Scope) -> Element {
    render! {
        Router::<Route> {}
    }
}

#[component]
fn NavBar(cx: Scope) -> Element {
    render! {
        nav {
            ul {
                li { Link { to: Route::Home {}, "Home" } }
                li { Link { to: Route::BlogList {}, "Blog" } }
            }
        }
        Outlet::<Route> {}
    }
}

#[component]
fn Home(cx: Scope) -> Element {
    render! {
        h1 { "Welcome to the Dioxus Blog!" }
    }
}

#[component]
fn Blog(cx: Scope) -> Element {
    render! {
        h1 { "Blog" }
        Outlet::<Route> {}
    }
}

#[component]
fn BlogList(cx: Scope) -> Element {
    render! {
        h2 { "Choose a post" }
        ul {
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 1".into() },
                    "Read the first blog post"
                }
            }
            li {
                Link {
                    to: Route::BlogPost { name: "Blog post 2".into() },
                    "Read the second blog post"
                }
            }
        }
    }
}

#[component]
fn BlogPost(cx: Scope, name: String) -> Element {
    render! {
        h2 { "Blog Post: {name}"}
    }
}

#[component]
fn PageNotFound(cx: Scope, route: Vec<String>) -> Element {
    render! {
        h1 { "Page not found" }
        p { "We are terribly sorry, but the page you requested doesn't exist." }
        pre {
            color: "red",
            "log:\nattemped to navigate to: {route:?}"
        }
    }
}

````
# Adding the router to your application

In this chapter, we will learn how to add the router to our app. By itself, this
is not very useful. However, it is a prerequisite for all the functionality
described in the other chapters.

 > 
 > Make sure you added the `dioxus-router` dependency as explained in the
 > [introduction](../index.md).

In most cases, we want to add the router to the root component of our app. This
way, we can ensure that we have access to all its functionality everywhere.

First, we define the router with the router macro:

````rs@first_route.rs
#![allow(non_snake_case)]
use dioxus::prelude::*;

/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route("/")]
    // If the name of the component and variant are the same you can omit the component and props name
    // If they are different you can specify them like this:
    // #[route("/", ComponentName, PropsName)]
    Home {},
}
````

Then we render the router with the \[`Router`\] component.

````rs@first_route.rs
fn App(cx: Scope) -> Element {
    render! {
        Router::<Route> {}
    }
}
````
# Defining Routes

When creating a \[`Routable`\] enum, we can define routes for our application using the `route("path")` attribute.

## Route Segments

Each route is made up of segments. Most segments are separated by `/` characters in the path.

There are four fundamental types of segments:

1. [Static segments](#static-segments) are fixed strings that must be present in the path.
1. [Dynamic segments](#dynamic-segments) are types that can be parsed from a segment.
1. [Catch-all segments](#catch-all-segments) are types that can be parsed from multiple segments.
1. [Query segments](#query-segments) are types that can be parsed from the query string.

Routes are matched:

* First, from most specific to least specific (Static then Dynamic then Catch All) (Query is always matched)
* Then, if multiple routes match the same path, the order in which they are defined in the enum is followed.

## Static segments

Fixed routes match a specific path. For example, the route `#[route("/about")]` will match the path `/about`.

````rs@static_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // Routes always start with a slash
    #[route("/")]
    Home {},
    // You can have multiple segments in a route
    #[route("/hello/world")]
    HelloWorld {},
}

#[component]
fn Home(cx: Scope) -> Element {
    todo!()
}

#[component]
fn HelloWorld(cx: Scope) -> Element {
    todo!()
}
````

## Dynamic Segments

Dynamic segments are in the form of `:name` where `name` is
the name of the field in the route variant. If the segment is parsed
successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromStr`.

````rs@dynamic_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with : are dynamic segments
    #[route("/post/:name")]
    BlogPost {
        // You must include dynamic segments in child variants
        name: String,
    },

    #[route("/document/:id")]
    Document {
        // You can use any type that implements FromStr
        // If the segment can't be parsed, the route will not match
        id: usize,
    },
}

// Components must contain the same dynamic segments as their corresponding variant
#[component]
fn BlogPost(cx: Scope, name: String) -> Element {
    todo!()
}

#[component]
fn Document(cx: Scope, id: usize) -> Element {
    todo!()
}
````

## Catch All Segments

Catch All segments are in the form of `:..name` where `name` is the name of the field in the route variant. If the segments are parsed successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromSegments`. (`Vec<String>` implements this by default)

Catch All segments must be the *last route segment* in the path (query segments are not counted) and cannot be included in nests.

````rs@catch_all_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with :.. are catch all segments
    #[route("/blog/:..segments")]
    BlogPost {
        // You must include catch all segment in child variants
        segments: Vec<String>,
    },
}

// Components must contain the same catch all segments as their corresponding variant
#[component]
fn BlogPost(cx: Scope, segments: Vec<String>) -> Element {
    todo!()
}
````

## Query Segments

Query segments are in the form of `?:name` where `name` is the name of the field in the route variant.

Unlike [Dynamic Segments](#dynamic-segments) and [Catch All Segments](#catch-all-segments), parsing a Query segment must not fail.

The segment can be of any type that implements `FromQuery`.

Query segments must be the *after all route segments* and cannot be included in nests.

````rs@query_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with ?: are query segments
    #[route("/blog?:query_params")]
    BlogPost {
        // You must include query segments in child variants
        query_params: BlogQuerySegments,
    },
}

#[derive(Debug, Clone, PartialEq)]
struct BlogQuerySegments {
    name: String,
    surname: String,
}

/// The display impl needs to display the query in a way that can be parsed:
impl Display for BlogQuerySegments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "name={}&surname={}", self.name, self.surname)
    }
}

/// The query segment is anything that implements https://docs.rs/dioxus-router/latest/dioxus_router/routable/trait.FromQuery.html. You can implement that trait for a struct if you want to parse multiple query parameters.
impl FromQuery for BlogQuerySegments {
    fn from_query(query: &str) -> Self {
        let mut name = None;
        let mut surname = None;
        let pairs = form_urlencoded::parse(query.as_bytes());
        pairs.for_each(|(key, value)| {
            if key == "name" {
                name = Some(value.clone().into());
            }
            if key == "surname" {
                surname = Some(value.clone().into());
            }
        });
        Self {
            name: name.unwrap(),
            surname: surname.unwrap(),
        }
    }
}

#[component]
fn BlogPost(cx: Scope, query_params: BlogQuerySegments) -> Element {
    render! {
        div{"This is your blogpost with a query segment:"}
        div{format!("{:?}", query_params)}
    }
}

fn App(cx: Scope) -> Element {
    render! { Router::<Route>{} }
}

fn main() {}
````
# Nested Routes

When developing bigger applications we often want to nest routes within each
other. As an example, we might want to organize a settings menu using this
pattern:

````plain
â”” Settings
  â”œ General Settings (displayed when opening the settings)
  â”œ Change Password
  â”” Privacy Settings
````

We might want to map this structure to these paths and components:

````plain
/settings		  -> Settings { GeneralSettings }
/settings/password -> Settings { PWSettings }
/settings/privacy  -> Settings { PrivacySettings }
````

Nested routes allow us to do this without repeating /settings in every route.

## Nesting

To nest routes, we use the `#[nest("path")]` and `#[end_nest]` attributes.

The path in nest must not:

1. Contain a [Catch All Segment](index.md#catch-all-segments)
1. Contain a [Query Segment](index.md#query-segments)

If you define a dynamic segment in a nest, it will be available to all child routes and layouts.

To finish a nest, we use the `#[end_nest]` attribute or the end of the enum.

````rs@nest.rs
#[derive(Routable, Clone)]
// Skipping formatting allows you to indent nests
#[rustfmt::skip]
enum Route {
    // Start the /blog nest
    #[nest("/blog")]
        // You can nest as many times as you want
        #[nest("/:id")]
            #[route("/post")]
            PostId {
                // You must include parent dynamic segments in child variants
                id: usize,
            },
        // End nests manually with #[end_nest]
        #[end_nest]
        #[route("/:id")]
        // The absolute route of BlogPost is /blog/:name
        BlogPost {
            id: usize,
        },
    // Or nests are ended automatically at the end of the enum
}

#[component]
fn BlogPost(cx: Scope, id: usize) -> Element {
    todo!()
}

#[component]
fn PostId(cx: Scope, id: usize) -> Element {
    todo!()
}
````
# Layouts

Layouts allow you to wrap all child routes in a component. This can be useful when creating something like a header that will be used in many different routes.

\[`Outlet`\] tells the router where to render content in layouts. In the following example,
the Index will be rendered within the \[`Outlet`\].

This page is built with Dioxus. It uses Layouts in several different places. Here is an outline of how layouts are used on the current page:

````inject-dioxus
LayoutsExplanation {}
````

Here is a more complete example of a layout wrapping the body of a page.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/")]
        Index {},
}

#[component]
fn Wrapper(cx: Scope) -> Element {
    render! {
        header { "header" }
        // The index route will be rendered here
        Outlet::<Route> { }
        footer { "footer" }
    }
}

#[component]
fn Index(cx: Scope) -> Element {
    render! {
        h1 { "Index" }
    }
}
````

The example above will output the following HTML (line breaks added for
readability):

````html
<header>header</header>
<h1>Index</h1>
<footer>footer</footer>
````

## Layouts with dynamic segments

You can combine layouts with [nested routes](./routes/nested.md) to create dynamic layouts with content that changes based on the current route.

Just like routes, layouts components must accept a prop for each dynamic segment in the route. For example, if you have a route with a dynamic segment like `/:name`, your layout component must accept a `name` prop:

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[nest("/:name")]
        #[layout(Wrapper)]
            #[route("/")]
            Index {
                name: String,
            },
}

#[component]
fn Wrapper(cx: Scope, name: String) -> Element {
    render! {
        header { "Welcome {name}!" }
        // The index route will be rendered here
        Outlet::<Route> { }
        footer { "footer" }
    }
}

#[component]
fn Index(cx: Scope, name: String) -> Element {
    render! {
        h1 { "This is a homepage for {name}" }
    }
}
````

Or to get the full route, you can use the [`use_route`](https://docs.rs/dioxus-router/latest/dioxus_router/hooks/fn.use_route.html) hook.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/:name")]
        Index {
            name: String,
        },
}

#[component]
fn Wrapper(cx: Scope) -> Element {
    let full_route = use_route::<Route>(cx).unwrap();
    render! {
        header { "Welcome to {full_route}!" }
        // The index route will be rendered here
        Outlet::<Route> { }
        footer { "footer" }
    }
}

#[component]
fn Index(cx: Scope, name: String) -> Element {
    render! {
        h1 { "This is a homepage for {name}" }
    }
}
````
# Links & Navigation

When we split our app into pages, we need to provide our users with a way to
navigate between them. On regular web pages, we'd use an anchor element for that,
like this:

````html
<a href="/other">Link to an other page</a>
````

However, we cannot do that when using the router for three reasons:

1. Anchor tags make the browser load a new page from the server. This takes a
   lot of time, and it is much faster to let the router handle the navigation
   client-side.
1. Navigation using anchor tags only works when the app is running inside a
   browser. This means we cannot use them inside apps using Dioxus Desktop.
1. Anchor tags cannot check if the target page exists. This means we cannot
   prevent accidentally linking to non-existent pages.

To solve these problems, the router provides us with a \[`Link`\] component we can
use like this:

````rs@links.rs
#[component]
fn NavBar(cx: Scope) -> Element {
    render! {
        nav {
            Link {
                // The Link component will navigate to the route specified
                // in the target prop which is checked to exist at compile time
                to: Route::Home {},
                "Home"
            }
        }
        Outlet::<Route> {}
    }
}
````

The `target` in the example above is similar to the `href` of a regular anchor
element. However, it tells the router more about what kind of navigation it
should perform. It accepts something that can be converted into a
\[`NavigationTarget`\]:

* The example uses a Internal route. This is the most common type of navigation.
  It tells the router to navigate to a page within our app by passing a variant of a \[`Routable`\] enum. This type of navigation can never fail if the link component is used inside a router component.
* \[`External`\] allows us to navigate to URLs outside of our app. This is useful
  for links to external websites. NavigationTarget::External accepts an URL to navigate to. This type of navigation can fail if the URL is invalid.

 > 
 > The \[`Link`\] accepts several props that modify its behavior. See the API docs
 > for more details.
# Programmatic Navigation

Sometimes we want our application to navigate to another page without having the
user click on a link. This is called programmatic navigation.

## Using a Navigator

We can get a navigator with the \[`use_navigator`\] hook. This hook returns a \[`Navigator`\].

We can use the \[`Navigator`\] to trigger four different kinds of navigation:

* `push` will navigate to the target. It works like a regular anchor tag.
* `replace` works like `push`, except that it replaces the current history entry
  instead of adding a new one. This means the prior page cannot be restored with the browser's back button.
* `Go back` works like the browser's back button.
* `Go forward` works like the browser's forward button.

````rs@navigator.rs
#[component]
fn Home(cx: Scope) -> Element {
    let nav = use_navigator(cx);

    // push
    nav.push(Route::PageNotFound { route: vec![] });

    // replace
    nav.replace(Route::Home {});

    // go back
    nav.go_back();

    // go forward
    nav.go_forward();

    render! {
        h1 { "Welcome to the Dioxus Blog!" }
    }
}
````

You might have noticed that, like \[`Link`\], the \[`Navigator`\]s `push` and
`replace` functions take a \[`NavigationTarget`\]. This means we can use either
\[`Internal`\], or \[`External`\] targets.

## External Navigation Targets

Unlike a \[`Link`\], the \[`Navigator`\] cannot rely on the browser (or webview) to
handle navigation to external targets via a generated anchor element.

This means, that under certain conditions, navigation to external targets can
fail.
# History Providers

\[`HistoryProvider`\]s are used by the router to keep track of the navigation history
and update any external state (e.g. the browser's URL).

The router provides two \[`HistoryProvider`\]s, but you can also create your own.
The two default implementations are:

* The \[`MemoryHistory`\] is a custom implementation that works in memory.
* The \[`WebHistory`\] integrates with the browser's URL.

By default, the router uses the \[`MemoryHistory`\]. It might be changed to use
\[`WebHistory`\] when the `web` feature is active, but that is not guaranteed.

You can override the default history:

````rs@history_provider.rs
#[component]
fn App(cx: Scope) -> Element {
    render! {
        Router::<Route> {
            config: || RouterConfig::default().history(WebHistory::default())
        }
    }
}
````
# History Buttons

Some platforms, like web browsers, provide users with an easy way to navigate
through an app's history. They have UI elements or integrate with the OS.

However, native platforms usually don't provide such amenities, which means that
apps wanting users to have access to them, need to implement them. For this
reason, the router comes with two components, which emulate a browser's back and
forward buttons:

* [`GoBackButton`](https://docs.rs/dioxus-router/latest/dioxus_router/components/fn.GoBackButton.html)
* [`GoForwardButton`](https://docs.rs/dioxus-router/latest/dioxus_router/components/fn.GoForwardButton.html)

 > 
 > If you want to navigate through the history programmatically, take a look at
 > [`programmatic navigation`](./navigation/programmatic.md).

````rs@history_buttons.rs
fn HistoryNavigation(cx: Scope) -> Element {
    render! {
        GoBackButton {
            "Back to the Past"
        }
        GoForwardButton {
            "Back to the Future" /* You see what I did there? ðŸ˜‰ */
        }
    }
}
````

As you might know, browsers usually disable the back and forward buttons if
there is no history to navigate to. The router's history buttons try to do that
too, but depending on the \[history provider\] that might not be possible.

Importantly, neither \[`WebHistory`\] supports that feature.
This is due to limitations of the browser History API.

However, in both cases, the router will just ignore button presses, if there is
no history to navigate to.

Also, when using \[`WebHistory`\], the history buttons might
navigate a user to a history entry outside your app.
# Static Generation

## Getting the Sitemap

The \[`Routable`\] trait includes an associated \[`SITE_MAP`\] constant that contains the map of all of the routes in the enum.

By default, the sitemap is a tree of (static or dynamic) RouteTypes, but it can be flattened into a list of individual routes with the `.flatten()` method.

## Generating a Sitemap

To statically render pages, we need to flatten the route tree and generate a file for each route that contains only static segments:

````rs@static_generation.rs
#![allow(non_snake_case)]

use dioxus::prelude::*;

use dioxus_ssr::incremental::{DefaultRenderer, IncrementalRendererConfig};

#[tokio::main]
async fn main() {
    let mut renderer = IncrementalRendererConfig::new()
        .static_dir("./static")
        .build();

    println!(
        "SITE MAP:\n{}",
        Route::SITE_MAP
            .iter()
            .flat_map(|route| route.flatten().into_iter())
            .map(|route| {
                route
                    .iter()
                    .map(|segment| segment.to_string())
                    .collect::<Vec<_>>()
                    .join("")
            })
            .collect::<Vec<_>>()
            .join("\n")
    );

    pre_cache_static_routes::<Route, _>(
        &mut renderer,
        &DefaultRenderer {
            before_body: r#"<!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width,
            initial-scale=1.0">
            <title>Dioxus Application</title>
        </head>
        <body>"#
                .to_string(),
            after_body: r#"</body>
        </html>"#
                .to_string(),
        },
    )
    .await
    .unwrap();
}

#[component]
fn Blog(cx: Scope) -> Element {
    render! {
        div {
            "Blog"
        }
    }
}

#[component]
fn Post(cx: Scope, id: usize) -> Element {
    render! {
        div {
            "PostId: {id}"
        }
    }
}

#[component]
fn PostHome(cx: Scope) -> Element {
    render! {
        div {
            "Post"
        }
    }
}

#[component]
fn Home(cx: Scope) -> Element {
    render! {
        div {
            "Home"
        }
    }
}

#[rustfmt::skip]
#[derive(Clone, Debug, PartialEq, Routable)]
enum Route {
    #[nest("/blog")]
        #[route("/")]
        Blog {},
        #[route("/post/index")]
        PostHome {},
        #[route("/post/:id")]
        Post {
            id: usize,
        },
    #[end_nest]
    #[route("/")]
    Home {},
}

````

## Example

* [examples/static-hydrated](https://github.com/DioxusLabs/dioxus/tree/master/packages%2Ffullstack%2Fexamples%2Fstatic-hydrated)
# Routing Update Callback

In some cases, we might want to run custom code when the current route changes. For this reason, the \[`RouterConfig`\] exposes an `on_update` field.

## How does the callback behave?

The `on_update` is called whenever the current routing information changes. It is called after the router updated its internal state, but before dependent components and hooks are updated.

If the callback returns a \[`NavigationTarget`\], the router will replace the current location with the specified target. It will not call the `on_update` again.

If at any point the router encounters a navigation failure, it will go to the appropriate state without calling the `on_update`. It doesn't matter if the invalid target initiated the navigation, was found as a redirect target, or was returned by the `on_update` itself.

## Code Example

````rs@routing_update.rs
#[derive(Routable, Clone, PartialEq)]
enum Route {
    #[route("/")]
    Index {},
    #[route("/home")]
    Home {},
}

#[component]
fn Home(cx: Scope) -> Element {
    render! {
        p { "Home" }
    }
}

#[component]
fn Index(cx: Scope) -> Element {
    render! {
        p { "Index" }
    }
}

fn app(cx: Scope) -> Element {
    render! {
        Router::<Route> {
            config: || RouterConfig::default().on_update(|state|{
                (state.current() == Route::Index {}).then_some(
                    NavigationTarget::Internal(Route::Home {})
                )
            })
        }
    }
}
````
# Cookbook

The cookbook contains common recipes for different patterns within Dioxus.

There are a few different sections in the cookbook:

* [Publishing](publishing.md) will teach you how to present your app in a variety of delicious forms.
* Explore the [Anti-patterns](antipatterns.md) section to discover what ingredients to avoid when preparing your application.
* Within [Error Handling](error_handling.md), we'll master the fine art of managing spoiled ingredients in Dioxus.
* Take a culinary journey through [State management](state/index.md), where we'll explore the world of handling local, global, and external state in Dioxus.
* [Integrations](integrations/index.md) will guide you how to seamlessly blend external libraries into your Dioxus culinary creations.
* [Testing](testing.md) explains how to examine the unique flavor of Dioxus-specific features, like components.
* [Examples](examples.md) is a curated list of delightful recipes that demonstrate the various ways of using Dioxus ingredients.
* [Tailwind](tailwind.md) reveals the secrets of combining your Tailwind and Dioxus ingredients into a complete meal. You will also learn about using other NPM ingredients (packages) with Dioxus.
* In the [Custom Renderer](custom_renderer.md) section, we embark on a cooking adventure, inventing new ways to cook with Dioxus!
* [Optimizing](optimizing.md) will show you how to maximize the quality of your ingredients.
# Publishing

After you have build your application, you will need to publish it somewhere. This reference will outline different methods of publishing your desktop or web application.

## Web: Publishing with GitHub Pages

Edit your `Dioxus.toml` to point your `out_dir` to the `docs` folder and the `base_path` to the name of your repo:

````toml
[application]
# ...
out_dir = "docs"

[web.app]
base_path = "your_repo"
````

Then build your app and publish it to Github:

* Make sure GitHub Pages is set up for your repo to publish any static files in the docs directory
* Build your app with:

````sh
dx build --release
````

* Add and commit with git
* Push to GitHub

## Desktop: Creating an installer

Dioxus desktop app uses your operating system's WebView library, so it's portable to be distributed for other platforms.

In this section, we'll cover how to bundle your app for macOS, Windows, and Linux.

## Preparing your application for bundling

Depending on your platform, you may need to add some additional code to your `main.rs` file to make sure your app is ready for bundling. On Windows, you'll need to add the `#![windows_subsystem = "windows"]` attribute to your `main.rs` file to hide the terminal window that pops up when you run your app. **If you're developing on Windows, only use this when bundling.** It will disable the terminal, so you will not get logs of any kind. You can gate it behind a feature, like so:

````toml
# Cargo.toml
[features]
bundle = []
````

And then your `main.rs`:

````rust
#![cfg_attr(feature = "bundle", windows_subsystem = "windows")]
````

## Install `dioxus CLI`

The first thing we'll do is install the [dioxus-cli](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli). This extension to cargo will make it very easy to package our app for the various platforms.

To install, simply run

`cargo install dioxus-cli`

## Building

To bundle your application you can simply run `dx bundle --release` (also add `--features bundle` if you're using that, see the [this](#preparing-your-application-for-bundling) for more) to produce a final app with all the optimizations and assets builtin.

Once you've ran the command, your app should be accessible in `dist/bundle/`.

For example, a macOS app would look like this:

![Published App](/assets/static/publish.png)

Nice! And it's only 4.8 Mb â€“ extremely lean!! Because Dioxus leverages your platform's native WebView, Dioxus apps are extremely memory efficient and won't waste your battery.

 > 
 > Note: not all CSS works the same on all platforms. Make sure to view your app's CSS on each platform â€“ or web browser (Firefox, Chrome, Safari) before publishing.
# Antipatterns

This example shows what not to do and provides a reason why a given pattern is considered an "AntiPattern". Most anti-patterns are considered wrong for performance or code re-usability reasons.

## Unnecessarily Nested Fragments

Fragments don't mount a physical element to the DOM immediately, so Dioxus must recurse into its children to find a physical DOM node. This process is called "normalization". This means that deeply nested fragments make Dioxus perform unnecessary work. Prefer one or two levels of fragments / nested components until presenting a true DOM element.

Only Component and Fragment nodes are susceptible to this issue. Dioxus mitigates this with components by providing an API for registering shared state without the Context Provider pattern.

````rs@anti_patterns.rs
// âŒ Don't unnecessarily nest fragments
let _ = cx.render(rsx!(
    Fragment {
        Fragment {
            Fragment {
                Fragment {
                    Fragment {
                        div { "Finally have a real node!" }
                    }
                }
            }
        }
    }
));

// âœ… Render shallow structures
cx.render(rsx!(
    div { "Finally have a real node!" }
))
````

## Incorrect Iterator Keys

As described in the [dynamic rendering chapter](../reference/dynamic_rendering.md#the-key-attribute), list items must have unique keys that are associated with the same items across renders. This helps Dioxus associate state with the contained components and ensures good diffing performance. Do not omit keys, unless you know that the list will never change.

````rs@anti_patterns.rs
let data: &HashMap<_, _> = &cx.props.data;

// âŒ No keys
cx.render(rsx! {
    ul {
        data.values().map(|value| rsx!(
            li { "List item: {value}" }
        ))
    }
});

// âŒ Using index as keys
cx.render(rsx! {
    ul {
        cx.props.data.values().enumerate().map(|(index, value)| rsx!(
            li { key: "{index}", "List item: {value}" }
        ))
    }
});

// âœ… Using unique IDs as keys:
cx.render(rsx! {
    ul {
        cx.props.data.iter().map(|(key, value)| rsx!(
            li { key: "{key}", "List item: {value}" }
        ))
    }
})
````

## Avoid Interior Mutability in Props

While it is technically acceptable to have a `Mutex` or a `RwLock` in the props, they will be difficult to use.

Suppose you have a struct `User` containing the field `username: String`. If you pass a `Mutex<User>` prop to a `UserComponent` component, that component may wish to pass the username as a `&str` prop to a child component. However, it cannot pass that borrowed field down, since it only would live as long as the `Mutex`'s lock, which belongs to the `UserComponent` function. Therefore, the component will be forced to clone the `username` field.

## Avoid Updating State During Render

Every time you update the state, Dioxus needs to re-render the component â€“ this is inefficient! Consider refactoring your code to avoid this.

Also, if you unconditionally update the state during render, it will be re-rendered in an infinite loop.
# Error handling

A selling point of Rust for web development is the reliability of always knowing where errors can occur and being forced to handle them

However, we haven't talked about error handling at all in this guide! In this chapter, we'll cover some strategies in handling errors to ensure your app never crashes.

## The simplest â€“ returning None

Astute observers might have noticed that `Element` is actually a type alias for `Option<VNode>`. You don't need to know what a `VNode` is, but it's important to recognize that we could actually return nothing at all:

````rust
fn App(cx: Scope) -> Element {
	None
}
````

This lets us add in some syntactic sugar for operations we think *shouldn't* fail, but we're still not confident enough to "unwrap" on.

 > 
 > The nature of `Option<VNode>` might change in the future as the `try` trait gets upgraded.

````rust
fn App(cx: Scope) -> Element {
	// immediately return "None"
	let name = cx.use_hook(|_| Some("hi"))?;
}
````

## Early return on result

Because Rust can't accept both Options and Results with the existing try infrastructure, you'll need to manually handle Results. This can be done by converting them into Options or by explicitly handling them.

````rust
fn App(cx: Scope) -> Element {
	// Convert Result to Option
	let name = cx.use_hook(|_| "1.234").parse().ok()?;


	// Early return
	let count = cx.use_hook(|_| "1.234");
	let val = match count.parse() {
		Ok(val) => val
		Err(err) => return cx.render(rsx!{ "Parsing failed" })
	};
}
````

Notice that while hooks in Dioxus do not like being called in conditionals or loops, they *are* okay with early returns. Returning an error state early is a completely valid way of handling errors.

## Match results

The next "best" way of handling errors in Dioxus is to match on the error locally. This is the most robust way of handling errors, though it doesn't scale to architectures beyond a single component.

To do this, we simply have an error state built into our component:

````rust
let err = use_state(cx, || None);
````

Whenever we perform an action that generates an error, we'll set that error state. We can then match on the error in a number of ways (early return, return Element, etc).

````rust
fn Commandline(cx: Scope) -> Element {
	let error = use_state(cx, || None);

	cx.render(match *error {
		Some(error) => rsx!(
			h1 { "An error occurred" }
		)
		None => rsx!(
			input {
				oninput: move |_| error.set(Some("bad thing happened!")),
			}
		)
	})
}
````

## Passing error states through components

If you're dealing with a handful of components with minimal nesting, you can just pass the error handle into child components.

````rust
fn Commandline(cx: Scope) -> Element {
	let error = use_state(cx, || None);

	if let Some(error) = **error {
		return cx.render(rsx!{ "An error occurred" });
	}

	cx.render(rsx!{
		Child { error: error.clone() }
		Child { error: error.clone() }
		Child { error: error.clone() }
		Child { error: error.clone() }
	})
}
````

Much like before, our child components can manually set the error during their own actions. The advantage to this pattern is that we can easily isolate error states to a few components at a time, making our app more predictable and robust.

## Going global

A strategy for handling cascaded errors in larger apps is through signaling an error using global state. This particular pattern involves creating an "error" context, and then setting it wherever relevant. This particular method is not as "sophisticated" as React's error boundary, but it is more fitting for Rust.

To get started, consider using a built-in hook like `use_context` and `use_context_provider` or Fermi. Of course, it's pretty easy to roll your own hook too.

At the "top" of our architecture, we're going to want to explicitly declare a value that could be an error.

````rust
enum InputError {
	None,
	TooLong,
	TooShort,
}

static INPUT_ERROR: Atom<InputError> = |_| InputError::None;
````

Then, in our top level component, we want to explicitly handle the possible error state for this part of the tree.

````rust
fn TopLevel(cx: Scope) -> Element {
	let error = use_read(cx, INPUT_ERROR);

	match error {
		TooLong => return cx.render(rsx!{ "FAILED: Too long!" }),
		TooShort => return cx.render(rsx!{ "FAILED: Too Short!" }),
		_ => {}
	}
}
````

Now, whenever a downstream component has an error in its actions, it can simply just set its own error state:

````rust
fn Commandline(cx: Scope) -> Element {
	let set_error = use_set(cx, INPUT_ERROR);

	cx.render(rsx!{
		input {
			oninput: move |evt| {
				if evt.value.len() > 20 {
					set_error(InputError::TooLong);
				}
			}
		}
	})
}
````

This approach to error handling is best in apps that have "well defined" error states. Consider using a crate like `thiserror` or `anyhow` to simplify the generation of the error types.

This pattern is widely popular in many contexts and is particularly helpful whenever your code generates a non-recoverable error. You can gracefully capture these "global" error states without panicking or mucking up state.
This section of the guide provides getting started guides for common tools used with Dioxus.

* [Logging](./logging.md)
* [Internationalization](./internationalization.md)
# Logging

Dioxus has a wide range of supported platforms, each with their own logging requirements. We'll discuss the different options available to you.

#### The Log Crate

The [Log](https://crates.io/crates/log) crate is the most universally recognized logging facade in Rust. It is also the easiest to work with in Dioxus; therefore we will be focusing on loggers that work with this crate.

The log crate provides a variety of simple `println`-like macros with varying levels of severity.
The available macros are as follows with the highest severity on the bottom:

````rs
fn main() {
    log::trace!("trace");
    log::debug!("debug");
    log::info!("info");
    log::warn!("warn");
    log::error!("error");
}
````

All the loggers provided on this page are, besides configuration and initialization, interfaced using these macros. Often you will also utilize the log crate's `LevelFilter` enum. This enum usually represents the lowest log severity you want your application to emit and can be loaded from a configuration file, environment variable, or other.

For more information, visit log crate's [docs](https://docs.rs/log/latest/log/).

## Dioxus Logger

[Dioxus Logger](https://crates.io/crates/dioxus-logger) is a planned-to-be feature-rich logger that supports all of Dioxus' platforms. Currently only Desktop, Web, and any server-based targets work with Dioxus Logger.

The easiest way to use Dioxus Logger is by calling the `init()` function:

````rs
use log::LevelFilter;

fn main() {
    // Init logger
    dioxus_logger::init(LevelFilter::Info).expect("failed to init logger");
    // Dioxus code
}
````

The `dioxus_logger::init()` function initializes Dioxus Logger with the log crate using the default configuration and provided `LevelFilter`.

#### Custom Format

Dioxus Logger allows you more control with the ability to set a custom format using the `new` function on the `DioxusLogger` struct:

````rs
use log::LevelFilter;

fn main() {
    // Init logger
    dioxus_logger::DioxusLogger::new(LevelFilter::Info)
        .use_format("[{LEVEL}] {PATH} - {ARGS}")
        .build()
        .expect("failed to init logger");

    // Dioxus code
}
````

In this example, we are building a new `DioxusLogger` struct, providing the `LevelFilter`, calling the `use_format()` function, and initializing the logger with the `build()` function (acts as `init()` in the previous example).

The key function call in this example is `use_format()`. This function takes a `&str` that specifies how you want your logs to be formatted. To specify a variable in the format, you wrap it's name in `{}`.

The available variables are:

* LEVEL     - The `LevelFilter` of the emitted log.
* PATH      - The file path of where the log was emitted, or the crate name.
* ARGS      - The arguments passed through the log macro.
* TIMESTAMP - A timestamp of when the log was emitted. (Requires `timestamps` feature)

#### Timestamps

Another feature of Dioxus Logger is the ability to include timestamps with your logs. By default, this feature is disabled and has to be enabled by adding `timestamps` to your features section of the `dioxus-logger` dependency:

````toml
dioxus-logger = { version = "*", features = ["timestamps"] }
````

By enabling this feature, you gain access to the `TIMESTAMP` format variable.

#### Dioxus Logger Platform Intricacies

On web, Dioxus Logger will use [web-sys](https://crates.io/crates/web-sys) to interact with `console.log()` to output your logs to the browser's console. On Desktop and server-based targets, Dioxus Logger will output using `println()`.

#### Final Notes

Dioxus Logger is the preferred logger to use with Dioxus if it suites your needs. There are many more features to come and Dioxus Logger is planned to become an integral part of Dioxus. If there are any feature suggestions or issues with Dioxus Logger, feel free to reach out on the [Dioxus Discord Server](https://discord.gg/XgGxMSkvUM)!

For more information, visit Dioxus Logger's [docs](https://docs.rs/dioxus-logger/latest/dioxus_logger/).

## Desktop and Server

For Dioxus' desktop and server targets, you can generally use the logger of your choice.

Some popular options are:

* [env_logger](https://crates.io/crates/env_logger)
* [simple_logger](https://crates.io/crates/simple_logger)
* [pretty_env_logger](https://crates.io/crates/pretty_env_logger)

To keep this guide short, we will not be covering the usage of these loggers.

For a full list of popular log-based logging crates, visit [this](https://docs.rs/log/latest/log/#available-logging-implementations) list in the log crate's docs.

## Web

[WASM Logger](https://crates.io/crates/wasm-logger) is a logging interface that can be used with Dioxus' web platform.

The easiest way to use WASM Logger is with the `init` function:

````rs
fn main() {
    // Init logger
    wasm_logger::init(wasm_logger::Config::default());

    // Dioxus code
}
````

This starts WASM Logger with a `LevelFilter` of `Debug`.

To specify a custom `LevelFilter`, build the `Config` struct:

````rs
use log::LevelFilter;

fn main() {
    // Init logger
    let log_config = wasm_logger::Config::new(LevelFilter::Info);
    wasm_logger::init(log_config);

    // Dioxus code
}
````

#### Wasm Logger Platform Intricacies

WASM Logger also uses the [web-sys](https://crates.io/crates/web-sys) crate to output to the console.

For more information, visit wasm-logger's [docs](https://docs.rs/wasm-logger/latest/wasm_logger/).

## Android

[Android Logger](https://crates.io/crates/android_logger) is a logging interface that can be used when targeting Android. Android Logger runs whenever an event `native_activity_create` is called by the Android system:

````rs
use log::LevelFilter;
use android_logger::Config;

fn native_activity_create() {
    android_logger::init_once(
        Config::default()
            .with_max_level(LevelFilter::Info)
            .with_tag("myapp");
    );
}
````

The `with_tag()` is what your app's logs will show as.

#### Viewing Android Logs

Android logs are sent to logcat. To use logcat through the Android debugger, run:

````cmd
adb -d logcat
````

Your Android device will need developer options/usb debugging enabled.

For more information, visit android_logger's [docs](https://docs.rs/android_logger/latest/android_logger/).

## iOS

The current option for iOS is the [oslog](https://crates.io/crates/oslog) crate.

````rs
fn main() {
    // Init logger
    OsLogger::new("com.example.test")
        .level_filter(LevelFilter::Debug)
        .init()
        .expect("failed to init logger");
    // Dioxus code
}
````

#### Viewing IOS Logs

You can view the emitted logs in Xcode.

For more information, visit [oslog](https://crates.io/crates/oslog).
# Internationalization

If your application supports multiple languages, the [Dioxus SDK](https://github.com/DioxusLabs/sdk) crate contains helpers to make working with translations in your application easier.

## The full code for internationalization

````rs@i18n.rs
use dioxus::prelude::*;
use dioxus_std::i18n::*;
use dioxus_std::translate;
use std::str::FromStr;

fn main() {
    dioxus_web::launch(app);
}

static EN_US: &str = r#"{
    "id": "en-US",
    "texts": {
        "messages": {
            "hello_world": "Hello World!"
        },
        "messages.hello": "Hello {name}"
    }
}"#;
static ES_ES: &str = r#"{
    "id": "es-ES",
    "texts": {
        "messages": {
            "hello_world": "Hola Mundo!"
        },
        "messages.hello": "Hola {name}"
    }
}"#;

#[allow(non_snake_case)]
fn Body(cx: Scope) -> Element {
    let i18 = use_i18(cx);

    let change_to_english = move |_| i18.set_language("en-US".parse().unwrap());
    let change_to_spanish = move |_| i18.set_language("es-ES".parse().unwrap());

    render!(
        button {
            onclick: change_to_english,
            label {
                "English"
            }
        }
        button {
            onclick: change_to_spanish,
            label {
                "Spanish"
            }
        }
        p { translate!(i18, "messages.hello_world") }
        p { translate!(i18, "messages.hello", name: "Dioxus")  }
    )
}

fn app(cx: Scope) -> Element {
    use_init_i18n(
        cx,
        "en-US".parse().unwrap(),
        "en-US".parse().unwrap(),
        || {
            let en_us = Language::from_str(EN_US).unwrap();
            let es_es = Language::from_str(ES_ES).unwrap();
            vec![en_us, es_es]
        },
    );

    render!(Body {})
}

````
# State Cookbook

* [External State](external/index.md)
* [Custom Hook](custom_hooks/index.md)
# Working with External State

This guide will help you integrate your Dioxus application with some external state like a different thread or a websocket connection.

## Working with non-reactive State

[Coroutines](../../../reference/use_coroutine.md) are great tool for dealing with non-reactive (state you don't render directly) state within your application.

You can store your state inside the coroutine async block and communicate with the coroutine with messages from any child components.

````rs@use_coroutine.rs
// import futures::StreamExt to use the next() method
use futures::StreamExt;
let response_state = use_state(cx, || None);
let tx = use_coroutine(cx, |mut rx| {
    to_owned![response_state];
    async move {
        // Define your state before the loop
        let mut state = reqwest::Client::new();
        let mut cache: HashMap<String, String> = HashMap::new();
        loop {
            // Loop and wait for the next message
            if let Some(request) = rx.next().await {
                // Resolve the message
                let response = if let Some(response) = cache.get(&request) {
                    response.clone()
                } else {
                    let response = state
                        .get(&request)
                        .send()
                        .await
                        .unwrap()
                        .text()
                        .await
                        .unwrap();
                    cache.insert(request, response.clone());
                    response
                };
                response_state.set(Some(response));
            } else {
                break;
            }
        }
    }
});
// Send a message to the coroutine
tx.send("https://example.com".to_string());
// Get the current state of the coroutine
let response = response_state.get();
````

## Making Reactive State External

If you have some reactive state (state that is rendered), that you want to modify from another thread, you can use the [use_rw](https://github.com/DioxusLabs/dioxus-std/blob/master/src/utils/rw/use_rw.rs) hook in the [dioxus-std](https://github.com/DioxusLabs/dioxus-std) crate.

The use_rw hook works like the use_ref hook, but it is Send + Sync which makes it possible to move the hook into another thread.
# Custom Hooks

Hooks are a great way to encapsulate business logic. If none of the existing hooks work for your problem, you can write your own.

When writing your hook, you can make a function that accepts `cx: &ScopeState` as a parameter to accept a scope with any Props.

## Composing Hooks

To avoid repetition, you can encapsulate business logic based on existing hooks to create a new hook.

For example, if many components need to access an `AppSettings` struct, you can create a "shortcut" hook:

````rs@hooks_composed.rs
fn use_settings(cx: &ScopeState) -> &UseSharedState<AppSettings> {
    use_shared_state::<AppSettings>(cx).expect("App settings not provided")
}
````

Or if you want to wrap a hook that persists reloads with the storage API, you can build on top of the use_ref hook to work with mutable state:

````rs@hooks_composed.rs
use gloo_storage::{LocalStorage, Storage};
use serde::{de::DeserializeOwned, Serialize};

/// A persistent storage hook that can be used to store data across application reloads.
#[allow(clippy::needless_return)]
pub fn use_persistent<T: Serialize + DeserializeOwned + Default + 'static>(
    cx: &ScopeState,
    // A unique key for the storage entry
    key: impl ToString,
    // A function that returns the initial value if the storage entry is empty
    init: impl FnOnce() -> T,
) -> &UsePersistent<T> {
    // Use the use_ref hook to create a mutable state for the storage entry
    let state = use_ref(cx, move || {
        // This closure will run when the hook is created
        let key = key.to_string();
        let value = LocalStorage::get(key.as_str()).ok().unwrap_or_else(init);
        StorageEntry { key, value }
    });

    // Wrap the state in a new struct with a custom API
    // Note: We use use_hook here so that this hook is easier to use in closures in the rsx. Any values with the same lifetime as the ScopeState can be used in the closure without cloning.
    cx.use_hook(|| UsePersistent {
        inner: state.clone(),
    })
}

struct StorageEntry<T> {
    key: String,
    value: T,
}

/// Storage that persists across application reloads
pub struct UsePersistent<T: 'static> {
    inner: UseRef<StorageEntry<T>>,
}

impl<T: Serialize + DeserializeOwned + Clone + 'static> UsePersistent<T> {
    /// Returns a reference to the value
    pub fn get(&self) -> T {
        self.inner.read().value.clone()
    }

    /// Sets the value
    pub fn set(&self, value: T) {
        let mut inner = self.inner.write();
        // Write the new value to local storage
        LocalStorage::set(inner.key.as_str(), &value);
        inner.value = value;
    }
}
````

## Custom Hook Logic

You can use [`cx.use_hook`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.use_hook) to build your own hooks. In fact, this is what all the standard hooks are built on!

`use_hook` accepts a single closure for initializing the hook. It will be only run the first time the component is rendered. The return value of that closure will be used as the value of the hook â€“ Dioxus will take it, and store it for as long as the component is alive. On every render (not just the first one!), you will get a reference to this value.

 > 
 > Note: You can implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) for your hook value â€“ it will be dropped then the component is unmounted (no longer in the UI)

Inside the initialization closure, you will typically make calls to other `cx` methods. For example:

* The `use_state` hook tracks state in the hook value, and uses [`cx.schedule_update`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.schedule_update) to make Dioxus re-render the component whenever it changes.

Here is a simplified implementation of the `use_state` hook:

````rs@hooks_custom_logic.rs
use std::cell::RefCell;
use std::rc::Rc;
use std::sync::Arc;

#[derive(Clone)]
struct UseState<T> {
    value: Rc<RefCell<T>>,
    update: Arc<dyn Fn()>,
}

fn my_use_state<T: 'static>(cx: &ScopeState, init: impl FnOnce() -> T) -> &UseState<T> {
    cx.use_hook(|| {
        // The update function will trigger a re-render in the component cx is attached to
        let update = cx.schedule_update();
        // Create the initial state
        let value = Rc::new(RefCell::new(init()));

        UseState { value, update }
    })
}

impl<T: Clone> UseState<T> {
    fn get(&self) -> T {
        self.value.borrow().clone()
    }

    fn set(&self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render on the component the state is from
        (self.update)();
    }
}
````

* The `use_context` hook calls [`cx.consume_context`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ScopeState.html#method.consume_context) (which would be expensive to call on every render) to get some context from the scope

Here is an implementation of the `use_context` and `use_context_provider` hooks:

````rs@hooks_custom_logic.rs
pub fn use_context<T: 'static + Clone>(cx: &ScopeState) -> Option<&T> {
    cx.use_hook(|| cx.consume_context::<T>()).as_ref()
}

pub fn use_context_provider<T: 'static + Clone>(cx: &ScopeState, f: impl FnOnce() -> T) -> &T {
    cx.use_hook(|| {
        let val = f();
        // Provide the context state to the scope
        cx.provide_context(val.clone());
        val
    })
}

````

## Hook Anti-Patterns

When writing a custom hook, you should avoid the following anti-patterns:

* !Clone Hooks: To allow hooks to be used within async blocks, the hooks must be Clone. To make a hook clone, you can wrap data in Rc or Arc and avoid lifetimes in hooks.

This version of use_state may seem more efficient, but it is not cloneable:

````rs@hooks_anti_patterns.rs
use std::cell::RefCell;
use std::rc::Rc;
use std::sync::Arc;

struct UseState<'a, T> {
    value: &'a RefCell<T>,
    update: Arc<dyn Fn()>,
}

fn my_use_state<T: 'static>(cx: &ScopeState, init: impl FnOnce() -> T) -> UseState<T> {
    // The update function will trigger a re-render in the component cx is attached to
    let update = cx.schedule_update();
    // Create the initial state
    let value = cx.use_hook(|| RefCell::new(init()));

    UseState { value, update }
}

impl<T: Clone> UseState<'_, T> {
    fn get(&self) -> T {
        self.value.borrow().clone()
    }

    fn set(&self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render on the component the state is from
        (self.update)();
    }
}
````

If we try to use this hook in an async block, we will get a compile error:

````rust
fn FutureComponent(cx: &ScopeState) -> Element {
	let my_state = my_use_state(cx, || 0);
	cx.spawn({
		to_owned![my_state];
		async move {
			my_state.set(1);
		}
	});

	todo!()
}
````

But with the original version, we can use it in an async block:

````rust
fn FutureComponent(cx: &ScopeState) -> Element {
	let my_state = use_state(cx, || 0);
	cx.spawn({
		to_owned![my_state];
		async move {
			my_state.set(1);
		}
	});

	todo!()
}
````
# Testing

When building application or libraries with Dioxus, you may want to include some tests to check the behavior of parts of your application. This guide will teach you how to test different parts of your Dioxus application.

## Component Testing

You can use a combination of [pretty-assertions](https://docs.rs/pretty_assertions/latest/pretty_assertions/) and [dioxus-ssr](https://docs.rs/dioxus-ssr/latest/dioxus_ssr/) to check that two snippets of rsx are equal:

````rs@component_test.rs
use futures::FutureExt;
use std::{cell::RefCell, sync::Arc};

use dioxus::prelude::*;

#[test]
fn test() {
    assert_rsx_eq(
        rsx! {
            div {
                "Hello world"
            }
            div {
                "Hello world"
            }
        },
        rsx! {
            for _ in 0..2 {
                div {
                    "Hello world"
                }
            }
        },
    )
}

fn assert_rsx_eq(first: LazyNodes<'static, 'static>, second: LazyNodes<'static, 'static>) {
    let first = dioxus_ssr::render_lazy(first);
    let second = dioxus_ssr::render_lazy(second);
    pretty_assertions::assert_str_eq!(first, second);
}

````

## Hook Testing

When creating libraries around Dioxus, it can be helpful to make tests for your [custom hooks](./state/custom_hooks/index.md).

Dioxus does not currently have a full hook testing library, but you can build a bespoke testing framework by manually driving the virtual dom.

````rs@hook_test.rs
use futures::FutureExt;
use std::{cell::RefCell, sync::Arc};

use dioxus::prelude::*;

#[test]
fn test() {
    test_hook(
        |cx| use_ref(cx, || 0).clone(),
        |value, mut proxy| match proxy.generation {
            0 => {
                value.set(1);
            }
            1 => {
                assert_eq!(*value.read(), 1);
                value.set(2);
            }
            2 => {
                proxy.rerun();
            }
            3 => {}
            _ => todo!(),
        },
        |proxy| assert_eq!(proxy.generation, 4),
    );
}

fn test_hook<V: 'static>(
    initialize: impl FnMut(&ScopeState) -> V + 'static,
    check: impl FnMut(V, MockProxy) + 'static,
    mut final_check: impl FnMut(MockProxy) + 'static,
) {
    #[derive(Props)]
    struct MockAppComponent<
        I: FnMut(&ScopeState) -> V + 'static,
        C: FnMut(V, MockProxy) + 'static,
        V,
    > {
        hook: RefCell<I>,
        check: RefCell<C>,
    }

    impl<I: FnMut(&ScopeState) -> V, C: FnMut(V, MockProxy), V> PartialEq
        for MockAppComponent<I, C, V>
    {
        fn eq(&self, _: &Self) -> bool {
            true
        }
    }

    fn mock_app<I: FnMut(&ScopeState) -> V, C: FnMut(V, MockProxy), V>(
        cx: Scope<MockAppComponent<I, C, V>>,
    ) -> Element {
        let value = cx.props.hook.borrow_mut()(cx);

        cx.props.check.borrow_mut()(value, MockProxy::new(cx));

        render! {
            div {}
        }
    }

    let mut vdom = VirtualDom::new_with_props(
        mock_app,
        MockAppComponent {
            hook: RefCell::new(initialize),
            check: RefCell::new(check),
        },
    );

    let _ = vdom.rebuild();

    while vdom.wait_for_work().now_or_never().is_some() {
        let _ = vdom.render_immediate();
    }

    final_check(MockProxy::new(vdom.base_scope()));
}

struct MockProxy {
    rerender: Arc<dyn Fn()>,
    pub generation: usize,
}

impl MockProxy {
    fn new(scope: &ScopeState) -> Self {
        let generation = scope.generation();
        let rerender = scope.schedule_update();

        Self {
            rerender,
            generation,
        }
    }

    pub fn rerun(&mut self) {
        (self.rerender)();
    }
}

````

## End to End Testing

You can use [Playwright](https://playwright.dev/) to create end to end tests for your dioxus application.

In your `playwright.config.js`, you will need to run cargo run or dx serve instead of the default build command. Here is a snippet from the end to end web example:

````js
//...
webServer: [
    {
        cwd: path.join(process.cwd(), 'playwright-tests', 'web'),
        command: 'dx serve',
        port: 8080,
        timeout: 10 * 60 * 1000,
        reuseExistingServer: !process.env.CI,
        stdout: "pipe",
    },
],
````

* [Web example](https://github.com/DioxusLabs/dioxus/tree/master/playwright-tests/web)
* [Liveview example](https://github.com/DioxusLabs/dioxus/tree/master/playwright-tests/liveview)
* [Fullstack example](https://github.com/DioxusLabs/dioxus/tree/master/playwright-tests/fullstack)
# Examples

There's a *lot* of these, so if you're having trouble implementing something, or you just want to see cool things
that you can do with Dioxus, make sure to give these a look!

Each of the examples in the main repository also has a permalink attached, in case the main one doesn't work.
However, permalinks lead to an older "archived" version, so if you're reading this a long time in the future in a galaxy far, far away...
The examples in the permalinks might not work.

* [Main list](https://github.com/DioxusLabs/dioxus/tree/master/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/examples) - This is the largest list.
* Package-specific examples from the [main repository](https://github.com/DioxusLabs/dioxus/). To learn more about these packages, search them up on [crates.io](https://crates.io/), or navigate from the examples to the root of the package.
  * [dioxus-web](https://github.com/DioxusLabs/dioxus/tree/master/packages/web/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/web/examples)
  * [dioxus-fullstack](https://github.com/DioxusLabs/dioxus/tree/master/packages/fullstack/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/fullstack/examples)
  * [dioxus-liveview](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/liveview/examples)
  * [dioxus-router](https://github.com/DioxusLabs/dioxus/tree/master/packages/router/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/router/examples)
  * [dioxus-tui](https://github.com/DioxusLabs/dioxus/tree/master/packages/dioxus-tui/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/dioxus-tui/examples)
  * [plasmo ("rink" is the old name, it will be updated)](https://github.com/DioxusLabs/dioxus/tree/master/packages/rink/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/rink/examples)
  * [rsx-rosetta](https://github.com/DioxusLabs/dioxus/tree/master/packages/rsx-rosetta/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/rsx-rosetta/examples)
  * [native-core](https://github.com/DioxusLabs/dioxus/tree/master/packages/native-core/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/native-core/examples)
  * [signals](https://github.com/DioxusLabs/dioxus/tree/master/packages/signals/examples) - [permalink](https://github.com/DioxusLabs/dioxus/tree/60ee82942c4decf67b6ad263f639553d9b7e28a9/packages/signals/examples) - This is unreleased, but it's a very exciting project, so stay tuned!
* The [example-projects](https://github.com/DioxusLabs/example-projects) repository. It might be deprecated/removed in the future though. See [\#25](https://github.com/DioxusLabs/example-projects/issues/25).
# Tailwind

You can style your Dioxus application with whatever CSS framework you choose, or just write vanilla CSS.

One popular option for styling your Dioxus application is [Tailwind](https://tailwindcss.com/). Tailwind allows you to style your elements with CSS utility classes. This guide will show you how to setup tailwind CSS with your Dioxus application.

## Setup

1. Install the Dioxus CLI:
   
   ````bash
   cargo install --git https://github.com/DioxusLabs/cli
   ````

1. Install npm: https://docs.npmjs.com/downloading-and-installing-node-js-and-npm

1. Install the tailwind css cli: https://tailwindcss.com/docs/installation

1. Initialize the tailwind css project:
   
   ````bash
   npx tailwindcss init
   ````
   
   This should create a `tailwind.config.js` file in the root of the project.

1. Edit the `tailwind.config.js` file to include rust files:
   
   ````js
   module.exports = {
       mode: "all",
       content: [
           // include all rust, html and css files in the src directory
           "./src/**/*.{rs,html,css}",
           // include all html files in the output (dist) directory
           "./dist/**/*.html",
       ],
       theme: {
           extend: {},
       },
       plugins: [],
   }
   ````

1. Create a `input.css` file with the following content:
   
   ````css
   @tailwind base;
   @tailwind components;
   @tailwind utilities;
   ````

1. Create a `Dioxus.toml` file with the following content that links to the `tailwind.css` file:
   
   ````toml
   [application]
   
   # App (Project) Name
   name = "Tailwind CSS + Dioxus"
   
   # Dioxus App Default Platform
   # desktop, web, mobile, ssr
   default_platform = "web"
   
   # `build` & `serve` dist path
   out_dir = "dist"
   
   # resource (public) file folder
   asset_dir = "public"
   
   [web.app]
   
   # HTML title tag content
   title = "dioxus | â›º"
   
   [web.watcher]
   
   # when watcher trigger, regenerate the `index.html`
   reload_html = true
   
   # which files or dirs will be watcher monitoring
   watch_path = ["src", "public"]
   
   # uncomment line below if using Router
   # index_on_404 = true
   
   # include `assets` in web platform
   [web.resource]
   
   # CSS style file
   style = ["/tailwind.css"]
   
   # Javascript code file
   script = []
   
   [web.resource.dev]
   
   # serve: [dev-server] only
   
   # CSS style file
   style = []
   
   # Javascript code file
   script = []
   ````

### Bonus Steps

1. Install the tailwind css vs code extension

1. Go to the settings for the extension and find the experimental regex support section. Edit the setting.json file to look like this:
   
   ````json
   "tailwindCSS.experimental.classRegex": ["class: \"(.*)\""],
   "tailwindCSS.includeLanguages": {
       "rust": "html"
   },
   ````

## Development

* Run the following command in the root of the project to start the tailwind css compiler:
  
  ````bash
  npx tailwindcss -i ./input.css -o ./public/tailwind.css --watch
  ````

### Web

* Run the following command in the root of the project to start the dioxus dev server:
  
  ````bash
  dx serve --hot-reload
  ````

* Open the browser to [http://localhost:8080](http://localhost:8080).

### Desktop

* Add a custom head pointing to the generated tailwind CSS file in your `main`. It looks like:
  
  ````rust
  dioxus_desktop::launch_cfg(
    App,
    dioxus_desktop::Config::new()
      .with_custom_head(r#"<link rel="stylesheet" href="public/tailwind.css">"#.to_string()))
  ````

* Launch the dioxus desktop app:
  
  ````bash
  cargo run
  ````
# Custom Renderer

Dioxus is an incredibly portable framework for UI development. The lessons, knowledge, hooks, and components you acquire over time can always be used for future projects. However, sometimes those projects cannot leverage a supported renderer or you need to implement your own better renderer.

Great news: the design of the renderer is entirely up to you! We provide suggestions and inspiration with the 1st party renderers, but only really require processing `Mutations` and sending `UserEvents`.

## The specifics:

Implementing the renderer is fairly straightforward. The renderer needs to:

1. Handle the stream of edits generated by updates to the virtual DOM
1. Register listeners and pass events into the virtual DOM's event system

Essentially, your renderer needs to process edits and generate events to update the VirtualDOM. From there, you'll have everything needed to render the VirtualDOM to the screen.

Internally, Dioxus handles the tree relationship, diffing, memory management, and the event system, leaving as little as possible required for renderers to implement themselves.

For reference, check out the [javascript interpreter](https://github.com/DioxusLabs/dioxus/tree/master/packages/interpreter) or [tui renderer](https://github.com/DioxusLabs/dioxus/tree/master/packages/dioxus-tui) as a starting point for your custom renderer.

## Templates

Dioxus is built around the concept of [Templates](https://docs.rs/dioxus-core/latest/dioxus_core/prelude/struct.Template.html). Templates describe a UI tree known at compile time with dynamic parts filled at runtime. This is useful internally to make skip diffing static nodes, but it is also useful for the renderer to reuse parts of the UI tree. This can be useful for things like a list of items. Each item could contain some static parts and some dynamic parts. The renderer can use the template to create a static part of the UI once, clone it for each element in the list, and then fill in the dynamic parts.

## Mutations

The `Mutation` type is a serialized enum that represents an operation that should be applied to update the UI. The variants roughly follow this set:

````rust
enum Mutation {
	AppendChildren,
	AssignId,
	CreatePlaceholder,
	CreateTextNode,
	HydrateText,
	LoadTemplate,
	ReplaceWith,
	ReplacePlaceholder,
	InsertAfter,
	InsertBefore,
	SetAttribute,
	SetText,
	NewEventListener,
	RemoveEventListener,
	Remove,
	PushRoot,
}
````

The Dioxus diffing mechanism operates as a [stack machine](https://en.wikipedia.org/wiki/Stack_machine) where the [LoadTemplate](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.LoadTemplate), [CreatePlaceholder](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.CreatePlaceholder), and [CreateTextNode](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.CreateTextNode) mutations pushes a new "real" DOM node onto the stack and [AppendChildren](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.AppendChildren), [InsertAfter](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.InsertAfter), [InsertBefore](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.InsertBefore), [ReplacePlaceholder](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.ReplacePlaceholder), and [ReplaceWith](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.ReplaceWith) all remove nodes from the stack.

## Node storage

Dioxus saves and loads elements with IDs. Inside the VirtualDOM, this is just tracked as as a u64.

Whenever a `CreateElement` edit is generated during diffing, Dioxus increments its node counter and assigns that new element its current NodeCount. The RealDom is responsible for remembering this ID and pushing the correct node when id is used in a mutation. Dioxus reclaims the IDs of elements when removed. To stay in sync with Dioxus you can use a sparse Vec (Vec\<Option<T>\>) with possibly unoccupied items. You can use the ids as indexes into the Vec for elements, and grow the Vec when an id does not exist.

### An Example

For the sake of understanding, let's consider this example â€“ a very simple UI declaration:

````rust
rsx!( h1 {"count: {x}"} )
````

#### Building Templates

The above rsx will create a template that contains one static h1 tag and a placeholder for a dynamic text node. The template contains the static parts of the UI, and ids for the dynamic parts along with the paths to access them.

The template will look something like this:

````rust
Template {
	// Some id that is unique for the entire project
	name: "main.rs:1:1:0",
	// The root nodes of the template
	roots: &[
		TemplateNode::Element {
			tag: "h1",
			namespace: None,
			attrs: &[],
			children: &[
				TemplateNode::DynamicText {
					id: 0
				},
			],
		}
	],
	// the path to each of the dynamic nodes
	node_paths: &[
		// the path to dynamic node with a id of 0
		&[
			// on the first root node
			0,
			// the first child of the root node
			0,
		]
	],
	// the path to each of the dynamic attributes
	attr_paths: &'a [&'a [u8]],
}
````

 > 
 > For more detailed docs about the structure of templates see the [Template api docs](https://docs.rs/dioxus-core/latest/dioxus_core/prelude/struct.Template.html)

This template will be sent to the renderer in the [list of templates](https://docs.rs/dioxus-core/latest/dioxus_core/struct.Mutations.html#structfield.templates) supplied with the mutations the first time it is used. Any time the renderer encounters a [LoadTemplate](https://docs.rs/dioxus-core/latest/dioxus_core/enum.Mutation.html#variant.LoadTemplate) mutation after this, it should clone the template and store it in the given id.

For dynamic nodes and dynamic text nodes, a placeholder node should be created and inserted into the UI so that the node can be modified later.

In HTML renderers, this template could look like this:

````html
<h1>""</h1>
````

#### Applying Mutations

After the renderer has created all of the new templates, it can begin to process the mutations.

When the renderer starts, it should contain the Root node on the stack and store the Root node with an id of 0. The Root node is the top-level node of the UI. In HTML, this is the `<div id="main">` element.

````rust
instructions: []
stack: [
	RootNode,
]
nodes: [
	RootNode,
]
````

The first mutation is a `LoadTemplate` mutation. This tells the renderer to load a root from the template with the given id. The renderer will then push the root node of the template onto the stack and store it with an id for later. In this case, the root node is an h1 element.

````rust
instructions: [
	LoadTemplate {
		// the id of the template
		name: "main.rs:1:1:0",
		// the index of the root node in the template
		index: 0,
		// the id to store
		id: ElementId(1),
	}
]
stack: [
	RootNode,
	<h1>""</h1>,
]
nodes: [
	RootNode,
	<h1>""</h1>,
]
````

Next, Dioxus will create the dynamic text node. The diff algorithm decides that this node needs to be created, so Dioxus will generate the Mutation `HydrateText`. When the renderer receives this instruction, it will navigate to the placeholder text node in the template and replace it with the new text.

````rust
instructions: [
	LoadTemplate {
		name: "main.rs:1:1:0",
		index: 0,
		id: ElementId(1),
	},
	HydrateText {
		// the id to store the text node
		id: ElementId(2),
		// the text to set
		text: "count: 0",
	}
]
stack: [
	RootNode,
	<h1>"count: 0"</h1>,
]
nodes: [
	RootNode,
	<h1>"count: 0"</h1>,
	"count: 0",
]
````

Remember, the h1 node is not attached to anything (it is unmounted) so Dioxus needs to generate an Edit that connects the h1 node to the Root. It depends on the situation, but in this case, we use `AppendChildren`. This pops the text node off the stack, leaving the Root element as the next element on the stack.

````rust
instructions: [
	LoadTemplate {
		name: "main.rs:1:1:0",
		index: 0,
		id: ElementId(1),
	},
	HydrateText {
		id: ElementId(2),
		text: "count: 0",
	},
	AppendChildren {
		// the id of the parent node
		id: ElementId(0),
		// the number of nodes to pop off the stack and append
		m: 1
	}
]
stack: [
	RootNode,
]
nodes: [
	RootNode,
	<h1>"count: 0"</h1>,
	"count: 0",
]
````

Over time, our stack looked like this:

````rust
[Root]
[Root, <h1>""</h1>]
[Root, <h1>"count: 0"</h1>]
[Root]
````

Conveniently, this approach completely separates the Virtual DOM and the Real DOM. Additionally, these edits are serializable, meaning we can even manage UIs across a network connection. This little stack machine and serialized edits make Dioxus independent of platform specifics.

Dioxus is also really fast. Because Dioxus splits the diff and patch phase, it's able to make all the edits to the RealDOM in a very short amount of time (less than a single frame) making rendering very snappy. It also allows Dioxus to cancel large diffing operations if higher priority work comes in while it's diffing.

This little demo serves to show exactly how a Renderer would need to process a mutation stream to build UIs.

## Event loop

Like most GUIs, Dioxus relies on an event loop to progress the VirtualDOM. The VirtualDOM itself can produce events as well, so it's important for your custom renderer can handle those too.

The code for the WebSys implementation is straightforward, so we'll add it here to demonstrate how simple an event loop is:

````rust, ignore
pub async fn run(&mut self) -> dioxus_core::error::Result<()> {
	// Push the body element onto the WebsysDom's stack machine
	let mut websys_dom = crate::new::WebsysDom::new(prepare_websys_dom());
	websys_dom.stack.push(root_node);

	// Rebuild or hydrate the virtualdom
	let mutations = self.internal_dom.rebuild();
	websys_dom.apply_mutations(mutations);

	// Wait for updates from the real dom and progress the virtual dom
	loop {
		let user_input_future = websys_dom.wait_for_event();
		let internal_event_future = self.internal_dom.wait_for_work();

		match select(user_input_future, internal_event_future).await {
			Either::Left((_, _)) => {
				let mutations = self.internal_dom.work_with_deadline(|| false);
				websys_dom.apply_mutations(mutations);
			},
			Either::Right((event, _)) => websys_dom.handle_event(event),
		}

		// render
	}
}
````

It's important to decode what the real events are for your event system into Dioxus' synthetic event system (synthetic meaning abstracted). This simply means matching your event type and creating a Dioxus `UserEvent` type. Right now, the virtual event system is modeled almost entirely around the HTML spec, but we are interested in slimming it down.

````rust, ignore
fn virtual_event_from_websys_event(event: &web_sys::Event) -> VirtualEvent {
	match event.type_().as_str() {
		"keydown" => {
			let event: web_sys::KeyboardEvent = event.clone().dyn_into().unwrap();
			UserEvent::KeyboardEvent(UserEvent {
				scope_id: None,
				priority: EventPriority::Medium,
				name: "keydown",
				// This should be whatever element is focused
				element: Some(ElementId(0)),
				data: Arc::new(KeyboardData{
					char_code: event.char_code(),
					key: event.key(),
					key_code: event.key_code(),
					alt_key: event.alt_key(),
					ctrl_key: event.ctrl_key(),
					meta_key: event.meta_key(),
					shift_key: event.shift_key(),
					location: event.location(),
					repeat: event.repeat(),
					which: event.which(),
				})
			})
		}
		_ => todo!()
	}
}
````

## Custom raw elements

If you need to go as far as relying on custom elements/attributes for your renderer â€“ you totally can. This still enables you to use Dioxus' reactive nature, component system, shared state, and other features, but will ultimately generate different nodes. All attributes and listeners for the HTML and SVG namespace are shuttled through helper structs that essentially compile away. You can drop in your elements any time you want, with little hassle. However, you must be sure your renderer can handle the new namespace.

For more examples and information on how to create custom namespaces, see the [`dioxus_html` crate](https://github.com/DioxusLabs/dioxus/blob/master/packages/html/README.md#how-to-extend-it).

# Native Core

If you are creating a renderer in rust, the [native-core](https://github.com/DioxusLabs/dioxus/tree/master/packages/native-core) crate provides some utilities to implement a renderer. It provides an abstraction over Mutations and Templates and contains helpers that can handle the layout and text editing for you.

## The RealDom

The `RealDom` is a higher-level abstraction over updating the Dom. It uses an entity component system to manage the state of nodes. This system allows you to modify insert and modify arbitrary components on nodes. On top of this, the RealDom provides a way to manage a tree of nodes, and the State trait provides a way to automatically add and update these components when the tree is modified. It also provides a way to apply `Mutations` to the RealDom.

### Example

Let's build a toy renderer with borders, size, and text color.
Before we start let's take a look at an example element we can render:

````rust
cx.render(rsx!{
	div{
		color: "red",
		p{
			border: "1px solid black",
			"hello world"
		}
	}
})
````

In this tree, the color depends on the parent's color. The layout depends on the children's layout, the current text, and the text size. The border depends on only the current node.

In the following diagram arrows represent dataflow:

[![](https://mermaid.ink/img/pako:eNqllV1vgjAUhv8K6W4wkQVa2QdLdrHsdlfukmSptEhjoaSWqTH-9xVwONAKst70g5739JzzlO5BJAgFAYi52EQJlsr6fAszS7d1sVhKnCdWJDJFt6peLVs5-9owohK7HFrVcFJ_pxnpmK8VVvRkTJikkWIiaxy1dhP23bUwW1WW5WbPrrqJ4ziR4EJ6dtVN2ls5y1ZztePUcrWZFCvqVEcPPDffvlyS1XoLIQnVgnVvVPR6FU9Zc-6dV453ojjOPbuetRJ57gIeXQR3cez7rjtteZyZQ2j5MqmjqwE0ZW0VKx9RKtgpFewp1aw3sXXFy6TWgiYlv8mfq1scD8ofbBCAfQg8_AMBOAyBxzEIwA4CxgQ99QbQkjnD2KT7_CfxGF8_9WXQEsq5sDZCcjICOXRCri4h6r3NA38Q6Jdi1EOx5w3DGDYYI6MUvJFjM3VoGHUeGoMd6mBnDmh2E3fo7O4Yhf0x4OkBmIKUyhQzol_GfbkcApXQlIYg0EOC5SoEYXbQ-3ChxHyXRSBQsqBTUOREx_7OsAY3BUGM-VqvUsKUkB_1U6vf05gtweEHTk4_HQ?type=png)](https://mermaid.live/edit#pako:eNqllV1vgjAUhv8K6W4wkQVa2QdLdrHsdlfukmSptEhjoaSWqTH-9xVwONAKst70g5739JzzlO5BJAgFAYi52EQJlsr6fAszS7d1sVhKnCdWJDJFt6peLVs5-9owohK7HFrVcFJ_pxnpmK8VVvRkTJikkWIiaxy1dhP23bUwW1WW5WbPrrqJ4ziR4EJ6dtVN2ls5y1ZztePUcrWZFCvqVEcPPDffvlyS1XoLIQnVgnVvVPR6FU9Zc-6dV453ojjOPbuetRJ57gIeXQR3cez7rjtteZyZQ2j5MqmjqwE0ZW0VKx9RKtgpFewp1aw3sXXFy6TWgiYlv8mfq1scD8ofbBCAfQg8_AMBOAyBxzEIwA4CxgQ99QbQkjnD2KT7_CfxGF8_9WXQEsq5sDZCcjICOXRCri4h6r3NA38Q6Jdi1EOx5w3DGDYYI6MUvJFjM3VoGHUeGoMd6mBnDmh2E3fo7O4Yhf0x4OkBmIKUyhQzol_GfbkcApXQlIYg0EOC5SoEYXbQ-3ChxHyXRSBQsqBTUOREx_7OsAY3BUGM-VqvUsKUkB_1U6vf05gtweEHTk4_HQ)

To help in building a Dom, native-core provides the State trait and a RealDom struct. The State trait provides a way to describe how states in a node depend on other states in its relatives. By describing how to update a single node from its relations, native-core will derive a way to update the states of all nodes for you. Once you have a state you can provide it as a generic to RealDom. RealDom provides all of the methods to interact and update your new dom.

Native Core cannot create all of the required methods for the State trait, but it can derive some of them. To implement the State trait, you must implement the following methods and let the `#[partial_derive_state]` macro handle the rest:

````rs@custom_renderer.rs
// All states must derive Component (https://docs.rs/shipyard/latest/shipyard/derive.Component.html)
// They also must implement Default or provide a custom implementation of create in the State trait
#[derive(Default, Component)]
struct MyState;

/// Derive some of the boilerplate for the State implementation
#[partial_derive_state]
impl State for MyState {
    // The states of the parent nodes this state depends on
    type ParentDependencies = ();

    // The states of the child nodes this state depends on
    type ChildDependencies = (Self,);

    // The states of the current node this state depends on
    type NodeDependencies = ();

    // The parts of the current text, element, or placeholder node in the tree that this state depends on
    const NODE_MASK: NodeMaskBuilder<'static> = NodeMaskBuilder::new();

    // How to update the state of the current node based on the state of the parent nodes, child nodes, and the current node
    // Returns true if the node was updated and false if the node was not updated
    fn update<'a>(
        &mut self,
        // The view of the current node limited to the parts this state depends on
        _node_view: NodeView<()>,
        // The state of the current node that this state depends on
        _node: <Self::NodeDependencies as Dependancy>::ElementBorrowed<'a>,
        // The state of the parent nodes that this state depends on
        _parent: Option<<Self::ParentDependencies as Dependancy>::ElementBorrowed<'a>>,
        // The state of the child nodes that this state depends on
        _children: Vec<<Self::ChildDependencies as Dependancy>::ElementBorrowed<'a>>,
        // The context of the current node used to pass global state into the tree
        _context: &SendAnyMap,
    ) -> bool {
        todo!()
    }

    // partial_derive_state will generate a default implementation of all the other methods
}
````

Lets take a look at how to implement the State trait for a simple renderer.

````rs@custom_renderer.rs
struct FontSize(f64);

// All states need to derive Component
#[derive(Default, Debug, Copy, Clone, Component)]
struct Size(f64, f64);

/// Derive some of the boilerplate for the State implementation
#[partial_derive_state]
impl State for Size {
    type ParentDependencies = ();

    // The size of the current node depends on the size of its children
    type ChildDependencies = (Self,);

    type NodeDependencies = ();

    // Size only cares about the width, height, and text parts of the current node
    const NODE_MASK: NodeMaskBuilder<'static> = NodeMaskBuilder::new()
        // Get access to the width and height attributes
        .with_attrs(AttributeMaskBuilder::Some(&["width", "height"]))
        // Get access to the text of the node
        .with_text();

    fn update<'a>(
        &mut self,
        node_view: NodeView<()>,
        _node: <Self::NodeDependencies as Dependancy>::ElementBorrowed<'a>,
        _parent: Option<<Self::ParentDependencies as Dependancy>::ElementBorrowed<'a>>,
        children: Vec<<Self::ChildDependencies as Dependancy>::ElementBorrowed<'a>>,
        context: &SendAnyMap,
    ) -> bool {
        let font_size = context.get::<FontSize>().unwrap().0;
        let mut width;
        let mut height;
        if let Some(text) = node_view.text() {
            // if the node has text, use the text to size our object
            width = text.len() as f64 * font_size;
            height = font_size;
        } else {
            // otherwise, the size is the maximum size of the children
            width = children
                .iter()
                .map(|(item,)| item.0)
                .reduce(|accum, item| if accum >= item { accum } else { item })
                .unwrap_or(0.0);

            height = children
                .iter()
                .map(|(item,)| item.1)
                .reduce(|accum, item| if accum >= item { accum } else { item })
                .unwrap_or(0.0);
        }
        // if the node contains a width or height attribute it overrides the other size
        for a in node_view.attributes().into_iter().flatten() {
            match &*a.attribute.name {
                "width" => width = a.value.as_float().unwrap(),
                "height" => height = a.value.as_float().unwrap(),
                // because Size only depends on the width and height, no other attributes will be passed to the member
                _ => panic!(),
            }
        }
        // to determine what other parts of the dom need to be updated we return a boolean that marks if this member changed
        let changed = (width != self.0) || (height != self.1);
        *self = Self(width, height);
        changed
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Default, Component)]
struct TextColor {
    r: u8,
    g: u8,
    b: u8,
}

#[partial_derive_state]
impl State for TextColor {
    // TextColor depends on the TextColor part of the parent
    type ParentDependencies = (Self,);

    type ChildDependencies = ();

    type NodeDependencies = ();

    // TextColor only cares about the color attribute of the current node
    const NODE_MASK: NodeMaskBuilder<'static> =
        // Get access to the color attribute
        NodeMaskBuilder::new().with_attrs(AttributeMaskBuilder::Some(&["color"]));

    fn update<'a>(
        &mut self,
        node_view: NodeView<()>,
        _node: <Self::NodeDependencies as Dependancy>::ElementBorrowed<'a>,
        parent: Option<<Self::ParentDependencies as Dependancy>::ElementBorrowed<'a>>,
        _children: Vec<<Self::ChildDependencies as Dependancy>::ElementBorrowed<'a>>,
        _context: &SendAnyMap,
    ) -> bool {
        // TextColor only depends on the color tag, so getting the first tag is equivalent to looking through all tags
        let new = match node_view
            .attributes()
            .and_then(|mut attrs| attrs.next())
            .and_then(|attr| attr.value.as_text())
        {
            // if there is a color tag, translate it
            Some("red") => TextColor { r: 255, g: 0, b: 0 },
            Some("green") => TextColor { r: 0, g: 255, b: 0 },
            Some("blue") => TextColor { r: 0, g: 0, b: 255 },
            Some(color) => panic!("unknown color {}", "red"),
            // otherwise check if the node has a parent and inherit that color
            None => match parent {
                Some((parent,)) => *parent,
                None => Self::default(),
            },
        };
        // check if the member has changed
        let changed = new != *self;
        *self = new;
        changed
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Default, Component)]
struct Border(bool);

#[partial_derive_state]
impl State for Border {
    // TextColor depends on the TextColor part of the parent
    type ParentDependencies = (Self,);

    type ChildDependencies = ();

    type NodeDependencies = ();

    // Border does not depended on any other member in the current node
    const NODE_MASK: NodeMaskBuilder<'static> =
        // Get access to the border attribute
        NodeMaskBuilder::new().with_attrs(AttributeMaskBuilder::Some(&["border"]));

    fn update<'a>(
        &mut self,
        node_view: NodeView<()>,
        _node: <Self::NodeDependencies as Dependancy>::ElementBorrowed<'a>,
        _parent: Option<<Self::ParentDependencies as Dependancy>::ElementBorrowed<'a>>,
        _children: Vec<<Self::ChildDependencies as Dependancy>::ElementBorrowed<'a>>,
        _context: &SendAnyMap,
    ) -> bool {
        // check if the node contains a border attribute
        let new = Self(
            node_view
                .attributes()
                .and_then(|mut attrs| attrs.next().map(|a| a.attribute.name == "border"))
                .is_some(),
        );
        // check if the member has changed
        let changed = new != *self;
        *self = new;
        changed
    }
}
````

Now that we have our state, we can put it to use in our RealDom. We can update the RealDom with apply_mutations to update the structure of the dom (adding, removing, and changing properties of nodes) and then update_state to update the States for each of the nodes that changed.

````rs@custom_renderer.rs
fn main() -> Result<(), Box<dyn std::error::Error>> {
    fn app(cx: Scope) -> Element {
        let count = use_state(cx, || 0);

        use_future(cx, (count,), |(count,)| async move {
            loop {
                tokio::time::sleep(std::time::Duration::from_secs(1)).await;
                count.set(*count + 1);
            }
        });

        cx.render(rsx! {
            div{
                color: "red",
                "{count}"
            }
        })
    }

    // create the vdom, the real_dom, and the binding layer between them
    let mut vdom = VirtualDom::new(app);
    let mut rdom: RealDom = RealDom::new([
        Border::to_type_erased(),
        TextColor::to_type_erased(),
        Size::to_type_erased(),
    ]);
    let mut dioxus_intigration_state = DioxusState::create(&mut rdom);

    let mutations = vdom.rebuild();
    // update the structure of the real_dom tree
    dioxus_intigration_state.apply_mutations(&mut rdom, mutations);
    let mut ctx = SendAnyMap::new();
    // set the font size to 3.3
    ctx.insert(FontSize(3.3));
    // update the State for nodes in the real_dom tree
    let _to_rerender = rdom.update_state(ctx);

    // we need to run the vdom in a async runtime
    tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()?
        .block_on(async {
            loop {
                // wait for the vdom to update
                vdom.wait_for_work().await;

                // get the mutations from the vdom
                let mutations = vdom.render_immediate();

                // update the structure of the real_dom tree
                dioxus_intigration_state.apply_mutations(&mut rdom, mutations);

                // update the state of the real_dom tree
                let mut ctx = SendAnyMap::new();
                // set the font size to 3.3
                ctx.insert(FontSize(3.3));
                let _to_rerender = rdom.update_state(ctx);

                // render...
                rdom.traverse_depth_first(|node| {
                    let indent = " ".repeat(node.height() as usize);
                    let color = *node.get::<TextColor>().unwrap();
                    let size = *node.get::<Size>().unwrap();
                    let border = *node.get::<Border>().unwrap();
                    let id = node.id();
                    let node = node.node_type();
                    let node_type = &*node;
                    println!("{indent}{id:?} {color:?} {size:?} {border:?} {node_type:?}");
                });
            }
        })
}
````

## Layout

For most platforms, the layout of the Elements will stay the same. The [layout_attributes](https://docs.rs/dioxus-native-core/latest/dioxus_native_core/layout_attributes/index.html) module provides a way to apply HTML attributes a [Taffy](https://docs.rs/taffy/latest/taffy/index.html) layout style.

## Text Editing

To make it easier to implement text editing in rust renderers, `native-core` also contains a renderer-agnostic cursor system. The cursor can handle text editing, selection, and movement with common keyboard shortcuts integrated.

````rs@custom_renderer.rs
fn text_editing() {
    let mut cursor = Cursor::default();
    let mut text = String::new();

    // handle keyboard input with a max text length of 10
    cursor.handle_input(
        &Code::ArrowRight,
        &Key::ArrowRight,
        &Modifiers::empty(),
        &mut text,
        10,
    );

    // manually select text between characters 0-5 on the first line (this could be from dragging with a mouse)
    cursor.start = Pos::new(0, 0);
    cursor.end = Some(Pos::new(5, 0));

    // delete the selected text and move the cursor to the start of the selection
    cursor.delete_selection(&mut text);
}
````

## Conclusion

That should be it! You should have nearly all the knowledge required on how to implement your renderer. We're super interested in seeing Dioxus apps brought to custom desktop renderers, mobile renderers, video game UI, and even augmented reality! If you're interested in contributing to any of these projects, don't be afraid to reach out or join the [community](https://discord.gg/XgGxMSkvUM).
# Optimizing

*Note: This is written primarily for the web, but the main optimizations will work on other platforms too.*

You might have noticed that Dioxus binaries are pretty big.
The WASM binary of a [TodoMVC app](https://github.com/tigerros/dioxus-todo-app) weighs in at 2.36mb!
Don't worry; we can get it down to a much more manageable 234kb.
This will get obviously lower over time.
For example, the new [event system](https://github.com/DioxusLabs/dioxus/pull/1402) will reduce the binary size of a hello world app to less than 100kb (with unstable features).

We will also discuss ways to optimize your app for increased speed.

However, certain optimizations will sacrifice speed for decreased binary size or the other way around.
That's what you need to figure out yourself. Does your app perform performance-intensive tasks, such as graphical processing or tons of DOM manipulations?
You could go for increased speed. In most cases, though, decreased binary size is the better choice, especially because Dioxus WASM binaries are quite large.

To test binary sizes, we will use [this](https://github.com/tigerros/dioxus-todo-app) repository as a sample app.
The `no-optimizations` package will serve as the base, which weighs 2.36mb as of right now.

Additional resources:

* [WASM book - Shrinking `.wasm` code size](https://rustwasm.github.io/docs/book/reference/code-size.html)
* [min-sized-rust](https://github.com/johnthagen/min-sized-rust)

## Building in release mode

This is the best way to optimize. In fact, the 2.36mb figure at the start of the guide is with release mode.
In debug mode, it's actually a whopping 32mb! It also increases the speed of your app.

Thankfully, no matter what tool you're using to build your app, it will probably have a `--release` flag to do this.

Using the [Dioxus CLI](https://dioxuslabs.com/learn/0.4/CLI) or [Trunk](https://trunkrs.dev/):

* Dioxus CLI: `dx build --release`
* Trunk: `trunk build --release`

## UPX

If you're not targeting web, you can use the [UPX](https://github.com/upx/upx) CLI tool to compress your executables.

Setup:

* Download a [release](https://github.com/upx/upx/releases) and extract the directory inside to a sensible location.
* Add the executable located in the directory to your path variable.

You can run `upx --help` to get the CLI options, but you should also view `upx-doc.html` for more detailed information.
It's included in the extracted directory.

An example command might be: `upx --best -o target/release/compressed.exe target/release/your-executable.exe`.

## Build configuration

*Note: Settings defined in `.cargo/config.toml` will override settings in `Cargo.toml`.*

Other than the `--release` flag, this is the easiest way to optimize your projects, and also the most effective way,
at least in terms of reducing binary size.

### Stable

This configuration is 100% stable and decreases the binary size from 2.36mb to 310kb.
Add this to your `.cargo/config.toml`:

````toml
[profile.release]
opt-level = "z"
debug = false
lto = true
codegen-units = 1
panic = "abort"
strip = true
incremental = false
````

Links to the documentation of each value:

* [`opt-level`](https://doc.rust-lang.org/rustc/codegen-options/index.html#opt-level)
* [`debug`](https://doc.rust-lang.org/rustc/codegen-options/index.html#debuginfo)
* [`lto`](https://doc.rust-lang.org/rustc/codegen-options/index.html#lto)
* [`codegen-units`](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units)
* [`panic`](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic)
* [`strip`](https://doc.rust-lang.org/rustc/codegen-options/index.html#strip)
* [`incremental`](https://doc.rust-lang.org/rustc/codegen-options/index.html#incremental)

### Unstable

This configuration contains some unstable features, but it should work just fine.
It decreases the binary size from 310kb to 234kb.
Add this to your `.cargo/config.toml`:

````toml
[unstable]
build-std = ["std", "panic_abort", "core", "alloc"]
build-std-features = ["panic_immediate_abort"]

[build]
rustflags = [
    "-Clto",
    "-Zvirtual-function-elimination",
    "-Zlocation-detail=none"
]

# Same as in the Stable section
[profile.release]
opt-level = "z"
debug = false
lto = true
codegen-units = 1
panic = "abort"
strip = true
incremental = false
````

*Note: The omitted space in each flag (e.g., `-C<no space here>lto`) is intentional. It is not a typo.*

The values in `[profile.release]` are documented in the [Stable](#stable) section. Links to the documentation of each value:

* [`[build.rustflags]`](https://doc.rust-lang.org/cargo/reference/config.html#buildrustflags)
* [`-C lto`](https://doc.rust-lang.org/rustc/codegen-options/index.html#lto)
* [`-Z virtual-function-elimination`](https://doc.rust-lang.org/stable/unstable-book/compiler-flags/virtual-function-elimination.html)
* [`-Z location-detail`](https://doc.rust-lang.org/stable/unstable-book/compiler-flags/location-detail.html)

## wasm-opt

*Note: In the future, `wasm-opt` will be supported natively through the [Dioxus CLI](https://crates.io/crates/dioxus-cli).*

`wasm-opt` is a tool from the [binaryen](https://github.com/WebAssembly/binaryen) library that optimizes your WASM files.
To use it, install a [binaryen release](https://github.com/WebAssembly/binaryen/releases) and run this command from the package directory:

````
wasm-opt dist/assets/dioxus/APP_NAME_bg.wasm -o dist/assets/dioxus/APP_NAME_bg.wasm -Oz
````

The `-Oz` flag specifies that `wasm-opt` should optimize for size. For speed, use `-O4`.

## Improving Dioxus code

Let's talk about how you can improve your Dioxus code to be more performant.

It's important to minimize the number of dynamic parts in your `rsx`, like conditional rendering.
When Dioxus is rendering your component, it will skip parts that are the same as the last render.
That means that if you keep dynamic rendering to a minimum, your app will speed up, and quite a bit if it's not just hello world.
To see an example of this, check out [Dynamic Rendering](../reference/dynamic_rendering.md).

Also check out [Anti-patterns](antipatterns.md) for patterns that you should avoid.
Obviously, not all of them are just about performance, but some of them are.

## Bundling and minifying the output JS and HTML

This will be added in [dioxus/#1369](https://github.com/DioxusLabs/dioxus/pull/1369).
# Introduction

The âœ¨**Dioxus CLI**âœ¨ is a tool to get Dioxus projects off the ground.

There's no documentation for commands here, but you can see all commands using `dx --help` once you've installed the CLI! Furthermore, you can run `dx <command> --help` to get help with a specific command.

## Features

* Build and pack a Dioxus project.
* Format `rsx` code.
* Hot Reload for `web` platform.
* Create a Dioxus project from a template repository.
* And more!
# Installation

## Install the stable version (recommended)

````
cargo install dioxus-cli
````

If you get an OpenSSL error on installation, ensure the dependencies listed [here](https://docs.rs/openssl/latest/openssl/#automatic) are installed.

## Install the latest development build through git

To get the latest bug fixes and features, you can install the development version from git. However, this is not fully tested. That means you're probably going to have more bugs despite having the latest bug fixes.

````
cargo install --git https://github.com/DioxusLabs/dioxus dioxus-cli
````

This will download the CLI from the master branch, and install it in Cargo's global binary directory (`~/.cargo/bin/` by default).

Run `dx --help` for a list of all the available commands. Furthermore, you can run `dx <command> --help` to get help with a specific command.
# Create a Project

Once you have the Dioxus CLI installed, you can use it to create your own project!

## Initializing a project

First, run the `dx create` command to create a new project.

 > 
 > It clones this [template](https://github.com/DioxusLabs/dioxus-template), which is used for web apps.
 > 
 > You can create your project from a different template by passing the `template` argument:
 > 
 > ````
 > dx create --template gh:dioxuslabs/dioxus-template
 > ````

Next, navigate into your new project using `cd project-name`, or simply opening it in an IDE.

 > 
 > Make sure the WASM target is installed before running the projects.
 > You can install the WASM target for rust using rustup:
 > 
 > ````
 > rustup target add wasm32-unknown-unknown
 > ````

Finally, serve your project with `dx serve`! The CLI will tell you the address it is serving on, along with additional info such as code warnings.
# Configure Project

This chapter will teach you how to configure the CLI with the `Dioxus.toml` file. There's an [example](#config-example) which has comments to describe individual keys. You can copy that or view this documentation for a more complete learning experience.

"ðŸ”’" indicates a mandatory item. Some headers are mandatory, but none of the keys inside them are. In that case, you only need to include the header, but no keys. It might look weird, but it's normal.

## Structure

Each header has its TOML form directly under it.

### Application ðŸ”’

````toml
[application]
````

Application-wide configuration. Applies to both web and desktop.

* **name** ðŸ”’ - Project name & title.
  ````toml
  name = "my_project"
  ````

* **default_platform** ðŸ”’ - The platform this project targets
  ````toml
  # Currently supported platforms: web, desktop
  default_platform = "web"
  ````

* **out_dir** - The directory to place the build artifacts from `dx build` or `dx serve` into. This is also where the `assets` directory will be copied into.
  ````toml
  out_dir = "dist"
  ````

* **asset_dir** - The directory with your static assets. The CLI will automatically copy these assets into the **out_dir** after a build/serve.
  ````toml
  asset_dir = "public"
  ````

* **sub_package** - The sub package in the workspace to build by default.
  ````toml
  sub_package = "my-crate"
  ````

### Web.App ðŸ”’

````toml
[web.app]
````

Web-specific configuration.

* **title** - The title of the web page.
  ````toml
  # HTML title tag content
  title = "project_name"
  ````

* **base_path** - The base path to build the application for serving at. This can be useful when serving your application in a subdirectory under a domain. For example, when building a site to be served on GitHub Pages.
  ````toml
  # The application will be served at domain.com/my_application/, so we need to modify the base_path to the path where the application will be served
  base_path = "my_application"
  ````

### Web.Watcher ðŸ”’

````toml
[web.watcher]
````

Development server configuration.

* **reload_html** - If this is true, the cli will rebuild the index.html file every time the application is rebuilt
  
  ````toml
  reload_html = true
  ````

* **watch_path** - The files & directories to monitor for changes
  
  ````toml
  watch_path = ["src", "public"]
  ````

* **index_on_404** - If enabled, Dioxus will serve the root page when a route is not found.
  *This is needed when serving an application that uses the router*. However, when serving your app using something else than Dioxus (e.g. GitHub Pages), you will have to check how to configure it on that platform. In GitHub Pages, you can make a copy of `index.html` named `404.html` in the same directory.
  
  ````toml
  index_on_404 = true
  ````

### Web.Resource ðŸ”’

````toml
[web.resource]
````

Static resource configuration.

* **style** - CSS files to include in your application.
  
  ````toml
  style = [
     # Include from public_dir.
     "./assets/style.css",
     # Or some asset from online cdn.
     "https://cdn.jsdelivr.net/npm/bootstrap/dist/css/bootstrap.css"
  ]
  ````

* **script** - JavaScript files to include in your application.
  
  ````toml
  script = [
      # Include from asset_dir.
      "./public/index.js",
      # Or from an online CDN.
      "https://cdn.jsdelivr.net/npm/bootstrap/dist/js/bootstrap.js"
  ]
  ````

### Web.Resource.Dev ðŸ”’

````toml
[web.resource.dev]
````

This is the same as [`[web.resource]`](#webresource-), but it only works in development servers. For example, if you want to include a file in a `dx serve` server, but not a `dx serve --release` server, put it here.

### Web.Proxy

````toml
[[web.proxy]]
````

Configuration related to any proxies your application requires during development. Proxies will forward requests to a new service.

* **backend** - The URL to the server to proxy. The CLI will forward any requests under the backend relative route to the backend instead of returning 404
  ````toml
  backend = "http://localhost:8000/api/"
  ````
  
  This will cause any requests made to the dev server with prefix /api/ to be redirected to the backend server at http://localhost:8000. The path and query parameters will be passed on as-is (path rewriting is currently not supported).

## Config example

This includes all fields, mandatory or not.

````toml
[application]

# App name
name = "project_name"

# The Dioxus platform to default to
default_platform = "web"

# `build` & `serve` output path
out_dir = "dist"

# The static resource path
asset_dir = "public"

[web.app]

# HTML title tag content
title = "project_name"

[web.watcher]

# When watcher is triggered, regenerate the `index.html`
reload_html = true

# Which files or dirs will be monitored
watch_path = ["src", "public"]

# Include style or script assets
[web.resource]

# CSS style file
style = []

# Javascript code file
script = []

[web.resource.dev]

# Same as [web.resource], but for development servers

# CSS style file
style = []

# JavaScript files
script = []

[[web.proxy]]
backend = "http://localhost:8000/api/"
````

## Desktop and TUI

For the desktop and TUI (terminal user interface) renderers,
Dioxus bundles your app using `dx bundle` and the [tauri-bundler](https://docs.rs/crate/tauri-bundler/latest).

You can check out the [tauri-bundler docs.rs](https://docs.rs/tauri-bundler/latest/tauri_bundler/bundle/index.html).
This covers all the different settings. Keep in mind that `FooSettings` becomes just `foo` in the TOML.

Tauri uses a JSON file for the configuration, but Dioxus uses TOML. So this tauri-bundler example:

````json
{
  "package": {
    "productName": "Your Awesome App",
    "version": "0.1.0"
  },
  "tauri": {
    "bundle": {
      "active": true,
      "identifier": "com.my.app",
      "shortDescription": "",
      "longDescription": "",
      "copyright": "Copyright (c) You 2021. All rights reserved.",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ],
      "resources": ["./assets/**/*.png"],
      "deb": {
        "depends": ["debian-dependency1", "debian-dependency2"]
      },
      "macOS": {
        "frameworks": [],
        "minimumSystemVersion": "10.11",
        "license": "./LICENSE"
      },
      "externalBin": ["./sidecar-app"]
    }
  }
}
````

needs to be translated to TOML.

However, Dioxus has Dioxus-specific mandatory TOML fields that we need to include as well.
We can see what fields are mandatory from the documentation above.

Additionally, we also need to remove `tauri` from the TOML headers.

This is our final `Dioxus.toml`:

````toml
# From Dioxus
[application]
name = "Your Awesome App"
default_platform = "desktop"

# You might only be running on desktop, but the following "web" values are still required.
[web.app]
title = "Awesome"

[web.watcher]

[web.resource.dev]

# From the tauri-bundler.
[package]
productName = "Your Awesome App"
version = "0.1.0"

[bundle]
active = true
identifier = "com.my.app"
shortDescription = ""
longDescription = ""
copyright = "Copyright (c) You 2021. All rights reserved."
icon = [
  "icons/32x32.png",
  "icons/128x128.png",
  "icons/128x128@2x.png",
  "icons/icon.icns",
  "icons/icon.ico"
]
resources = [ "./assets/**/*.png" ]
externalBin = [ "./sidecar-app" ]

[bundle.deb]
depends = [ "debian-dependency1", "debian-dependency2" ]

[bundle.macOS]
frameworks = [ ]
minimumSystemVersion = "10.11"
license = "./LICENSE"
````
# Translating existing HTML

Dioxus uses a custom format called RSX to represent the HTML because it is more concise and looks more like Rust code. However, it can be a pain to convert existing HTML to RSX. That's why Dioxus comes with a tool called `dx translate` that can automatically convert HTML to RSX!

Dx translate can make converting large chunks of HTML to RSX much easier! Lets try translating some of the HTML from the Dioxus homepage:

````sh
dx translate --raw  "<div class=\"relative w-full mx-4 sm:mx-auto text-gray-600\"><div class=\"text-[3em] md:text-[5em] font-semibold dark:text-white text-ghdarkmetal font-sans py-12 flex flex-col\"><span>Fullstack, crossplatform,</span><span>lightning fast, fully typed.</span></div><h3 class=\"text-[2em] dark:text-white font-extralight text-ghdarkmetal pt-4 max-w-screen-md mx-auto\">Dioxus is a Rust library for building apps that run on desktop, web, mobile, and more.</h3><div class=\"pt-12 text-white text-[1.2em] font-sans font-bold flex flex-row justify-center space-x-4\"><a href=\"/learn/0.4/getting_started\" dioxus-prevent-default=\"onclick\" class=\"bg-red-600 py-2 px-8 hover:-translate-y-2 transition-transform duration-300\" data-dioxus-id=\"216\">Quickstart</a><a href=\"/learn/0.4/reference\" dioxus-prevent-default=\"onclick\" class=\"bg-blue-500 py-2 px-8 hover:-translate-y-2 transition-transform duration-300\" data-dioxus-id=\"214\">Read the docs</a></div><div class=\"max-w-screen-2xl mx-auto pt-36\"><h1 class=\"text-md\">Trusted by top companies</h1><div class=\"pt-4 flex flex-row flex-wrap justify-center\"><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/futurewei_bw.png\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/airbuslogo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/ESA_logo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/yclogo.svg\"></div><div class=\"h-12 w-40 bg-black p-2 m-4 flex justify-center items-center\"><img src=\"static/satellite.webp\"></div></div></div></div>"
````

We get the following RSX you can easily copy and paste into your code:

````rs
div { class: "relative w-full mx-4 sm:mx-auto text-gray-600",
   div { class: "text-[3em] md:text-[5em] font-semibold dark:text-white text-ghdarkmetal font-sans py-12 flex flex-col",
      span { "Fullstack, crossplatform," }
      span { "lightning fast, fully typed." }
   }
   h3 { class: "text-[2em] dark:text-white font-extralight text-ghdarkmetal pt-4 max-w-screen-md mx-auto",
      "Dioxus is a Rust library for building apps that run on desktop, web, mobile, and more."
   }
   div { class: "pt-12 text-white text-[1.2em] font-sans font-bold flex flex-row justify-center space-x-4",
      a {
         href: "/learn/0.4/getting_started",
         data_dioxus_id: "216",
         dioxus_prevent_default: "onclick",
         class: "bg-red-600 py-2 px-8 hover:-translate-y-2 transition-transform duration-300",
         "Quickstart"
      }
      a {
         dioxus_prevent_default: "onclick",
         href: "/learn/0.4/reference",
         data_dioxus_id: "214",
         class: "bg-blue-500 py-2 px-8 hover:-translate-y-2 transition-transform duration-300",
         "Read the docs"
      }
   }
   div { class: "max-w-screen-2xl mx-auto pt-36",
      h1 { class: "text-md", "Trusted by top companies" }
      div { class: "pt-4 flex flex-row flex-wrap justify-center",
         div { class: "h-12 w-40 bg-black p-2 m-4 flex justify-center items-center",
            img { src: "static/futurewei_bw.png" }
         }
         div { class: "h-12 w-40 bg-black p-2 m-4 flex justify-center items-center",
            img { src: "static/airbuslogo.svg" }
         }
         div { class: "h-12 w-40 bg-black p-2 m-4 flex justify-center items-center",
            img { src: "static/ESA_logo.svg" }
         }
         div { class: "h-12 w-40 bg-black p-2 m-4 flex justify-center items-center",
            img { src: "static/yclogo.svg" }
         }
         div { class: "h-12 w-40 bg-black p-2 m-4 flex justify-center items-center",
            img { src: "static/satellite.webp" }
         }
      }
   }
}
````

## Usage

The `dx translate` command has several flags you can use to control your html input and rsx output.

You can use the `--file` flag to translate an HTML file to RSX:

````sh
dx translate --file index.html
````

Or you can use the `--raw` flag to translate a string of HTML to RSX:

````sh
dx translate --raw "<div>Hello world</div>"
````

Both of those commands will output the following RSX:

````rs
div { "Hello world" }
````

The `dx translate` command will output the RSX to stdout. You can use the `--output` flag to write the RSX to a file instead.

````sh
dx translate --raw "<div>Hello world</div>" --output index.rs
````

You can automatically create a component with the `--component` flag.

````sh
dx translate --raw "<div>Hello world</div>" --component
````

This will output the following component:

````rs
fn component(cx: Scope) -> Element {
   cx.render(rsx! {
      div { "Hello world" }
   })
}
````

To learn more about the different flags `dx translate` supports, run `dx translate --help`.
# Contributing

Development happens in the [Dioxus GitHub repository](https://github.com/DioxusLabs/dioxus). If you've found a bug or have an idea for a feature, please submit an issue (but first check if someone hasn't [done it already](https://github.com/DioxusLabs/dioxus/issues)).

[GitHub discussions](https://github.com/DioxusLabs/dioxus/discussions) can be used as a place to ask for help or talk about features. You can also join [our Discord channel](https://discord.gg/XgGxMSkvUM) where some development discussion happens.

## Improving Docs

If you'd like to improve the docs, PRs are welcome! Both Rust docs ([source](https://github.com/DioxusLabs/dioxus/tree/master/packages)) and this guide ([source](https://github.com/DioxusLabs/dioxus/tree/master/docs/guide)) can be found in the GitHub repo.

## Working on the Ecosystem

Part of what makes React great is the rich ecosystem. We'd like the same for Dioxus! So if you have a library in mind that you'd like to write and many people would benefit from, it will be appreciated. You can [browse npm.js](https://www.npmjs.com/search?q=keywords:react-component) for inspiration. Once you are done, add your library to the [awesome dioxus](https://github.com/DioxusLabs/awesome-dioxus) list or share it in the `#I-made-a-thing` channel on [Discord](https://discord.gg/XgGxMSkvUM).

## Bugs & Features

If you've fixed [an open issue](https://github.com/DioxusLabs/dioxus/issues), feel free to submit a PR! You can also take a look at [the roadmap](./roadmap.md) and work on something in there. Consider [reaching out](https://discord.gg/XgGxMSkvUM) to the team first to make sure everyone's on the same page, and you don't do useless work!

All pull requests (including those made by a team member) must be approved by at least one other team member.
Larger, more nuanced decisions about design, architecture, breaking changes, trade-offs, etc. are made by team consensus.

## Before you contribute

You might be surprised that a lot of checks fail when making your first PR.
That's why you should first run these commands before contributing, and it will save you *lots* of time, because the
GitHub CI is much slower at executing all of these than your PC.

* Format code with [rustfmt](https://github.com/rust-lang/rustfmt):

````sh
cargo fmt --all
````

* Check all code [cargo check](https://doc.rust-lang.org/cargo/commands/cargo-check.html):

````sh
cargo check --workspace --examples --tests
````

* Check if [Clippy](https://doc.rust-lang.org/clippy/) generates any warnings. Please fix these!

````sh
cargo clippy --workspace --examples --tests -- -D warnings
````

* Test all code with [cargo-test](https://doc.rust-lang.org/cargo/commands/cargo-test.html):

````sh
cargo test --all --tests
````

* More tests, this time with [cargo-make](https://sagiegurari.github.io/cargo-make/). Here are all steps, including installation:

````sh
cargo install --force cargo-make
cargo make tests
````

* Test unsafe crates with [MIRI](https://github.com/rust-lang/miri). Currently, this is used for the two MIRI tests in `dioxus-core` and `dioxus-native-core`:

````sh
cargo miri test --package dioxus-core --test miri_stress
cargo miri test --package dioxus-native-core --test miri_native
````

* Test with Playwright. This tests the UI itself, right in a browser. Here are all steps, including installation:
  **Disclaimer: This might inexplicably fail on your machine without it being your fault.** Make that PR anyway!

````sh
cd playwright-tests
npm ci
npm install -D @playwright/test
npx playwright install --with-deps
npx playwright test
````

## How to test dioxus with local crate

If you are developing a feature, you should test it in your local setup before raising a PR. This process makes sure you are aware of your code functionality before being reviewed by peers.

* Fork the following github repo (DioxusLabs/dioxus):

`https://github.com/DioxusLabs/dioxus`

* Create a new or use an existing rust crate (ignore this step if you will use an existing rust crate):
  This is where we will be testing the features of the forked

````sh
cargo new --bin demo
````

* Add the dioxus dependencies for your rust crate (new/existing) in cargo.toml:

````toml
dioxus = { path = "<path to forked dioxus project>/dioxus/packages/dioxus/" }

dioxus-web = { path = "<path to forked dioxus project>/dioxus/packages/web/" }
````

This above example is for dioxus-web. To know about the dependencies for different renderer visit [here](https://dioxuslabs.com/learn/0.4/getting_started).

* Run and test your feature

````sh
dx serve
````

If this is your first time with dioxus, please read [the guide](https://dioxuslabs.com/learn/0.4/guide) to get familiar with dioxus.
# Project Structure

There are many packages in the Dioxus organization. This document will help you understand the purpose of each package and how they fit together.

## Renderers

* [Desktop](https://github.com/DioxusLabs/dioxus/tree/master/packages/desktop): A Render that Runs Dioxus applications natively, but renders them with the system webview
* [Mobile](https://github.com/DioxusLabs/dioxus/tree/master/packages/mobile): A Render that Runs Dioxus applications natively, but renders them with the system webview. This is currently a copy of the desktop render
* [Web](https://github.com/DioxusLabs/dioxus/tree/master/packages/web): Renders Dioxus applications in the browser by compiling to WASM and manipulating the DOM
* [Liveview](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview): A Render that Runs on the server, and renders using a websocket proxy in the browser
* [Rink](https://github.com/DioxusLabs/dioxus/tree/master/packages/rink): A Renderer that renders a HTML-like tree into a terminal
* [TUI](https://github.com/DioxusLabs/dioxus/tree/master/packages/dioxus-tui): A Renderer that uses Rink to render a Dioxus application in a terminal
* [Blitz-Core](https://github.com/DioxusLabs/blitz/tree/master/blitz-core): An experimental native renderer that renders a HTML-like tree using WGPU.
* [Blitz](https://github.com/DioxusLabs/blitz): An experimental native renderer that uses Blitz-Core to render a Dioxus application using WGPU.
* [SSR](https://github.com/DioxusLabs/dioxus/tree/master/packages/ssr): A Render that Runs Dioxus applications on the server, and renders them to HTML

## State Management/Hooks

* [Hooks](https://github.com/DioxusLabs/dioxus/tree/master/packages/hooks): A collection of common hooks for Dioxus applications
* [Signals](https://github.com/DioxusLabs/dioxus/tree/master/packages/signals): A experimental state management library for Dioxus applications. This currently contains a `Copy` version of UseRef
* [Dioxus STD](https://github.com/DioxusLabs/dioxus-std): A collection of platform agnostic hooks to interact with system interfaces (The clipboard, camera, etc.).
* [Fermi](https://github.com/DioxusLabs/dioxus/tree/master/packages/fermi): A global state management library for Dioxus applications.
* [Router](https://github.com/DioxusLabs/dioxus/tree/master/packages/router): A client-side router for Dioxus applications

## Core utilities

* [core](https://github.com/DioxusLabs/dioxus/tree/master/packages/core): The core virtual dom implementation every Dioxus application uses
  * You can read more about the architecture of the core [in this blog post](https://dioxuslabs.com/blog/templates-diffing/) and the [custom renderer section of the guide](../cookbook/custom_renderer.md)
* [RSX](https://github.com/DioxusLabs/dioxus/tree/master/packages/rsx): The core parsing for RSX used for hot reloading, autoformatting, and the macro
* [core-macro](https://github.com/DioxusLabs/dioxus/tree/master/packages/core-macro): The rsx! macro used to write Dioxus applications. (This is a wrapper over the RSX crate)
* [HTML macro](https://github.com/DioxusLabs/dioxus-html-macro): A html-like alternative to the RSX macro

## Native Renderer Utilities

* [native-core](https://github.com/DioxusLabs/dioxus/tree/master/packages/native-core): Incrementally computed tree of states (mostly styles)
  * You can read more about how native-core can help you build native renderers in the [custom renderer section of the guide](../cookbook/custom_renderer.md#native-core)
* [native-core-macro](https://github.com/DioxusLabs/dioxus/tree/master/packages/native-core-macro): A helper macro for native core
* [Taffy](https://github.com/DioxusLabs/taffy): Layout engine powering Blitz-Core, Rink, and Bevy UI

## Web renderer tooling

* [HTML](https://github.com/DioxusLabs/dioxus/tree/master/packages/html): defines html specific elements, events, and attributes
* [Interpreter](https://github.com/DioxusLabs/dioxus/tree/master/packages/interpreter): defines browser bindings used by the web and desktop renderers

## Developer tooling

* [hot-reload](https://github.com/DioxusLabs/dioxus/tree/master/packages/hot-reload): Macro that uses the RSX crate to hot reload static parts of any rsx! macro. This macro works with any non-web renderer with an [integration](https://crates.io/crates/dioxus-hot-reload)
* [autofmt](https://github.com/DioxusLabs/dioxus/tree/master/packages/autofmt): Formats RSX code
* [rsx-rosetta](https://github.com/DioxusLabs/dioxus/tree/master/packages/rsx-rosetta): Handles conversion between HTML and RSX
* [CLI](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli): A Command Line Interface and VSCode extension to assist with Dioxus usage
# Walkthrough of the Hello World Example Internals

This walkthrough will take you through the internals of the Hello World example program. It will explain how major parts of Dioxus internals interact with each other to take the readme example from a source file to a running application. This guide should serve as a high-level overview of the internals of Dioxus. It is not meant to be a comprehensive guide.

The core crate roughly works like this:

![](https://mermaid.ink/img/pako:eNqNk01v2zAMhv8KocsuTQ876lCgWAb0sGDD0mMAg7PoWogsBvpwWhT976MlJ3OKbKtOEvmIfEWRr6plQ0qrmDDR2uJTwGE1ft55kBXIGwqNHQYyVvywWt3BA3rjKGj4gs5BX0-V_1n4QtUthW_Mh6WzWgryg537OpJPsQJ_zsX9PrmG0fBwWxM2NIH1nmdRFuxTn4C7K4mn9djTpYAjWsnTcQBaSJiWxIcULEVILCIiu5Egyf3RhpTRwfr75tOC73LKggGmQkUcBLcDVUJyFoF_qcEkoxEVzZHDvjIXpnOhtm1PJp8rvcGw37Z8oPu4FlkvhVvbrivGypyP_3dWXRo2WdrAsp-fN391Qd5n1BBnSU0-GDy9sHyGo678xcOyOU7fMHcMHINNtcgIPfP-Wr2WAu6NeeRzGTS0z7fxgEd_7T3_Zi8b5kp1T1IxvvgWfjlu9x-SexHqo1VTN2qgMKA1MoavU6CdkkaSBlJatoY6zC7t1M6_CYo58VZUKZ1CphtVo8yDq3SHLopVJiZx2NTRLhP-9htxEk8q?type=png)

## The Source File

We start will a hello world program. This program renders a desktop app with the text "Hello World" in a webview.

````rs@readme.rs
use dioxus::prelude::*;

pub fn App(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    })
}

````

[![](https://mermaid.ink/img/pako:eNqNkT1vwyAQhv8KvSlR48HphtQtqjK0S6tuSBGBS0CxwcJHk8rxfy_YVqxKVdR3ug_u4YXrQHmNwOFQ-bMyMhB7fReOJbVxfwyyMSy0l7GSpW1ARda727ksUy5MuSyKgvBC5ULA1h5N8WK_kCkfHWHgrBuiXsBynrvdsY9E3u1iM_eyvFOVVadMnELOap-o1911JLPHZ1b-YqLTc3LjTt7WifTZMJPsPdx1ov3Z_ellfcdL8R8vmTy5eUqsTUpZ-vzZzjAEK6gx1NLqtJwuNwSQwRoF8BRqGU4ChOvTORnJf3w7BZxCxBXERkvCjZXpQTXwg6zaVEVtyYe3cdvD0vsf4bucgw?type=png)](https://mermaid.live/edit#pako:eNqNkT1vwyAQhv8KvSlR48HphtQtqjK0S6tuSBGBS0CxwcJHk8rxfy_YVqxKVdR3ug_u4YXrQHmNwOFQ-bMyMhB7fReOJbVxfwyyMSy0l7GSpW1ARda727ksUy5MuSyKgvBC5ULA1h5N8WK_kCkfHWHgrBuiXsBynrvdsY9E3u1iM_eyvFOVVadMnELOap-o1911JLPHZ1b-YqLTc3LjTt7WifTZMJPsPdx1ov3Z_ellfcdL8R8vmTy5eUqsTUpZ-vzZzjAEK6gx1NLqtJwuNwSQwRoF8BRqGU4ChOvTORnJf3w7BZxCxBXERkvCjZXpQTXwg6zaVEVtyYe3cdvD0vsf4bucgw)

## The rsx! Macro

Before the Rust compiler runs the program, it will expand all [macros](https://doc.rust-lang.org/reference/procedural-macros.html). Here is what the hello world example looks like expanded:

````rs@readme_expanded.rs
use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);

    cx.render(
        // rsx expands to LazyNodes::new
        ::dioxus::core::LazyNodes::new(
            move |__cx: &::dioxus::core::ScopeState| -> ::dioxus::core::VNode {
                // The template is every static part of the rsx
                static TEMPLATE: ::dioxus::core::Template = ::dioxus::core::Template {
                    // This is the source location of the rsx that generated this template. This is used to make hot rsx reloading work. Hot rsx reloading just replaces the template with a new one generated from the rsx by the CLI.
                    name: "examples\\readme.rs:14:15:250",
                    // The root nodes are the top level nodes of the rsx
                    roots: &[
                        // The h1 node
                        ::dioxus::core::TemplateNode::Element {
                            // Find the built in h1 tag in the dioxus_elements crate exported by the dioxus html crate
                            tag: dioxus_elements::h1::TAG_NAME,
                            namespace: dioxus_elements::h1::NAME_SPACE,
                            attrs: &[],
                            // The children of the h1 node
                            children: &[
                                // The dynamic count text node
                                // Any nodes that are dynamic have a dynamic placeholder with a unique index
                                ::dioxus::core::TemplateNode::DynamicText {
                                    // This index is used to find what element in `dynamic_nodes` to use instead of the placeholder
                                    id: 0usize,
                                },
                            ],
                        },
                        // The up high button node
                        ::dioxus::core::TemplateNode::Element {
                            tag: dioxus_elements::button::TAG_NAME,
                            namespace: dioxus_elements::button::NAME_SPACE,
                            attrs: &[
                                // The dynamic onclick listener attribute
                                // Any attributes that are dynamic have a dynamic placeholder with a unique index.
                                ::dioxus::core::TemplateAttribute::Dynamic {
                                    // Similar to dynamic nodes, dynamic attributes have a unique index used to find the attribute in `dynamic_attrs` to use instead of the placeholder
                                    id: 0usize,
                                },
                            ],
                            children: &[::dioxus::core::TemplateNode::Text { text: "Up high!" }],
                        },
                        // The down low button node
                        ::dioxus::core::TemplateNode::Element {
                            tag: dioxus_elements::button::TAG_NAME,
                            namespace: dioxus_elements::button::NAME_SPACE,
                            attrs: &[
                                // The dynamic onclick listener attribute
                                ::dioxus::core::TemplateAttribute::Dynamic { id: 1usize },
                            ],
                            children: &[::dioxus::core::TemplateNode::Text { text: "Down low!" }],
                        },
                    ],
                    // Node paths is a list of paths to every dynamic node in the rsx
                    node_paths: &[
                        // The first node path is the path to the dynamic node with an id of 0 (the count text node)
                        &[
                            // Go to the index 0 root node
                            0u8, //
                            // Go to the first child of the root node
                            0u8,
                        ],
                    ],
                    // Attr paths is a list of paths to every dynamic attribute in the rsx
                    attr_paths: &[
                        // The first attr path is the path to the dynamic attribute with an id of 0 (the up high button onclick listener)
                        &[
                            // Go to the index 1 root node
                            1u8,
                        ],
                        // The second attr path is the path to the dynamic attribute with an id of 1 (the down low button onclick listener)
                        &[
                            // Go to the index 2 root node
                            2u8,
                        ],
                    ],
                };
                // The VNode is a reference to the template with the dynamic parts of the rsx
                ::dioxus::core::VNode {
                    parent: None,
                    key: None,
                    // The static template this node will use. The template is stored in a Cell so it can be replaced with a new template when hot rsx reloading is enabled
                    template: std::cell::Cell::new(TEMPLATE),
                    root_ids: dioxus::core::exports::bumpalo::collections::Vec::with_capacity_in(
                        3,
                        __cx.bump(),
                    )
                    .into(),
                    dynamic_nodes: __cx.bump().alloc([
                        // The dynamic count text node (dynamic node id 0)
                        __cx.text_node(format_args!("High-Five counter: {0}", count)),
                    ]),
                    dynamic_attrs: __cx.bump().alloc([
                        // The dynamic up high button onclick listener (dynamic attribute id 0)
                        dioxus_elements::events::onclick(__cx, move |_| count += 1),
                        // The dynamic down low button onclick listener (dynamic attribute id 1)
                        dioxus_elements::events::onclick(__cx, move |_| count -= 1),
                    ]),
                }
            },
        ),
    )
}

````

The rsx macro separates the static parts of the rsx (the template) and the dynamic parts (the [dynamic_nodes](https://docs.rs/dioxus-core/0.3.2/dioxus_core/prelude/struct.VNode.html#structfield.dynamic_nodes) and [dynamic_attributes](https://docs.rs/dioxus-core/0.3.2/dioxus_core/prelude/struct.VNode.html#structfield.dynamic_attrs)).

The static template only contains the parts of the rsx that cannot change at runtime with holes for the dynamic parts:

[![](https://mermaid.ink/img/pako:eNqdksFuwjAMhl8l8wkkKtFx65njdtm0E0GVSQKJoEmVOgKEeHecUrXStO0wn5Lf9u8vcm6ggjZQwf4UzspiJPH2Ib3g6NLuELG1oiMkp0TsLs9EDu2iUeSCH8tz2HJmy3lRFPrqsXGq9mxeLzcbCU6LZSUGXWRdwnY7tY7Tdoko-Dq1U64fODgiUfzJMeuOe7_ZGq-ny2jNhGQu9DqT8NUK6w72RcL8dxgdzv4PnHLAKf-Fk80HoBUDrfkqeBkTUd8EC2hMbNBpXtYtJySQNQ0PqPioMR4lSH_nOkwUPq9eQUUxmQWkViOZtUN-UwPVHk8dq0Y7CvH9uf3-E9wfrmuk1A?type=png)](https://mermaid.live/edit#pako:eNqdksFuwjAMhl8l8wkkKtFx65njdtm0E0GVSQKJoEmVOgKEeHecUrXStO0wn5Lf9u8vcm6ggjZQwf4UzspiJPH2Ib3g6NLuELG1oiMkp0TsLs9EDu2iUeSCH8tz2HJmy3lRFPrqsXGq9mxeLzcbCU6LZSUGXWRdwnY7tY7Tdoko-Dq1U64fODgiUfzJMeuOe7_ZGq-ny2jNhGQu9DqT8NUK6w72RcL8dxgdzv4PnHLAKf-Fk80HoBUDrfkqeBkTUd8EC2hMbNBpXtYtJySQNQ0PqPioMR4lSH_nOkwUPq9eQUUxmQWkViOZtUN-UwPVHk8dq0Y7CvH9uf3-E9wfrmuk1A)

The dynamic_nodes and dynamic_attributes are the parts of the rsx that can change at runtime:

[![](https://mermaid.ink/img/pako:eNp1UcFOwzAM_RXLVzZpvUbighDiABfgtkxTlnirtSaZUgc0df130hZEEcwny35-79nu0EZHqHDfxA9bmyTw9KIDlGjz7pDMqQZ3DsazhVCQ7dQbwnEiKxwDvN3NqhN4O4C3q_VaIztYKXjkQ7184HcCG3MQSgq6Mes1bjbTPAV3RdqIJN5l-V__2_Fcf5iY68dgG7ZHBT4WD5ftZfIBN7dQ_Tj4w1B9MVTXGZa_GMYdcIGekjfsymW7oaFRavKkUZXUmXTUqENfcCZLfD0Hi0pSpgXmkzNC92zKATyqvWnaUiXHEtPz9KrxY_0nzYOPmA?type=png)](https://mermaid.live/edit#pako:eNp1UcFOwzAM_RXLVzZpvUbighDiABfgtkxTlnirtSaZUgc0df130hZEEcwny35-79nu0EZHqHDfxA9bmyTw9KIDlGjz7pDMqQZ3DsazhVCQ7dQbwnEiKxwDvN3NqhN4O4C3q_VaIztYKXjkQ7184HcCG3MQSgq6Mes1bjbTPAV3RdqIJN5l-V__2_Fcf5iY68dgG7ZHBT4WD5ftZfIBN7dQ_Tj4w1B9MVTXGZa_GMYdcIGekjfsymW7oaFRavKkUZXUmXTUqENfcCZLfD0Hi0pSpgXmkzNC92zKATyqvWnaUiXHEtPz9KrxY_0nzYOPmA)

## Launching the App

The app is launched by calling the `launch` function with the root component. Internally, this function will create a new web view using [wry](https://docs.rs/wry/latest/wry/) and create a virtual dom with the root component (`fn app()` in the readme example). This guide will not explain the renderer in-depth, but you can read more about it in the [custom renderer](../cookbook/custom_renderer.md) section.

## The Virtual DOM

Before we dive into the initial render in the virtual DOM, we need to discuss what the virtual DOM is. The virtual DOM is a representation of the DOM that is used to diff the current DOM from the new DOM. This diff is then used to create a list of mutations that need to be applied to the DOM to bring it into sync with the virtual DOM.

The Virtual DOM roughly looks like this:

````rust, no_run
pub struct VirtualDom {
    // All the templates that have been created or set during hot reloading
    pub(crate) templates: FxHashMap<TemplateId, FxHashMap<usize, Template<'static>>>,

    // A slab of all the scopes that have been created
    pub(crate) scopes: ScopeSlab,

    // All scopes that have been marked as dirty
    pub(crate) dirty_scopes: BTreeSet<DirtyScope>,

    // Every element is actually a dual reference - one to the template and the other to the dynamic node in that template
    pub(crate) elements: Slab<ElementRef>,

    // This receiver is used to receive messages from hooks about what scopes need to be marked as dirty
    pub(crate) rx: futures_channel::mpsc::UnboundedReceiver<SchedulerMsg>,

    // The changes queued up to be sent to the renderer
    pub(crate) mutations: Mutations<'static>,
}
````

 > 
 > What is a [slab](https://docs.rs/slab/latest/slab/)?
 > 
 > A slab acts like a hashmap with integer keys if you don't care about the value of the keys. It is internally backed by a dense vector which makes it more efficient than a hashmap. When you insert a value into a slab, it returns an integer key that you can use to retrieve the value later.

 > 
 > How does Dioxus use slabs?
 > 
 > Dioxus uses "synchronized slabs" to communicate between the renderer and the VDOM. When a node is created in the Virtual DOM, an (elementId, mutation) pair is passed to the renderer to identify that node, which the renderer will then render in actual DOM. These ids are also used by the Virtual Dom to reference that node in future mutations, like setting an attribute on a node or removing a node. When the renderer sends an event to the Virtual Dom, it sends the ElementId of the node that the event was triggered on. The Virtual DOM uses this id to find that node in the slab and then run the necessary event handlers.

The virtual DOM is a tree of scopes. A new `Scope` is created for every component when it is first rendered and recycled when the component is unmounted.

Scopes serve three main purposes:

1. They store the state of hooks used by the component
1. They store the state for the context API (for example: using
   [use_shared_state_provider](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_shared_state_provider.html)).
1. They store the current and previous versions of the `VNode` that was rendered, so they can be
   diffed to generate the set of mutations needed to re-render it.

### The Initial Render

The root scope is created and rebuilt:

1. The root component is run
1. The root component returns a `VNode`
1. Mutations for this `VNode` are created and added to the mutation list (this may involve creating new child components)
1. The `VNode` is stored in the root's `Scope`.

After the root's `Scope` is built, all generated mutations are sent to the renderer, which applies them to the DOM.

After the initial render, the root `Scope` looks like this:

[![](https://mermaid.ink/img/pako:eNqtVE1P4zAQ_SuzPrWikRpWXCLtBRDisItWsOxhCaqM7RKricdyJrQV8N93QtvQNCkfEnOynydv3nxkHoVCbUQipjnOVSYDwc_L1AFbWd3dB-kzuEQkuFLoDUwDFkCZAek9nGDh0RlHK__atA1GkUUHf45f0YbppAqB_aOzIAvz-t7-chN_Y-1bw1WSJKsglIu2w9tktWXxIIuHURT5XCqTYa5NmDguw2R8c5MKq2GcgF46WTB_jafi9rZL0yi5q4jQTSrf9altO4okCn1Ratwyz55Qxuku2ITlTMgs6HCQimsPmb3PvqVi-L5gjXP3QcnxWnL8JZLrwGvR31n0KV-Bx6-r-oVkT_-3G1S-NQLbk9i8rj7udP2cixed2QcDCitHJiQw7ub3EVlNecrPjudG2-6soFO5VbMECmR9T5OnlUY4-AFxfw9aTFst3McU9TK1Otm6NEn_DubBYlX2_dglLXOz48FgwJmJ5lZTlhz6xWgNaFnyDgpymcARHO0W2a9J_l5w2wYXvHuGPcqaQ-rESBQmFNJq3nCPNZoK3l4sUSR81DLMUpG6Z_aTFeHV0imRUKjMSFReSzKnVnKGhUimMi8ZNdoShl-rlfmyOUfCS_cPcePz_B_Wl4pc?type=png)](https://mermaid.live/edit#pako:eNqtVE1P4zAQ_SuzPrWikRpWXCLtBRDisItWsOxhCaqM7RKricdyJrQV8N93QtvQNCkfEnOynydv3nxkHoVCbUQipjnOVSYDwc_L1AFbWd3dB-kzuEQkuFLoDUwDFkCZAek9nGDh0RlHK__atA1GkUUHf45f0YbppAqB_aOzIAvz-t7-chN_Y-1bw1WSJKsglIu2w9tktWXxIIuHURT5XCqTYa5NmDguw2R8c5MKq2GcgF46WTB_jafi9rZL0yi5q4jQTSrf9altO4okCn1Ratwyz55Qxuku2ITlTMgs6HCQimsPmb3PvqVi-L5gjXP3QcnxWnL8JZLrwGvR31n0KV-Bx6-r-oVkT_-3G1S-NQLbk9i8rj7udP2cixed2QcDCitHJiQw7ub3EVlNecrPjudG2-6soFO5VbMECmR9T5OnlUY4-AFxfw9aTFst3McU9TK1Otm6NEn_DubBYlX2_dglLXOz48FgwJmJ5lZTlhz6xWgNaFnyDgpymcARHO0W2a9J_l5w2wYXvHuGPcqaQ-rESBQmFNJq3nCPNZoK3l4sUSR81DLMUpG6Z_aTFeHV0imRUKjMSFReSzKnVnKGhUimMi8ZNdoShl-rlfmyOUfCS_cPcePz_B_Wl4pc)

### Waiting for Events

The Virtual DOM will only ever re-render a `Scope` if it is marked as dirty. Each hook is responsible for marking the `Scope` as dirty if the state has changed. Hooks can mark a scope as dirty by sending a message to the Virtual Dom's channel. You can see the [implementations](https://github.com/DioxusLabs/dioxus/tree/master/packages/hooks) for the hooks dioxus includes by default on how this is done. Calling `needs_update()` on a hook will also cause it to mark its scope as dirty.

There are generally two ways a scope is marked as dirty:

1. The renderer triggers an event: An event listener on this event may be called, which may mark a
   component as dirty, if processing the event resulted in any generated any mutations.
1. The renderer calls
   [`wait_for_work`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.VirtualDom.html#method.wait_for_work):
   This polls dioxus internal future queue. One of these futures may mark a component as dirty.

Once at least one `Scope` is marked as dirty, the renderer can call [`render_with_deadline`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.VirtualDom.html#method.render_with_deadline) to diff the dirty scopes.

### Diffing Scopes

When a user clicks the "up high" button, the root `Scope` will be marked as dirty by the `use_state` hook. The desktop renderer will then call `render_with_deadline`, which will diff the root `Scope`.

To start the diffing process, the component function is run. After the root component is run it, the root `Scope` will look like this:

[![](https://mermaid.ink/img/pako:eNrFVlFP2zAQ_iuen0BrpCaIl0i8AEJ72KQJtpcRFBnbJVYTn-U4tBXw33dpG5M2CetoBfdkny_ffb67fPIT5SAkjekkhxnPmHXk-3WiCVpZ3T9YZjJyDeDIDQcjycRCQVwmCTOGXEBhQEvtVvG1CWUldwo0-XX-6vVIF5W1GB9cWVbI1_PNL5v8jW3uPFbpmFOc2HK-GfA2WG1ZeJSFx0EQmJxxmUEupE01liEd394mVAkyjolYaFYgfu1P6N1dF8Yzua-cA51WphtTWzsLc872Zan9CnEGUkktuk6fFm_i5NxFRwn9bUimHrIvCT3-N2EBM70j5XBNOTwI5TrxmvQJkr7ELcHx67Jeggz0v92g8q0RaE-iP1193On6NyxecKUeJeFQaSdtTMLu_Xah5ctT_u94Nty2ZwU0zxWfxqQA5PecPq84kq9nfRw7SK0WDiEFZ4O37d34S_-08lFBVfb92KVb5HIrAp0WpjKYKeGyODLz0dohWIkaZNkiJqfkdLvIH6oRaTSoEmm0n06k0a5K0ZdpL61Io0Yt0nfpxc7UQ0_9cJrhyZ8syX-6brS706Mc489Vjja7fbWj3cxDqIdfJJqOaCFtwZTAV8hT7U0ovjBQRmiMS8HsNKGJfsE4Vjm4WWhOY2crOaKVEczJS8WwgAWNJywv0SuFcmB_rJ41y9fNiBqm_wA0MS9_AUuAiy0?type=png)](https://mermaid.live/edit#pako:eNrFVlFP2zAQ_iuen0BrpCaIl0i8AEJ72KQJtpcRFBnbJVYTn-U4tBXw33dpG5M2CetoBfdkny_ffb67fPIT5SAkjekkhxnPmHXk-3WiCVpZ3T9YZjJyDeDIDQcjycRCQVwmCTOGXEBhQEvtVvG1CWUldwo0-XX-6vVIF5W1GB9cWVbI1_PNL5v8jW3uPFbpmFOc2HK-GfA2WG1ZeJSFx0EQmJxxmUEupE01liEd394mVAkyjolYaFYgfu1P6N1dF8Yzua-cA51WphtTWzsLc872Zan9CnEGUkktuk6fFm_i5NxFRwn9bUimHrIvCT3-N2EBM70j5XBNOTwI5TrxmvQJkr7ELcHx67Jeggz0v92g8q0RaE-iP1193On6NyxecKUeJeFQaSdtTMLu_Xah5ctT_u94Nty2ZwU0zxWfxqQA5PecPq84kq9nfRw7SK0WDiEFZ4O37d34S_-08lFBVfb92KVb5HIrAp0WpjKYKeGyODLz0dohWIkaZNkiJqfkdLvIH6oRaTSoEmm0n06k0a5K0ZdpL61Io0Yt0nfpxc7UQ0_9cJrhyZ8syX-6brS706Mc489Vjja7fbWj3cxDqIdfJJqOaCFtwZTAV8hT7U0ovjBQRmiMS8HsNKGJfsE4Vjm4WWhOY2crOaKVEczJS8WwgAWNJywv0SuFcmB_rJ41y9fNiBqm_wA0MS9_AUuAiy0)

Next, the Virtual DOM will compare the new VNode with the previous VNode and only update the parts of the tree that have changed. Because of this approach, when a component is re-rendered only the parts of the tree that have changed will be updated in the DOM by the renderer.

The diffing algorithm goes through the list of dynamic attributes and nodes and compares them to the previous VNode. If the attribute or node has changed, a mutation that describes the change is added to the mutation list.

Here is what the diffing algorithm looks like for the root `Scope` (red lines indicate that a mutation was generated, and green lines indicate that no mutation was generated)

[![](https://mermaid.ink/img/pako:eNrFlFFPwjAQx7_KpT7Kko2Elya8qCE-aGLAJ5khpe1Yw9Zbug4k4He3OJjbGPig0T5t17tf_nf777aEo5CEkijBNY-ZsfAwDjW4kxfzhWFZDGNECxOOmYTIYAo2lsCyDG4xzVBLbcv8_RHKSG4V6orSIN0Wxrh8b2RYKr_uTyubd1W92GiWKg7aac6bOU3G803HbVk82xfP_Ok0JEqAT-FeLWJvpFYSOBbaSkMhCMnra5MgtfhWFrPWqHlhL2urT6atbU-oa0PNE8WXFFJ0-nazXakRroddGk9IwYEUnCd5w7Pddr5UTT8ZuVJY5F0fM7ebRLYyXNDgUnprJWxM-9lb7xAQLHe-M2xDYQCD9pD_2hez_kVn-P_rjLq6n3qjYv2iO5qz9DyvPdyv1ETp5eTTJ_7BGvQq8v1TVtl5jXUcRRcrqFh-dI4VtFlBN6t_ynLNkh5JpUmZEm5rbvfhkLiN6H4BQt2jYGYZklC_uzxWWJxsNCfUmkL2SJEJZuWdYs4cKaERS3IXlUJZNI_lGv7cxj2SMf2CeMx5_wBcbK19?type=png)](https://mermaid.live/edit#pako:eNrFlFFPwjAQx7_KpT7Kko2Elya8qCE-aGLAJ5khpe1Yw9Zbug4k4He3OJjbGPig0T5t17tf_nf777aEo5CEkijBNY-ZsfAwDjW4kxfzhWFZDGNECxOOmYTIYAo2lsCyDG4xzVBLbcv8_RHKSG4V6orSIN0Wxrh8b2RYKr_uTyubd1W92GiWKg7aac6bOU3G803HbVk82xfP_Ok0JEqAT-FeLWJvpFYSOBbaSkMhCMnra5MgtfhWFrPWqHlhL2urT6atbU-oa0PNE8WXFFJ0-nazXakRroddGk9IwYEUnCd5w7Pddr5UTT8ZuVJY5F0fM7ebRLYyXNDgUnprJWxM-9lb7xAQLHe-M2xDYQCD9pD_2hez_kVn-P_rjLq6n3qjYv2iO5qz9DyvPdyv1ETp5eTTJ_7BGvQq8v1TVtl5jXUcRRcrqFh-dI4VtFlBN6t_ynLNkh5JpUmZEm5rbvfhkLiN6H4BQt2jYGYZklC_uzxWWJxsNCfUmkL2SJEJZuWdYs4cKaERS3IXlUJZNI_lGv7cxj2SMf2CeMx5_wBcbK19)

## Conclusion

This is only a brief overview of how the Virtual Dom works. There are several aspects not yet covered in this guide including:

* How the Virtual DOM handles async-components
* Keyed diffing
* Using [bump allocation](https://github.com/fitzgen/bumpalo) to efficiently allocate VNodes.

If you need more information about the Virtual Dom, you can read the code of the [core](https://github.com/DioxusLabs/dioxus/tree/master/packages/core) crate or reach out to us on [Discord](https://discord.gg/XgGxMSkvUM).
# Overall Goals

This document outlines some of the overall goals for Dioxus. These goals are not set in stone, but they represent general guidelines for the project.

The goal of Dioxus is to make it easy to build **cross-platform applications that scale**.

## Cross-Platform

Dioxus is designed to be cross-platform by default. This means that it should be easy to build applications that run on the web, desktop, and mobile. However, Dioxus should also be flexible enough to allow users to opt into platform-specific features when needed. The `use_eval` is one example of this. By default, Dioxus does not assume that the platform supports JavaScript, but it does provide a hook that allows users to opt into JavaScript when needed.

## Performance

As Dioxus applications grow, they should remain relatively performant without the need for manual optimizations. There will be cases where manual optimizations are needed, but Dioxus should try to make these cases as rare as possible.

One of the benefits of the core architecture of Dioxus is that it delivers reasonable performance even when components are rerendered often. It is based on a Virtual Dom which performs diffing which should prevent unnecessary re-renders even when large parts of the component tree are rerun. On top of this, Dioxus groups static parts of the RSX tree together to skip diffing them entirely.

## Type Safety

As teams grow, the Type safety of Rust is a huge advantage. Dioxus should leverage this advantage to make it easy to build applications with large teams.

To take full advantage of Rust's type system, Dioxus should try to avoid exposing public `Any` types and string-ly typed APIs where possible.

## Developer Experience

Dioxus should be easy to learn and ergonomic to use.

* The API of Dioxus attempts to remain close to React's API where possible. This makes it easier for people to learn Dioxus if they already know React

* We can avoid the tradeoff between simplicity and flexibility by providing multiple layers of API: One for the very common use case, one for low-level control
  
  * Hooks: the hooks crate has the most common use cases, but `cx.hook` provides a way to access the underlying persistent reference if needed.
  * The builder pattern in platform Configs: The builder pattern is used to default to the most common use case, but users can change the defaults if needed.
* Documentation:
  
  * All public APIs should have rust documentation
  * Examples should be provided for all public features. These examples both serve as documentation and testing. They are checked by CI to ensure that they continue to compile
  * The most common workflows should be documented in the guide
# Roadmap & Feature-set

This feature set and roadmap can help you decide if what Dioxus can do today works for you.

If a feature that you need doesn't exist or you want to contribute to projects on the roadmap, feel free to get involved by [joining the discord](https://discord.gg/XgGxMSkvUM).

Generally, here's the status of each platform:

* **Web**: Dioxus is a great choice for pure web-apps â€“ especially for CRUD/complex apps. However, it does lack the ecosystem of React, so you might be missing a component library or some useful hook.

* **SSR**: Dioxus is a great choice for pre-rendering, hydration, and rendering HTML on a web endpoint. Be warned â€“ the VirtualDom is not (currently) `Send + Sync`.

* **Desktop**: You can build very competent single-window desktop apps right now. However, multi-window apps require support from Dioxus core and are not ready.

* **Mobile**: Mobile support is very young. You'll be figuring things out as you go and there are not many support crates for peripherals.

* **LiveView**: LiveView support is very young. You'll be figuring things out as you go. Thankfully, none of it is too hard and any work can be upstreamed into Dioxus.

## Features

---

|Feature|Status|Description|
|-------|------|-----------|
|Conditional Rendering|x|if/then to hide/show component|
|Map, Iterator|x|map/filter/reduce to produce rsx!|
|Keyed Components|x|advanced diffing with keys|
|Web|x|renderer for web browser|
|Desktop (webview)|x|renderer for desktop|
|Shared State (Context)|x|share state through the tree|
|Hooks|x|memory cells in components|
|SSR|x|render directly to string|
|Component Children|x|cx.children() as a list of nodes|
|Headless components|x|components that don't return real elements|
|Fragments|x|multiple elements without a real root|
|Manual Props|x|Manually pass in props with spread syntax|
|Controlled Inputs|x|stateful wrappers around inputs|
|CSS/Inline Styles|x|syntax for inline styles/attribute groups|
|Custom elements|x|Define new element primitives|
|Suspense|x|schedule future render from future/promise|
|Integrated error handling|x|Gracefully handle errors with ? syntax|
|NodeRef|x|gain direct access to nodes|
|Re-hydration|x|Pre-render to HTML to speed up first contentful paint|
|Jank-Free Rendering|x|Large diffs are segmented across frames for silky-smooth transitions|
|Effects|x|Run effects after a component has been committed to render|
|Portals|\*|Render nodes outside of the traditional tree structure|
|Cooperative Scheduling|\*|Prioritize important events over non-important events|
|Server Components|\*|Hybrid components for SPA and Server|
|Bundle Splitting|i|Efficiently and asynchronously load the app|
|Lazy Components|i|Dynamically load the new components as the page is loaded|
|1st class global state|x|redux/recoil/mobx on top of context|
|Runs natively|x|runs as a portable binary w/o a runtime (Node)|
|Subtree Memoization|x|skip diffing static element subtrees|
|High-efficiency templates|x|rsx! calls are translated to templates on the DOM's side|
|Compile-time correct|x|Throw errors on invalid template layouts|
|Heuristic Engine|x|track component memory usage to minimize future allocations|
|Fine-grained reactivity|i|Skip diffing for fine-grain updates|

* x = implemented and working
* \* = actively being worked on
* i = not yet implemented or being worked on

## Roadmap

These Features are planned for the future of Dioxus:

### Core

* [x] Release of Dioxus Core
* [x] Upgrade documentation to include more theory and be more comprehensive
* [x] Support for HTML-side templates for lightning-fast dom manipulation
* [ ] Support for multiple renderers for same virtualdom (subtrees)
* [ ] Support for ThreadSafe (Send + Sync)
* [ ] Support for Portals

### SSR

* [x] SSR Support + Hydration
* [ ] Integrated suspense support for SSR

### Desktop

* [ ] Declarative window management
* [ ] Templates for building/bundling
* [ ] Access to Canvas/WebGL context natively

### Mobile

* [ ] Mobile standard library
  * [ ] GPS
  * [ ] Camera
  * [ ] filesystem
  * [ ] Biometrics
  * [ ] WiFi
  * [ ] Bluetooth
  * [ ] Notifications
  * [ ] Clipboard
* [ ] Animations

### Bundling (CLI)

* [x] Translation from HTML into RSX
* [x] Dev server
* [x] Live reload
* [x] Translation from JSX into RSX
* [ ] Hot module replacement
* [ ] Code splitting
* [ ] Asset macros
* [ ] Css pipeline
* [ ] Image pipeline

### Essential hooks

* [x] Router
* [x] Global state management
* [ ] Resize observer

## Work in Progress

### Build Tool

We are currently working on our own build tool called [Dioxus CLI](https://github.com/DioxusLabs/dioxus/tree/master/packages/cli) which will support:

* an interactive TUI
* on-the-fly reconfiguration
* hot CSS reloading
* two-way data binding between browser and source code
* an interpreter for `rsx!`
* ability to publish to github/netlify/vercel
* bundling for iOS/Desktop/etc

### Server Component Support

While not currently fully implemented, the expectation is that LiveView apps can be a hybrid between Wasm and server-rendered where only portions of a page are "live" and the rest of the page is either server-rendered, statically generated, or handled by the host SPA.

### Native rendering

We are currently working on a native renderer for Dioxus using WGPU called [Blitz](https://github.com/DioxusLabs/blitz/). This will allow you to build apps that are rendered natively for iOS, Android, and Desktop.
# 0.3 Migration Guide

This guide will outline the API changes between the `0.3` and `0.4` releases. The two major breaking changes in this release are how hot reloading works on desktop platforms and how the router works:

* [Hot reload](hot_reload.md)
* [Router](router.md)
# Router

The router has been entirely rewritten in the `0.4` release to provide type safe routes. This guide serves to help you upgrade your project to the new router. For more information on the router, see the [router guide](../router/index.md).

## Defining Your Router

Previously, you defined your route with components:

````rust
rsx! {
    Router::<Route> {
        Route { to: "/home", Home {} }
        Route { to: "/blog", Blog {} }
        // BlogPost has a dynamic id
        Route { to: "/blog/:id", BlogPost {} }
    }
}
````

Now you must define your routes as an enum of possible routes:

````rust
use dioxus::prelude::*;

#[derive(Routable, PartialEq, Debug, Clone)]
enum Route {
    #[route("/home")]
    // This route will render the Home component with the HomeProps props. (make sure you have the props imported)
    // You can modify the props by passing extra arguments to the macro. For example, if you want the Home variant to render a component called Homepage, you could use:
    // #[route("/home", Homepage)]
    Home {},
    #[route("/blog")]
    Blog {},
    // BlogPost has a dynamic id
    #[route("/blog/:id")]
    BlogPost {
        id: usize
    }
}

#[component]
fn Home(cx: Scope) -> Element {
    todo!()
}

#[component]
fn Blog(cx: Scope) -> Element {
    todo!()
}

#[component]
fn BlogPost(cx: Scope, id: usize) -> Element {
    // Note that you have access to id here in a type safe way without calling any extra functions!
    todo!()
}
````

## Linking to routes

Now that routes are enums, you should use the enum as the route in Links. If you try to link to a route that does not exist, you will get a compiler error.

````rust
use dioxus::prelude::*;

fn Component(cx: Scope) -> Element {
    render! {
        Link {
            to: Route::BlogPost { id: 123 },
            "blog post"
        }
    }
}
````

## External Links

To link to external routes, you can use a string:

````rust
use dioxus::prelude::*;

fn Component(cx: Scope) -> Element {
    render! {
        Link {
            to: "https://google.com",
            "google"
        }
    }
}
````

## use_router

The `use_router` hook has been split into two separate hooks: the `use_route` hook and the `use_navigator` hook.

### use_route

The new use_route hook lets you read the current route:

````rust
use dioxus::prelude::*;

#[derive(Clone, Routable)]
enum Route {
    #[route("/")]
    Index {},
}

fn App(cx: Scope) -> Element {
    render! {
        h1 { "App" }
        Router::<Route> {}
    }
}

#[component]
fn Index(cx: Scope) -> Element {
    // Read from (and subscribe to the current route)
    let path = use_route(&cx).unwrap();
    render! {
        h2 { "Current Path" }
        p { "{path}" }
    }
}
````

### use_navigator

`use_navigator` lets you change the route programmatically:

````rs@navigator.rs
#[component]
fn Home(cx: Scope) -> Element {
    let nav = use_navigator(cx);

    // push
    nav.push(Route::PageNotFound { route: vec![] });

    // replace
    nav.replace(Route::Home {});

    // go back
    nav.go_back();

    // go forward
    nav.go_forward();

    render! {
        h1 { "Welcome to the Dioxus Blog!" }
    }
}
````

You can read more about programmatic navigation in the [Router Book](../router/reference/navigation/programmatic.md).

### New features

In addition to these changes, there have been many new features added to the router:

* [static generation support](../router/reference/static-generation.md)
* [Layouts](../router/reference/layouts.md)
* [Nesting](../router/reference/routes/nested.md)
# Hot reloading

Desktop hot reloading has changed in the `0.4` release to use the [Dioxus CLI](../CLI/index.md) for all platforms.

Previously, you may have included the `hot_reload_init!` macro in your main function. This is no longer needed.

old:

````rust
fn main() {
    hot_reload_init!();
    // ...
}
````

new:

````rust
fn main() {
    // ...
}
````

Now you can run your project with the dioxus CLI by passing the `--platform` flag:

````sh
dx serve --platform desktop --hot-reload
````
# Introduction

![dioxuslogo](/assets/blog/release-03/dioxuslogo_full.png)

Dioxus is a portable, performant, and ergonomic framework for building cross-platform user interfaces in Rust. This guide will help you get started with writing Dioxus apps for the Web, Desktop, Mobile, and more.

````rust
fn app(cx: Scope) -> Element {
    let mut count = use_state(cx, || 0);

    cx.render(rsx!(
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    ))
}
````

Dioxus is heavily inspired by React. If you know React, getting started with Dioxus will be a breeze.

 > 
 > This guide assumes you already know some [Rust](https://www.rust-lang.org/)! If not, we recommend reading [*the book*](https://doc.rust-lang.org/book/ch01-00-getting-started.html) to learn Rust first.

## Features

* Desktop apps running natively (no Electron!) in less than 10 lines of code.
* Incredibly ergonomic and powerful state management.
* Comprehensive inline documentation â€“ hover and guides for all HTML elements, listeners, and events.
* Extremely memory efficient â€“ 0 global allocations for steady-state components.
* Multi-channel asynchronous scheduler for first-class async support.
* And more! Read the [full release post](https://dioxuslabs.com/blog/introducing-dioxus/).

### Multiplatform

Dioxus is a *portable* toolkit, meaning the Core implementation can run anywhere with no platform-dependent linking. Unlike many other Rust frontend toolkits, Dioxus is not intrinsically linked to WebSys. In fact, every element and event listener can be swapped out at compile time. By default, Dioxus ships with the `html` feature enabled, but this can be disabled depending on your target renderer.

Right now, we have several 1st-party renderers:

* WebSys (for WASM): Great support
* Tao/Tokio (for Desktop apps): Good support
* Tao/Tokio (for Mobile apps): Poor support
* SSR (for generating static markup)
* TUI/Rink (for terminal-based apps): Experimental

## Stability

Dioxus has not reached a stable release yet.

Web: Since the web is a fairly mature platform, we expect there to be very little API churn for web-based features.

Desktop: APIs will likely be in flux as we figure out better patterns than our ElectronJS counterpart.

SSR: We don't expect the SSR API to change drastically in the future.
# Getting Started

This section will help you set up your Dioxus project!

## Prerequisites

### An Editor

Dioxus integrates very well with the [Rust-Analyzer LSP plugin](https://rust-analyzer.github.io) which will provide appropriate syntax highlighting, code navigation, folding, and more.

### Rust

Head over to [https://rust-lang.org](http://rust-lang.org) and install the Rust compiler.

We strongly recommend going through the [official Rust book](https://doc.rust-lang.org/book/ch01-00-getting-started.html) *completely*. However, we hope that a Dioxus app can serve as a great first Rust project. With Dioxus, you'll learn about:

* Error handling
* Structs, Functions, Enums
* Closures
* Macros

We've put a lot of care into making Dioxus syntax familiar and easy to understand, so you won't need deep knowledge of async, lifetimes, or smart pointers until you start building complex Dioxus apps.

## Setup Guides

Dioxus supports multiple platforms. Choose the platform you want to target below to get platform-specific setup instructions:

* [Web](web.md): runs in the browser through WebAssembly
* [Server Side Rendering](ssr.md): renders to HTML text on the server
* [Liveview](liveview.md): runs on the server, renders in the browser using WebSockets
* [Desktop](desktop.md): runs in a web view on desktop
* [Mobile](mobile.md): runs in a web view on mobile
* [Terminal UI](tui.md): renders text-based graphics in the terminal
# Desktop Overview

Build a standalone native desktop app that looks and feels the same across operating systems.

Apps built with Dioxus are typically \<5mb in size and use existing system resources, so they won't hog extreme amounts of RAM or memory.

Examples:

* [File Explorer](https://github.com/DioxusLabs/example-projects/blob/master/file-explorer)
* [WiFi Scanner](https://github.com/DioxusLabs/example-projects/blob/master/wifi-scanner)

[![File ExplorerExample](https://github.com/DioxusLabs/example-projects/raw/master/file-explorer/assets/image.png)](https://github.com/DioxusLabs/example-projects/tree/master/file-explorer)

## Support

The desktop is a powerful target for Dioxus but is currently limited in capability when compared to the Web platform. Currently, desktop apps are rendered with the platform's WebView library, but your Rust code is running natively on a native thread. This means that browser APIs are *not* available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs *are* accessible, so streaming, WebSockets, filesystem, etc are all viable APIs. In the future, we plan to move to a custom web renderer-based DOM renderer with WGPU integrations.

Dioxus Desktop is built off [Tauri](https://tauri.app/). Right now there aren't any Dioxus abstractions over keyboard shortcuts, menubar, handling, etc, so you'll want to leverage Tauri â€“ mostly [Wry](http://github.com/tauri-apps/wry/) and [Tao](http://github.com/tauri-apps/tao)) directly.

# Getting started

## Platform-Specific Dependencies

Dioxus desktop renders through a web view. Depending on your platform, you might need to install some dependancies.

### Windows

Windows Desktop apps depend on WebView2 â€“ a library that should be installed in all modern Windows distributions. If you have Edge installed, then Dioxus will work fine. If you *don't* have Webview2, [then you can install it through Microsoft](https://developer.microsoft.com/en-us/microsoft-edge/webview2/). MS provides 3 options:

1. A tiny "evergreen" *bootstrapper* that fetches an installer from Microsoft's CDN
1. A tiny *installer* that fetches Webview2 from Microsoft's CDN
1. A statically linked version of Webview2 in your final binary for offline users

For development purposes, use Option 1.

### Linux

Webview Linux apps require WebkitGtk. When distributing, this can be part of your dependency tree in your `.rpm` or `.deb`. However, likely, your users will already have WebkitGtk.

````bash
sudo apt install libwebkit2gtk-4.0-dev libgtk-3-dev libappindicator3-dev
````

When using Debian/bullseye `libappindicator3-dev` is no longer available but replaced by `libayatana-appindicator3-dev`.

````bash
# on Debian/bullseye use:
sudo apt install libwebkit2gtk-4.0-dev libgtk-3-dev libayatana-appindicator3-dev
````

If you run into issues, make sure you have all the basics installed, as outlined in the [Tauri docs](https://tauri.studio/v1/guides/getting-started/prerequisites#setting-up-linux).

### MacOS

Currently â€“ everything for macOS is built right in! However, you might run into an issue if you're using nightly Rust due to some permissions issues in our Tao dependency (which have been resolved but not published).

## Creating a Project

Create a new crate:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the desktop renderer as dependencies (this will edit your `Cargo.toml`):

````shell
cargo add dioxus
cargo add dioxus-desktop
````

Edit your `main.rs`:

````rs@hello_world_desktop.rs
#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the dioxus app in a webview
    dioxus_desktop::launch(App);
}

// define a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````
# Web

Build single-page applications that run in the browser with Dioxus. To run on the Web, your app must be compiled to WebAssembly and depend on the `dioxus` and `dioxus-web` crates.

A build of Dioxus for the web will be roughly equivalent to the size of a React build (70kb vs 65kb) but it will load significantly faster because [WebAssembly can be compiled as it is streamed](https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/).

Examples:

* [TodoMVC](https://github.com/DioxusLabs/example-projects/tree/master/todomvc)
* [ECommerce](https://github.com/DioxusLabs/example-projects/tree/master/ecommerce-site)

[![TodoMVC example](https://github.com/DioxusLabs/example-projects/raw/master/todomvc/example.png)](https://github.com/DioxusLabs/example-projects/blob/master/todomvc)

 > 
 > Note: Because of the limitations of Wasm, [not every crate will work](https://rustwasm.github.io/docs/book/reference/which-crates-work-with-wasm.html) with your web apps, so you'll need to make sure that your crates work without native system calls (timers, IO, etc).

## Support

The Web is the best-supported target platform for Dioxus.

* Because your app will be compiled to WASM you have access to browser APIs through [wasm-bingen](https://rustwasm.github.io/docs/wasm-bindgen/introduction.html).
* Dioxus provides hydration to resume apps that are rendered on the server. See the [hydration example](https://github.com/DioxusLabs/dioxus/blob/master/packages/web/examples/hydrate.rs) for more details.

## Tooling

To develop your Dioxus app for the web, you'll need a tool to build and serve your assets. We recommend using [dioxus-cli](https://github.com/DioxusLabs/cli) which includes a build system, Wasm optimization, a dev server, and support hot reloading:

````shell
cargo install dioxus-cli
````

Make sure the `wasm32-unknown-unknown` target for rust is installed:

````shell
rustup target add wasm32-unknown-unknown
````

## Creating a Project

Create a new crate:

````shell
cargo new --bin demo
cd demo
````

Add Dioxus and the web renderer as dependencies (this will edit your `Cargo.toml`):

````bash
cargo add dioxus
cargo add dioxus-web
````

Edit your `main.rs`:

````rs@hello_world_web.rs
#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the web app
    dioxus_web::launch(App);
}

// create a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}

````

And to serve our app:

````bash
dioxus serve
````
# Setting Up Hot Reload

1. Hot reloading allows much faster iteration times inside of rsx calls by interpreting them and streaming the edits.
1. It is useful when changing the styling/layout of a program, but will not help with changing the logic of a program.
1. Currently the cli only implements hot reloading for the web renderer.

# Setup

Install [dioxus-cli](https://github.com/DioxusLabs/cli).
Hot reloading is automatically enabled when using the web renderer on debug builds.

# Usage

1. run:

````
dioxus serve --hot-reload
````

2. change some code within a rsx macro
2. open your localhost in a browser
2. save and watch the style change without recompiling

# Limitations

1. The interpreter can only use expressions that existed on the last full recompile. If you introduce a new variable or expression to the rsx call, it will trigger a full recompile to capture the expression.
1. Components and Iterators can contain arbitrary rust code and will trigger a full recompile when changed.
# Server-Side Rendering

The Dioxus VirtualDom can be rendered server-side.

[Example: Dioxus DocSite](https://github.com/dioxusLabs/docsite)

## Multithreaded Support

The Dioxus VirtualDom, sadly, is not currently `Send`. Internally, we use quite a bit of interior mutability which is not thread-safe. This means you can't easily use Dioxus with most web frameworks like Tide, Rocket, Axum, etc.

To solve this, you'll want to spawn a VirtualDom on its own thread and communicate with it via channels.

When working with web frameworks that require `Send`, it is possible to render a VirtualDom immediately to a String â€“ but you cannot hold the VirtualDom across an await point. For retained-state SSR (essentially LiveView), you'll need to create a pool of VirtualDoms.

## Setup

For this guide, we're going to show how to use Dioxus SSR with [Axum](https://docs.rs/axum/latest/axum/).

Make sure you have Rust and Cargo installed, and then create a new project:

````shell
cargo new --bin demo
cd app
````

Add Dioxus and the ssr renderer as dependencies:

````shell
cargo add dioxus
cargo add dioxus-ssr
````

Next, add all the Axum dependencies. This will be different if you're using a different Web Framework

````
cargo add tokio --features full
cargo add axum
````

Your dependencies should look roughly like this:

````toml
[dependencies]
axum = "0.4.5"
dioxus = { version = "*" }
dioxus-ssr = { version = "*" }
tokio = { version = "1.15.0", features = ["full"] }
````

Now, set up your Axum app to respond on an endpoint.

````rust
use axum::{response::Html, routing::get, Router};
use dioxus::prelude::*;

#[tokio::main]
async fn main() {
    let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("listening on http://{}", addr);

    axum::Server::bind(&addr)
        .serve(
            Router::new()
                .route("/", get(app_endpoint))
                .into_make_service(),
        )
        .await
        .unwrap();
}
````

And then add our endpoint. We can either render `rsx!` directly:

````rust
async fn app_endpoint() -> Html<String> {
    // render the rsx! macro to HTML
    Html(dioxus_ssr::render_lazy(rsx! {
        div { "hello world!" }
    }))
}
````

Or we can render VirtualDoms.

````rust
async fn app_endpoint() -> Html<String> {
    // create a component that renders a div with the text "hello world"
    fn app(cx: Scope) -> Element {
        cx.render(rsx!(div { "hello world" }))
    }
    // create a VirtualDom with the app component
    let mut app = VirtualDom::new(app);
    // rebuild the VirtualDom before rendering
    let _ = app.rebuild();

    // render the VirtualDom to HTML
    Html(dioxus_ssr::render_vdom(&app))
}
````

And that's it!

 > 
 > You might notice that you cannot hold the VirtualDom across an await point. Dioxus is currently not ThreadSafe, so it *must* remain on the thread it started. We are working on loosening this requirement.
# Liveview

Liveview allows apps to *run* on the server and *render* in the browser. It uses WebSockets to communicate between the server and the browser.

Examples:

* [`Axum Example`](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/axum.rs)
* [`Salvo Example`](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/salvo.rs)
* [`Warp Example`](https://github.com/DioxusLabs/dioxus/tree/master/packages/liveview/examples/warp.rs)

## Support

Liveview is currently limited in capability when compared to the Web platform. Liveview apps run on the server in a native thread. This means that browser APIs are not available, so rendering WebGL, Canvas, etc is not as easy as the Web. However, native system APIs are accessible, so streaming, WebSockets, filesystem, etc are all viable APIs.

## Setup

For this guide, we're going to show how to use Dioxus Liveview with [Axum](https://docs.rs/axum/latest/axum/).

Make sure you have Rust and Cargo installed, and then create a new project:

````shell
cargo new --bin demo
cd app
````

Add Dioxus and the liveview renderer with the Axum feature as dependencies:

````shell
cargo add dioxus
cargo add dioxus-liveview --features axum
````

Next, add all the Axum dependencies. This will be different if you're using a different Web Framework

````
cargo add tokio --features full
cargo add axum
````

Your dependencies should look roughly like this:

````toml
[dependencies]
axum = "0.4.5"
dioxus = { version = "*" }
dioxus-liveview = { version = "*", features = ["axum"] }
tokio = { version = "1.15.0", features = ["full"] }
````

Now, set up your Axum app to respond on an endpoint.

````rs@hello_world_liveview.rs
#[tokio::main]
async fn main() {
    let addr: std::net::SocketAddr = ([127, 0, 0, 1], 3030).into();

    let view = dioxus_liveview::LiveViewPool::new();

    let app = Router::new()
        // The root route contains the glue code to connect to the WebSocket
        .route(
            "/",
            get(move || async move {
                Html(format!(
                    r#"
                <!DOCTYPE html>
                <html>
                <head> <title>Dioxus LiveView with Axum</title>  </head>
                <body> <div id="main"></div> </body>
                {glue}
                </html>
                "#,
                    // Create the glue code to connect to the WebSocket on the "/ws" route
                    glue = dioxus_liveview::interpreter_glue(&format!("ws://{addr}/ws"))
                ))
            }),
        )
        // The WebSocket route is what Dioxus uses to communicate with the browser
        .route(
            "/ws",
            get(move |ws: WebSocketUpgrade| async move {
                ws.on_upgrade(move |socket| async move {
                    // When the WebSocket is upgraded, launch the LiveView with the app component
                    _ = view.launch(dioxus_liveview::axum_socket(socket), app).await;
                })
            }),
        );

    println!("Listening on http://{}", addr);

    axum::Server::bind(&addr.to_string().parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}
````

And then add our app component:

````rs@hello_world_liveview.rs
fn app(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

And that's it!
# Terminal UI

You can build a text-based interface that will run in the terminal using Dioxus.

![Hello World screenshot](https://github.com/DioxusLabs/rink/raw/master/examples/example.png)

 > 
 > Note: this book was written with HTML-based platforms in mind. You might be able to follow along with TUI, but you'll have to adapt a bit.

## Support

TUI support is currently quite experimental. But, if you're willing to venture into the realm of the unknown, this guide will get you started.

* It uses flexbox for the layout
* It only supports a subset of the attributes and elements
* Regular widgets will not work in the tui render, but the tui renderer has its own widget components that start with a capital letter. See the [widgets example](https://github.com/DioxusLabs/dioxus/blob/master/packages/tui/examples/tui_widgets.rs)
* 1px is one character line height. Your regular CSS px does not translate
* If your app panics, your terminal is wrecked. This will be fixed eventually

## Getting Set up

Start by making a new package and adding Dioxus and the TUI renderer as dependancies.

````shell
cargo new --bin demo
cd demo
cargo add dioxus
cargo add dioxus-tui
````

Then, edit your `main.rs` with the basic template.

````rs@hello_world_tui.rs
#![allow(non_snake_case)]
// import the prelude to get access to the `rsx!` macro and the `Scope` and `Element` types
use dioxus::prelude::*;

fn main() {
    // launch the app in the terminal
    dioxus_tui::launch(App);
}

// create a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}

````

To run our app:

````shell
cargo run
````

Press "ctrl-c" to close the app. To switch from "ctrl-c" to just "q" to quit you can launch the app with a configuration to disable the default quit and use the root TuiContext to quit on your own.

````rs@hello_world_tui_no_ctrl_c.rs
// todo remove deprecated
#![allow(non_snake_case, deprecated)]

use dioxus::events::{KeyCode, KeyboardEvent};
use dioxus::prelude::*;
use dioxus_tui::TuiContext;

fn main() {
    dioxus_tui::launch_cfg(
        App,
        dioxus_tui::Config::new()
            .without_ctrl_c_quit()
            // Some older terminals only support 16 colors or ANSI colors
            // If your terminal is one of these, change this to BaseColors or ANSI
            .with_rendering_mode(dioxus_tui::RenderingMode::Rgb),
    );
}

fn App(cx: Scope) -> Element {
    let tui_ctx: TuiContext = cx.consume_context().unwrap();

    cx.render(rsx! {
        div {
            width: "100%",
            height: "10px",
            background_color: "red",
            justify_content: "center",
            align_items: "center",
            onkeydown: move |k: KeyboardEvent| if let KeyCode::Q = k.key_code {
                tui_ctx.quit();
            },

            "Hello world!"
        }
    })
}

````
# Mobile App

Build a mobile app with Dioxus!

Example: [Todo App](https://github.com/DioxusLabs/example-projects/blob/master/ios_demo)

## Support

Mobile is currently the least-supported renderer target for Dioxus. Mobile apps are rendered with either the platform's WebView or experimentally through [WGPU](https://github.com/DioxusLabs/blitz). WebView doesn't support animations, transparency, and native widgets.

Mobile support is currently best suited for CRUD-style apps, ideally for internal teams who need to develop quickly but don't care much about animations or native widgets.

This guide is primarily targeted at iOS apps, however, you can follow it while using the `android` guide in `cargo-mobile`.

## Getting Set up

Getting set up with mobile can be quite challenging. The tooling here isn't great (yet) and might take some hacking around to get things working. macOS M1 is broadly unexplored and might not work for you.

We're going to be using `cargo-mobile` to build for mobile. First, install it:

````shell
cargo install --git https://github.com/BrainiumLLC/cargo-mobile
````

And then initialize your app for the right platform. Use the `winit` template for now. Right now, there's no "Dioxus" template in cargo-mobile.

````shell
cargo mobile init
````

We're going to completely clear out the `dependencies` it generates for us, swapping out `winit` with `dioxus-mobile`.

````toml

[package]
name = "dioxus-ios-demo"
version = "0.1.0"
authors = []
edition = "2018"


# leave the `lib` declaration
[lib]
crate-type = ["staticlib", "cdylib", "rlib"]


# leave the binary it generates for us
[[bin]]
name = "dioxus-ios-demo-desktop"
path = "gen/bin/desktop.rs"

# clear all the dependencies
[dependencies]
mobile-entry-point = "0.1.0"
dioxus = { version = "*"}
dioxus-desktop = { version = "*" }
simple_logger = "*"
````

Edit your `lib.rs`:

````rust
use dioxus::prelude::*;

fn main() {
    dioxus_desktop::launch(app);
}

fn app(cx: Scope) -> Element {
    cx.render(rsx!{
        div {
            "hello world!"
        }
    })
}
````
# Describing the UI

Dioxus is a *declarative* framework. This means that instead of telling Dioxus what to do (e.g. to "create an element" or "set the color to red") we simply *declare* what we want the UI to look like using RSX.

You have already seen a simple example of RSX syntax in the "hello world" application:

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

Here, we use the `rsx!` macro to *declare* that we want a `div` element, containing the text `"Hello, world!"`. Dioxus takes the RSX and constructs a UI from it.

## RSX Features

RSX is very similar to HTML in that it describes elements with attributes and children. Here's an empty `div` element in RSX, as well as the resulting HTML:

````rs@rsx_overview.rs
cx.render(rsx!(div {
// attributes / listeners
// children
}))
````

````html
<div></div>
````

### Attributes

Attributes (and [listeners](../interactivity/index.md)) modify the behavior or appearance of the element they are attached to. They are specified inside the `{}` brackets, using the `name: value` syntax. You can provide the value as a literal in the RSX:

````rs@rsx_overview.rs
cx.render(rsx!(a {
href: "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
class: "primary_button",
color: "red",
}))
````

````html
<a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ" class="primary_button" autofocus="true" style="color: red"></a>
````

 > 
 > Note: All attributes defined in `dioxus-html` follow the snake_case naming convention. They transform their `snake_case` names to HTML's `camelCase` attributes.

 > 
 > Note: Styles can be used directly outside of the `style:` attribute. In the above example, `color: "red"` is turned into `style="color: red"`.

#### Custom Attributes

Dioxus has a pre-configured set of attributes that you can use. RSX is validated at compile time to make sure you didn't specify an invalid attribute. If you want to override this behavior with a custom attribute name, specify the attribute in quotes:

````rs@rsx_overview.rs
cx.render(rsx!(b {
    "customAttribute": "value",
}))
````

````html
<b customAttribute="value">
</b>
````

### Interpolation

Similarly to how you can [format](https://doc.rust-lang.org/rust-by-example/hello/print/fmt.html) Rust strings, you can also interpolate in RSX text. Use `{variable}` to Display the value of a variable in a string, or `{variable:?}` to use the Debug representation:

````rs@rsx_overview.rs
let coordinates = (42, 0);
let country = "es";
cx.render(rsx!(div {
class: "country-{country}",
"position": "{coordinates:?}",
// arbitrary expressions are allowed,
// as long as they don't contain `{}`
div {
    "{country.to_uppercase()}"
},
div {
    "{7*6}"
},
// {} can be escaped with {{}}
div {
    "{{}}"
},
}))
````

````html
<div class="country-es" position="(42, 0)">
    <div>ES</div>
    <div>42</div>
    <div>{}</div>
</div>
````

### Children

To add children to an element, put them inside the `{}` brackets after all attributes and listeners in the element. They can be other elements, text, or [components](components.md). For example, you could have an `ol` (ordered list) element, containing 3 `li` (list item) elements, each of which contains some text:

````rs@rsx_overview.rs
cx.render(rsx!(ol {
li {"First Item"}
li {"Second Item"}
li {"Third Item"}
}))
````

````html
<ol>
    <li>First Item</li>
    <li>Second Item</li>
    <li>Third Item</li>
</ol>
````

### Fragments

You can render multiple elements at the top level of `rsx!` and they will be automatically grouped.

````rs@rsx_overview.rs
cx.render(rsx!(
p {"First Item"},
p {"Second Item"},
))
````

````html
<p>First Item</p>
<p>Second Item</p>
````

### Expressions

You can include arbitrary Rust expressions as children within RSX that implements [IntoDynNode](https://docs.rs/dioxus-core/0.3/dioxus_core/trait.IntoDynNode.html). This is useful for displaying data from an [iterator](https://doc.rust-lang.org/stable/book/ch13-02-iterators.html#processing-a-series-of-items-with-iterators):

````rs@rsx_overview.rs
let text = "Dioxus";
cx.render(rsx!(span {
text.to_uppercase(),
// create a list of text from 0 to 9
(0..10).map(|i| rsx!{ i.to_string() })
}))
````

````html
<span>DIOXUS0123456789</span>
````

### Loops

In addition to iterators you can also use for loops directly within RSX:

````rs@rsx_overview.rs
cx.render(rsx!{
// use a for loop where the body itself is RSX
div {
    // create a list of text from 0 to 9
    for i in 0..3 {
        // NOTE: the body of the loop is RSX not a rust statement
        div {
            "{i}"
        }
    }
}
// iterator equivalent
div {
    (0..3).map(|i| rsx!{ div { "{i}" } })
}
})
````

````html
<div>0</div>
<div>1</div>
<div>2</div>
<div>0</div>
<div>1</div>
<div>2</div>
````

### If statements

You can also use if statements without an else branch within RSX:

````rs@rsx_overview.rs
cx.render(rsx!{
// use if statements without an else
if true {
    rsx!(div { "true" })
}
})
````

````html
<div>true</div>
````
# Special Attributes

While most attributes are simply passed on to the HTML, some have special behaviors.

## The HTML Escape Hatch

If you're working with pre-rendered assets, output from templates, or output from a JS library, then you might want to pass HTML directly instead of going through Dioxus. In these instances, reach for `dangerous_inner_html`.

For example, shipping a markdown-to-Dioxus converter might significantly bloat your final application size. Instead, you'll want to pre-render your markdown to HTML and then include the HTML directly in your output. We use this approach for the [Dioxus homepage](https://dioxuslabs.com):

````rs@dangerous_inner_html.rs
// this should come from a trusted source
let contents = "live <b>dangerously</b>";

cx.render(rsx! {
div {
    dangerous_inner_html: "{contents}",
}
})
````

 > 
 > Note! This attribute is called "dangerous_inner_html" because it is **dangerous** to pass it data you don't trust. If you're not careful, you can easily expose [cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks to your users.
 > 
 > If you're handling untrusted input, make sure to sanitize your HTML before passing it into `dangerous_inner_html` â€“ or just pass it to a Text Element to escape any HTML tags.

## Boolean Attributes

Most attributes, when rendered, will be rendered exactly as the input you provided. However, some attributes are considered "boolean" attributes and just their presence determines whether they affect the output. For these attributes, a provided value of `"false"` will cause them to be removed from the target element.

So this RSX wouldn't actually render the `hidden` attribute:

````rs@boolean_attribute.rs
cx.render(rsx! {
div {
    hidden: "false",
    "hello"
}
})
````

````html
<div>hello</div>
````

Not all attributes work like this however. *Only the following attributes* have this behavior:

* `allowfullscreen`
* `allowpaymentrequest`
* `async`
* `autofocus`
* `autoplay`
* `checked`
* `controls`
* `default`
* `defer`
* `disabled`
* `formnovalidate`
* `hidden`
* `ismap`
* `itemscope`
* `loop`
* `multiple`
* `muted`
* `nomodule`
* `novalidate`
* `open`
* `playsinline`
* `readonly`
* `required`
* `reversed`
* `selected`
* `truespeed`

For any other attributes, a value of `"false"` will be sent directly to the DOM.
# Components

Just like you wouldn't want to write a complex program in a single, long, `main` function, you shouldn't build a complex UI in a single `App` function. Instead, you should break down the functionality of an app in logical parts called components.

A component is a Rust function, named in UpperCamelCase, that takes a `Scope` parameter and returns an `Element` describing the UI it wants to render. In fact, our `App` function is a component!

````rs@hello_world_desktop.rs
// define a component that renders a div with the text "Hello, world!"
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        div {
            "Hello, world!"
        }
    })
}
````

 > 
 > You'll probably want to add `#![allow(non_snake_case)]` to the top of your crate to avoid warnings about UpperCamelCase component names

A Component is responsible for some rendering task â€“ typically, rendering an isolated part of the user interface. For example, you could have an `About` component that renders a short description of Dioxus Labs:

````rs@components.rs
pub fn About(cx: Scope) -> Element {
    cx.render(rsx!(p {
        b {"Dioxus Labs"}
        " An Open Source project dedicated to making Rust UI wonderful."
    }))
}
````

Then, you can render your component in another component, similarly to how elements are rendered:

````rs@components.rs
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        About {},
        About {},
    })
}
````

![Screenshot containing the About component twice](/assets/blog/release-03/screenshot_about_component.png)

 > 
 > At this point, it might seem like components are nothing more than functions. However, as you learn more about the features of Dioxus, you'll see that they are actually more powerful!
# Component Props

Just like you can pass arguments to a function, you can pass props to a component that customize its behavior! The components we've seen so far didn't accept any props â€“ so let's write some components that do.

## derive(Props)

Component props are a single struct annotated with `#[derive(Props)]`. For a component to accept props, the type of its argument must be `Scope<YourPropsStruct>`. Then, you can access the value of the props using `cx.props`.

There are 2 flavors of Props structs:

* Owned props:
  * Don't have an associated lifetime
  * Implement `PartialEq`, allow for memoization (if the props don't change, Dioxus won't re-render the component)
* Borrowed props:
  * [Borrow](https://doc.rust-lang.org/beta/rust-by-example/scope/borrow.html) from a parent component
  * Cannot be memoized due to lifetime constraints

### Owned Props

Owned Props are very simple â€“ they don't borrow anything. Example:

````rs@component_owned_props.rs
// Remember: Owned props must implement `PartialEq`!
#[derive(PartialEq, Props)]
struct LikesProps {
    score: i32,
}

fn Likes(cx: Scope<LikesProps>) -> Element {
    cx.render(rsx! {
        div {
            "This post has ",
            b { "{cx.props.score}" },
            " likes"
        }
    })
}
````

You can then pass prop values to the component the same way you would pass attributes to an element:

````rs@component_owned_props.rs
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        Likes {
            score: 42,
        },
    })
}
````

![Screenshot: Likes component](/assets/blog/release-03/component_owned_props_screenshot.png)

### Borrowed Props

Owned props work well if your props are easy to copy around â€“ like a single number. But what if we need to pass a larger data type, like a String from an `App` Component to a `TitleCard` subcomponent? A naive solution might be to [`.clone()`](https://doc.rust-lang.org/std/clone/trait.Clone.html) the String, creating a copy of it for the subcomponent â€“ but this would be inefficient, especially for larger Strings.

Rust allows for something more efficient â€“ borrowing the String as a `&str` â€“ this is what Borrowed Props are for!

````rs@component_borrowed_props.rs
#[derive(Props)]
struct TitleCardProps<'a> {
    title: &'a str,
}

fn TitleCard<'a>(cx: Scope<'a, TitleCardProps<'a>>) -> Element {
    cx.render(rsx! {
        h1 { "{cx.props.title}" }
    })
}
````

We can then use the component like this:

````rs@component_borrowed_props.rs
fn App(cx: Scope) -> Element {
    let hello = "Hello Dioxus!";

    cx.render(rsx!(TitleCard { title: hello }))
}
````

![Screenshot: TitleCard component](/assets/blog/release-03/component_borrowed_props_screenshot.png)

Borrowed props can be very useful, but they do not allow for memorization so they will *always* rerun when the parent scope is rerendered. Because of this Borrowed Props should be reserved for components that are cheap to rerun or places where cloning data is an issue. Using Borrowed Props everywhere will result in large parts of your app rerunning every interaction.

## Prop Options

The `#[derive(Props)]` macro has some features that let you customize the behavior of props.

### Optional Props

You can create optional fields by using the `Option<â€¦>` type for a field:

````rs@component_props_options.rs
#[derive(Props)]
struct OptionalProps<'a> {
    title: &'a str,
    subtitle: Option<&'a str>,
}

fn Title<'a>(cx: Scope<'a, OptionalProps>) -> Element<'a> {
    cx.render(rsx!(h1{
        "{cx.props.title}: ",
        cx.props.subtitle.unwrap_or("No subtitle provided"),
    }))
}
````

Then, you can choose to either provide them or not:

````rs@component_props_options.rs
Title {
title: "Some Title",
},
Title {
title: "Some Title",
subtitle: "Some Subtitle",
},
// Providing an Option explicitly won't compile though:
// Title {
//     title: "Some Title",
//     subtitle: None,
// },
````

### Explicitly Required `Option`s

If you want to explicitly require an `Option`, and not an optional prop, you can annotate it with `#[props(!optional)]`:

````rs@component_props_options.rs
#[derive(Props)]
struct ExplicitOptionProps<'a> {
    title: &'a str,
    #[props(!optional)]
    subtitle: Option<&'a str>,
}

fn ExplicitOption<'a>(cx: Scope<'a, ExplicitOptionProps>) -> Element<'a> {
    cx.render(rsx!(h1 {
        "{cx.props.title}: ",
        cx.props.subtitle.unwrap_or("No subtitle provided"),
    }))
}
````

Then, you have to explicitly pass either `Some("str")` or `None`:

````rs@component_props_options.rs
ExplicitOption {
title: "Some Title",
subtitle: None,
},
ExplicitOption {
title: "Some Title",
subtitle: Some("Some Title"),
},
// This won't compile:
// ExplicitOption {
//     title: "Some Title",
// },
````

### Default Props

You can use `#[props(default = 42)]` to make a field optional and specify its default value:

````rs@component_props_options.rs
#[derive(PartialEq, Props)]
struct DefaultProps {
    // default to 42 when not provided
    #[props(default = 42)]
    number: i64,
}

fn DefaultComponent(cx: Scope<DefaultProps>) -> Element {
    cx.render(rsx!(h1 { "{cx.props.number}" }))
}
````

Then, similarly to optional props, you don't have to provide it:

````rs@component_props_options.rs
DefaultComponent {
number: 5,
},
DefaultComponent {},
````

### Automatic Conversion with `.into`

It is common for Rust functions to accept `impl Into<SomeType>` rather than just `SomeType` to support a wider range of parameters. If you want similar functionality with props, you can use `#[props(into)]`. For example, you could add it on a `String` prop â€“ and `&str` will also be automatically accepted, as it can be converted into `String`:

````rs@component_props_options.rs
#[derive(PartialEq, Props)]
struct IntoProps {
    #[props(into)]
    string: String,
}

fn IntoComponent(cx: Scope<IntoProps>) -> Element {
    cx.render(rsx!(h1 { "{cx.props.string}" }))
}
````

Then, you can use it so:

````rs@component_props_options.rs
IntoComponent {
string: "some &str",
},
````

## The inline_props macro

So far, every Component function we've seen had a corresponding ComponentProps struct to pass in props. This was quite verbose... Wouldn't it be nice to have props as simple function arguments? Then we wouldn't need to define a Props struct, and instead of typing `cx.props.whatever`, we could just use `whatever` directly!

`inline_props` allows you to do just that. Instead of typing the "full" version:

````rust
#[derive(Props, PartialEq)]
struct TitleCardProps {
    title: String,
}

fn TitleCard(cx: Scope<TitleCardProps>) -> Element {
    cx.render(rsx!{
        h1 { "{cx.props.title}" }
    })
}
````

...you can define a function that accepts props as arguments. Then, just annotate it with `#[inline_props]`, and the macro will turn it into a regular Component for you:

````rust
#[inline_props]
fn TitleCard(cx: Scope, title: String) -> Element {
    cx.render(rsx!{
        h1 { "{title}" }
    })
}
````

 > 
 > While the new Component is shorter and easier to read, this macro should not be used by library authors since you have less control over Prop documentation.
# Component Children

In some cases, you may wish to create a component that acts as a container for some other content, without the component needing to know what that content is. To achieve this, create a prop of type `Element`:

````rs@component_element_props.rs
#[derive(Props)]
struct ClickableProps<'a> {
    href: &'a str,
    body: Element<'a>,
}

fn Clickable<'a>(cx: Scope<'a, ClickableProps<'a>>) -> Element {
    cx.render(rsx!(
        a {
            href: "{cx.props.href}",
            class: "fancy-button",
            &cx.props.body
        }
    ))
}
````

Then, when rendering the component, you can pass in the output of `cx.render(rsx!(...))`:

````rs@component_element_props.rs
cx.render(rsx! {
    Clickable {
        href: "https://www.youtube.com/watch?v=C-M2hs3sXGo",
        body: cx.render(rsx!("How to " i {"not"} " be seen")),
    }
})
````

 > 
 > Note: Since `Element<'a>` is a borrowed prop, there will be no memoization.

 > 
 > Warning: While it may compile, do not include the same `Element` more than once in the RSX. The resulting behavior is unspecified.

## The children field

Rather than passing the RSX through a regular prop, you may wish to accept children similarly to how elements can have children. The "magic" `children` prop lets you achieve this:

````rs@component_children.rs
#[derive(Props)]
struct ClickableProps<'a> {
    href: &'a str,
    children: Element<'a>,
}

fn Clickable<'a>(cx: Scope<'a, ClickableProps<'a>>) -> Element {
    cx.render(rsx!(
        a {
            href: "{cx.props.href}",
            class: "fancy-button",
            &cx.props.children
        }
    ))
}
````

This makes using the component much simpler: simply put the RSX inside the `{}` brackets â€“ and there is no need for a `render` call or another macro!

````rs@component_children.rs
cx.render(rsx! {
    Clickable {
        href: "https://www.youtube.com/watch?v=C-M2hs3sXGo",
        "How to " i {"not"} " be seen"
    }
})
````
# Interactivity

So far, we've learned how to describe the structure and properties of our user interfaces. However, most interfaces need to be interactive in order to be useful. In this chapter, we describe how to make a Dioxus app that responds to the user.
# Event Handlers

Event handlers are used to respond to user actions. For example, an event handler could be triggered when the user clicks, scrolls, moves the mouse, or types a character.

Event handlers are attached to elements. For example, we usually don't care about all the clicks that happen within an app, only those on a particular button.

Event handlers are similar to regular attributes, but their name usually starts with `on`- and they accept closures as values. The closure will be called whenever the event it listens for is triggered and will be passed that event.

For example, to handle clicks on an element, we can specify an `onclick` handler:

````rs@event_click.rs
cx.render(rsx! {
button {
    onclick: move |event| println!("Clicked! Event: {event:?}"),
    "click me!"
}
})
````

## The Event object

Event handlers receive an [`Event`](https://docs.rs/dioxus-core/latest/dioxus_core/struct.Event.html) object containing information about the event. Different types of events contain different types of data. For example, mouse-related events contain [`MouseData`](https://docs.rs/dioxus/latest/dioxus/events/struct.MouseData.html), which tells you things like where the mouse was clicked and what mouse buttons were used.

In the example above, this event data was logged to the terminal:

````
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
````

To learn what the different event types for HTML provide, read the [events module docs](https://docs.rs/dioxus-html/latest/dioxus_html/events/index.html).

### Event propagation

Some events will trigger first on the element the event originated at upward. For example, a click event on a `button` inside a `div` would first trigger the button's event listener and then the div's event listener.

 > 
 > For more information about event propigation see [the mdn docs on event bubling](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling)

If you want to prevent this behavior, you can call `stop_propogation()` on the event:

````rs@event_nested.rs
cx.render(rsx! {
div {
    onclick: move |_event| {},
    "outer",
    button {
        onclick: move |event| {
            // now, outer won't be triggered
            event.stop_propagation();
        },
        "inner"
    }
}
})
````

## Prevent Default

Some events have a default behavior. For keyboard events, this might be entering the typed character. For mouse events, this might be selecting some text.

In some instances, might want to avoid this default behavior. For this, you can add the `prevent_default` attribute with the name of the handler whose default behavior you want to stop. This attribute is special: you can attach it multiple times for multiple attributes:

````rs@event_prevent_default.rs
cx.render(rsx! {
input {
    prevent_default: "oninput",
    prevent_default: "onclick",
}
})
````

Any event handlers will still be called.

 > 
 > Normally, in React or JavaScript, you'd call "preventDefault" on the event in the callback. Dioxus does *not* currently support this behavior. Note: this means you cannot conditionally prevent default behavior based on the data in the event.

## Handler Props

Sometimes, you might want to make a component that accepts an event handler. A simple example would be a `FancyButton` component, which accepts an `on_click` handler:

````rs@event_handler_prop.rs
#[derive(Props)]
pub struct FancyButtonProps<'a> {
    on_click: EventHandler<'a, MouseEvent>,
}

pub fn FancyButton<'a>(cx: Scope<'a, FancyButtonProps<'a>>) -> Element<'a> {
    cx.render(rsx!(button {
        class: "fancy-button",
        onclick: move |evt| cx.props.on_click.call(evt),
        "click me pls."
    }))
}
````

Then, you can use it like any other handler:

````rs@event_handler_prop.rs
cx.render(rsx! {
    FancyButton {
        on_click: move |event| println!("Clicked! {event:?}")
    }
})
````

 > 
 > Note: just like any other attribute, you can name the handlers anything you want! Though they must start with `on`, for the prop to be automatically turned into an `EventHandler` at the call site.
 > 
 > You can also put custom data in the event, rather than e.g. `MouseData`
# Hooks and Component State

So far our components have had no state like a normal rust functions. However, in a UI component, it is often useful to have stateful functionality to build user interactions. For example, you might want to track whether the user has opened a drop-down, and render different things accordingly.

Hooks allow us to create state in our components. Hooks are Rust functions that take a reference to `ScopeState` (in a component, you can pass `cx`), and provide you with functionality and state.

## use_state Hook

[`use_state`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_state.html) is one of the simplest hooks.

* You provide a closure that determines the initial value
* `use_state` gives you the current value, and a way to update it by setting it to something else
* When the value updates, `use_state` makes the component re-render, and provides you with the new value

For example, you might have seen the counter example, in which state (a number) is tracked using the `use_state` hook:

````rs@hooks_counter.rs
fn App(cx: Scope) -> Element {
    // count will be initialized to 0 the first time the component is rendered
    let mut count = use_state(cx, || 0);

    cx.render(rsx!(
        h1 { "High-Five counter: {count}" }
        button {
            onclick: move |_| {
                // changing the count will cause the component to re-render
                count += 1
            },
            "Up high!"
        }
        button {
            onclick: move |_| {
                // changing the count will cause the component to re-render
                count -= 1
            },
            "Down low!"
        }
    ))
}
````

![Screenshot: counter app](/assets/blog/release-03/counter.png)

Every time the component's state changes, it re-renders, and the component function is called, so you can describe what you want the new UI to look like. You don't have to worry about "changing" anything â€“ just describe what you want in terms of the state, and Dioxus will take care of the rest!

 > 
 > `use_state` returns your value wrapped in a smart pointer of type [`UseState`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.UseState.html). This is why you can both read the value and update it, even within an event handler.

You can use multiple hooks in the same component if you want:

````rs@hooks_counter_two_state.rs
fn App(cx: Scope) -> Element {
    let mut count_a = use_state(cx, || 0);
    let mut count_b = use_state(cx, || 0);

    cx.render(rsx!(
        h1 { "Counter_a: {count_a}" }
        button { onclick: move |_| count_a += 1, "a++" }
        button { onclick: move |_| count_a -= 1, "a--" }
        h1 { "Counter_b: {count_b}" }
        button { onclick: move |_| count_b += 1, "b++" }
        button { onclick: move |_| count_b -= 1, "b--" }
    ))
}
````

![Screenshot: app with two counters](/assets/blog/release-03/counter_two_state.png)

## Rules of Hooks

The above example might seem a bit magic, since Rust functions are typically not associated with state. Dioxus allows hooks to maintain state across renders through a reference to `ScopeState`, which is why you must pass `&cx` to them.

But how can Dioxus differentiate between multiple hooks in the same component? As you saw in the second example, both `use_state` functions were called with the same parameters, so how come they can return different things when the counters are different?

````rs@hooks_counter_two_state.rs
let mut count_a = use_state(cx, || 0);
let mut count_b = use_state(cx, || 0);
````

This is only possible because the two hooks are always called in the same order, so Dioxus knows which is which. Because the order you call hooks matters, you must follow certain rules when using hooks:

1. Hooks may be only used in components or other hooks (we'll get to that later)
1. On every call to the component function
   1. The same hooks must be called
   1. In the same order
1. Hooks name's should start with `use_` so you don't accidentally confuse them with regular functions

These rules mean that there are certain things you can't do with hooks:

### No Hooks in Conditionals

````rs@hooks_bad.rs
// âŒ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy && you_know_it {
let something = use_state(cx, || "hands");
println!("clap your {something}")
}

// âœ… instead, *always* call use_state
// You can put other stuff in the conditional though
let something = use_state(cx, || "hands");
if you_are_happy && you_know_it {
println!("clap your {something}")
}
````

### No Hooks in Closures

````rs@hooks_bad.rs
// âŒ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
let b = use_state(cx, || 0);
b.get()
};

// âœ… instead, move hook `b` outside
let b = use_state(cx, || 0);
let _a = || b.get();
````

### No Hooks in Loops

````rs@hooks_bad.rs
// `names` is a Vec<&str>

// âŒ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &names {
let is_selected = use_state(cx, || false);
println!("selected: {is_selected}");
}

// âœ… Instead, use a hashmap with use_ref
let selection_map = use_ref(cx, HashMap::<&str, bool>::new);

for name in &names {
let is_selected = selection_map.read()[name];
println!("selected: {is_selected}");
}
````

## use_ref Hook

`use_state` is great for tracking simple values. However, you may notice in the [`UseState` API](https://docs.rs/dioxus/latest/dioxus/hooks/struct.UseState.html) that the only way to modify its value is to replace it with something else (e.g., by calling `set`, or through one of the `+=`, `-=` operators). This works well when it is cheap to construct a value (such as any primitive). But what if you want to maintain more complex data in the components state?

For example, suppose we want to maintain a `Vec` of values. If we stored it with `use_state`, the only way to add a new value to the list would be to create a new `Vec` with the additional value, and put it in the state. This is expensive! We want to modify the existing `Vec` instead.

Thankfully, there is another hook for that, `use_ref`! It is similar to `use_state`, but it lets you get a mutable reference to the contained data.

Here's a simple example that keeps a list of events in a `use_ref`. We can acquire write access to the state with `.with_mut()`, and then just `.push` a new value to the state:

````rs@hooks_use_ref.rs
fn App(cx: Scope) -> Element {
    let list = use_ref(cx, Vec::new);

    cx.render(rsx!(
        p { "Current list: {list.read():?}" }
        button {
            onclick: move |event| {
                list.with_mut(|list| list.push(event));
            },
            "Click me!"
        }
    ))
}
````

 > 
 > The return values of `use_state` and `use_ref` (`UseState` and `UseRef`, respectively) are in some ways similar to [`Cell`](https://doc.rust-lang.org/std/cell/) and [`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) â€“ they provide interior mutability. However, these Dioxus wrappers also ensure that the component gets re-rendered whenever you change the state.
# User Input

Interfaces often need to provide a way to input data: e.g. text, numbers, checkboxes, etc. In Dioxus, there are two ways you can work with user input.

## Controlled Inputs

With controlled inputs, you are directly in charge of the state of the input. This gives you a lot of flexibility, and makes it easy to keep things in sync. For example, this is how you would create a controlled text input:

````rs@input_controlled.rs
fn App(cx: Scope) -> Element {
    let name = use_state(cx, || "bob".to_string());

    cx.render(rsx! {
        input {
            // we tell the component what to render
            value: "{name}",
            // and what to do when the value changes
            oninput: move |evt| name.set(evt.value.clone()),
        }
    })
}
````

Notice the flexibility â€“ you can:

* Also display the same contents in another element, and they will be in sync
* Transform the input every time it is modified (e.g. to make sure it is upper case)
* Validate the input every time it changes
* Have custom logic happening when the input changes (e.g. network request for autocompletion)
* Programmatically change the value (e.g. a "randomize" button that fills the input with nonsense)

## Uncontrolled Inputs

As an alternative to controlled inputs, you can simply let the platform keep track of the input values. If we don't tell a HTML input what content it should have, it will be editable anyway (this is built into the browser). This approach can be more performant, but less flexible. For example, it's harder to keep the input in sync with another element.

Since you don't necessarily have the current value of the uncontrolled input in state, you can access it either by listening to `oninput` events (similarly to controlled components), or, if the input is part of a form, you can access the form data in the form events (e.g. `oninput` or `onsubmit`):

````rs@input_uncontrolled.rs
fn App(cx: Scope) -> Element {
    cx.render(rsx! {
        form {
            onsubmit: move |event| {
                println!("Submitted! {event:?}")
            },
            input { name: "name", },
            input { name: "age", },
            input { name: "date", },
            input { r#type: "submit", },
        }
    })
}
````

````
Submitted! UiEvent { data: FormData { value: "", values: {"age": "very old", "date": "1966", "name": "Fred"} } }
````
# Sharing State

Often, multiple components need to access the same state. Depending on your needs, there are several ways to implement this.

## Lifting State

One approach to share state between components is to "lift" it up to the nearest common ancestor. This means putting the `use_state` hook in a parent component, and passing the needed values down as props.

Suppose we want to build a meme editor. We want to have an input to edit the meme caption, but also a preview of the meme with the caption. Logically, the meme and the input are 2 separate components, but they need access to the same state (the current caption).

 > 
 > Of course, in this simple example, we could write everything in one component â€“ but it is better to split everything out in smaller components to make the code more reusable, maintainable, and performant (this is even more important for larger, complex apps).

We start with a `Meme` component, responsible for rendering a meme with a given caption:

````rs@meme_editor.rs
#[inline_props]
fn Meme<'a>(cx: Scope<'a>, caption: &'a str) -> Element<'a> {
    let container_style = r#"
        position: relative;
        width: fit-content;
    "#;

    let caption_container_style = r#"
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 16px 8px;
    "#;

    let caption_style = r"
        font-size: 32px;
        margin: 0;
        color: white;
        text-align: center;
    ";

    cx.render(rsx!(
        div {
            style: "{container_style}",
            img {
                src: "https://i.imgflip.com/2zh47r.jpg",
                height: "500px",
            },
            div {
                style: "{caption_container_style}",
                p {
                    style: "{caption_style}",
                    "{caption}"
                }
            }
        }
    ))
}
````

 > 
 > Note that the `Meme` component is unaware where the caption is coming from â€“ it could be stored in `use_state`, `use_ref`, or a constant. This ensures that it is very reusable â€“ the same component can be used for a meme gallery without any changes!

We also create a caption editor, completely decoupled from the meme. The caption editor must not store the caption itself â€“ otherwise, how will we provide it to the `Meme` component? Instead, it should accept the current caption as a prop, as well as an event handler to delegate input events to:

````rs@meme_editor.rs
#[inline_props]
fn CaptionEditor<'a>(
    cx: Scope<'a>,
    caption: &'a str,
    on_input: EventHandler<'a, FormEvent>,
) -> Element<'a> {
    let input_style = r"
        border: none;
        background: cornflowerblue;
        padding: 8px 16px;
        margin: 0;
        border-radius: 4px;
        color: white;
    ";

    cx.render(rsx!(input {
        style: "{input_style}",
        value: "{caption}",
        oninput: move |event| on_input.call(event),
    }))
}
````

Finally, a third component will render the other two as children. It will be responsible for keeping the state and passing down the relevant props.

````rs@meme_editor.rs
fn MemeEditor(cx: Scope) -> Element {
    let container_style = r"
        display: flex;
        flex-direction: column;
        gap: 16px;
        margin: 0 auto;
        width: fit-content;
    ";

    let caption = use_state(cx, || "me waiting for my rust code to compile".to_string());

    cx.render(rsx! {
        div {
            style: "{container_style}",
            h1 { "Meme Editor" },
            Meme {
                caption: caption,
            },
            CaptionEditor {
                caption: caption,
                on_input: move |event: FormEvent| {caption.set(event.value.clone());},
            },
        }
    })
}
````

![Meme Editor Screenshot: An old plastic skeleton sitting on a park bench. Caption: "me waiting for a language feature"](/assets/blog/release-03/meme_editor_screenshot.png)

## Using Context

Sometimes, some state needs to be shared between multiple components far down the tree, and passing it down through props is very inconvenient.

Suppose now that we want to implement a dark mode toggle for our app. To achieve this, we will make every component select styling depending on whether dark mode is enabled or not.

 > 
 > Note: we're choosing this approach for the sake of an example. There are better ways to implement dark mode (e.g. using CSS variables). Let's pretend CSS variables don't exist â€“ welcome to 2013!

Now, we could write another `use_state` in the top component, and pass `is_dark_mode` down to every component through props. But think about what will happen as the app grows in complexity â€“ almost every component that renders any CSS is going to need to know if dark mode is enabled or not â€“ so they'll all need the same dark mode prop. And every parent component will need to pass it down to them. Imagine how messy and verbose that would get, especially if we had components several levels deep!

Dioxus offers a better solution than this "prop drilling" â€“ providing context. The [`use_context_provider`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context_provider.html) hook is similar to `use_ref`, but it makes it available through [`use_context`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_context.html) for all children components.

First, we have to create a struct for our dark mode configuration:

````rs@meme_editor_dark_mode.rs
struct DarkMode(bool);
````

Now, in a top-level component (like `App`), we can provide the `DarkMode` context to all children components:

````rs@meme_editor_dark_mode.rs
use_shared_state_provider(cx, || DarkMode(false));
````

As a result, any child component of `App` (direct or not), can access the `DarkMode` context.

````rs@meme_editor_dark_mode.rs
let dark_mode_context = use_shared_state::<DarkMode>(cx);
````

 > 
 > `use_context` returns `Option<UseSharedState<DarkMode>>` here. If the context has been provided, the value is `Some(UseSharedState<DarkMode>)`, which you can call `.read` or `.write` on, similarly to `UseRef`. Otherwise, the value is `None`.

For example, here's how we would implement the dark mode toggle, which both reads the context (to determine what color it should render) and writes to it (to toggle dark mode):

````rs@meme_editor_dark_mode.rs
pub fn DarkModeToggle(cx: Scope) -> Element {
    let dark_mode = use_shared_state::<DarkMode>(cx).unwrap();

    let style = if dark_mode.read().0 {
        "color:white"
    } else {
        ""
    };

    cx.render(rsx!(label {
        style: "{style}",
        "Dark Mode",
        input {
            r#type: "checkbox",
            oninput: move |event| {
                let is_enabled = event.value == "true";
                dark_mode.write().0 = is_enabled;
            },
        },
    }))
}
````
# Custom Hooks

Hooks are a great way to encapsulate business logic. If none of the existing hooks work for your problem, you can write your own.

## Composing Hooks

To avoid repetition, you can encapsulate business logic based on existing hooks to create a new hook.

For example, if many components need to access an `AppSettings` struct, you can create a "shortcut" hook:

````rs@hooks_composed.rs
fn use_settings(cx: &ScopeState) -> UseSharedState<AppSettings> {
    use_shared_state::<AppSettings>(cx).expect("App settings not provided")
}
````

## Custom Hook Logic

You can use [`cx.use_hook`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.Scope.html#method.use_hook) to build your own hooks. In fact, this is what all the standard hooks are built on!

`use_hook` accepts a single closure for initializing the hook. It will be only run the first time the component is rendered. The return value of that closure will be used as the value of the hook â€“ Dioxus will take it, and store it for as long as the component is alive. On every render (not just the first one!), you will get a reference to this value.

 > 
 > Note: You can implement [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) for your hook value â€“ it will be dropped then the component is unmounted (no longer in the UI)

Inside the initialization closure, you will typically make calls to other `cx` methods. For example:

* The `use_state` hook tracks state in the hook value, and uses [`cx.schedule_update`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.Scope.html#method.schedule_update) to make Dioxus re-render the component whenever it changes.
* The `use_context` hook calls [`cx.consume_context`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.Scope.html#method.consume_context) (which would be expensive to call on every render) to get some context from the scope
# Dynamic Rendering

Sometimes you want to render different things depending on the state/props. With Dioxus, just describe what you want to see using Rust control flow â€“ the framework will take care of making the necessary changes on the fly if the state or props change!

## Conditional Rendering

To render different elements based on a condition, you could use an `if-else` statement:

````rs@conditional_rendering.rs
if *is_logged_in {
cx.render(rsx! {
    "Welcome!"
    button {
        onclick: move |_| on_log_out.call(()),
        "Log Out",
    }
})
} else {
cx.render(rsx! {
    button {
        onclick: move |_| on_log_in.call(()),
        "Log In",
    }
})
}
````

 > 
 > You could also use `match` statements, or any Rust function to conditionally render different things.

### Improving the `if-else` Example

You may have noticed some repeated code in the `if-else` example above. Repeating code like this is both bad for maintainability and performance. Dioxus will skip diffing static elements like the button, but when switching between multiple `rsx` calls it cannot perform this optimization. For this example either approach is fine, but for components with large parts that are reused between conditionals, it can be more of an issue.

We can improve this example by splitting up the dynamic parts and inserting them where they are needed.

````rs@conditional_rendering.rs
cx.render(rsx! {
// We only render the welcome message if we are logged in
// You can use if statements in the middle of a render block to conditionally render elements
if *is_logged_in {
    // Notice the body of this if statment is rsx code, not an expression
    "Welcome!"
}
button {
    // depending on the value of `is_logged_in`, we will call a different event handler
    onclick: move |_| if *is_logged_in {
        on_log_in.call(())
    }
    else{
        on_log_out.call(())
    },
    if *is_logged_in {
        // if we are logged in, the button should say "Log Out"
        "Log Out"
    } else {
        // if we are not logged in, the button should say "Log In"
        "Log In"
    }
}
})
````

### Inspecting `Element` props

Since `Element` is a `Option<VNode>`, components accepting `Element` as a prop can inspect its contents, and render different things based on that. Example:

````rs@component_children_inspect.rs
fn Clickable<'a>(cx: Scope<'a, ClickableProps<'a>>) -> Element {
    match cx.props.children {
        Some(VNode { dynamic_nodes, .. }) => {
            todo!("render some stuff")
        }
        _ => {
            todo!("render some other stuff")
        }
    }
}
````

You can't mutate the `Element`, but if you need a modified version of it, you can construct a new one based on its attributes/children/etc.

## Rendering Nothing

To render nothing, you can return `None` from a component. This is useful if you want to conditionally hide something:

````rs@conditional_rendering.rs
if *is_logged_in {
return None;
}

cx.render(rsx! {
a {
    "You must be logged in to comment"
}
})
````

This works because the `Element` type is just an alias for `Option<VNode>`

 > 
 > Again, you may use a different method to conditionally return `None`. For example the boolean's [`then()`](https://doc.rust-lang.org/std/primitive.bool.html#method.then) function could be used.

## Rendering Lists

Often, you'll want to render a collection of components. For example, you might want to render a list of all comments on a post.

For this, Dioxus accepts iterators that produce `Element`s. So we need to:

* Get an iterator over all of our items (e.g., if you have a `Vec` of comments, iterate over it with `iter()`)
* `.map` the iterator to convert each item into a `LazyNode` using `rsx!(...)`
  * Add a unique `key` attribute to each iterator item
* Include this iterator in the final RSX (or use it inline)

Example: suppose you have a list of comments you want to render. Then, you can render them like this:

````rs@rendering_lists.rs
let comment_field = use_state(cx, String::new);
let mut next_id = use_state(cx, || 0);
let comments = use_ref(cx, Vec::<Comment>::new);

let comments_lock = comments.read();
let comments_rendered = comments_lock.iter().map(|comment| {
rsx!(CommentComponent {
    key: "{comment.id}",
    comment: comment.clone(),
})
});

cx.render(rsx!(
form {
    onsubmit: move |_| {
        comments.write().push(Comment {
            content: comment_field.get().clone(),
            id: *next_id.get(),
        });
        next_id += 1;

        comment_field.set(String::new());
    },
    input {
        value: "{comment_field}",
        oninput: |event| comment_field.set(event.value.clone()),
    }
    input {
        r#type: "submit",
    }
},
comments_rendered,
))
````

### Inline for loops

Because of how common it is to render a list of items, Dioxus provides a shorthand for this. Instead of using `.iter, `.map`, and `rsx`, you can use a `for\` loop with a body of rsx code:

````rs@rendering_lists.rs
let comment_field = use_state(cx, String::new);
let mut next_id = use_state(cx, || 0);
let comments = use_ref(cx, Vec::<Comment>::new);

cx.render(rsx!(
form {
    onsubmit: move |_| {
        comments.write().push(Comment {
            content: comment_field.get().clone(),
            id: *next_id.get(),
        });
        next_id += 1;

        comment_field.set(String::new());
    },
    input {
        value: "{comment_field}",
        oninput: |event| comment_field.set(event.value.clone()),
    }
    input {
        r#type: "submit",
    }
},
for comment in &*comments.read() {
    // Notice the body of this for loop is rsx code, not an expression
    CommentComponent {
        key: "{comment.id}",
        comment: comment.clone(),
    }
}
))
````

### The key Attribute

Every time you re-render your list, Dioxus needs to keep track of which items go where to determine what updates need to be made to the UI.

For example, suppose the `CommentComponent` had some state â€“ e.g. a field where the user typed in a reply. If the order of comments suddenly changes, Dioxus needs to correctly associate that state with the same comment â€“ otherwise, the user will end up replying to a different comment!

To help Dioxus keep track of list items, we need to associate each item with a unique key. In the example above, we dynamically generated the unique key. In real applications, it's more likely that the key will come from e.g. a database ID. It doesn't matter where you get the key from, as long as it meets the requirements:

* Keys must be unique in a list
* The same item should always get associated with the same key
* Keys should be relatively small (i.e. converting the entire Comment structure to a String would be a pretty bad key) so they can be compared efficiently

You might be tempted to use an item's index in the list as its key. Thatâ€™s what Dioxus will use if you donâ€™t specify a key at all. This is only acceptable if you can guarantee that the list is constant â€“ i.e., no re-ordering, additions, or deletions.

 > 
 > Note that if you pass the key to a component you've made, it won't receive the key as a prop. Itâ€™s only used as a hint by Dioxus itself. If your component needs an ID, you have to pass it as a separate prop.
# Router

In many of your apps, you'll want to have different "scenes". For a webpage, these scenes might be the different webpages with their own content. For a desktop app, these scenes might be different views in your app.

To unify these platforms, Dioxus provides a first-party solution for scene management called Dioxus Router.

## What is it?

For an app like the Dioxus landing page (https://dioxuslabs.com), we want to have several different scenes:

* Homepage
* Blog

Each of these scenes is independent â€“ we don't want to render both the homepage and blog at the same time.

The Dioxus router makes it easy to create these scenes. To make sure we're using the router, add the `dioxus-router` package to your `Cargo.toml`.

````shell
cargo add dioxus-router
````

## Using the router

Unlike other routers in the Rust ecosystem, our router is built declaratively. This makes it possible to compose our app layout simply by arranging components.

````rust
rsx!{
    // All of our routes will be rendered inside this Router component
    Router {
        // if the current location is "/home", render the Home component
        Route { to: "/home", Home {} }
        // if the current location is "/blog", render the Blog component
        Route { to: "/blog", Blog {} }
    }
}
````

Whenever we visit this app, we will get either the Home component or the Blog component rendered depending on which route we enter at. If neither of these routes match the current location, then nothing will render.

We can fix this one of two ways:

* A fallback 404 page

````rust
rsx!{
    Router {
        Route { to: "/home", Home {} }
        Route { to: "/blog", Blog {} }
        //  if the current location doesn't match any of the above routes, render the NotFound component
        Route { to: "", NotFound {} }
    }
}
````

* Redirect 404 to home

````rust
rsx!{
    Router {
        Route { to: "/home", Home {} }
        Route { to: "/blog", Blog {} }
        //  if the current location doesn't match any of the above routes, redirect to "/home"
        Redirect { from: "", to: "/home" }
    }
}
````

## Links

For our app to navigate these routes, we can provide clickable elements called Links. These simply wrap `<a>` elements that, when clicked, navigate the app to the given location.

````rust
rsx!{
    Link {
        to: "/home",
        "Go home!"
    }
}
````

## More reading

This page is just a very brief overview of the router. For more information, check out [the router book](https://dioxuslabs.com/router/guide/) or some of [the router examples](https://github.com/DioxusLabs/dioxus/blob/master/examples/router.rs).
# Working with Async

Often, apps need to interact with file systems, network interfaces, hardware, or timers. This chapter provides an overview of using async code in Dioxus.

## The Runtime

By default, Dioxus-Desktop ships with the `Tokio` runtime and automatically sets everything up for you. This is currently not configurable, though it would be easy to write an integration for Dioxus desktop that uses a different asynchronous runtime.

Dioxus is not currently thread-safe, so any async code you write does *not* need to be `Send/Sync`. That means that you can use non-thread-safe structures like `Cell`, `Rc`, and `RefCell`.
# UseFuture

[`use_future`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_future.html) lets you run an async closure, and provides you with its result.

For example, we can make an API request (using [reqwest](https://docs.rs/reqwest/latest/reqwest/index.html)) inside `use_future`:

````rs@use_future.rs
let future = use_future(cx, (), |_| async move {
    reqwest::get("https://dog.ceo/api/breeds/image/random")
        .await
        .unwrap()
        .json::<ApiResponse>()
        .await
});
````

The code inside `use_future` will be submitted to the Dioxus scheduler once the component has rendered.

We can use `.value()` to get the result of the future. On the first run, since there's no data ready when the component loads, its value will be `None`.  However, once the future is finished, the component will be re-rendered and the value will now be `Some(...)`, containing the return value of the closure.

We can then render that result:

````rs@use_future.rs
cx.render(match future.value() {
    Some(Ok(response)) => rsx! {
        button {
            onclick: move |_| future.restart(),
            "Click to fetch another doggo"
        }
        div {
            img {
                max_width: "500px",
                max_height: "500px",
                src: "{response.image_url}",
            }
        }
    },
    Some(Err(_)) => rsx! { div { "Loading dogs failed" } },
    None => rsx! { div { "Loading dogs..." } },
})
````

## Restarting the Future

The `UseFuture` handle provides a `restart` method. It can be used to execute the future again, producing a new value.

## Dependencies

Often, you will need to run the future again every time some value (e.g. a prop) changes. Rather than calling `restart` manually, you can provide a tuple of "dependencies" to the hook. It will automatically re-run the future when any of those dependencies change. Example:

````rs@use_future.rs
let future = use_future(cx, (breed,), |(breed,)| async move {
    reqwest::get(format!("https://dog.ceo/api/breed/{breed}/images/random"))
        .await
        .unwrap()
        .json::<ApiResponse>()
        .await
});
````
# Coroutines

Another tool in your async toolbox are coroutines. Coroutines are futures that can be manually stopped, started, paused, and resumed.

Like regular futures, code in a coroutine will run until the next `await` point before yielding. This low-level control over asynchronous tasks is quite powerful, allowing for infinitely looping tasks like WebSocket polling, background timers, and other periodic actions.

## use_coroutine

The `use_coroutine` hook allows you to create a coroutine. Most coroutines we write will be polling loops using async/await.

````rust
fn app(cx: Scope) -> Element {
    let ws: &UseCoroutine<()> = use_coroutine(cx, |rx| async move {
        // Connect to some sort of service
        let mut conn = connect_to_ws_server().await;

        // Wait for data on the service
        while let Some(msg) = conn.next().await {
            // handle messages
        }
    });
}
````

For many services, a simple async loop will handle the majority of use cases.

However, if we want to temporarily disable the coroutine, we can "pause" it using the `pause` method, and "resume" it using the `resume` method:

````rust
let sync: &UseCoroutine<()> = use_coroutine(cx, |rx| async move {
    // code for syncing
});

if sync.is_running() {
    cx.render(rsx!{
        button {
            onclick: move |_| sync.pause(),
            "Disable syncing"
        }
    })
} else {
    cx.render(rsx!{
        button {
            onclick: move |_| sync.resume(),
            "Enable syncing"
        }
    })
}
````

This pattern is where coroutines are extremely useful â€“ instead of writing all the complicated logic for pausing our async tasks like we would with JavaScript promises, the Rust model allows us to just not poll our future.

## Yielding Values

To yield values from a coroutine, simply bring in a `UseState` handle and set the value whenever your coroutine completes its work.

The future must be `'static` â€“ so any values captured by the task cannot carry any references to `cx`, such as a `UseState`.

You can use [to_owned](https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned) to create a clone of the hook handle which can be moved into the async closure.

````rust
let sync_status = use_state(cx, || Status::Launching);
let sync_task = use_coroutine(cx, |rx: UnboundedReceiver<SyncAction>| {
    let sync_status = sync_status.to_owned();
    async move {
        loop {
            delay_ms(1000).await;
            sync_status.set(Status::Working);
        }
    }
})
````

To make this a bit less verbose, Dioxus exports the `to_owned!` macro which will create a binding as shown above, which can be quite helpful when dealing with many values.

````rust
let sync_status = use_state(cx, || Status::Launching);
let load_status = use_state(cx, || Status::Launching);
let sync_task = use_coroutine(cx, |rx: UnboundedReceiver<SyncAction>| {
    to_owned![sync_status, load_status];
    async move {
        // ...
    }
})
````

## Sending Values

You might've noticed the `use_coroutine` closure takes an argument called `rx`. What is that? Well, a common pattern in complex apps is to handle a bunch of async code at once. With libraries like Redux Toolkit, managing multiple promises at once can be challenging and a common source of bugs.

With Coroutines, we can centralize our async logic. The `rx` parameter is an Channel that allows code external to the coroutine to send data *into* the coroutine. Instead of looping on an external service, we can loop on the channel itself, processing messages from within our app without needing to spawn a new future. To send data into the coroutine, we would call "send" on the handle.

````rust
enum ProfileUpdate {
    SetUsername(String),
    SetAge(i32)
}

let profile = use_coroutine(cx, |mut rx: UnboundedReciver<ProfileUpdate>| async move {
    let mut server = connect_to_server().await;

    while let Ok(msg) = rx.next().await {
        match msg {
            ProfileUpdate::SetUsername(name) => server.update_username(name).await,
            ProfileUpdate::SetAge(age) => server.update_age(age).await,
        }
    }
});


cx.render(rsx!{
    button {
        onclick: move |_| profile.send(ProfileUpdate::SetUsername("Bob".to_string())),
        "Update username"
    }
})
````

For sufficiently complex apps, we could build a bunch of different useful "services" that loop on channels to update the app.

````rust
let profile = use_coroutine(cx, profile_service);
let editor = use_coroutine(cx, editor_service);
let sync = use_coroutine(cx, sync_service);

async fn profile_service(rx: UnboundedReceiver<ProfileCommand>) {
    // do stuff
}

async fn sync_service(rx: UnboundedReceiver<SyncCommand>) {
    // do stuff
}

async fn editor_service(rx: UnboundedReceiver<EditorCommand>) {
    // do stuff
}
````

We can combine coroutines with [Fermi](https://docs.rs/fermi/latest/fermi/index.html) to emulate Redux Toolkit's Thunk system with much less headache. This lets us store all of our app's state *within* a task and then simply update the "view" values stored in Atoms. It cannot be understated how powerful this technique is: we get all the perks of native Rust tasks with the optimizations and ergonomics of global state. This means your *actual* state does not need to be tied up in a system like Fermi or Redux â€“ the only Atoms that need to exist are those that are used to drive the display/UI.

````rust
static USERNAME: Atom<String> = |_| "default".to_string();

fn app(cx: Scope) -> Element {
    let atoms = use_atom_root(cx);

    use_coroutine(cx, |rx| sync_service(rx, atoms.clone()));

    cx.render(rsx!{
        Banner {}
    })
}

fn Banner(cx: Scope) -> Element {
    let username = use_read(cx, USERNAME);

    cx.render(rsx!{
        h1 { "Welcome back, {username}" }
    })
}
````

Now, in our sync service, we can structure our state however we want. We only need to update the view values when ready.

````rust
enum SyncAction {
    SetUsername(String),
}

async fn sync_service(mut rx: UnboundedReceiver<SyncAction>, atoms: AtomRoot) {
    let username = atoms.write(USERNAME);
    let errors = atoms.write(ERRORS);

    while let Ok(msg) = rx.next().await {
        match msg {
            SyncAction::SetUsername(name) => {
                if set_name_on_server(&name).await.is_ok() {
                    username.set(name);
                } else {
                    errors.make_mut().push("SetUsernameFailed");
                }
            }
        }
    }
}
````

## Automatic injection into the Context API

Coroutine handles are automatically injected through the context API. You can use the `use_coroutine_handle` hook with the message type as a generic to fetch a handle.

````rust
fn Child(cx: Scope) -> Element {
    let sync_task = use_coroutine_handle::<SyncAction>(cx);

    sync_task.send(SyncAction::SetUsername);
}
````
# Spawning Futures

The `use_future` and `use_coroutine` hooks are useful if you want to unconditionally spawn the future. Sometimes, though, you'll want to only spawn a future in response to an event, such as a mouse click. For example, suppose you need to send a request when the user clicks a "log in" button. For this, you can use `cx.spawn`:

````rs@spawn.rs
let logged_in = use_state(cx, || false);

let log_in = move |_| {
    cx.spawn({
        let logged_in = logged_in.to_owned();

        async move {
            let resp = reqwest::Client::new()
                .post("http://example.com/login")
                .send()
                .await;

            match resp {
                Ok(_data) => {
                    println!("Login successful!");
                    logged_in.set(true);
                }
                Err(_err) => {
                    println!(
                        "Login failed - you need a login server running on localhost:8080."
                    )
                }
            }
        }
    });
};

cx.render(rsx! {
    button {
        onclick: log_in,
        "Login",
    }
})
````

 > 
 > Note: `spawn` will always spawn a *new* future. You most likely don't want to call it on every render.

Calling `spawn` will give you a `JoinHandle` which lets you cancel or pause the future.

## Spawning Tokio Tasks

Sometimes, you might want to spawn a background task that needs multiple threads or talk to hardware that might block your app code. In these cases, we can directly spawn a Tokio task from our future. For Dioxus-Desktop, your task will be spawned onto Tokio's Multithreaded runtime:

````rs@spawn.rs
cx.spawn(async {
    let _ = tokio::spawn(async {}).await;

    let _ = tokio::task::spawn_local(async {
        // some !Send work
    })
    .await;
});
````
# Best Practices

## Reusable Components

As much as possible, break your code down into small, reusable components and hooks, instead of implementing large chunks of the UI in a single component. This will help you keep the code maintainable â€“ it is much easier to e.g. add, remove or re-order parts of the UI if it is organized in components.

Organize your components in modules to keep the codebase easy to navigate!

## Minimize State Dependencies

While it is possible to share state between components, this should only be done when necessary. Any component that is associated with a particular state object needs to be re-rendered when that state changes. For this reason:

* Keep state local to a component if possible
* When sharing state through props, only pass down the specific data necessary
# Error handling

A selling point of Rust for web development is the reliability of always knowing where errors can occur and being forced to handle them

However, we haven't talked about error handling at all in this guide! In this chapter, we'll cover some strategies in handling errors to ensure your app never crashes.

## The simplest â€“ returning None

Astute observers might have noticed that `Element` is actually a type alias for `Option<VNode>`. You don't need to know what a `VNode` is, but it's important to recognize that we could actually return nothing at all:

````rust
fn App(cx: Scope) -> Element {
    None
}
````

This lets us add in some syntactic sugar for operations we think *shouldn't* fail, but we're still not confident enough to "unwrap" on.

 > 
 > The nature of `Option<VNode>` might change in the future as the `try` trait gets upgraded.

````rust
fn App(cx: Scope) -> Element {
    // immediately return "None"
    let name = cx.use_hook(|_| Some("hi"))?;
}
````

## Early return on result

Because Rust can't accept both Options and Results with the existing try infrastructure, you'll need to manually handle Results. This can be done by converting them into Options or by explicitly handling them.

````rust
fn App(cx: Scope) -> Element {
    // Convert Result to Option
    let name = cx.use_hook(|_| "1.234").parse().ok()?;


    // Early return
    let count = cx.use_hook(|_| "1.234");
    let val = match count.parse() {
        Ok(val) => val
        Err(err) => return cx.render(rsx!{ "Parsing failed" })
    };
}
````

Notice that while hooks in Dioxus do not like being called in conditionals or loops, they *are* okay with early returns. Returning an error state early is a completely valid way of handling errors.

## Match results

The next "best" way of handling errors in Dioxus is to match on the error locally. This is the most robust way of handling errors, though it doesn't scale to architectures beyond a single component.

To do this, we simply have an error state built into our component:

````rust
let err = use_state(cx, || None);
````

Whenever we perform an action that generates an error, we'll set that error state. We can then match on the error in a number of ways (early return, return Element, etc).

````rust
fn Commandline(cx: Scope) -> Element {
    let error = use_state(cx, || None);

    cx.render(match *error {
        Some(error) => rsx!(
            h1 { "An error occured" }
        )
        None => rsx!(
            input {
                oninput: move |_| error.set(Some("bad thing happened!")),
            }
        )
    })
}
````

## Passing error states through components

If you're dealing with a handful of components with minimal nesting, you can just pass the error handle into child components.

````rust
fn Commandline(cx: Scope) -> Element {
    let error = use_state(cx, || None);

    if let Some(error) = **error {
        return cx.render(rsx!{ "An error occured" });
    }

    cx.render(rsx!{
        Child { error: error.clone() }
        Child { error: error.clone() }
        Child { error: error.clone() }
        Child { error: error.clone() }
    })
}
````

Much like before, our child components can manually set the error during their own actions. The advantage to this pattern is that we can easily isolate error states to a few components at a time, making our app more predictable and robust.

## Going global

A strategy for handling cascaded errors in larger apps is through signaling an error using global state. This particular pattern involves creating an "error" context, and then setting it wherever relevant. This particular method is not as "sophisticated" as React's error boundary, but it is more fitting for Rust.

To get started, consider using a built-in hook like `use_context` and `use_context_provider` or Fermi. Of course, it's pretty easy to roll your own hook too.

At the "top" of our architecture, we're going to want to explicitly declare a value that could be an error.

````rust
enum InputError {
    None,
    TooLong,
    TooShort,
}

static INPUT_ERROR: Atom<InputError> = |_| InputError::None;
````

Then, in our top level component, we want to explicitly handle the possible error state for this part of the tree.

````rust
fn TopLevel(cx: Scope) -> Element {
    let error = use_read(cx, INPUT_ERROR);

    match error {
        TooLong => return cx.render(rsx!{ "FAILED: Too long!" }),
        TooShort => return cx.render(rsx!{ "FAILED: Too Short!" }),
        _ => {}
    }
}
````

Now, whenever a downstream component has an error in its actions, it can simply just set its own error state:

````rust
fn Commandline(cx: Scope) -> Element {
    let set_error = use_set(cx, INPUT_ERROR);

    cx.render(rsx!{
        input {
            oninput: move |evt| {
                if evt.value.len() > 20 {
                    set_error(InputError::TooLong);
                }
            }
        }
    })
}
````

This approach to error handling is best in apps that have "well defined" error states. Consider using a crate like `thiserror` or `anyhow` to simplify the generation of the error types.

This pattern is widely popular in many contexts and is particularly helpful whenever your code generates a non-recoverable error. You can gracefully capture these "global" error states without panicking or mucking up state.
# Antipatterns

This example shows what not to do and provides a reason why a given pattern is considered an "AntiPattern". Most anti-patterns are considered wrong for performance or code re-usability reasons.

## Unnecessarily Nested Fragments

Fragments don't mount a physical element to the DOM immediately, so Dioxus must recurse into its children to find a physical DOM node. This process is called "normalization". This means that deeply nested fragments make Dioxus perform unnecessary work. Prefer one or two levels of fragments / nested components until presenting a true DOM element.

Only Component and Fragment nodes are susceptible to this issue. Dioxus mitigates this with components by providing an API for registering shared state without the Context Provider pattern.

````rs@anti_patterns.rs
// âŒ Don't unnecessarily nest fragments
let _ = cx.render(rsx!(
    Fragment {
        Fragment {
            Fragment {
                Fragment {
                    Fragment {
                        div { "Finally have a real node!" }
                    }
                }
            }
        }
    }
));

// âœ… Render shallow structures
cx.render(rsx!(
    div { "Finally have a real node!" }
))
````

## Incorrect Iterator Keys

As described in the [dynamic rendering chapter](../interactivity/dynamic_rendering.md#the-key-attribute), list items must have unique keys that are associated with the same items across renders. This helps Dioxus associate state with the contained components and ensures good diffing performance. Do not omit keys, unless you know that the list will never change.

````rs@anti_patterns.rs
let data: &HashMap<_, _> = &cx.props.data;

// âŒ No keys
cx.render(rsx! {
    ul {
        data.values().map(|value| rsx!(
            li { "List item: {value}" }
        ))
    }
});

// âŒ Using index as keys
cx.render(rsx! {
    ul {
        cx.props.data.values().enumerate().map(|(index, value)| rsx!(
            li { key: "{index}", "List item: {value}" }
        ))
    }
});

// âœ… Using unique IDs as keys:
cx.render(rsx! {
    ul {
        cx.props.data.iter().map(|(key, value)| rsx!(
            li { key: "{key}", "List item: {value}" }
        ))
    }
})
````

## Avoid Interior Mutability in Props

While it is technically acceptable to have a `Mutex` or a `RwLock` in the props, they will be difficult to use.

Suppose you have a struct `User` containing the field `username: String`. If you pass a `Mutex<User>` prop to a `UserComponent` component, that component may wish to pass the username as a `&str` prop to a child component. However, it cannot pass that borrowed field down, since it only would live as long as the `Mutex`'s lock, which belongs to the `UserComponent` function. Therefore, the component will be forced to clone the `username` field.

## Avoid Updating State During Render

Every time you update the state, Dioxus needs to re-render the component â€“ this is inefficient! Consider refactoring your code to avoid this.

Also, if you unconditionally update the state during render, it will be re-rendered in an infinite loop.
# Publishing
# Publishing

Congrats! You've made your first Dioxus app that actually does some pretty cool stuff. This app uses your operating system's WebView library, so it's portable to be distributed for other platforms.

In this section, we'll cover how to bundle your app for macOS, Windows, and Linux.

## Install `cargo-bundle`

The first thing we'll do is install [`cargo-bundle`](https://github.com/burtonageo/cargo-bundle). This extension to cargo will make it very easy to package our app for the various platforms.

According to the `cargo-bundle` github page,

*"cargo-bundle is a tool used to generate installers or app bundles for GUI  executables built with cargo. It can create .app bundles for Mac OS X and iOS, .deb packages for Linux, and .msi installers for Windows (note however that iOS and Windows support is still experimental). Support for creating .rpm packages (for Linux) and .apk packages (for Android) is still pending."*

To install, simply run

`cargo install cargo-bundle`

## Setting up your project

To get a project setup for bundling, we need to add some flags to our `Cargo.toml` file.

````toml
[package]
name = "example"
# ...other fields...

[package.metadata.bundle]
name = "DogSearch"
identifier = "com.dogs.dogsearch"
version = "1.0.0"
copyright = "Copyright (c) Jane Doe 2016. All rights reserved."
category = "Developer Tool"
short_description = "Easily search for Dog photos"
long_description = """
This app makes it quick and easy to browse photos of dogs from over 200 bree
"""
````

## Building

Following cargo-bundle's instructions, we simply `cargo-bundle --release` to produce a final app with all the optimizations and assets builtin.

Once you've ran `cargo-bundle --release`, your app should be accessible in

`target/release/bundle/<platform>/`.

For example, a macOS app would look like this:

![Published App](/assets/static/publish.png)

Nice! And it's only 4.8 Mb â€“ extremely lean!! Because Dioxus leverages your platform's native WebView, Dioxus apps are extremely memory efficient and won't waste your battery.

 > 
 > Note: not all CSS works the same on all platforms. Make sure to view your app's CSS on each platform â€“ or web browser (Firefox, Chrome, Safari) before publishing.
## Publishing with Github Pages

To build our app and publish it to Github:

* Make sure GitHub Pages is set up for your repo
* Build your app with `trunk build --release` (include `--public-url <repo-name>` to update asset prefixes if using a project site)
* Move your generated HTML/CSS/JS/Wasm from `dist` into the folder configured for Github Pages
* Add and commit with git
* Push to GitHub
# Custom Renderer

Dioxus is an incredibly portable framework for UI development. The lessons, knowledge, hooks, and components you acquire over time can always be used for future projects. However, sometimes those projects cannot leverage a supported renderer or you need to implement your own better renderer.

Great news: the design of the renderer is entirely up to you! We provide suggestions and inspiration with the 1st party renderers, but only really require processing `DomEdits` and sending `UserEvents`.

## The specifics:

Implementing the renderer is fairly straightforward. The renderer needs to:

1. Handle the stream of edits generated by updates to the virtual DOM
1. Register listeners and pass events into the virtual DOM's event system

Essentially, your renderer needs to process edits and generate events to update the VirtualDOM. From there, you'll have everything needed to render the VirtualDOM to the screen.

Internally, Dioxus handles the tree relationship, diffing, memory management, and the event system, leaving as little as possible required for renderers to implement themselves.

For reference, check out the [javascript interpreter](https://github.com/DioxusLabs/dioxus/tree/master/packages/interpreter) or [tui renderer](https://github.com/DioxusLabs/dioxus/tree/master/packages/tui) as a starting point for your custom renderer.

## Templates

Dioxus is built around the concept of [Templates](https://docs.rs/dioxus-core/latest/dioxus_core/prelude/struct.Template.html). Templates describe a UI tree known at compile time with dynamic parts filled at runtime. This is useful internally to make skip diffing static nodes, but it is also useful for the renderer to reuse parts of the UI tree. This can be useful for things like a list of items. Each item could contain some static parts and some dynamic parts. The renderer can use the template to create a static part of the UI once, clone it for each element in the list, and then fill in the dynamic parts.

## Mutations

The `Mutation` type is a serialized enum that represents an operation that should be applied to update the UI. The variants roughly follow this set:

````rust
enum Mutation {
    AppendChildren,
    AssignId,
    CreatePlaceholder,
    CreateTextNode,
    HydrateText,
    LoadTemplate,
    ReplaceWith,
    ReplacePlaceholder,
    InsertAfter,
    InsertBefore,
    SetAttribute,
    SetText,
    NewEventListener,
    RemoveEventListener,
    Remove,
    PushRoot,
}
````

The Dioxus diffing mechanism operates as a [stack machine](https://en.wikipedia.org/wiki/Stack_machine) where the "push_root" method pushes a new "real" DOM node onto the stack and "append_child" and "replace_with" both remove nodes from the stack.

### An Example

For the sake of understanding, let's consider this example â€“ a very simple UI declaration:

````rust
rsx!( h1 {"count {x}"} )
````

To get things started, Dioxus must first navigate to the container of this h1 tag. To "navigate" here, the internal diffing algorithm generates the DomEdit `PushRoot` where the ID of the root is the container.

When the renderer receives this instruction, it pushes the actual Node onto its own stack. The real renderer's stack will look like this:

````rust
instructions: [
    PushRoot(Container)
]
stack: [
    ContainerNode,
]
````

Next, Dioxus will encounter the h1 node. The diff algorithm decides that this node needs to be created, so Dioxus will generate the DomEdit `CreateElement`. When the renderer receives this instruction, it will create an unmounted node and push it into its own stack:

````rust
instructions: [
    PushRoot(Container),
    CreateElement(h1),
]
stack: [
    ContainerNode,
    h1,
]
````

Next, Dioxus sees the text node, and generates the `CreateTextNode` DomEdit:

````rust
instructions: [
    PushRoot(Container),
    CreateElement(h1),
    CreateTextNode("hello world")
]
stack: [
    ContainerNode,
    h1,
    "hello world"
]
````

Remember, the text node is not attached to anything (it is unmounted) so Dioxus needs to generate an Edit that connects the text node to the h1 element. It depends on the situation, but in this case, we use `AppendChildren`. This pops the text node off the stack, leaving the h1 element as the next element in line.

````rust
instructions: [
    PushRoot(Container),
    CreateElement(h1),
    CreateTextNode("hello world"),
    AppendChildren(1)
]
stack: [
    ContainerNode,
    h1
]
````

We call `AppendChildren` again, popping off the h1 node and attaching it to the parent:

````rust
instructions: [
    PushRoot(Container),
    CreateElement(h1),
    CreateTextNode("hello world"),
    AppendChildren(1),
    AppendChildren(1)
]
stack: [
    ContainerNode,
]
````

Finally, the container is popped since we don't need it anymore.

````rust
instructions: [
    PushRoot(Container),
    CreateElement(h1),
    CreateTextNode("hello world"),
    AppendChildren(1),
    AppendChildren(1),
    PopRoot
]
stack: []
````

Over time, our stack looked like this:

````rust
[]
[Container]
[Container, h1]
[Container, h1, "hello world"]
[Container, h1]
[Container]
[]
````

Notice how our stack is empty once UI has been mounted. Conveniently, this approach completely separates the Virtual DOM and the Real DOM. Additionally, these edits are serializable, meaning we can even manage UIs across a network connection. This little stack machine and serialized edits make Dioxus independent of platform specifics.

Dioxus is also really fast. Because Dioxus splits the diff and patch phase, it's able to make all the edits to the RealDOM in a very short amount of time (less than a single frame) making rendering very snappy. It also allows Dioxus to cancel large diffing operations if higher priority work comes in while it's diffing.

It's important to note that there *is* one layer of connectedness between Dioxus and the renderer. Dioxus saves and loads elements (the PushRoot edit) with an ID. Inside the VirtualDOM, this is just tracked as a u64.

Whenever a `CreateElement` edit is generated during diffing, Dioxus increments its node counter and assigns that new element its current NodeCount. The RealDom is responsible for remembering this ID and pushing the correct node when PushRoot(ID) is generated. Dioxus reclaims the IDs of elements when removed. To stay in sync with Dioxus you can use a sparse Vec (Vec\<Option<T>\>) with possibly unoccupied items. You can use the ids as indexes into the Vec for elements, and grow the Vec when an id does not exist.

This little demo serves to show exactly how a Renderer would need to process an edit stream to build UIs. A set of serialized DomEditss for various demos is available for you to test your custom renderer against.

## Event loop

Like most GUIs, Dioxus relies on an event loop to progress the VirtualDOM. The VirtualDOM itself can produce events as well, so it's important that your custom renderer can handle those too.

The code for the WebSys implementation is straightforward, so we'll add it here to demonstrate how simple an event loop is:

````rust
pub async fn run(&mut self) -> dioxus_core::error::Result<()> {
    // Push the body element onto the WebsysDom's stack machine
    let mut websys_dom = crate::new::WebsysDom::new(prepare_websys_dom());
    websys_dom.stack.push(root_node);

    // Rebuild or hydrate the virtualdom
    let mutations = self.internal_dom.rebuild();
    websys_dom.apply_mutations(mutations);

    // Wait for updates from the real dom and progress the virtual dom
    loop {
        let user_input_future = websys_dom.wait_for_event();
        let internal_event_future = self.internal_dom.wait_for_work();

        match select(user_input_future, internal_event_future).await {
            Either::Left((_, _)) => {
                let mutations = self.internal_dom.work_with_deadline(|| false);
                websys_dom.apply_mutations(mutations);
            },
            Either::Right((event, _)) => websys_dom.handle_event(event),
        }

        // render
    }
}
````

It's important that you decode the real events from your event system into Dioxus' synthetic event system (synthetic meaning abstracted). This simply means matching your event type and creating a Dioxus `UserEvent` type. Right now, the VirtualEvent system is modeled almost entirely around the HTML spec, but we are interested in slimming it down.

````rust
fn virtual_event_from_websys_event(event: &web_sys::Event) -> VirtualEvent {
    match event.type_().as_str() {
        "keydown" => {
            let event: web_sys::KeyboardEvent = event.clone().dyn_into().unwrap();
            UserEvent::KeyboardEvent(UserEvent {
                scope_id: None,
                priority: EventPriority::Medium,
                name: "keydown",
                // This should be whatever element is focused
                element: Some(ElementId(0)),
                data: Arc::new(KeyboardData{
                    char_code: event.char_code(),
                    key: event.key(),
                    key_code: event.key_code(),
                    alt_key: event.alt_key(),
                    ctrl_key: event.ctrl_key(),
                    meta_key: event.meta_key(),
                    shift_key: event.shift_key(),
                    location: event.location(),
                    repeat: event.repeat(),
                    which: event.which(),
                })
            })
        }
        _ => todo!()
    }
}
````

## Custom raw elements

If you need to go as far as relying on custom elements for your renderer â€“ you totally can. This still enables you to use Dioxus' reactive nature, component system, shared state, and other features, but will ultimately generate different nodes. All attributes and listeners for the HTML and SVG namespace are shuttled through helper structs that essentially compile away (pose no runtime overhead). You can drop in your own elements any time you want, with little hassle. However, you must be absolutely sure your renderer can handle the new type, or it will crash and burn.

These custom elements are defined as unit structs with trait implementations.

For example, the `div` element is (approximately!) defined as such:

````rust
struct div;
impl div {
    /// Some glorious documentation about the class property.
    const TAG_NAME: &'static str = "div";
    const NAME_SPACE: Option<&'static str> = None;
    // define the class attribute
    pub fn class<'a>(&self, cx: NodeFactory<'a>, val: Arguments) -> Attribute<'a> {
        cx.attr("class", val, None, false)
    }
    // more attributes
}
````

You've probably noticed that many elements in the `rsx!` macros support on-hover documentation. The approach we take to custom elements means that the unit struct is created immediately where the element is used in the macro. When the macro is expanded, the doc comments still apply to the unit struct, giving tons of in-editor feedback, even inside a proc macro.

# Native Core

If you are creating a renderer in rust, native-core provides some utilities to implement a renderer. It provides an abstraction over DomEdits and handles the layout for you.

## RealDom

The `RealDom` is a higher-level abstraction over updating the Dom. It updates with `DomEdits` and provides a way to incrementally update the state of nodes based on what attributes change.

### Example

Let's build a toy renderer with borders, size, and text color.
Before we start let's take a look at an example element we can render:

````rust
cx.render(rsx!{
    div{
        color: "red",
        p{
            border: "1px solid black",
            "hello world"
        }
    }
})
````

In this tree, the color depends on the parent's color. The size depends on the children's size, the current text, and the text size. The border depends on only the current node.

In the following diagram arrows represent dataflow:

[![](https://mermaid.ink/img/pako:eNqdVNFqgzAU_RXJXizUUZPJmIM-jO0LukdhpCbO0JhIGteW0n9fNK1Oa0brfUnu9VxyzzkXjyCVhIIYZFzu0hwr7X2-JcIzsa3W3wqXuZdKoele22oddfa1Y0Tnfn31muvMfqeCDNq3GmvaNROmaKqZFO1DPTRhP8MOd1fTWYNDvzlmQbBMJZcq9JtjNgY1mLVUhBqQPQeojl3wGCw5PsjqnIe-zXqEL8GZ2Kz0gVMPmoeU3ND4IcuiaLGY2zRouuKncv_qGKv3VodpJe0JVU6QCQ5kgqMyWQVr8hbk4hm1PBcmsuwmnrCVH94rP7xN_ucp8sOB_EPSfz9drYVrkpc_AmH8_yTjJueUc-ntpOJkgt2os9tKjcYlt-DLUiD3UsB2KZCLcwjv3Aq33-g2v0M0xXA0MBy5DUdXi-gcJZriuLmAOSioKjAj5ld8rMsJ0DktaAJicyVYbRKQiJPBVSUx438QpqUCcYb5ls4BrrRcHUTaFizqnWGzR8W5evoFI-bJdw)](https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNqdVNFqgzAU_RXJXizUUZPJmIM-jO0LukdhpCbO0JhIGteW0n9fNK1Oa0brfUnu9VxyzzkXjyCVhIIYZFzu0hwr7X2-JcIzsa3W3wqXuZdKoele22oddfa1Y0Tnfn31muvMfqeCDNq3GmvaNROmaKqZFO1DPTRhP8MOd1fTWYNDvzlmQbBMJZcq9JtjNgY1mLVUhBqQPQeojl3wGCw5PsjqnIe-zXqEL8GZ2Kz0gVMPmoeU3ND4IcuiaLGY2zRouuKncv_qGKv3VodpJe0JVU6QCQ5kgqMyWQVr8hbk4hm1PBcmsuwmnrCVH94rP7xN_ucp8sOB_EPSfz9drYVrkpc_AmH8_yTjJueUc-ntpOJkgt2os9tKjcYlt-DLUiD3UsB2KZCLcwjv3Aq33-g2v0M0xXA0MBy5DUdXi-gcJZriuLmAOSioKjAj5ld8rMsJ0DktaAJicyVYbRKQiJPBVSUx438QpqUCcYb5ls4BrrRcHUTaFizqnWGzR8W5evoFI-bJdw)

To help in building a Dom, native-core provides four traits: State, ChildDepState, ParentDepState, NodeDepState, and a RealDom struct. The ChildDepState, ParentDepState, and NodeDepState provide a way to describe how some information in a node relates to that of its relatives. By providing how to build a single node from its relations, native-core will derive a way to update the state of all nodes for you with `#[derive(State)]`. Once you have a state you can provide it as a generic to RealDom. RealDom provides all of the methods to interact and update your new dom.

````rust
use dioxus_native_core::node_ref::*;
use dioxus_native_core::state::{ChildDepState, NodeDepState, ParentDepState, State};
use dioxus_native_core_macro::{sorted_str_slice, State};

#[derive(Default, Copy, Clone)]
struct Size(f32, f32);
// Size only depends on the current node and its children, so it implements ChildDepState
impl ChildDepState for Size {
    // Size accepts a font size context
    type Ctx = f32;
    // Size depends on the Size part of each child
    type DepState = Self;
    // Size only cares about the width, height, and text parts of the current node
    const NODE_MASK: NodeMask =
        NodeMask::new_with_attrs(AttributeMask::Static(&sorted_str_slice!(["width", "height"]))).with_text();
    fn reduce<'a>(
        &mut self,
        node: NodeView,
        children: impl Iterator<Item = &'a Self::DepState>,
        ctx: &Self::Ctx,
    ) -> bool
    where
        Self::DepState: 'a,
    {
        let mut width;
        let mut height;
        if let Some(text) = node.text() {
            // if the node has text, use the text to size our object
            width = text.len() as f32 * ctx;
            height = *ctx;
        } else {
            // otherwise, the size is the maximum size of the children
            width = children
                .by_ref()
                .map(|item| item.0)
                .reduce(|accum, item| if accum >= item { accum } else { item })
                .unwrap_or(0.0);

            height = children
                .map(|item| item.1)
                .reduce(|accum, item| if accum >= item { accum } else { item })
                .unwrap_or(0.0);
        }
        // if the node contains a width or height attribute it overrides the other size
        for a in node.attributes(){
            match a.name{
                "width" => width = a.value.as_float32().unwrap(),
                "height" => height = a.value.as_float32().unwrap(),
                // because Size only depends on the width and height, no other attributes will be passed to the member
                _ => panic!()
            }
        }
        // to determine what other parts of the dom need to be updated we return a boolean that marks if this member changed
        let changed = (width != self.0) || (height != self.1);
        *self = Self(width, height);
        changed
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Default)]
struct TextColor {
    r: u8,
    g: u8,
    b: u8,
}
// TextColor only depends on the current node and its parent, so it implements ParentDepState
impl ParentDepState for TextColor {
    type Ctx = ();
    // TextColor depends on the TextColor part of the parent
    type DepState = Self;
    // TextColor only cares about the color attribute of the current node
    const NODE_MASK: NodeMask = NodeMask::new_with_attrs(AttributeMask::Static(&["color"]));
    fn reduce(
        &mut self,
        node: NodeView,
        parent: Option<&Self::DepState>,
        _ctx: &Self::Ctx,
    ) -> bool {
        // TextColor only depends on the color tag, so getting the first tag is equivilent to looking through all tags
        let new = match node.attributes().next().map(|attr| attr.name) {
            // if there is a color tag, translate it
            Some("red") => TextColor { r: 255, g: 0, b: 0 },
            Some("green") => TextColor { r: 0, g: 255, b: 0 },
            Some("blue") => TextColor { r: 0, g: 0, b: 255 },
            Some(_) => panic!("unknown color"),
            // otherwise check if the node has a parent and inherit that color
            None => match parent {
                Some(parent) => *parent,
                None => Self::default(),
            },
        };
        // check if the member has changed
        let changed = new != *self;
        *self = new;
        changed
    }
}

#[derive(Debug, Clone, PartialEq, Default)]
struct Border(bool);
// TextColor only depends on the current node, so it implements NodeDepState
impl NodeDepState<()> for Border {
    type Ctx = ();
   
    // Border does not depended on any other member in the current node
    const NODE_MASK: NodeMask =
        NodeMask::new_with_attrs(AttributeMask::Static(&["border"]));
    fn reduce(&mut self, node: NodeView, _sibling: (), _ctx: &Self::Ctx) -> bool {
        // check if the node contians a border attribute
        let new = Self(node.attributes().next().map(|a| a.name == "border").is_some());
        // check if the member has changed
        let changed = new != *self;
        *self = new;
        changed
    }
}

// State provides a derive macro, but anotations on the members are needed in the form #[dep_type(dep_member, CtxType)]
#[derive(State, Default, Clone)]
struct ToyState {
    // the color member of it's parent and no context
    #[parent_dep_state(color)]
    color: TextColor,
    // depends on the node, and no context
    #[node_dep_state()]
    border: Border,
    // depends on the layout_width member of children and f32 context (for text size)
    #[child_dep_state(size, f32)]
    size: Size,
}
````

Now that we have our state, we can put it to use in our dom. Re can update the dom with update_state to update the structure of the dom (adding, removing, and changing properties of nodes) and then apply_mutations to update the ToyState for each of the nodes that changed.

````rust
fn main(){
    fn app(cx: Scope) -> Element {
        cx.render(rsx!{
            div{
                color: "red",
                "hello world"
            }
        })
    }
    let vdom = VirtualDom::new(app);
    let rdom: RealDom<ToyState> = RealDom::new();

    let mutations = dom.rebuild();
    // update the structure of the real_dom tree
    let to_update = rdom.apply_mutations(vec![mutations]);
    let mut ctx = AnyMap::new();
    // set the font size to 3.3
    ctx.insert(3.3f32);
    // update the ToyState for nodes in the real_dom tree
    let _to_rerender = rdom.update_state(&dom, to_update, ctx).unwrap();

    // we need to run the vdom in a async runtime
    tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()?
        .block_on(async {
            loop{
                let wait = vdom.wait_for_work();
                let mutations = vdom.work_with_deadline(|| false);
                let to_update = rdom.apply_mutations(mutations);
                let mut ctx = AnyMap::new();
                ctx.insert(3.3);
                let _to_rerender = rdom.update_state(vdom, to_update, ctx).unwrap();

                // render...
            }
        })
}
````

## Layout

For most platforms, the layout of the Elements will stay the same. The layout_attributes module provides a way to apply HTML attributes to a stretch layout style.

## Conclusion

That should be it! You should have nearly all the knowledge required on how to implement your own renderer. We're super interested in seeing Dioxus apps brought to custom desktop renderers, mobile renderers, video game UI, and even augmented reality! If you're interested in contributing to any of these projects, don't be afraid to reach out or join the [community](https://discord.gg/XgGxMSkvUM).
# Roadmap & Feature-set

This feature set and roadmap can help you decide if what Dioxus can do today works for you.

If a feature that you need doesn't exist or you want to contribute to projects on the roadmap, feel free to get involved by [joining the discord](https://discord.gg/XgGxMSkvUM).

Generally, here's the status of each platform:

* **Web**: Dioxus is a great choice for pure web-apps â€“ especially for CRUD/complex apps. However, it does lack the ecosystem of React, so you might be missing a component library or some useful hook.

* **SSR**: Dioxus is a great choice for pre-rendering, hydration, and rendering HTML on a web endpoint. Be warned â€“ the VirtualDom is not (currently) `Send + Sync`.

* **Desktop**: You can build very competent single-window desktop apps right now. However, multi-window apps require support from Dioxus core and are not ready.

* **Mobile**: Mobile support is very young. You'll be figuring things out as you go and there are not many support crates for peripherals.

* **LiveView**: LiveView support is very young. You'll be figuring things out as you go. Thankfully, none of it is too hard and any work can be upstreamed into Dioxus.

## Features

---

|Feature|Status|Description|
|-------|------|-----------|
|Conditional Rendering|âœ…|if/then to hide/show component|
|Map, Iterator|âœ…|map/filter/reduce to produce rsx!|
|Keyed Components|âœ…|advanced diffing with keys|
|Web|âœ…|renderer for web browser|
|Desktop (webview)|âœ…|renderer for desktop|
|Shared State (Context)|âœ…|share state through the tree|
|Hooks|âœ…|memory cells in components|
|SSR|âœ…|render directly to string|
|Component Children|âœ…|cx.children() as a list of nodes|
|Headless components|âœ…|components that don't return real elements|
|Fragments|âœ…|multiple elements without a real root|
|Manual Props|âœ…|Manually pass in props with spread syntax|
|Controlled Inputs|âœ…|stateful wrappers around inputs|
|CSS/Inline Styles|âœ…|syntax for inline styles/attribute groups|
|Custom elements|âœ…|Define new element primitives|
|Suspense|âœ…|schedule future render from future/promise|
|Integrated error handling|âœ…|Gracefully handle errors with ? syntax|
|NodeRef|âœ…|gain direct access to nodes|
|Re-hydration|âœ…|Pre-render to HTML to speed up first contentful paint|
|Jank-Free Rendering|âœ…|Large diffs are segmented across frames for silky-smooth transitions|
|Effects|âœ…|Run effects after a component has been committed to render|
|Portals|ðŸ› |Render nodes outside of the traditional tree structure|
|Cooperative Scheduling|ðŸ› |Prioritize important events over non-important events|
|Server Components|ðŸ› |Hybrid components for SPA and Server|
|Bundle Splitting|ðŸ‘€|Efficiently and asynchronously load the app|
|Lazy Components|ðŸ‘€|Dynamically load the new components as the page is loaded|
|1st class global state|âœ…|redux/recoil/mobx on top of context|
|Runs natively|âœ…|runs as a portable binary w/o a runtime (Node)|
|Subtree Memoization|âœ…|skip diffing static element subtrees|
|High-efficiency templates|âœ…|rsx! calls are translated to templates on the DOM's side|
|Compile-time correct|âœ…|Throw errors on invalid template layouts|
|Heuristic Engine|âœ…|track component memory usage to minimize future allocations|
|Fine-grained reactivity|ðŸ‘€|Skip diffing for fine-grain updates|

* âœ… = implemented and working
* ðŸ›  = actively being worked on
* ðŸ‘€ = not yet implemented or being worked on

## Roadmap

These Features are planned for the future of Dioxus:

### Core

* [x] Release of Dioxus Core
* [x] Upgrade documentation to include more theory and be more comprehensive
* [x] Support for HTML-side templates for lightning-fast dom manipulation
* [ ] Support for multiple renderers for same virtualdom (subtrees)
* [ ] Support for ThreadSafe (Send + Sync)
* [ ] Support for Portals

### SSR

* [x] SSR Support + Hydration
* [ ] Integrated suspense support for SSR

### Desktop

* [ ] Declarative window management
* [ ] Templates for building/bundling
* [ ] Fully native renderer
* [ ] Access to Canvas/WebGL context natively

### Mobile

* [ ] Mobile standard library
  * [ ] GPS
  * [ ] Camera
  * [ ] filesystem
  * [ ] Biometrics
  * [ ] WiFi
  * [ ] Bluetooth
  * [ ] Notifications
  * [ ] Clipboard
* [ ] Animations
* [ ] Native Renderer

### Bundling (CLI)

* [x] Translation from HTML into RSX
* [x] Dev server
* [x] Live reload
* [x] Translation from JSX into RSX
* [ ] Hot module replacement
* [ ] Code splitting
* [ ] Asset macros
* [ ] Css pipeline
* [ ] Image pipeline

### Essential hooks

* [x] Router
* [x] Global state management
* [ ] Resize observer

## Work in Progress

### Build Tool

We are currently working on our own build tool called [Dioxus CLI](https://github.com/DioxusLabs/cli) which will support:

* an interactive TUI
* on-the-fly reconfiguration
* hot CSS reloading
* two-way data binding between browser and source code
* an interpreter for `rsx!`
* ability to publish to github/netlify/vercel
* bundling for iOS/Desktop/etc

### Server Component Support

While not currently fully implemented, the expectation is that LiveView apps can be a hybrid between Wasm and server-rendered where only portions of a page are "live" and the rest of the page is either server-rendered, statically generated, or handled by the host SPA.

### Native rendering

We are currently working on a native renderer for Dioxus using WGPU called [Blitz](https://github.com/DioxusLabs/blitz/). This will allow you to build apps that are rendered natively for iOS, Android, and Desktop.
# Contributing

Development happens in the [Dioxus GitHub repository](https://github.com/DioxusLabs/dioxus). If you've found a bug or have an idea for a feature, please submit an issue (but first check if someone hasn't [done it already](https://github.com/DioxusLabs/dioxus/issues)).

[GitHub discussions](https://github.com/DioxusLabs/dioxus/discussions) can be used as a place to ask for help or talk about features. You can also join [our Discord channel](https://discord.gg/XgGxMSkvUM) where some development discussion happens.

## Improving Docs

If you'd like to improve the docs, PRs are welcome! Both Rust docs ([source](https://github.com/DioxusLabs/dioxus/tree/master/packages)) and this guide ([source](https://github.com/DioxusLabs/dioxus/tree/master/docs/guide)) can be found in the GitHub repo.

## Working on the Ecosystem

Part of what makes React great is the rich ecosystem. We'd like the same for Dioxus! So if you have a library in mind that you'd like to write and many people would benefit from, it will be appreciated. You can [browse npm.js](https://www.npmjs.com/search?q=keywords:react-component) for inspiration.

## Bugs & Features

If you've fixed [an open issue](https://github.com/DioxusLabs/dioxus/issues), feel free to submit a PR! You can also take a look at [the roadmap](./roadmap.md) and work on something in there. Consider [reaching out](https://discord.gg/XgGxMSkvUM) to the team first to make sure everyone's on the same page, and you don't do useless work!

All pull requests (including those made by a team member) must be approved by at least one other team member.
Larger, more nuanced decisions about design, architecture, breaking changes, trade-offs, etc. are made by team consensus.
