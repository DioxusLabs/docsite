<SYSTEM>This is the developer documentation for Dioxus at /learn/0.7/essentials/ui/ and all its subroutes.</SYSTEM>

# Building User Interfaces

Welcome to Dioxus! This first chapter teaches you how to build beautiful user interfaces in Rust and Dioxus.

Dioxus allows you to write user interfaces in HTML and CSS. On the web, your UI is native and accessible, and on desktop and mobile, your widgets are rendered either in a webview or natively with hybrid native components.

HTML and CSS allow you to build very beautiful, rich, interactive experiences. The world's top companies all use HTML and CSS for their sites and applications. Even this doc site is built in HTML and CSS:

![Animated Homepage](/assets/07/anim-homepage.mp4)

## What Dioxus Gives You

Dioxus gives you all the tools you need to leverage HTML, CSS, and Rust in their full glory.

This includes:

* Hot-reloading for Rust code, UI, styles, and assets
* Cross-platform renderers for web, desktop, and mobile
* Reactivity system for managing and updating state
* Growing SDK of cross-platform APIs
* Backend integration for building fullstack web apps
* Tools for bundling and deploying to production

You can do anything in Dioxus that you could do with HTML and CSS alone.

## What HTML and CSS Gives You

HTML and CSS are powerful technologies (albet, with lots of baggage) that make it easy to build beautiful UIs that work across billions of devices.

HTML and CSS give you lots of tools:

* Multiple layout algorithms (flexbox, grid, table, float, block, etc)
* Stylesheets for app-level theming
* Per-element styling
* Great accessibility and screen-reader support
* Inline SVG support
* CSS Animations
* Multimedia elements like `img`, `video`, and `audio`
* and more!

HTML and CSS might not be the *absolute best* tools for UI work, but they are widely used, work nearly everywhere, and are extremely well documented.

## What Rust Gives You

Why write a UI framework in Rust? Why build an app with Rust? Rust was originally intended for systems programming, though we at Dioxus are working on making it suitable for high-level programming like app dev.

Rust has a rather steep learning curve, but the benefits are tremendous:

* Great, standardized tooling (cargo, rustc)
* Huge ecosystem and great package manager (crates.io, Cargo.toml)
* Runs everywhere - Mac, Windows, Linux, iOS, Android, Web, etc
* Strong type system that prevents many logic bugs at compile time
* Great performance, rivaling languages like C / C++
* Reliable, even at massive scale

There are drawbacks too, like slower compile times, steep learning curve, and ergonomic papercuts. Our goal is to improve the "high-level Rust" experience to make it on par with languages like TypeScript, but with the added benefits of Rust.

We've been pushing Rust forward *so much* that we gave a long-form keynote at RustConf 2025 to talk about our work on things like hot-patching and automatic ref-counting.

<iframe style="width: 100%" height="500px" class="centered-overflow" src="https://www.youtube.com/embed/Kl90J5RmPxY" title="High-Level Rust" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

# Introducing RSX

Dioxus apps are comprised of small elements composed into components and then assembled into a tree. To construct our components, we use a combination of Rust code and a simplified dialect of Rust that we call "RSX".

RSX is designed to look and feel like a blend between HTML and SwiftUI:

````rust
rsx! {
    h1 { "Welcome to Dioxus!" }
    h3 { "Brought to you by {author}" }
    p { class: "main-content", {article.content} }
}
````

Currently, RSX is the primary syntax that developers use to build Dioxus apps. There are other options, but RSX has the best developer tooling like instant hot-reloading, code-folding, and syntax highlighting.

## The `rsx!` macro

If you're familiar with libraries like React or Vue, you will likely be familiar with the JSX markup language. JSX is an alternative form of JavaScript that lets developers blend JavaScript code and XML in one file. These libraries rely on compiler plugins to transform the syntax into pure JavaScript code which then renders HTML.

With Rust, we achieve a similar experience through the use of [procedural macros](https://doc.rust-lang.org/reference/procedural-macros.html) (proc macros). Proc macros are tiny compiler plugins that transform Rust tokens into Rust code. You can recognize that a function is a proc macro thanks to the `!` modifier. For example, the `rsx!` macro transforms RSX syntax into Rust code:

````rust
// This macro...
rsx! {
    div { "hello {world}!" }
}

// Expands to this template:
static TEMPLATE: Template = Template {
    nodes: [
        ElementNode {
            tag: div,
            children: [
                TextNode {
                    contents: DynamicText(0)
                }
            ]
        }
    ]
}
TEMPLATE.render([
    format!("hello {world}")
])
````

RSX does a *lot* of heavy lifting for us, significantly cutting down on the verbosity of declaring UI. It also constructs our UIs in the *most* efficient representation, making rendering extremely fast.

## Dioxus renders HTML and CSS

We want to ensure Dioxus is easy to learn and extremely portable. Instead of inventing a new styling, layout, and markup system, we instead opted to simply rely on HTML and CSS everywhere. For the web, this is handy - websites are already built with HTML and CSS. On desktop and mobile, we ship a renderer that converts your HTML and CSS to native widgets automatically.

Our hybrid HTML approach combines the best parts of frameworks like Flutter and React Native. Teams get maximum code-reuse, get to work with a familiar markup language, and AI tools are immediately helpful. Instead of building bespoke native apps for each platform, teams can simply write their components once and render them everywhere.

Our rendering engine [Blitz](https://github.com/dioxuslabs/blitz) is open source and is often indistinguishable from browser-grade engines:

![Blitz vs Safari](/assets/07/blitz-vs-safari.png)

If you are not familiar with HTML, this guide will help you get started with the basics. For more detail, the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTML) are a great resource. Many tools provide visual designers or AI assistance for constructing UI from HTML elements.

## A Variety of Renderers

Dioxus is extremely modular. Because the RSX representation is generic, you can even swap out the elements, choosing to render UI that is *not* made of HTML and CSS. While the Dioxus team intends to only maintain HTML/CSS-based renderers, third-party renderers exist that unlock extended functionality.

For example, the [Freya](https://freyaui.dev) project renders the Dioxus tree using Google's Skia renderer. Skia has a CPU-only architecture, works across a wide range of devices, and enables deeper control over UI effects:

![Example Freya App](/assets/07/freya-todo.webm)

The Dioxus team maintains three first-party renderers:

* Dioxus-Web: A web-compatible engine that renders directly to HTML DOM Nodes
* Dioxus-Webview: A desktop and mobile engine that renders to the system webview
* Dioxus-Native: A desktop and mobile engine that renders to native elements

The Web and Webview renderers are the most mature engines while Dioxus-Native is still undergoing substantial improvements.
# Elements and Text

User interfaces are assembled by combining text and UI elements together in a useful and visually appealing tree. An example of some text and elements with RSX may look like:

````rs@building_uis_with_rsx.rs
let author = "Dioxus Labs";
let content = "Build cool things ✌️";

rsx! {
    h1 { "Welcome to Dioxus!" }
    h3 { "Brought to you by {author}" }
    p { class: "main-content", {content} }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::Basic {}
}
````

## Text Nodes

Any content surrounded by quotes is rendered as a text node in RSX:

````rs@building_uis_with_rsx.rs
rsx! { "Hello world" }
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::Text {}
}
````

Text nodes in Dioxus automatically implement the same rules as Rust's [`format!`](https://doc.rust-lang.org/std/macro.format.html) macro, including [Display](https://doc.rust-lang.org/std/fmt/trait.Display.html) and [Debug](https://doc.rust-lang.org/std/fmt/trait.Debug.html) printing.

````rs@building_uis_with_rsx.rs
let world = "earth";
rsx! { "Hello {world}!" }
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::SimpleFormattedText {}
}
````

Unlike Rust's format macro, `rsx!` lets us embed entire Rust expressions which can be quite handy when working with complex objects or calling functions inline.

````rs@building_uis_with_rsx.rs
let user = use_signal(|| User {
    name: "Dioxus".to_string(),
});
rsx! { "Hello {user.read().name}" }
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::FormattedText {}
}
````

## Elements

The most basic building block of HTML is an element. In RSX, an element is declared with a name and then curly braces. One of the most common elements is the `input` element. The input element creates an interactive input box:

````rs@building_uis_with_rsx.rs
rsx! {
    input {}
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::Input {}
}
````

Elements can take additional parameters called attributes that modify how the element is rendered. Attributes are added inline, similar to adding fields to a struct instantiation:

````rs@building_uis_with_rsx.rs
rsx! {
    input { placeholder: "type something cool!" }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputPlaceholder {}
}
````

There are a huge number of HTML elements available, including, but not limited to:

* Text and Content: `p`, `h1`, `span`, `div`, `a`, `pre`, etc.
* Forms and Input: `form`, `input`, `textarea`, `select`, `button`, etc.
* Media and Content: `img`, `video`, `audio`, `source`, `canvas`, `svg`, `iframe`, etc.
* Tables: `table`, `thead`, `tbody`, `tfoot`, `tr`, `th`, `td`, etc.
* Semantic Elements: `details`, `summary`, `dialog`, `progress`, `meter`, `time`, etc.

Check the [HTML Element reference](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements) for the full list.

## The `Element` type

The `rsx!` macro returns an object with the type of `Element`. These objects can be assigned to variables, cheaply cloned, and stored in state.

````rust
let header: Element = rsx! {
    div {
        h1 { "Dioxus!" }
    }
}
````

We can even create functions that return an `Element`:

````rust
fn create_description(content: &str) -> Element {
    rsx! {
        span { class: "description", "{content}" }
    }
}
````

Under the hood, the `Element` type is actually an alias for `Result<VNode>`. In Rust, a [Result](https://doc.rust-lang.org/std/result/) is an enumerated value that can either be an `Ok(value)` or an `Err(error)`. This means we can match on an Element, or even throw errors while rendering it:

````rust
fn create_description(content: &str) -> Element {
    if content.is_empty() {
        return Err("Missing description".into());
    }

    rsx! {
        span { class: "description", "{content}" }
    }
}
````

Dioxus defines its own error based on the [`anyhow`](https://docs.rs/anyhow/latest/anyhow/) error which then composes with other utilities like Error Boundaries and Server Functions.
# Attributes

While we could build a UI by assembling unstyled elements and text, we typically want to customize their appearance and behavior. This is where we use *element attributes*. Attributes provide extra information to the renderer on how to display the UI.

You can specify attributes by adding the name of the attribute, a colon, and then the value to the body of an element. For example, we might want to style a div with a particular [class](https://www.w3schools.com/html/html_classes.asp) and [ID](https://www.w3schools.com/html/html_id.asp), which we add as attributes:

````rust
rsx! {
    div {
        class: "container",
        id: "root-container"
    }
}
````

We can use an attribute to set the `type` of an input element. The default type is `text` which shows a text input box, but we can set it to `number` to only accept numbers:

````rs@building_uis_with_rsx.rs
rsx! {
    input { type: "number" }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputType {}
}
````

Just like text nodes, attributes can include formatted segments. We can set the value of the input element to a signal to control it:

````rs@building_uis_with_rsx.rs
let mut value = use_signal(|| "Hello world".to_string());
rsx! {
    input { value: "{value}" }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputValue {}
}
````

## Attribute Scope

Every element has two sets of attributes:

* [Global Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes): attributes which can be applied to *every* element
* [Specific Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes): attributes that only apply to one specific element

For example, all elements support the `id` and `class` attributes, but only `video` elements support the `autoplay` attribute. For a full list of attributes, visit the relevant links above.

## IDE Support

RSX provides autocomplete and inline docs support for elements and their attributes. To get autocomplete suggestions, simply start typing in your editor:

![Autocomplete](/assets/07/ide_autocomplete.png)

We've documented every element with documentation pulled from the [Mozilla Developer Docs](https://developer.mozilla.org/en-US/docs/Web). Simply hover over the element with your cursor for more information:

![Element Hover](/assets/07/ide_hover.png)

The same docs apply for attributes as well:

![Element Hover](/assets/07/ide_listener.png)

## Non-Text Attributes

Typically, you'll add attributes to your elements using formatted text. However, attributes can accept a wide range of value types, including:

* `Text`: Formatted text, the `String` type, or anything that implements `Display`.
* `Float`: Floating point numbers, typically on sliders and inputs.
* `Int`: Integer numbers for discrete gradations.
* `Bool`: A boolean value indicating true/false.
* `Listener`: A Rust callback that will be executed when the attribute is triggered.
* `Any`: A type-erased [`Rc<dyn Any>`](https://doc.rust-lang.org/std/any/index.html), typically used by 3rd-party renderers.
* `None`: The attribute will be removed from the element entirely.

Most commonly, you might use the `bool` attribute to set a boolean state:

````rust
rsx! {
    input {
        type: "checkbox",
        checked: true
    }
}
````

Or the `Some`/`None` variant for setting an HTML Boolean Attribute:

````rust
rsx! {
    div { itemscope: Some("scope") }
}
````

Note that Dioxus automatically converts `false` for some attributes to `None` in order to match the behavior of the [HTML Boolean Attribute](https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML).

## Event Listeners

While some attributes influence how an element is rendered, other attributes influence its interactive behavior. These attributes, called Event Listeners, allow you to respond to user input.

In RSX, event handlers always start with `on`. The syntax is the same as normal attributes, but event handlers only accept a closure that responds to the event. We can attach an event listener to the `oninput` event of the input element to listen for changes to the input:

````rs@building_uis_with_rsx.rs
rsx! {
    input {
        oninput: move |event| {
            println!("Input changed to: {}", event.value());
        },
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::OnInputSimple {}
}
````

More information about event listeners including how events bubble and how to prevent default behavior can be found later in the [Event Handlers](../basics/event_handlers.md) of the Reactivity section.

There are a wide range of event listeners available - see the full [HTML list](https://developer.mozilla.org/en-US/docs/Web/Events) for more details.

## Spreading Attributes

Occasionally, the set of attributes you want to pass to an element might either be dynamic or defined elsewhere in your application. In these cases, you can spread attribute lists into elements with the `..` syntax. Typically, lists of attributes will be passed into a component via its Properties, which we cover in a later chapter.

````rust
let attributes = vec![
    Attribute {
        name: "id",
        namespace: None,
        volatile: false,
        value: "cool-button".into_value(),
    }
];

rsx! {
    button { ..attributes, "button" }
}
````

Attributes lists will be merged in the order they appear, so later attributes in the list take precedence over earlier attributes. Attribute spreading becomes very useful when refactoring your UI into a reusable component libraries.

## Special Attributes

Most attributes in RSX are rendered verbatim, but there are a few exceptions. In some cases, RSX deviates from traditional HTML to simplify development or work better with the ecosystem tools.

### Conditional Attributes

You can conditionally set an attribute by setting the attribute value to an unterminated if statement. If the if statement evaluates to true, the attribute will be set:

````rs@building_uis_with_rsx.rs
let number_type = use_signal(|| false);
rsx! {
    input { type: if number_type() { "number" } }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::InputDisabled {}
}
````

### Style attributes

In addition to the standard `style` attribute, each style can also be passed as a separate attribute. For example, we can set the `color` and `font-size` of an element using the `color` and `font_size` attributes:

````rs@building_uis_with_rsx.rs
rsx! {
    div { style: "width: 20px; height: 20px; background-color: red; margin: 10px;" }
    div {
        width: "20px",
        height: "20px",
        background_color: "red",
        margin: "10px",
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::StyleAttributes {}
}
````

### Class attribute

Most attributes can only be defined once per element, but the `class` attribute can be defined multiple times. Each class will be added to the element's class list. This can be convenient when adding many optional classes to an element in a styling system like TailwindCSS:

````rs@building_uis_with_rsx.rs
rsx! {
    span {
        class: if red { "bg-red-500" },
        class: if blue_border { "border border-blue-500" },
        class: "w-4 h-4 block",
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::ClassAttribute {}
}
````

This feature is especially important when using TailwindCSS since the class compiler does not understand formatted Rust strings when collecting classes. By placing the dynamic class in a sibling attribute, the Tailwind compiler sees *both* class lists at compile time.

### onresize and onvisible

Dioxus provides two custom HTML attributes *not* found in the HTML specification.

* onresize
* onvisible

Dioxus automatically constructs a cross-platform `IntersectionObserver` that emits the respective events for you.

With onresize, you can watch for changes to an element's size and position:

````rust
fn app() -> Element {
    let mut items = use_signal(|| 100);

    rsx! {
        // Adding a value will cause the `div` to be re-rendered with an extra div
        button { onclick: move |_| items += 1, "Add one" }

        div {
            // This will be called when the `div` is resized
            onresize: move |data| {
                info!("resized to {:#?}", data.get_border_box_size().unwrap());
            },

            for x in 0..items() {
                div { "{x}" }
            }
        }
    }
}
````

With `onvisible`, you can handle the cases when an element enters and exits the viewport. This is useful for implementing things like lazy loading, infinite scrolls, and virtual lists:

````rust
fn app() -> Element {
    rsx! {
        div {
            onvisible: move |data| info!("visibility changed"),
            "Hello world!"
        }
    }
}
````

You can add rich scroll-aware animations to your app without needing to write custom JavaScript.

![gif_of_visible_working.mp4](/assets/06assets/onvisible.mp4)

### Custom Attributes

Dioxus has a pre-configured set of attributes that are validated at compile time. If you surround the attribute name in quotes, you can use a custom attribute outside of the pre-defined set:

````rs@building_uis_with_rsx.rs
rsx! {
    div { "style": "width: 20px; height: 20px; background-color: red;" }
}
````

````inject-dioxus
DemoFrame {
	building_uis_with_rsx::CustomAttributes {}
}
````

Note that this works even with event listeners. We occasionally use this to insert small snippets of JavaScript into our apps when writing the corresponding web-sys code might be verbose:

````rust
rsx! {
    button {
        "onclick": "navigator.clipboard.writeText(window.document.title);",
        "Copy to clipboard"
    }
}
````

````inject-dioxus
DemoFrame {
	building_uis_with_rsx::CustomAttributesEvents {}
}
````

### The HTML Escape Hatch

If you're working with pre-rendered assets, output from templates, or output from a JS library, then you might want to pass HTML directly instead of going through Dioxus. In these instances, reach for `dangerous_inner_html`.

`dangerous_inner_html` sets the text content of the element to the provided value. This will overwrite any other attributes or children of the element.

For example, shipping a markdown-to-Dioxus converter might significantly bloat your final application size. Instead, you'll want to pre-render your markdown to HTML and then include the HTML directly in your output. We use this approach for the [Dioxus homepage](https://dioxuslabs.com):

````rs@dangerous_inner_html.rs
// this should come from a trusted source
let contents = "live <b>dangerously</b>";

rsx! {
    div { dangerous_inner_html: "{contents}" }
}
````

````inject-dioxus
DemoFrame {
	dangerous_inner_html::App {}
}
````

 > 
 > Note! This attribute is called "dangerous_inner_html" because it is **dangerous** to pass it data you don't trust. If you're not careful, you can easily expose [cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks to your users.
 > 
 > If you're handling untrusted input, make sure to sanitize your HTML before passing it into `dangerous_inner_html` – or just pass it to a Text Element to escape any HTML tags.
# Conditional Rendering

Our user interfaces have been quite static so far. However, most apps we build with Dioxus usually contain lots of dynamic content. Our UIs will react to changes in buttons, form inputs, sliders, or external data sources like the network. Dioxus apps generally store this dynamic state in Hooks or Context.

In this chapter, we're not going to dive too deep in how we store this state - future chapters cover state in depth.

## Expressions

Just like JSX, RSX allows you to easily compose `Element` objects together using plain Rust code. You can write Rust expressions directly within your RSX. As long as the expression evaluates to an `Element` or anything that implements `IntoDynNode`, you can simply wrap it in curly braces (`{}`):

````rust
let content = "world!";
rsx! {
    h1 {
        "Hello"
        {content}
    }
}
````

For example, we might need to create a string from some complex formatting functions:

````rust
rsx! {
    span {
        {
            format!(
                "The time is: {now}, your timezone is {zone}",
                now = current_time(),
                zone = current_timezone()
            ).to_ascii_uppercase()
        }
    }
}
````

Or, we might want to render some RSX dynamically and assign it to a variable:

````rust
let header = match current_timezone() {
    TimeZone::PST => rsx! {
        h1 { "Welcome home" }
    },
    _ => rsx! {
        h1 { "Bon voyage!" }
    },
}

rsx! {
    div {
        {header}
    }
}
````

Rust's expression system makes evaluation of RSX from `match` statements and `if` blocks quite nice. While in JavaScript you might use a ternary:

````jsx
let screen = authenticated ? renderApp() : renderLogin();

return <div>{screen}</div>;
````

In Dioxus, you'd simply use an if/else statement:

````rust
let screen = if authenticated { render_app() } else { render_login() };
rsx! {
    div {
        {screen}
    }
}
````

Rust's guards can be especially helpful in these scenarios, letting us select match arms with inline `if` statements.

````rust
let header = match current_timezone() {
    TimeZone::PST => rsx! {
        h1 { "Welcome home" }
    },
    _ if app.snoozed() => rsx! {
        h1 { "snoozed..." }
    },
    _ => rsx! {
        h1 { "Bon voyage!" }
    },
}

rsx! {
    div {
        {header}
    }
}
````

## The IntoDynNode Trait

Dioxus uses the [`IntoDynNode`](https://docs.rs/dioxus-core/latest/dioxus_core/trait.IntoDynNode.html) trait to determine if an expression can be used within RSX. The conversion will take a Rust expression and turn it into one of four `DynamicNode` variants:

* Component: Functions that take Properties and render an Element
* Text: The Rust `String` type
* Placeholder: An optimized `None` value
* List: A Vec of Elements

Many things implement this trait. For example, empty expressions are valid:

````rust
rsx! {
    div {
        { /* empty.. */}
    }
}
````

Other Element objects are valid:

````rust
let inner = rsx! { "inner" };
rsx! {
    div {
        {inner}
    }
}
````

All the string types (str, String, Arguments) are valid:

````rust
rsx! {
    div {
        // Strings
        {"abc"}

        // lazy formatting
        {format_args!("lazy fmt -> {}", arg())}
    }
}
````

The Rust `Option` type is valid provided the inner type implements `IntoDynNode`:

````rust
let inner = Some(rsx! { "inner" });
rsx! {
    div {
        {inner}
    }
}
````

And even iterators can become a VNode through the List variant:

````rust
let cards = (0..10).map(|i| rsx! {
    li { "Card: {i}" }
});

rsx! {
    ol {
        {cards}
    }
}
````

Iterators are very interesting since IntoDynNode is implemented for anything that is an iterator. For example, we could build a custom iterator that returns an `Element`.

````rust
let mut count = 0;
let cards = std::iter::from_fn(move || {
    count += 1;
    if count > 6 {
        return None;
    }

    Some(rsx! { "card {count}" })
})

rsx! {
    ol {
        {cards}
    }
}
````

## Inline `If` Statements

When rendering content derived from a boolean condition (eg, "active" or "inactive"), RSX provides some small "syntax sugar" that enables inline `if` statements in RSX.

````rs@building_uis_with_rsx.rs
let logged_in = use_signal(|| false);

rsx! {
    div {
        if logged_in() {
            "You are logged in"
        } else {
            "You are not logged in"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::IfStatement {}
}
````

Note that the body of inline `if` statements *is* RSX, not Rust expressions. This syntax sugar helps keep RSX blocks tidy and idiomatic.

````rust
rsx! {
    div {
        if logged_in() {
            LoggedInScreen {}
        } else {
            LoggedOutScreen {}
        }
    }
}
````

Inline `if` statements deviate from Rust in one way: they still evaluate to an `Element` even without an `else` branch. If RSX doesn't find an `else` branch on your `if` statement, it automatically returns a placeholder element instead.

````rust
rsx! {
    div {
        if logged_out() {
            span { "You should log in!" }
        }
    }
}
````

## More syntax sugar?

Syntax can be very subjective and syntax sugar like inline `if` and `for` blocks can open the door to inconsistent behavior. We don't plan to introduce any further syntax sugar to RSX. Our goal is to maintain similarity to React's JSX while slightly massaging ergonomics for Rust developers.

The RSX syntax was carefully designed to work well with your normal development flow:

* Typing an RSX element involves typing the name, and then a single curly
* RSX does not require additional editor extensions for superb support
* RSX follows Rust tokenization for automatic highlighting and code-folding

Definitely spend some time with RSX to get a feel for it.
# Rendering Lists

## Iterators and inline `for`

In the [Conditional Rendering](./conditional.md) chapter we showed how Rust expressions become Dynamic Nodes in RSX blocks.

Any iterator that returns `Element` or an object that implements `IntoVnode` can be used inside RSX blocks to render lists:

````rust
rsx! {
    // mapping existing iterators
    {(0..10).map(|idx| rsx! { "item {idx}" })}

    // or calling .iter()
    {users.iter().map(|user| rsx!{ User { id: user.id } })}
}
````

Dioxus provides a small amount of syntax sugar to make using iterators a bit nicer. Instead of wrapping your iterator in an expression, you can instead move it to an inline `for` block:

````rust
rsx! {
    for idx in 0..10 {
        "Item {idx}"
    }

    for user in users.iter() {
        User { id: user.id }
    }
}
````

Just like inline `if` blocks, the bodies of `for` loops are RSX - not Rust expressions. If you need to create temporary variables or do some extra computation while iterating, you can use an inline expression:

````rust
rsx! {
    for user in users.iter() {
        {
            let id = user.id();
            rsx! {
                User { id }
            }
        }
    }
}
````

If we're using iterators alongside wrapper types like a `Signal<T>`, we need to call `.iter()` first:

````rs@building_uis_with_rsx.rs
let mut items = use_signal(|| vec!["Hello", "Dioxus"]);

rsx! {
    ul {
        for item in items.iter() {
            li { "{item}" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::ForLoop {}
}
````

## Keys are Required

Each item in your list should have unique value that is stable across rerenders called a key. Keys are used to identify how items move between renders. Without keys, it is easy to accidentally lose or move state when you reorder items in a list. We can add keys to our list items by using the `key` attribute:

````rs@building_uis_with_rsx.rs
let mut items = use_signal(|| vec!["Hello", "Dioxus"]);

rsx! {
    ul {
        for item in items.iter() {
            li { key: "{item}", "{item}" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    building_uis_with_rsx::KeyedForLoop {}
}
````

You can usually find a suitable key from your state itself. Most data in your UI has some unique identifier that can be used to disambiguate it from other entries in the collection. For example, users typically have a unique ID, time samples have a unique timestamp, and emails have a unique sender address.

````rust
rsx! {
    for user in users {
        div { key: "{user.id}", "{user.name}" }
    }
}
````

Note that some fields might *seem* like a suitable unique ID, but are not. Two users might share the same name, two data points might share a timestamp, or not every entry actually has the required data present. In these cases, we recommend creating a unique ID for each item based on a global "generation" counter. Typically, a database might provide this, but we can also use state to manage this:

````rust
let mut generation = use_signal(|| 0);
let mut items = use_signal(|| vec![]);

let mut add_item = move |name| {
    let id = generation();
    generation.set(id + 1);
    items.write().push(Item { id, name })
};

rsx! {
    for item in items.iter() {
        div { key: "{item.id}", "{item.name}" }
    }
    // ...
}
````

The *worst* key to use is the index of the item in the collection. The index for an item will change as you mutate the list and almost certainly cause either performance issues or loss of state in components.

````rust
// ❌ do not do this!
rsx! {
    for (idx, user) in users.iter().enumerate() {
        div { key: "{idx}", "{user.name}" }
    }
}
````

## The Fragment Component

In some cases, your iterators might return multiple root elements. This doesn't give us a great location to place a key. RSX automatically uses the first element's key as iterator key, if it exists:

````rust
rsx! {
    for item in items.iter() {
        h1 { key: "{item.id}", "{item.name}" }
        p { "content" }
    }
}
````

If there's no easy way to attach a key to the first element, you can use a `Fragment` component to wrap the elements and give that the key instead:

````rust
rsx! {
    for item in items.iter() {
        Fragment {
            key: "{item.id}",
            for child in item.children.iter() {
                div { "{child}" }
            }
        }
    }
}
````

The `Fragment` component is nothing special. It is plainly a component that forwards its children as its body. However, RSX sees it as valid element syntax and is able to assign the key properly.

````rust
#[component]
fn Fragment(children: Element) -> Element {
    children
}
````

## Borrowed State

When rendering lists, you might want to borrow some of data contents into child components. The common Dioxus container, Signal, is not capable of providing references to child components.

````rust
let items = use_signal(|| vec![]);

rsx! {
    for item in items.iter() {
        Card {
            // ❌ not possible to forward a reference to the child.
            content: item.name.as_str()
        }
    }
}
````

While earlier versions of Dioxus did allow forwarding references, we eventually disabled this feature since it relied on some unsound Rust semantics. Instead, we recommend three strategies:

* Use owned data and `clone` if its cheap to do so
* Pass the collection *and* the index to the component
* Use a `Store` to provide a reactive reference to a slice of data within the collection

Stores make it possible to zoom into reactive state efficiently. They are covered in more detail in the [Stores](../basics/collections.md) chapter, but here's a quick preview of how to use them:

````rust
fn app() -> Element {
    let mut vec = use_store(|| vec![]);

    rsx! {
        div {
            // Iterating over a store provides references to reactive items within the store
            // without cloning them.
            for count in vec.iter() {
                Child { count }
            }
        }
    }
}

#[component]
fn Child(count: ReadSignal<i32>) -> Element {
    rsx! { "{count}" }
}
````

For complex apps, we recommend using building a system around global context or using a Store.
# Components and Properties

In Dioxus, components are simple functions that encapsulate your UI's presentation, state, and interactions. As your apps grow in size, consider combining shared functionality into smaller reusable components. Modular components make working in large teams easier, prevent annoying bugs, and enable better code reuse across all platforms.

## Defining Components

In its simplest form, a component is a function that returns an Element. For example, the base `app` component:

````rust
fn app() -> Element {
  rsx! { "hello world!" }
}
````

If you want to use a component from another component, then you must annotate the function with the `#[component]` macro. This macro provides essential metadata to the RSX macro, allowing function arguments to become fields in the component's properties. Your function must meet the following requirements:

* Either start with a capital letter (`MyComponent`) or contain an underscore (`my_component`)
* Take arguments that implement [`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html) and [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html)
* Return an [`Element`](https://docs.rs/dioxus/latest/dioxus/prelude/type.Element.html)

We call the arguments a component takes its **properties**. Properties are used to pass data into the component, similar to how you would pass arguments to a function.

For example, we can define a simple component that takes a `name` property and renders a greeting:

````rs@components.rs
#[component]
pub fn MyComponent(name: String) -> Element {
    rsx! {
        div {
            h3 { "Hello, {name}!" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
	components::MyComponent { name: "world" }
}
````

## Using Components in RSX

Once you have defined a component, you can use it in your RSX markup just like any other element:

````rs@components.rs
rsx! {
    MyComponent { name: "World" }
}
````

````inject-dioxus
DemoFrame {
	components::MyComponentCall {}
}
````

 > 
 > Although components are defined as functions, they should not be called like
 > regular functions. When you use a component in RSX, Dioxus will create
 > a new instance of the component that controls its own state and lifecycle.

## Component Properties

A component's properties is the object passed to the component when it renders. These properties are similar to a function's arguments - this is why the property fields are defined as function arguments in components. In some cases, you might find it useful to extract the component properties to a separate struct. Instead of defining properties inline, we can simply use an argument named "props" and then define the props in an accompanying struct.

````rust
#[derive(PartialEq, Clone, Props)]
struct CardProps {
  title: String,
  content: String
}

#[component]
fn Card(props: CardProps) -> Element {
  rsx! {
      h1 { "{card.title}" }
      span { "{card.content}" }
    }
}
````

When we extract properties into a struct, we need to make sure the struct implements three required traits:

* `PartialEq`: used to identify if a component needs to be rerendered
* `Clone`: on each render, the properties object is cloned
* `Props`: derives the `Properties` trait which Dioxus uses for rendering and building

Each of these bounds has implications for how we structure our component's properties.

### PartialEq

`PartialEq` is used by the Dioxus runtime to determine if a component's properties have changed due to some user action. Because components are called by other components, small changes to properties up the component tree can result in a cascade of work for the Dioxus runtime. The `PartialEq` implementation is used to minimize the amount of work the Dioxus runtime needs to do when reacting to these changes.

For advanced use cases, it can be worth customizing a properties' `PartialEq` implementation for performance. For example, we might want to compare large datasets just by their ID, not their actual contents. In these cases, we'd manually implement the `PartialEq` trait to skip the dataset equality check:

````rust
#[derive(Clone, Props)]
struct DatasetViewer {
  id: Uuid,
  contents: Vec<u8>
}

impl PartialEq for DatasetViewer {
  fn eq(&self, other: &Self) -> bool {
      self.id.eq(&other.id)
  }
}
````

Many Dioxus utilities use comparison-by-pointer instead of comparison-by-contents to improve performance.

### Clone

The `Clone` bound is a particularly interesting requirement for component properties. The Dioxus component tree architecture is designed around an idea called "unidirectional data flow." This is a design pattern that prevents components down the component tree from modifying their input properties. By preventing these accidental mutations, user interfaces generally have fewer bugs. Rust itself generally solves this problem its borrow checker system, but the borrow checker does not work well with asynchronous work which is quite prevalent in app development.

Generally, it's fine to `.clone()` most component properties, but some objects might be too expensive to clone and negatively impact performance. In most cases, you can simply wrap the value in the \[`ReadSignal`\] wrapper type and the object will be automatically wrapped in a smart pointer:

````rust
// previously...
struct CardProps {
  content: String
}

// with ReadSignal:
struct CardProps {
  content: ReadSignal<String>
}
````

Fortunately, there are no code changes required on the calling side:

````rust
rsx! {
  CardProps {
    content: query.content()
  }
}
````

Note that `ReadSignal` is not the only smart pointer available. The Rust smart pointers (Arc, Rc) also make clones cheaper as can a custom `Clone` implementation.

### Props

The `Props` derive macro implements the `Properties` trait for the properties object. This trait and its implementation are an implementation detail in Dioxus and not generally meant to be implemented manually. The `Props` derive is useful because it derives a strongly typed builder for the Properties. We can even use this builder outside RSX:

````rust
let props = CardProps::builder().content("body".to_string()).build();
````

## The `#[component]` macro

Properties can be modified to accept a wider variety of inputs than a normal function argument. We don't cover all of the details here, but you can find information in the [component macro](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html) documentation.

For example, the Dioxus Router `Link` component uses the modifiers extensively:

````rust
/// The properties for a [`Link`].
#[derive(Props, Clone, PartialEq)]
pub struct LinkProps {
    /// The class attribute for the `a` tag.
    pub class: Option<String>,

    /// A class to apply to the generate HTML anchor tag if the `target` route is active.
    pub active_class: Option<String>,

    /// The children to render within the generated HTML anchor tag.
    pub children: Element,

    /// When [`true`], the `target` route will be opened in a new tab.
    ///
    /// This does not change whether the [`Link`] is active or not.
    #[props(default)]
    pub new_tab: bool,

    /// The onclick event handler.
    pub onclick: Option<EventHandler<MouseEvent>>,

    /// Whether the default behavior should be executed if an `onclick` handler is provided.
    ///
    /// 1. When `onclick` is [`None`] (default if not specified), `onclick_only` has no effect.
    /// 2. If `onclick_only` is [`false`] (default if not specified), the provided `onclick` handler
    ///    will be executed after the links regular functionality.
    /// 3. If `onclick_only` is [`true`], only the provided `onclick` handler will be executed.
    #[props(default)]
    pub onclick_only: bool,

    /// The rel attribute for the generated HTML anchor tag.
    ///
    /// For external `a`s, this defaults to `noopener noreferrer`.
    pub rel: Option<String>,

    /// The navigation target. Roughly equivalent to the href attribute of an HTML anchor tag.
    #[props(into)]
    pub to: NavigationTarget,

    #[props(extends = GlobalAttributes)]
    attributes: Vec<Attribute>,
}
````

You can use the `#[props()]` attribute on each field to modify properties your component accepts:

* [`#[props(default)]`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#default-props) - Makes the field optional in the component and uses the default value if it is not set when creating the component.
* [`#[props(!optional)]`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#optional-props) - Makes a field with the type `Option<T>` required.
* [`#[props(into)]`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#converting-props) - Converts a field into the correct type by using the \[`Into`\] trait.
* [`#[props(extends = GlobalAttributes)]`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#extending-elements) - Extends the props with all the attributes from an element or the global element attributes.

Props also act slightly differently when used with:

* [`Option<T>`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#optional-props) - The field is automatically optional with a default value of `None`.
* [`ReadOnlySignal<T>`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#reactive-props) - The props macro will automatically convert `T` into `ReadOnlySignal<T>` when it is passed as a prop.
* [`String`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#formatted-props) - The props macro will accept formatted strings for any prop field with the type `String`.
* [`children: Element`](https://docs.rs/dioxus/latest/dioxus/prelude/attr.component.html#children-props) - The props macro will accept child elements if you include the `children` prop.
* `EventHandler<T>` enforces closures

Note that these attributes work both for struct-based property definitions as well as inline definitions:

````rust
#[component]
fn Link(
  /// When [`true`], the `target` route will be opened in a new tab.
  #[props(default)]
  new_tab: bool,

  /// The navigation target. Roughly equivalent to the href attribute of an HTML anchor tag.
  #[props(into)]
  to: NavigationTarget,
) -> Element {
  // ...
}
````

Because documentation comments are parsed by the `#[component]` macro, they become available as inline documentation when calling the component:

![Doc Comment Fields](/assets/07/doc-comment-props.png)

The docs on the component are also available when hovering its use:

![Doc Comment Components](/assets/07/doc-comment-components.png)

## Spreading Props

For more composability, we can create a component's properties manually and then pass them directly using Rust's spread syntax with `..some_props`.

````rust
let props = CardProps::lorem_ipsum();
rsx! {
  Card { ..props }
}
````

This mechanism behaves similar to Rust's struct spreading, allowing you to override various fields of the spread, enabling default and overrides:

````rust
let props = CardProps::lorem_ipsum();
rsx! {
  Card { title: "Chapter 1", ..props }
}
````

## Children

Properties have a special field called "children" that contain a component's child elements. For example, we can build a wrapper component that wraps its children in a red div. This component takes a special argument named "children" which is an Element that is used in RSX expressions.

````rust
#[component]
fn RedDiv(children: Element) {
  rsx! {
    div {
      background_color: "red",
      {children}
    }
  }
}
````

When calling the component, we can simply add nested children like an element:

````rust
rsx! {
  RedDiv {
    h1 { "Lorem Ipsum Dolor" }
    p { "..." }
  }
}
````
# Reconciliation: How Components Render

We've covered extensively how components and their properties are defined, but we haven't yet covered how they actually work. Dioxus components are *not* normal Rust functions. While technically possible to call them like regular Rust functions, components rely on an *active* Dioxus runtime to function properly.

To use components properly, it's important to understand the fundamentals of how state flows, how elements are created, and how state is stored. We are going to outline how state works here, but state can be complex so we've given it its own [chapter](../basics/index.md).

## Components Render

In Dioxus, the term "rendering" refers to the process that Dioxus uses to call your component functions and draw elements to the screen. When you call `dioxus::launch`, Dioxus sets up the app's runtime and then calls the provided initial component to create the initial `Element`. This element declares styles, layouts, children, and event listeners. Dioxus converts your elements into draw calls and converts your event listeners into native event handlers.

![Component Loop](/assets/07/render-calls.png)

Because Dioxus uses a "virtual" tree, the elements in your RSX tree are not actual handles to "real" nodes in the renderer. For example, the Dioxus `Element` type is not a full [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) object. When Dioxus receives your initial Element, it converts your virtual elements into real elements and draw calls using a platform-specific renderer.

## Components Rerender

Components will be rerun when the state they depend on changes. After the initial Element has been drawn with the platform-specific renderer, Dioxus listens for events on your elements. When an event is received, the corresponding event listeners are called, and your code has an opportunity to mutate state. Mutating state is the primary mechanism by which Dioxus knows to run your component functions again and look for changes in the tree.

![Component Loop](/assets/07/render-loop.png)

Dioxus considers state to have been changed in two situations:

* The component's properties change, as determined its `PartialEq` implementation
* Internal [state](../basics/index.md) the component depends on changes (e.g. `signal.write()`) and an "update" is scheduled

````rs@components.rs
// When the name property changes, the component will rerender
#[component]
fn Button(name: String) -> Element {
    let mut count = use_signal(|| 0);
    log!("Component rerendered with name: {name} count: {count}");

    rsx! {
        h3 { "Hello, {name}!" }
        // MyComponent reads the `count` signal, so it will rerender
        // whenever `count` changes.
        "Count: {count}"
        button {
            // When the button is clicked, it increments the count signal
            onclick: move |_| count += 1,
            "Increment"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    components::ButtonDemo {}
}
````

After a component runs again, Dioxus will compare the old `Element` and the new `Element` to look for changes. The Dioxus runtime will identify the least amount of draw calls required to change the old UI to match your desired UI. This comparison process is called "diffing". Dioxus optimizes diffing by only comparing dynamic parts of the RSX, so static elements are not checked for changes (see this [blog post](https://dioxuslabs.com/blog/templates-diffing) for details). This entire loop - Render, Display, Listen, Mutate - is called "reconciliation" and Dioxus has one of the most performant implementations of any UI framework.

## Components are Functions of State

Components are a pure function of your current application state in the form `fn(State) -> Element`. They read state from various sources like props, [hooks](../basics/hooks.md), or [context](../basics/context.md) and return a view of the current UI as an `Element`.

We have already seen how components map the props state into UI, but state can also come from the component itself in the form of hooks. For example, we can use a signal to keep track of a count in our component. The component defines the mapping from the current state of the signal to the UI that should be rendered:

````rs@components.rs
#[component]
pub fn MyStatefulComponent() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        div {
            h3 { "Count: {count}" }
            button { onclick: move |_| count += 1, "Increment" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    components::MyStatefulComponent {}
}
````

When building Dioxus apps, it's important to understand that your UI code is a declaration of what you want your UI to be - it does not contain any logic on how to update the UI to get there. Dioxus itself is responsible for making the UI match your desired input.

## Components are Pure Functions

The body of a component must be pure. Pure functions always return the same output for the same input and do not have side effects. For example, this double function is pure:

````rs@components.rs
fn double(x: i32) -> i32 {
    x * 2
}
````

If you call `double(2)`, it will always return `4`.

However, this function is not pure because it modifies external state:

````rs@components.rs
static GLOBAL_COUNT: AtomicI32 = AtomicI32::new(0);

fn increment_global_count() -> i32 {
    GLOBAL_COUNT.fetch_add(1, Ordering::SeqCst)
}
````

When you call `increment_global_count()` the first time, it will return `0`, but the next time you call it, it will return `1`. This function has side effects because it modifies the global state.

In addition to global variables, context and hooks are also external state in components. Components shouldn't modify state from context or hooks while rendering:

````rs@components.rs
#[component]
fn MyImpureComponent() -> Element {
    let mut count = use_signal(|| 0);

    // ❌ Modifying the count signal from a hook is a side effect.
    // Dioxus may try to rerender the component with the new value,
    // which can lead to unexpected behavior or infinite loops.
    count += 1;

    rsx! {
        div {
            h3 { "Count: {count}" }
        }
    }
}
````

Side effects that modify state should be placed in event handlers or [effects](../advanced/breaking_out.md#synchronizing-dom-updates-with-use_effect) which run after the component has rendered. This ensures that the component's output is stable and predictable.

````rs@components.rs
#[component]
fn MyPureComponent() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        div {
            h3 { "Count: {count}" }
            button {
                // ✅ Event handlers can modify state and have side effects.
                onclick: move |_| count += 1,
                "Increment"
            }
        }
    }
}
````

If you find yourself writing components that *are not* pure, then you are likely misusing or misunderstanding the reactive paradigm. Mutations should be placed either in event handlers as a response to user input, or in long running async tasks as a response to background processing.

## Similar to React

If you're familiar with libraries like ReactJS, then this paradigm is familar to you. Dioxus borrows many ideas from React and your existing knowledge will be extremely helpful. If anything here is confusing to you, check out the [React docs](https://react.dev/learn) or do some extra research on React's reactivity system.
# Assets

Assets are files that are included in the final build of the application. They can be images, fonts, stylesheets, or any other file that is not a source file. Dioxus includes first class support for assets, and provides a simple way to include them in your application and automatically optimize them for production.

Assets in dioxus are also compatible with libraries! If you are building a library, you can include assets in your library and they will be automatically included in the final build of any application that uses your library.

## Including images

To include an image in your application, you can simply wrap the path to the asset in the `asset!` macro:

````rs@assets.rs
use dioxus::prelude::*;

fn App() -> Element {
    // You can link to assets that are relative to the package root or even link to an asset from a url
    // These assets will automatically be picked up by the dioxus cli, optimized, and bundled with your final applications
    let ferrous = asset!("/assets/static/ferrous_wave.png");

    rsx! {
        img { src: "{ferrous}" }
    }
}
````

The asset macro takes a path to the asset relative to the root of your app. The path is *not* absolute to your machine, making it possible to use the same asset paths across multiple machines.

````rust
// ❌ does not work!
let ferrous = asset!("/Users/dioxus/Downloads/image.png");
````

The asset macro is `const`, meaning we can use it inline or as a static/const item:

````rust
// as a static item
static FERROUS: Asset = asset!("/assets/static/ferrous_wave.png");

// or inline
rsx! {
    img { src: asset!("/assets/static/ferrous_wave.png") }
}
````

## Customizing Image Processing Options

You can also optimize, resize, and preload images using the `asset!` macro. Choosing an optimized file type (like Avif) and a reasonable quality setting can significantly reduce the size of your images which helps your application load faster. For example, you can use the following code to include an optimized image in your application:

````rs@assets.rs
pub const ENUM_ROUTER_IMG: Asset = asset!(
    "/assets/static/enum_router.png",
    // You can pass a second argument to the asset macro to set up options for the asset
    ImageAssetOptions::new()
        // You can set the image size in pixels at compile time to send the smallest possible image to the client
        .with_size(ImageSize::Manual {
            width: 52,
            height: 52
        })
        // You can also convert the image to a web friendly format at compile time. This can make your images significantly smaller
        .with_format(ImageFormat::Avif)
);

fn EnumRouter() -> Element {
    rsx! {
        img { src: "{ENUM_ROUTER_IMG}" }
    }
}
````

## Including stylesheets

You can include stylesheets in your application using the `asset!` macro. Stylesheets will automatically be minified as they are bundled to speed up load times. For example, you can use the following code to include a stylesheet in your application:

````rs@assets.rs
// You can also bundle stylesheets with your application
// Any files that end with .css will be minified and bundled with your application even if you don't explicitly include them in your <head>
const _: Asset = asset!("/assets/tailwind.css");
````

 > 
 > The [tailwind guide](../../guides/utilities/tailwind.md) has more information on how to use tailwind with dioxus.

## SCSS Support

SCSS is also supported through the `asset!` macro. Include it the same way as a regular CSS file.

You can read more about assets and all the options available to optimize your assets in the [manganis documentation](https://docs.rs/manganis/0.6.0/manganis).

## Including arbitrary files

In dioxus desktop, you may want to include a file with data for your application. If you don't set any options for your asset and the file extension is not recognized, the asset will be copied without any changes. For example, you can use the following code to include a binary file in your application:

````rs@assets.rs
// You can also collect arbitrary files. Relative paths are resolved relative to the package root
const PATH_TO_BUNDLED_CARGO_TOML: Asset = asset!("/Cargo.toml");
````

These files will be automatically included in the final build of your application, and you can use them in your application as you would any other file.

## Asset Hashes

The asset macro automatically attaches a hash to the name of the asset after it's bundled. This makes your app's bundled assets unique across time, allowing you to infinitely cache the asset in your webserver or on a [CDN](https://en.wikipedia.org/wiki/Content_delivery_network).

````rust
// prints "/assets/ferrous_wave-dxhx13xj2j.png"
println!("{}", asset!("/assets/static/ferrous_wave.png"))
````

Asset hashes are an extremely powerful feature of the asset system. Hashes integrate with CDNs and can greatly speedup your application's load performance and save you money in infrastructure costs.

However, you occasionally might want to disable them. We can customize the asset processing options with the `AssetOptions` builder:

````rust
let ferrous = asset!("/assets/static/ferrous_wave.png", AssetOptions::builder().with_hash_suffix(false));
````

## Linker-based Asset Bundling

Unlike Rust's `include_bytes!` macro, the `asset!` macro *does not* copy the contents of the asset into your final application binary. Instead, it adds the asset path and options into the final binary's metadata. When you run `dx serve` or `dx build`, we automatically read that metadata and process the asset.

![Asset Bundling](/assets/07/asset-pipeline-full.png)

The metadata for each asset is automatically embedded in the final executable by serializing its path and properties using the [const-serialize](https://crates.io/crates/const-serialize) crate. When DX builds the executable, it then searches the output binary for asset metadata. After the build is complete, DX computes asset hashes and writes them back into the binary.

````rust
#[link_section = "dx-assets"]
static SERIALIZED_ASSET_OPTIONS: &[u8] = r#"{"path": "/assets/main.css","minify":"true","hash":"dxh0000"}"#;
````

This means that assets are not permanently baked into your final executable. The final executable is smaller, loads faster, and asset loading is much more flexible. This is important on platforms like the browser where assets are fetched in parallel over the network.

To dynamically load the asset's contents, you can use the [dioxus-asset-resolver](https://crates.io/crates/dioxus-asset-resolver) crate which properly understands the app's bundle format and loads an asset given its `Display` impl.

````rust
let contents = dioxus_asset_resolver::serve_asset(&asset!("/assets/main.css").to_string());
````

## Assets Must Be Used, Assets in Libraries

Because Dioxus uses the program's linker to save asset metadata, the resulting asset must be used somewhere in your application. If you forget to use the returned Asset, the Rust compiler is free to optimize away the call, and the asset metadata won't end up in the final output:

````rust
let ferrous = asset!("/assets/static/ferrous_wave.png");
rsx! {
    // our ferrous png won't be included since we forgot to use it!
    img { src: "..." }
}
````

This is expected behavior. We designed the asset system to automatically prune unused assets, making it possible for 3rd party libraries to export their own assets as part of their public API. For example, we could write a library that includes multiple stylesheets:

````rust
// crate: cool_dioxus_library
pub static GREEN_STYLES: Asset = asset!("/assets/red.css");
pub static RED_STYLES: Asset = asset!("/assets/green.css");
````

When a user builds an application using our library, they just need to import the stylesheet they want to use:

````rust
fn main() {
    dioxus::launch(|| rsx!{
        link { href: cool_dioxus_library::GREEN_STYLES, rel: "stylesheet" }
    })
}
````

Because the `RED_STYLES` asset is never referenced by the user's application, it won't be bundled in the final output.

However, you might want to include an asset even if you never reference it directly. Rust's [`#[used]`](https://doc.rust-lang.org/reference/abi.html#the-used-attribute) attribute is useful here, annotating to the compiler that asset *is* used, even if we can't prove so at compile time.

````rust
#[used]
static CERTS: Asset = asset!("/assets/keys.cert");
````

## Including Folders

The asset macro also supports importing entire folders of content! The folder itself won't be copied into the final bundle. Instead, you join the name of the files in the folder against the folder's path. For example, you might need to include a folder of 3rd-party JavaScript into your app and don't want to use an `asset!` call for every file in the folder.

````rust
let logging_js_path = format!("{}/logging.js", asset!("/assets/posthog-js"));
````

Note that we need to format the `Asset` returned by the `asset!()` macro here because the actual folder name will receive an asset hash.

## Reading Assets

When you use an asset in an element like the `img` tag, the browser automatically fetches the asset for you. However, sometimes you might want to read the contents of an asset directly in your application code. For example, you might want to read a JSON file and parse it into a data structure.

To read assets at runtime, you can use the [`read_asset_bytes`](https://docs.rs/dioxus-asset-resolver/latest/dioxus_asset_resolver/fn.read_asset_bytes.html) from the [`asset_resolver`](https://docs.rs/dioxus-asset-resolver/latest/dioxus_asset_resolver/) module. This will either fetch the asset from the network (for the web target) or read it from the bundle (for native targets):

````rs@assets.rs
use dioxus::prelude::*;

// Bundle the static JSON asset into the application
static JSON_ASSET: Asset = asset!("assets/data.json");

// Read the bytes of the JSON asset
let bytes = dioxus::asset_resolver::read_asset_bytes(&JSON_ASSET)
    .await
    .unwrap();

// Deserialize the JSON data
let json: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
assert_eq!(json["key"].as_str(), Some("value"));
````

If you are targeting a platform like windows or macos where assets are bundled alongside the executable in the filesystem, you can also get the path to the asset using the `asset_path` function. Keep in mind this will not work in the browser or in android bundles since assets are not stored in the filesystem:

````rs@assets.rs
use dioxus::prelude::*;

// Bundle the static JSON asset into the application
static JSON_ASSET: Asset = asset!("assets/data.json");

// Resolve the path of the asset. This will not work in web or Android bundles
let path = dioxus::asset_resolver::asset_path(&JSON_ASSET).unwrap();

println!("Asset path: {:?}", path);

// Read the bytes of the JSON asset
let bytes = std::fs::read(path).unwrap();

// Deserialize the JSON data
let json: serde_json::Value = serde_json::from_slice(&bytes).unwrap();
assert_eq!(json["key"].as_str(), Some("value"));
````

## The Public folder

If you're deploying your app to the web, then DX will automatically copy any files from your app's `/public` directory into the output `/public` directory.

This can be useful to copy files like `robots.txt` into the output directory since they're not referenced by any code in your app.

````
├── assets
├── src
└── public
    └── robots.txt
````

Note that this `/public` directory is *merged* into the output, allowing you to manually insert files into the output `/public/assets` directory.
# Styling your app

Dioxus uses standard HTML and CSS for styling, making it easy to leverage existing CSS frameworks, libraries, and knowledge. This chapter covers the various approaches to styling your Dioxus applications, from inline styles to CSS frameworks like TailwindCSS.

## Dioxus uses CSS for Styling

Unlike many other UI frameworks that introduce their own styling systems, Dioxus embraces the web's native styling approach: **HTML and CSS**. This means you can use all the CSS knowledge, tools, and frameworks you already know and love.

CSS is by-far the most popular styling system and is extremely capable. For example, here's a screenshot of [ebou](https://github.com/terhechte/Ebou), a very beautiful Mastodon client built with Dioxus.

![Ebou](/assets/06_docs/ebou-following.png)

All 1st-party Dioxus renderers leverage CSS, but other renderers like [Freya](http://freyaui.dev) might use their own style system. Dioxus automatically converts your CSS to the appropriate native widget properties when applicable, though in some cases you might need to write platform-specific code to achieve your ideal native look and feel.

## Inline CSS

The simplest way to add styles to your elements is through inline CSS using the [HTML `style` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/style). Simply write your CSS styles in an inline string:

````rust
use dioxus::prelude::*;

fn App() -> Element {
    rsx! {
        div {
            style: "background-color: blue; color: white; padding: 20px; border-radius: 8px;",
            "This is a styled div!"
        }
    }
}
````

For better ergonomics, Dioxus also allows you to set individual CSS properties directly as attributes. CSS property names are referenced via their snake_case variant:

````rust
fn App() -> Element {
    rsx! {
        div {
            background_color: "blue",
            color: "white",
            padding: "20px",
            border_radius: "8px",
            "This is a styled div!"
        }
    }
}
````

Because CSS properties are attributes, you can make them dynamic by using Rust expressions:

````rust
fn App() -> Element {
    let mut is_dark = use_signal(|| false);

    rsx! {
        div {
            background_color: if is_dark() { "black" } else { "white" },
            color: if is_dark() { "white" } else { "black" },
            padding: "20px",
            onclick: move |_| is_dark.toggle(),
            "Click to toggle theme"
        }
    }
}
````

## Stylesheets

For larger applications, it's better to organize your styles in separate CSS files. Dioxus provides excellent support for CSS stylesheets through the `asset!()` macro.

### Including CSS Files

Create a CSS file in your `assets` directory and include it using the `asset!()` macro. Dioxus provides two "document" elements - `document::Link` and `document::Stylesheet`:

````rust
use dioxus::prelude::*;

// Define the CSS asset
static MAIN_CSS: Asset = asset!("/assets/main.css");

fn App() -> Element {
    rsx! {
        // Include the stylesheet in the document head
        document::Stylesheet { href: MAIN_CSS }

        div {
            class: "my-component",
            "Hello, styled world!"
        }
    }
}
````

Note that a regular `<link>` element will work, though it won't be marked as pre-loadable when used with server-side-rendering:

````rust
rsx! {
    link { href: asset!("/assets/main.css") }
}
````

Your `assets/main.css` file might look like:

````css
.my-component {
    background-color: #f0f9ff;
    border: 2px solid #0ea5e9;
    border-radius: 8px;
    padding: 16px;
    font-family: system-ui, sans-serif;
}

.my-component:hover {
    background-color: #e0f2fe;
    transform: translateY(-2px);
    transition: all 0.2s ease;
}
````

### CSS Selectors

To use the style declarations from our stylesheet, we can use [class selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors) and [ID selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors):

````css
.my-component {
    background-color: #f0f9ff;
}
#root-component {
    font-weight: 500;
}
````

````rust
rsx! {
    div {
        id: "root-component",
        class: "my-component"
    }
}
````

CSS provides several selectors that you can leverage in your stylesheets:

* [**Element selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors) (`div`, `p`, `h1`): Target HTML elements by their tag name
* [**Class selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors) (`.my-class`): Target elements with a specific class attribute
* [**ID selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors) (`#my-id`): Target a single element with a specific ID attribute
* [**Attribute selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) (`[type="text"]`): Target elements based on their attributes
* [**Descendant selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator) (`div p`): Target elements that are descendants of another element
* [**Child selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Child_combinator) (`div > p`): Target direct children of an element
* [**Adjacent sibling selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Next-sibling_combinator) (`h1 + p`): Target elements immediately following another
* [**General sibling selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Subsequent-sibling_combinator) (`h1 ~ p`): Target elements that are siblings of another
* [**Pseudo-class selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes) (`:hover`, `:focus`, `:nth-child()`): Target elements in specific states
* [**Pseudo-element selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements) (`::before`, `::after`): Target virtual elements or parts of elements
* [**Universal selector**](https://developer.mozilla.org/en-US/docs/Web/CSS/Universal_selectors) (`*`): Target all elements
* [**Grouping selectors**](https://developer.mozilla.org/en-US/docs/Web/CSS/Selector_list) (`h1, h2, h3`): Apply styles to multiple selectors at once

### Conditional Styles with Classes

The [HTML `class` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/class) supports conditional styling and can be defined multiple times on the same element:

````rust
fn App() -> Element {
    let mut is_active = use_signal(|| false);
    let mut is_large = use_signal(|| false);

    rsx! {
        button {
            class: "btn",
            class: if is_active() { "btn-active" },
            class: if is_large() { "btn-large" },
            onclick: move |_| is_active.toggle(),
            "Toggle me!"
        }
    }
}
````

In HTML, the `class` attribute specifies a list of CSS classes a particular element has. A corresponding CSS stylesheet might include several classes that your elements use:

````css
/* The base `btn` class the button uses */
.btn {
    background-color: #f3f4f6;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    padding: 8px 16px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

/* The "active" class, added when `is_active()` is true */
.btn-active {
    background-color: #3b82f6;
    color: white;
    border-color: #2563eb;
}

/* The "large" class, added when `is_large()` is true */
.btn-large {
    padding: 12px 24px;
    font-size: 16px;
}
````

### CSS Custom Properties for Theming

You can use CSS custom properties (variables) for consistent theming. This is generally preferred over using Rust variables since dynamic string formatting can be less efficient and harder to optimize.

````css
:root {
    --color-primary: #3b82f6;
    --color-primary-hover: #2563eb;
    --color-text: #1f2937;
    --color-background: #ffffff;
    --border-radius: 6px;
    --spacing-xs: 4px;
    --spacing-sm: 8px;
    --spacing-md: 16px;
    --spacing-lg: 24px;
}

.button {
    background: var(--color-primary);
    color: var(--color-background);
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--border-radius);
    border: none;
    cursor: pointer;
}

.button:hover {
    background: var(--color-primary-hover);
}
````

## SCSS

Dioxus supports SCSS (Sass) files out of the box. Simply use the `asset!()` macro with `.scss` files:

````rust
static STYLES: Asset = asset!("/assets/styles.scss");
````

Your `assets/styles.scss` file can use all SCSS features:

````css
$primary-color: #3b82f6;
$secondary-color: #64748b;
$border-radius: 8px;

.card {
    background: white;
    border-radius: $border-radius;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);

    &:hover {
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .header {
        background: $primary-color;
        color: white;
        padding: 16px;
        border-radius: $border-radius $border-radius 0 0;
    }

    .content {
        padding: 16px;
        color: $secondary-color;
    }
}
````

## Tailwind

[Tailwind CSS](https://tailwindcss.com/) is a popular utility-first CSS framework that works excellently with Dioxus. It allows you to style elements using pre-defined utility classes. This very documentation site uses Tailwind! We can simply use tailwind classes in Dioxus:

````rust
rsx! {
    div { class: "flex flex-col items-center p-7 rounded-2xl",
        img { class: "size-48 shadow-xl rounded-md", src: "/img/cover.png" }
        div { class: "flex",
            span { "Class Warfare" }
            span { "The Anti-Patterns" }
            span { class: "flex",
                span { "No. 4" }
                span { "·" }
                span { "2025" }
            }
        }
    }
}
````

As of Dioxus 0.7, DX automatically downloads and starts the TailwindCSS watcher for you. Whenever you build your project with DX, the Tailwind CLI collects your classes and generates an output file in `assets/tailwind.css`.

![Tailwind Hotreload](/assets/07/tailwind-inline.mp4)

DX automatically detects if your project is using TailwindCSS if it finds a file called "tailwind.css" at the root of your project. In this file, you declare the basic Tailwind import and an extra line to ensure the watcher searches Rust files:

````css
@import "tailwindcss";
@source "./src/**/*.{rs,html,css}";
````

Note that we need to add the generated stylesheet to our app:

````rust
fn app() -> Element {
    rsx! {
        document::Stylesheet { href: asset!("/assets/tailwind.css") }
    }
}
````

Tailwind provides many [theme variables to configure](https://tailwindcss.com/docs/theme), which we can do by updating our `tailwind.css` file. For example, we can customize our document's font or define a custom color palette.

````css
@theme {
    --color-dxblue: #00A8D6;
    --color-ghmetal: #24292f;
    --color-ghdarkmetal: #161b22;
    --color-ideblack: #0e1116;
    --font-sans: "Inter var", sans-serif;
}
````

Tailwind works with Dioxus's multiple class attribute support:

````rust
fn Card() -> Element {
    let mut is_hovered = use_signal(|| false);

    rsx! {
        div {
            class: "bg-white rounded-lg shadow-md p-6 m-4",
            class: if is_hovered() { "shadow-xl transform -translate-y-1" },
            class: "transition-all duration-200",

            onmouseenter: move |_| is_hovered.set(true),
            onmouseleave: move |_| is_hovered.set(false),

            h2 {
                class: "text-xl font-bold text-gray-800 mb-2",
                "Card Title"
            }
            p {
                class: "text-gray-600",
                "This is a beautiful card component styled with Tailwind CSS."
            }
        }
    }
}
````

### VSCode Integration

For better Tailwind development experience, install the Tailwind CSS IntelliSense extension and add this to your VSCode settings:

````json
{
    "tailwindCSS.experimental.classRegex": ["class: \"(.*)\""],
    "tailwindCSS.includeLanguages": {
        "rust": "html"
    }
}
````

## Laying out Elements

If you're familiar with HTML and CSS, then you likely already know how to arrange the HTML elements to craft your desired UI. However, if HTML and CSS are new to you, then it's worth understanding the many ways you can lay out elements on the page. CSS supports several layout systems simultaneously:

* **Normal Flow**: The default layout where elements stack vertically (block elements) or flow horizontally (inline elements)
* **Flexbox**: One-dimensional layout system for arranging items in rows or columns with flexible sizing and alignment
* **CSS Grid**: Two-dimensional layout system for creating complex grid-based layouts with rows and columns
* **Float**: Legacy layout method that moves elements to the left or right, allowing text to wrap around them
* **Positioning**: Allows precise control over element placement using `static`, `relative`, `absolute`, `fixed`, or `sticky` positioning
* **Table Layout**: Displays elements as table cells, rows, and columns (can be used with non-table elements via `display: table`)
* **Multi-column**: Splits content into multiple columns, similar to newspaper layouts

Generally, you'll use either Flexbox or CSS Grid.

### Flexbox Layout

Flexbox is incredibly handy for building responsive user interfaces. As you adjust the document viewport, elements will automatically adjust their size and placement to fit their flex constraints. The [CSS-Tricks guide](https://css-tricks.com/snippets/css/a-guide-to-flexbox/) provides a very helpful tutorial on all the flex contraints you can use.

![Flexbox Guide](/assets/07/flexbox-diagram.webp)

### CSS Grid

CSS Grid is another powerful layout system. You can leverage CSS stylesheets to declare named regions of your document, dividing them along fixed or flexible grid lines. Several online tools exist that provide a [graphical interface](https://grid.layoutit.com) for building grid layouts.

### Fixed Position Layout

![CSS Grid Guide](/assets/07/css-grid.svg)

Occasionally you'll need to reach for [fixed-position layouts](https://developer.mozilla.org/en-US/docs/Web/CSS/position). These tend to be less flexible than CSS Grid and Flexbox, but make it possible to implement features like sticky headers and dynamically-positioned content.

## Icons and SVG

Dioxus supports several approaches for including icons and SVG graphics in your applications.

### Inline SVG

You can include SVG directly in your RSX:

````rust
fn IconButton() -> Element {
    rsx! {
        button {
            class: "flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded",

            // Inline SVG icon
            svg {
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "currentColor",
                path {
                    d: "M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"
                }
            }

            "Star"
        }
    }
}
````

### SVG Assets

For larger or reusable SVG files, you can store them in a separate file and import them with the `asset!()` macro.

````rust
fn Icon() -> Element {
    rsx! {
        img {
            src: asset!("/assets/logo.svg"),
            alt: "Logo",
            class: "h-8 w-8"
        }
    }
}
````

### Icon Libraries

You can also use Rust crates that provide icon collections. Several libraries exist:

* [Dioxus Free Icons](https://crates.io/crates/dioxus-free-icons) - The FreeIcons library for Dioxus
* [Dioxus Material Icons](https://crates.io/crates/dioxus-material-icons) - Google's Material Icons library for Dioxus
* [Dioxus Hero Icons](https://crates.io/crates/dioxus-heroicons) - The HeroIcons library for Dioxus

````rust
use dioxus_free_icons::{Icon, icons::fa_solid_icons};

fn App() -> Element {
    rsx! {
        Icon {
            width: 30,
            height: 30,
            fill: "blue",
            icon: fa_solid_icons::FaHeart
        }
    }
}
````

### Using `dangerous_inner_html`

If you want to include icons from their raw HTML representation, you can use `dangerous_inner_html` which sets the content from a Rust string:

````rust
rsx! {
    svg { dangerous_inner_html: r#"<path d="M256 352 128 160h256z" />"# }
}
````
# Dioxus Hot-Reloading Reference

The Dioxus Hot-Reload engine is incredibly powerful. When used properly, it provides the fastest development experience for building apps with Rust.

 > 
 > Dioxus 0.5 featured a limited form of hot-reloading, while Dioxus 0.6 drastically improved it.
 > 
 > **Dioxus 0.7 introduces experimental Rust hot-reloading**, making it the first Rust framework to support hot-reloading of actual Rust code. 🎉🎉

Dioxus provides three forms of hotreloading.

*Element hot-reloading:*

![Element Hot-reloading](/assets/07/dog_app_hotreload.mp4)

*Asset hot-reloading:*

![Element Hot-reloading](/assets/07/css-hotreload.mp4)

*Rust hot-reloading:*

![Element Hot-reloading](/assets/07/subsecond-tui.mp4)

We provide this text guide as a resource for the details of hot-reloading. This guide has an accompanying video as well:

<iframe style="width: 100%" height="500px" class="centered-overflow" src="https://www.youtube.com/embed/Q4Xzz8OJEoc" title="Dioxus 0.6" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## RSX Hot-Reload

RSX hot-reloading is fundamental to the Dioxus development experience. It allows you to modify the structure, styling, and content of your user interface without recompiling your entire application.

RSX hot-reload enables you to instantly add, remove, or modify an elements in an `rsx!` block. The RSX parser works both at compile time, and in our devtools, letting DX sidestep recompiling your Rust code entirely.

````rust
fn App() -> Element {
    rsx! {
        // You can add, remove, or modify any elements
        div { class: "container" }
        h1 { "My App" }
        button { "Click me" }
    }
}
````

All string-based attributes support instant hot-reloading:

````rust
fn Button() -> Element {
    rsx! {
        button {
            // All of these can be hot-reloaded instantly
            class: "btn btn-primary",
            id: "my-button",
            title: "Click this button",
            style: "background: blue; color: white;",

            "Submit"
        }
    }
}
````

Hot-reload supports modifying complex formatted strings anywhere in your RSX. While you cannot instantly hot-reload the interior Rust expressions, you *can* move existing expressions between formatted strings.

````rust
fn Counter() -> Element {
    let count = use_signal(|| 0);

    rsx! {
        div {
            // We can move this `count` variable from here
            "Count: {count}"

            button {
                // ... to here, without a recompile!
                "Increment ({count})"
            }
        }
    }
}
````

You can hot-reload simple Rust expressions passed as component props. If the attribute value is a [Rust "literal"](https://doc.rust-lang.org/reference/expressions/literal-expr.html) - a single "token" like a number, boolean, or string - DX will hot-reload it by re-parsing the new attribute and modifying the component's props in place.

````rust
fn App() -> Element {
    rsx! {
        MyButton {
            text: "Click me", // try changing the text
            enabled: true, // try changing true to false!
            count: 123, // or changing the number value!
        }
    }
}

#[component]
fn MyButton(text: String, enabled: bool, count: i32, color: String) -> Element {
    rsx! {
        button { disabled: !enabled, "{text} - {count}" }
    }
}
````

Hot-reloading works inside conditional blocks, loops, and component children. Note that the interior *expressions* don't support instant RSX hot-reload, but the interior *elements* and *markup* do.

````rust
fn TodoList() -> Element {
    let todos = use_signal(|| vec!["Learn Dioxus", "Build an app"]);

    rsx! {
        ul {
            // We can modify the *body*
            for (i, todo) in todos().iter().enumerate() {
                li {
                    key: "{i}",
                    class: "todo-item",
                    "{todo}"
                }
            }
        }

        // Conditional blocks bodies are hot-reloadable too
        if todos().len() > 5 {
            div { class: "warning", "You have many todos!" }
        }
    }
}
````

## What Requires a Full Rebuild (or a hot-patch!)

While RSX hot-reloading is very capable, some changes still require a full application rebuild:

* **New variables or expressions** not present in the last compilation.
* **Logic changes** outside of RSX (function bodies, hooks, etc.).
* **Component signatures** (adding/removing props).
* **Import statements** and module structure.
* **Complex Rust expressions** in attributes that involve function calls.

When Rust hotpatching is enabled with the `--hotpatch` flag, DX will modify your app's assembly *in place* and not require a full rebuild. With hotpatching enabled, DX rarely issues full rebuilds. You can manually force a full rebuild of your app at any time by pressing the `r` key with the DX TUI open.

## Experimental: Rust Hot-patching

**New in Dioxus 0.7**, you can enable experimental Rust code hot-reloading using the `--hotpatch` flag. This feature is revolutionary - allowing you to modify Rust logic and see changes without rebuilding.

To use Rust hot-reloading, run `dx serve --hotpatch`. The extra flag is required while hot-patching is still experimental, though we plan to make it default in the future.

````bash
dx serve --hotpatch
````

This system, named **Subsecond**, can reload most changes to Rust code. However, there are a few limitations:

* You may add new globals at runtime, but their destructors will never be called.
* Globals are tracked across patches, but will renames are observed as introducing a new global.
* Changes to static initializers will not be observed.

Also, most importantly, Rust hot-patching currently only tracks the "tip" crate in your project. If you edit code in any of your dependencies - which might be *your* crate in a workspace - DX does *not* register that change. While RSX hot-reloading works across a workspace, Subsecond currently does not.

Subsecond also works outside Dioxus. Many projects have already adopted the Subsecond library for Rust hot-reloading. For example, Bevy and Iced already have Subsecond integrations:

![Bevy Hot-patching](/assets/07/bevy-hotpatch.mp4)

## Asset Hot-Reload

Asset hot-reloading allows you to modify CSS, images, and other static files without rebuilding your application. This works seamlessly with the `asset!()` macro system.

### CSS Hot-Reloading

CSS files are automatically watched and hot-reloaded when changed:

````rust
fn App() -> Element {
    rsx! {
        // Editing this stylesheet will cause instant updates in the running app
        Stylesheet { href: asset!("/assets/main.css") }
        div { class: "my-component", "Hello World!" }
    }
}
````

````css
/* In assets/main.css - changes here are instantly applied */
.my-component {
    background: blue;
    color: white;
    padding: 20px;
    /* Change this to red and see instant updates! */
}
````

SCSS files are automatically re-compiled on changes and the generated CSS will be hot-reloaded.

### Image and Static Asset Hot-Reloading

Static assets like images also support hot-reloading:

````rust
fn Header() -> Element {
    rsx! {
        img { src: asset!("/assets/logo.png") }
    }
}
````

When you edit `/assets/logo.png`, the change appears instantly in your running application.

### Tailwind CSS Integration

When you `serve` your app, DX automatically downloads and starts the Tailwind CLI in the background. If a `tailwind.css` file is detected in the project root, the Tailwind watcher will watch your Rust code for changes and then recompile the output `/assets/tailwind.css` file.

![Inline Tailwind](/assets/07/tailwind-inline.mp4)

You can manually customize the Tailwind input and output file locations using the `tailwind_input` and `tailwind_output` configuration fields in your project's Dioxus.toml.
# Escaping RSX

While RSX is extremely capable, *some* changes to the UI require low-level access to system widgets or an imperative programming approach. Dioxus provides a number of "escape hatches," letting you use alternative UI techniques that don't fit into the declarative RSX paradigm. Also, Dioxus is relatively young and might not expose support for *every* feature the platform-specific renderer has.

## Custom Element Attributes

Under the hood, Dioxus declares every element attribute as a set of constants that describe the attribute's static properties. The definition is roughly equivalent to this pseudocode:

````rust
struct video;
impl video {
    const src: AttributeDefinition = AttributeDefinition {
        name: "src",
        namespace: None,
        type: String
    };
    const autoplay: AttributeDefinition = AttributeDefinition {
        name: "controls",
        namespace: None,
        type: Boolean
    };
}

//
rsx! {
    video { src: "...", autoplay: true }
}
````

In some cases, an attribute declaration might be missing, or you need to use a custom name. RSX enables this with quote-wrapped attribute names. Simply wrap the name of the custom attribute with quotes and pass in any expression that evalutes to `IntoAttributeValue`:

````rust
rsx! {
    div {
        "data-my-button-id": 123
    }
}
````

Custom attributes can be extremely handy when using data attributes and custom CSS selectors.

## Dangerous Inner HTML

If you're working with pre-rendered assets, output from templates, or output from a JS library, then you might want to pass HTML directly instead of going through Dioxus. In these instances, reach for `dangerous_inner_html`. This attribute sets the HTML `textContent` field of the element to the provided value. This will overwrite any other attributes or children of the element.

For example, shipping a markdown-to-Dioxus converter might significantly bloat your final application size. Instead, you'll want to pre-render your markdown to HTML and then include the HTML directly in your output. We use this approach for the [Dioxus homepage](https://dioxuslabs.com):

````rs@dangerous_inner_html.rs
// this should come from a trusted source
let contents = "live <b>dangerously</b>";

rsx! {
    div { dangerous_inner_html: "{contents}" }
}
````

````inject-dioxus
DemoFrame {
	dangerous_inner_html::App {}
}
````

 > 
 > Note! This attribute is called "dangerous_inner_html" because it is **dangerous** to pass it data you don't trust. If you're not careful, you can easily expose [cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks to your users.
 > 
 > If you're handling untrusted input, make sure to sanitize your HTML before passing it into `dangerous_inner_html` – or just pass it to a Text Element to escape any HTML tags.

## Web Components

While we generally suggest creating new components directly in Dioxus, a 3rd-party component might be distributed as a [*Web Component*](https://www.webcomponents.org). Web components provide a framework-agnostic way of building and distributing custom HTML elements.

Any element with a dash in the name is a web component. Web components are rendered directly in dioxus without type checking. Generally, you'll be importing a web component *into* Dioxus. We therefore recommend wrapping web components in a type safe component to make them easier to use.

````rs@building_uis_with_rsx.rs
rsx! {
    my-web-component {}
}
````

Because web components are untyped, they have no default attributes. Each attribute name must be wrapped in quotes, hence why we suggest wrapping the web component in a Dioxus component:

````rust
// our dioxus component provides a strongly-typed wrapper around our stringly-typed web component
#[component]
fn MyWebComponent(name: String, age: i32) -> Element {
    rsx! {
        my-web-component {
            "name": "hello, {name}",
            "age": age + 10
        }
    }
}
````

## Direct DOM Access

As mentioned earlier, RSX is *declarative.* You compose your elements in an `rsx! {}` block and Dioxus does the rendering. Sometimes, you'll need lower-level access to DOM elements to build deeply interactive UI. This might involve rendering into a canvas element or performing a synchronous modification to an element's properties.

To get direct access to the underlying [HTML DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction), Dioxus provides a few built-in mechanisms:

* Running JavaScript through `eval`
* Using [`web-sys`](https://docs.rs/web-sys/latest/web_sys/) to get element by ID
* Using the `onmounted` event handler
* Using the `onresize` and `onvisible` events

### Eval

Dioxus exposes an `eval` function that allows you to evaluate arbitary JavaScript in the platform renderer. On the web, this uses [`web-sys`](https://docs.rs/web-sys/latest/web_sys/), and for the webview renderer, this uses the webview's native `eval` method.

You can eval any valid JavaScript. Dioxus transforms the input source code into a `Function` declaration and then allows you to capture its result. To send custom data into JavaScript, we simply format the source code. To return data from JavaScript, we use `dioxus.send()` and the eval's `.recv()` method:

````rust
use dioxus::prelude::*;

fn app() -> Element {
    rsx! {
        button {
            onclick: move |_| async move {
                // You can send values from rust to the JavaScript code by using the `send` method on the object returned by `eval`.
                let mut eval = document::eval(
                    r#"for(let i = 0; i < 10; i++) {
                        // You can send values asynchronously with the `dioxus.send()` method.
                        dioxus.send(i);
                    }"#
                );

                // You can receive values from the JavaScript code with the `recv` method on the object returned by `eval`.
                for _ in 0..10 {
                    let value: i32 = eval.recv().await.unwrap();
                    println!("Received {}", value);
                }
            },
            "Log Count"
        }
    }
}
````

### Using `web-sys` and Event Downcasting

On the web, it's possible to use the [`web-sys`](https://docs.rs/web-sys/latest/web_sys/) crate to directly call JavaScript methods from Rust. This uses foreign-function-interfaces to bridge the gap between Rust and JavaScript. We don't necessarily suggest using web-sys in *all* cases since web-sys is currently not portable to the Dioxus Desktop and Mobile renderers.

With web-sys, we can call most JavaScript methods with a strongly-typed Rust interface:

````rust
rsx! {
    let alert_it = move |_| {
        let window = web_sys::window().unwrap();
        window.alert_with_message("Hello from Rust!");
    };
    button { onclick: alert_it, "Click to alert" }
}
````

If you *need* to use web-sys on desktop and mobile, you might want to use [Dioxus with Tauri](#using-dioxus-in-tauri) instead.

### Using `getElementById`

When using either eval or web_sys, it can be useful to get a direct handle to an HTML Dom Node. Generally, we suggest creating an ID for a given element, and then using `getElementById` to reference that node later.

````rust
// Set a unique ID for the div
let id = use_hook(|| Uuid::new_v4());

// Reference it in our eval logic
let set_div_contents = move |_| async move {
    dioxus::document::eval(format!(r#" document.getElementById("{{div-{id}}}").innerText = "one-two-three" "#)).await;
};

rsx! {
    // And then assign it on the element itself
    div { id: "div-{id}" }
    button { onclick:  set_div_contents, "Set Div Directly" }
}
````

## Child Windows and Overlays

Some apps require low-level access to the HTML [`canvas`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/canvas) element. For example, computer-aided-design (CAD) apps, video games, photo editors, video editors, or anything relying on lots of multimedia might want to render GUI textures manually.

When using the webview renderer, you can overlay your Dioxus HTML content *on top* of a native texture. This is an advanced escape hatch that unlocks the entire rendering pipeline - extremely powerful but also quite complex.

![wgpu-windows.mp4](/assets/06assets/wgpu-windows.mp4)

For more information, see the [accompanying example](https://github.com/DioxusLabs/dioxus/blob/main/examples/wgpu_child_window.rs).

## Using Dioxus in Tauri

If you *need* to use the `web-sys` crate on desktop and mobile platforms, then [Tauri](https://tauri.app) might be useful for you. Tauri is a framework that lets you combine a custom frontend across an IPC boundary with Rust code running natively. This is somewhat similar to Dioxus, but instead of your UI code running natively, it insteads runs as WebAssembly *inside* the webview. This can be slower and harder to setup, but does enable direct DOM access across all platforms.

Dioxus-Web is supported as a frontend option when creating a new Tauri app, so make sure to check out [their docs](https://tauri.app/start/).

## Native Widgets

The first-party Dioxus renderers currently only render HTML and CSS. This is either done via `HTMLDomElement` with `web-sys` or through a eval for the webview renderers. Sometimes, you want to render a platform-native widget. Internally, Dioxus uses this to open file dialogs, color pickers, and provide functionality where platform-consistency matters.

![File Upload Dialog](/assets/07/file-upload.png)

This is somewhat advanced and requires using FFI into Objective-C and Kotlin to use system libraries. See the [dioxus-desktop docs](https://crates.io/crates/dioxus-desktop) for more info.

## Dioxus Native

For *complete* control over the DOM, we've built the *Dioxus Native* renderer. This renderer combines platform-native widgets along with a stripped-down HTML/CSS renderer to paint the Dioxus widget tree directly to the screen. Currently, Dioxus Native supports a variety of backends based on the [Vello](https://github.com/linebender/vello) crate.

Dioxus Native is nascent. We specifically built Dioxus Native to paint arbitrary GPU textures into canvas elements. Instead of using child windows and overlays, you can directly pump WGPU textures in HTML elements. Likewise, you can embed Dioxus into any existing WGPU application, like a Bevy game.

![WGPU Native](/assets/07/wgpu-native-overlay.mp4)

See the [dioxus-native crate](https://crates.io/crates/dioxus-native) for more information.
# The Basics of State

Now that you know how to create user interfaces in Dioxus, it's time to learn about creating and update your app's state.

**Managaing state is, by far, the hardest part of building an app.**

This guide will walk you through the core principles of state management in Dioxus with an early emphasis on theory and then a shift into application.

## The Theory of State Management

Ultimately, "state management" refers to the act of:

1. Initializing data for the UI
1. Handling events from the user
1. Updating the data and re-rendering the UI

Managing this cycle is easy at first, but can become more challenging as apps grow in size, add more asynchronous work, and interact with external resources.

## For Experienced Web Developers

If you're coming to Dioxus as an experienced web developer, we hope you'll feel comfortable rather quickly. State management in Dioxus was heavily inspired by projects like React, Preact, SolidJS, and Svelte.

Dioxus uses signal-based reactivity. Unlike SolidJS, *reads* and *writes* of value are **explicit**. Rust does not have an equivalent to JavaScript's Proxy, so reactivity is traced by calls to `.read()` and `.write()`.

````rust
let mut count = use_signal(|| 0);

rsx! {
    button {
        onclick: move |_| *count.write() += 1,
        "Increment"
    }
    {count.read().to_string()}
}
````

In many cases, `.read()` is subtle, like using the value inside a string format:

````rust
rsx! { "Count: {count}" }
````

Unlike Svelte, Dioxus does not do compile-time transformation of your state. Unlike SolidJS, Dioxus components run multiple times. You can think of state management in Dioxus as a hybrid of React and SolidJS, where reactivity is automatically tracked, but components are free to run multiple times throughout their lifetime.

Dioxus also employs "common sense" optimizations like automatic property memoization and automatic reactivity tracking - two huge improvements over React. Dioxus also allows you to early return, optionally with a Suspended future, giving you an `async/await`-like model for data loading in components.

## For Experienced Rustaceans

If you're coming to Dioxus as an experienced Rustacean, you might be intimidated by our use of "unusual" primitives like `use_signal`, `use_memo`, `use_resource`, etc. Dioxus uses stateful "hooks" - a paradigm that has its origins in web development (in particular, React).

If you don't want to write React-like code in Dioxus, you can opt to using structs to store state and handle updates to the UI imperatively. You can store your state in a struct:

````rust
struct EditorState {
    text: String
}

impl EditorState {
    fn handle_input(&mut self, event: FormEvent) {
        self.text = event.value();
    }
}
````

And then use that state in a component with a single `use_signal`:

````rust
/// Define a component
#[component]
fn TextEditor() -> Element {
    // Use a single "state" object, wrapped in a `Signal`
    let mut state = use_signal(EditorState::new);

    rsx! {
        input {
            // In event handlers, call `.write()` to get `&mut self` on the "state" object
            oninput: move |event| state.write().handle_input(event)
        }
    }
}
````

Rust's borrow checker adds complexity to holding values across async tasks and callbacks. Using our built-in primitives solves a number of issues:

* Ability to reference data in `'static` tasks and callbacks
* Calls to `.write()` automatically queue a component to re-render
* Values are never "stale", even in async contexts.

Dioxus exposes its core runtime functions like `spawn` and `needs_update` - an approach Rustaceans might be more familiar with. The built-in reactive primitives leverage these functions intelligently, and thus will likely be more efficient than the simplistic state approach, but do come with a learning curve.
# Intro to Reactivity

So far, we've covered how to declare static user interfaces with RSX. Now, it's time to make our UI interactive. When the user clicks a button, moves their cursor, or inputs text, we want to update our UI in response.

The act of reacting to a state changes is called *reactivity*. Reactivity sits at the very heart of Dioxus. Everything from data fetching to routing is centered around reacting to state changes.

Similar to libraries like ReactJS, Dioxus provides an built-in reactivity system, saving you from manually queuing re-renders of components. If you're coming from web development, this should feel familiar. If you're mostly experienced with immediate-mode GUIs, this might seem foreign.

Reactivity systems enable larger, more modular, complex GUIs than is typically achievable with other approaches. To build UIs that effectively leverage reactivity, we follow three main pillars:

* **Data Flows Down**: Our apps maintain a one-way flow of data from parents to children
* **Data is Tracked**: Modifications to data is observed by reactive scopes and side-effects
* **Data is Derived**: Our UI and state is a pure function of our data sources

## Pillar 1: Data Flows Down

The first fundamental pillar of reactivity: data flows down. As our apps grow in size, so do their complexity. In apps with dozens of screens and hundreds of components, it can become difficult to reason about relationships between parent and child elements. By enforcing a unidirectional flow of data through our app, we can be sure that a child component renders *purely* as a function of its inputs.

To make our apps interactive, we follow a similar pattern. Components provide two items: *values* and *functions* to modify those values. These items are passed *down* the tree as properties. Dioxus does not provide a way for child components to "reach up" and modify the state of a parent.

The functions we pass down tree are free to mutate state in the *current* component. However, a child component cannot *directly* modify its parent's state. This ensures all mutations to state are defined in the **same scope as the state itself**, making it easier to reason about our app's state at scale.

![Reactivity Tree](/assets/07/reactivity-tree.png)

## Pillar 2: Data is Tracked

The second fundamental pillar of reactivity: data is tracked. When you use various state primitives in Dioxus, the Dioxus runtime *tracks* changes to underlying value. Whenever you call `.set()` or `.write()` on a *Reactive Value*, that operation is *observed* and *effects* are run.

The core Reactive Value in Dioxus is the Signal. When Signals are used in *reactive contexts*, their associated *reads* and *writes* are tracked. Every component is a reactive context. Whenever a Signal's value is modified, a *side-effect* is queued that re-reruns any reactive contexts that read the signal's value.

````rust
#[component]
fn Filter() -> Element {
    let mut selection = use_signal(|| "none");

    rsx! {
        // reading the *selection* value has a side-effect of re-rendering this component
        div { "{selection}" }

        // Calling `.set()` runs side-effects
        button { onclick: move |_| selection.set("dogs"), "Set Filter" }
    }
}
````

Many hooks utilize reactive contexts to attach their own side-effects.

## Pillar 3: Data is Derived

The third pillar of reactivity: values are *derived*. After any state in our app changes, we want the UI to match what we declared in our RSX. In this case, the UI is *derived* from our app state. Similarly, in reactive programming, all data is either a source, or *derived* from a source.

When rendering components, we therefore prefer to perform any transformations of the data while rendering or in a memo. We *do not* modify the data while rendering.

````rust
// ✅ *num_names* is derived from "names"
let names = use_signal(|| vec!["Jane", "Jack", "Jill"]);
let num_names = names.read().len();

// ❌ we do not store num_names in a signal
let names = use_signal(|| vec!["Jane", "Jack", "Jill"]);
let mut num_names = use_signal(|| 0);
num_names.set(names.len());
````

Hopefully, the fact that data should be *derived* is apparent. If we were to modify component state while rendering, we would inadvertently queue re-render side-effects, potentially leading to infinite loops.
# Hooks

In Dioxus, state that is local to a component is stored in *hooks*.

Dioxus hooks work similarly to React's hooks. If you haven't done much web development, hooks might seem particularly unusual. Hooks provide a way of storing state, and attaching effects composability in components. Even better - they're less verbose than declaring structs and implementing "render" traits!

## The `use_hook` primitive

All hooks in Dioxus are built on the `use_hook` primitive. While you might never directly use this primitive, it's good to know where all state eventually resides. The `use_hook` primitive is a function that takes an initializer and returns a `.clone()` of the value.

````rust
fn Simple() -> Element {
    let count = use_hook(|| 123);
    rsx! { "{count}" }
}
````

Whenever `use_hook` is called, one of two things happens:

* if this `use_hook` has never been called before, the initializer is ran and a new slot is created
* otherwise, `use_hook` returns a clone of the current value in the slot.

Internally, the "hook index" is incremented by 1 on every call to `use_hook` and reset to 0 before the component re-renders.

![Hook List](/assets/07/hook-list.png)

## Rules of Hooks

In Dioxus, we are transparent with the inner workings of the framework. Because hooks are implemented by walking an internal "hook list," they have certain rules that would cause walking the list to fail and your app to panic. It's important to note that these rules are not arbitrary - they are the intended result of how hooks are implemented.

Hooks use their call order to keep track of what state belongs to which hook. You must call hooks in the same order every time the component is run. To make sure the order is always the same, **you should only call hooks at the top level of a component or another hook**.

These rules mean that there are certain things you can't do with hooks:

### No Hooks in Conditionals

You should not call a hook function conditionally. When the component re-renders, this might lead to the hook list skipping an entry, causing the next hook to retrieve the wrong value.

````rs@hooks_bad.rs
// ❌ don't call hooks in conditionals!
// We must ensure that the same hooks will be called every time
// But `if` statements only run if the conditional is true!
// So we might violate rule 2.
if you_are_happy && you_know_it {
    let something = use_signal(|| "hands");
    println!("clap your {something}")
}

// ✅ instead, *always* call use_signal
// You can put other stuff in the conditional though
let something = use_signal(|| "hands");
if you_are_happy && you_know_it {
    println!("clap your {something}")
}
````

### No Hooks in Closures

Similar to conditionals, closures provide a way for hook functions to be called in an inconsistent order between renders. Instead of placing the hook in a closure, prefer to only use the result of the hook function in a closure.

````rs@hooks_bad.rs
// ❌ don't call hooks inside closures!
// We can't guarantee that the closure, if used, will be called in the same order every time
let _a = || {
    let b = use_signal(|| 0);
    b()
};

// ✅ instead, move hook `b` outside
let b = use_signal(|| 0);
let _a = || b();
````

### No Hooks in Loops

Just like conditionals and closures, calling hook functions in loops can lead to inconsistent retrieval of hook values between renders, causing hooks to return the wrong value.

````rs@hooks_bad.rs
// `names` is a Vec<&str>

// ❌ Do not use hooks in loops!
// In this case, if the length of the Vec changes, we break rule 2
for _name in &names {
    let is_selected = use_signal(|| false);
    println!("selected: {is_selected}");
}

// ✅ Instead, use a hashmap with use_signal
let selection_map = use_signal(HashMap::<&str, bool>::new);

for name in &names {
    let is_selected = selection_map.read()[name];
    println!("selected: {is_selected}");
}
````

### Early Returns

Unlike in React, in Dioxus, you *can* early return between hook calls. However, we generally discourage this pattern since it can lead to similar consistency issues as conditionals. Dioxus supports early returns because error boundaries and suspense boundaries use the question-mark syntax for ergonomics.

````rust
let name = use_signal(|| "bob".to_string());

// ❌ dont early return between hooks!
if name() == "jack" {
    return Err("wrong name".into())
}

let age = use_signal(|| 123);

rsx! { "{name}, {age}" }


// ✅ instead, prefer to early return *after* all hook functions are run
let name = use_signal(|| "bob".to_string());
let age = use_signal(|| 123);

if name() == "jack" {
    return Err("wrong name".into())
}

rsx! { "{name}, {age}" }
````

### Prefix hook names with "`use_`"

By convention, hooks are Rust functions that have the `use_` prefix. When you see a function with the `use_` prefix, you should be aware that it internally walks the component's hook list and therefore must follow the Rules of Hooks.

## Why Hooks?

You might be wondering - why use hooks? Aren't structs and traits enough?

Hooks are useful because they compose exceptionally well. We can combine hook primitives to build complex yet modular interactions with a consistent interface. With a single function, we can encapsulate both state *and* effects.

````rust
// This hook is *derived* from an initializer
fn use_document_title(initial: impl FnOnce() -> String) -> Signal<String> {
    let mut title = use_signal(initial);

    // Whenever the title signal changes, we queue a side-effect to modify the window state
    use_effect(move || {
        window().document().set_title(title());
    });

    // We return the reactive String
    title
}
````

Another perk of hooks: we don't need to declare the boilerplate that a struct-based approach might require. A simple component that stores user name and email is simple with hooks:

````rust
#[component]
fn Card(default_name: String) -> Element {
    let mut name = use_signal(|| default_name);
    let mut email = use_signal(|| "".to_string());
    rsx! {
        span { "default: {default_name}" }
        input { oninput: move |e| name.set(e.value()), }
        input { oninput: move |e| email.set(e.value()), }
    }
}
````

whereas struct components might be quite verbose:

````rust
struct Card {
    default_name: String
    name: Signal<String>,
    email: Signal<String>
}

#[derive(PartialEq, Clone)]
struct CardProps {
    default_name: String
}
impl Component for Card {
    type Props = CardProps;
    fn new(props: Self::Props) -> Self {
        Self {
            name: Signal::new(props.default_name)
            email: Signal::new("".to_string())
        }
    }

    fn change(&mut self, props: Self::Props) {
        self.default_name = props.default_name;
    }

    fn render(mut state: Handle<Self>) -> Element {
        rsx! {
            span { "default: {self.default_name}" }
            input { oninput: move |e| state.name.set(e.value()) }
            input { oninput: move |e| state.email.set(e.value()) }
        }
    }
}
````

With a single function, we are able to express a value initializer, establish automatic value tracking, and handle changes to component properties. We can easily encapsulate shared behavior, queue side-effects, and compose modular primitives.
# Reactive Signals

In Dioxus, your app's UI is defined as a function of its current state. As the state changes, the components and effects that depend on that state will automatically re-run. Reactivity automatically *tracks* state and *derives* new state, making it easy to build large applications that are efficient and simple to reason about.

Dioxus provides a single source of mutable state: the **Signal**.

## State with Signals

In Dioxus, mutable state is stored in Signals. Signals are *tracked* values that automatically update *reactive contexts* that watch them. They are the source of state from which all other state is derived from. Signals are modified directly by event handlers in response to user input or asynchronously in futures.

You can create a signal with the `use_signal` hook:

````rust
let mut signal = use_signal(|| 0);
````

Once you have your signal, you can gain a reference to the signal's inner value by calling the `.read()`:

````rust
let mut signal = use_signal(|| 0);

// use `.read()` to access the inner value
let inner = signal.read();
````

For Signals whose inner can be cheaply cloneable, you can also use "function" syntax to get a direct `Clone` of the value.

````rust
let name = use_signal(|| "Bob".to_string());

// Call the signal like a function
let inner = name();

// Or use `.cloned()`
let inner = name.cloned();
````

Finally, you can set the value of the signal with the `.set()` method or get a mutable reference to the inner value with the `.write()` method:

````rs@reactivity.rs
// Set the value from the signal
signal.set(1);

// get a mutable reference to the inner value with the .write() method
let mut value: &mut i32 = &mut signal.write();
*value += 1;
````

A simple component that uses `.read()` and `.write()` to update its own state with signals may look like:

````rust
fn Demo() -> Element {
    let mut count = use_signal(|| 0);

    // read the current value
    let current = count.read().clone();

    rsx! {
        button {
            onclick: move |_| *count.write() = current,
            "Increment ({current})"
        }
    }
}
````

When assigning values to a `.write()` call, note that we use the [*dereference operator*](https://doc.rust-lang.org/std/ops/trait.DerefMut.html) which let's us write a value directly into the mutable reference.

## Ergonomic Methods on Signals

In some cases, wrapping your data in Signals can make accessing the inner state awkward. Mutable Signals implement two fundamental traits: `Readable` and `Writable`. These traits provide a number of automatic ergonomic improvements.

* `Signal<T>` implements `Display` if `T` implements `Display`
* `Signal<bool>` implements `fn toggle()`
* `Signal<i32>` and other numbers implement math operators (+, -, /, etc)
* `Signal<T>` where `T` implements `IntoIterator` implements `.iter()`
* and many more!

The `Display` extension enables using signals in formatting expressions:

````rust
let mut count = use_signal(|| 0);
rsx! { "Count is: {count}" }
````

The toggle extension makes toggling boolean values simpler:

````rust
let mut enabled = use_signal(|| true);
rsx! {
    button {
        onclick: move |_| enabled.toggle(),
        if enabled() { "disable" } else { "enable" }
    }
}
````

Math operators simplify arithmetic operations:

````rust
fn app() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    }
}
````

The iterator extension makes iterating through collections easier:

````rust
fn app() -> Element {
    let names = use_signal(|| vec!["bob", "bill", "jane", "doe"]);

    rsx! {
        ul {
            for name in names.iter() {
                li { "hello {name}" }
            }
        }
    }
}
````

You'll generally want to use the extension methods unless the inner state does *not* implement the required traits. There are several methods available not listed here, so peruse the docs reference for more information.

## ReadSignal and WriteSignal

Dioxus provides two variations of the base Signal type: `ReadSignal` and `WriteSignal`.

* **`ReadSignal`**: a read-only version of the base Signal type
* **`WriteSignal`**: a read-write version of the base Signal type, equivalent to `Signal` itself

`ReadSignals` are reactive values that are implement the `Readable` trait. `WriteSignals` are reactive values that implement the `Writable` trait.

These two variations are useful when writing components that need to be generic over their input types. If a component only needs the `.read()` method and its extensions, then it can specify a `ReadSignal` as an argument.

````rust
fn app() -> Element {
    let mut name: Signal<String> = use_signal(|| "abc".to_string());

    rsx! {
        // The rsx macro automatically converts the Signal into a ReadSignal
        Name { name }
    }
}

// We can accept anything that implements `Into<ReadSignal>`
#[component]
fn Name(name: ReadSignal<String>) {
    rsx! { "{name}" }
}
````

In Dioxus, `Signal` is not the only reactive type. The entire ecosystem is full of custom reactive types. Dioxus itself also provides additional reactive types like `Memo` and `Resource`. To integrate well with the broader ecosystem, it's best to prefer using `ReadSignal` and `WriteSignal` in your interfaces rather than specific reactive types.

This ensures we can pass both `Signal` and `Memo` to the same function:

````rust
let name: Signal<String> = use_signal(|| "abc".to_string());
let uppercase: Memo<String> = use_memo(move || name.to_uppercase());

rsx! {
    // The rsx macro automatically converts the Signal into ReadSignal
    Name { name, uppercase }
    // The rsx macro automatically converts the Memo into ReadSignal
    Name { uppercase }
}

#[component]
fn Name(name: ReadSignal<String>) {
    rsx! { "{name}" }
}
````

## Reactive Scopes

A **Reactive Scope** is a block of Rust code that observes reads and writes of reactive values. Whenever `.write()` or `.set()` is called on a Signal, any active reactive scopes tracking that Signal run a callback as a side-effect.

The simplest reactive scope is a component. During a component render, components automatically subscribe to signals where `.read()` is called. The `.read()` method can be called *implicitly* in many circumstances - notably, the extension methods provided by `Readable` use the underlying `.read()` method and thus *also* contribute to the current reactive scope. When a signal's value changes, components queue a side-effect to re-render the component using `dioxus::core::needs_update`.

````rust
let mut name = use_signal(|| "abc".to_string());

rsx! {
    // An explicit call to `.read()`
    {name.read().to_string()}

    // An implicit call via `Display`
    "{name}"
}
````

If a component does not call `.read()` on a Signal while rendering, it does not subscribe to that signal's value. This provides us "zero cost reactivity" where we can freely modify signal values without worrying about unnecessary re-renders. If a value is not observed, it won't cause unnecessary re-renders.

````rust
let mut loading = use_signal(|| false);

rsx! {
    button {
        // Because we don't use "loading" in our markup, the component won't re-render!
        onclick: move |_| async move {
            if loading() {
                return;
            }
            loading.set(true);
            // .. do async work
            loading.set(false);
        }
    }
}
````

Calls to `.read()` access the current reactive scope, adding this scope to the list of subscribers to the Signal with a side effect that runs when that signal is changed. For components, the logic causes the component to queue a re-render side effect.

![Component effects](/assets/07/component-effect.png)

There are other uses of reactive scopes beyond component re-renders. Hooks like `use_effect`, `use_memo`, and `use_resource` all implement functionality by leveraging a reactive scope that exists *outside* the rendering lifecycle.

## Automatic Batching

All built in hooks batch updates if possible. Instead of running effects immediately, `.write()` calls queue an effect before the next "step" of your app. The runtime will try to wait until all writes in the current step are complete before running any effects. This provides automatic batching of `.write()` calls which is important both for performance and consistency in the UI.

By batching `.write()` calls, Dioxus ensures that our example UI always displays one of two states:

* **"loading?: false -> Complete"**
* **"loading?: true -> Loading"**

````rust
let mut loading = use_signal(|| false);
let mut text = use_signal(|| "Complete!");

rsx! {
    button {
        onclick: move |_| async move {
            // these writes are batched and side-effects are de-duplicated
            text.set("Loading");
            loading.set(true);

            // awaiting a future allows the runtime to continue
            do_async_work().await

            // these writes are also batched - only one re-render is queued
            text.set("Complete!");
            loading.set(false);
        },
        "loading?: {loading:?} -> {text}"
    }
}
````

Dioxus uses `await` boundaries as barriers between steps. If state is modified during a step, Dioxus prefers to paint the new UI first before polling additional futures. This ensures changes are flushed as fast as possible and pending states aren't missed.

While dioxus tries to batch writes, it prefers consistent state over batching when the two are in conflict. If you read the result of a memo directly after writing to a signal it depends on, the memo will be re-evaluated immediately to ensure you get the most up-to-date value. This ensures the memo is always equivalent to running the memo's function directly.

````rust
let mut count = use_signal(|| 0);
let double = use_memo(|| *count() * 2);

rsx! {
    button {
        onclick: move |_| async move {
            // This queues a rerun of the memo and marks it as dirty
            count += 1;
            // This forces the memo to re-evaluate immediately
            println!("double is now: {}", double());
        },
        "doubled: {double}"
    }
}
````

## Signals are Borrowed at Runtime

In Rust, the `&T` and `&mut T` reference types statically assert that the underlying value is either immutable or mutable *at compile time*. This assertion brings a number of guarantees, enabling Rust to generate fast and correct code.

Unfortunately, these static assertions do not mix well with asynchronous background tasks. If our `onclick` handler spawns a long-running Future that captures an `&mut T`, we can not safely handle any *other* events until that Future completes:

![Mutability Over Time](/assets/07/mutable-diagram.png)

At times, our UIs can be very concurrent. There *are* ways to re-orient how we concurrently access state that are compatible with Rust's static mutability assertions - unfortunately, they are not easy to program.

Instead, Signals provide a `.write()` method that checks *at runtime* if the value is safe to access. If you're not careful, you can combine a `.read()` and a `.write()` in the same scope, leading to a runtime borrow failure (panic).

This is most frequently encountered when holding `.read()` or `.write()` refs across await points:

````rust
let mut state = use_signal(|| 0);

rsx! {
    button {
        // Clicking this button quickly will cause multiple `.write()` calls to be active
        onclick: move |_| async move {
            let mut writer = state.write();
            sleep(Duration::from_millis(1000)).await;
            *writer = 10;
        }
    }
}
````

Fortunately, this code fails `cargo clippy` because the `writer` type should not be held across an await point.

Thankfully, Signals guard against the "trivial" case because the `.write()` method takes an `&mut Signal`. While the `.write()` guard is active in a scope (block), no other `.read()` or `.write()` guards can be held:

````rust, no_run
let mut state = use_signal(|| 0);

rsx! {
    button {
        // rust prevents this code from compiling since `.write()` takes `&mut T`
        onclick: move |_| {
            let cur = state.read();
            *state.write() = *cur + 1;
        }
    }
}
````

We get a very nice error from the Rust compiler explaining why this code does not compile:

````text
error[E0502]: cannot borrow `state` as mutable because it is also borrowed as immutable
  --> examples/readme.rs:22:18
   |
21 |                 let cur = state.read();
   |                           ----- immutable borrow occurs here
22 |                 *state.write() = *cur + 1;
   |                  ^^^^^^^^^^^^^ mutable borrow occurs here
23 |             }
   |             - immutable borrow might be used here, when `cur` is dropped and runs the destructor for type `GenerationalRef<Ref<'_, i32>>`
````

If we *do* want to read and write in the same scope, we need to stage our operations in the correct order such that the `.read()` and `.write()` guards do not overlap. Usually, this is done by deriving an owned value from the `.read()` operation to be used in the `.write()` operation.

````rust
let cur = state.read().clone(); // calling `.clone()` releases the `.read()` guard immediately.
*state.write() = *cur + 1;
````

Note that Rust automatically drops items *at the end* of a scope, unless they are manually dropped sooner. We can use the `.read()` guard provided it's dropped before `.write()` is called.

This is done either by creating a new, shorter scope to access the `.read()` guard -

````rust
// The .read() guard is only alive for a shorter scope
let next = {
    let cur = state.read();
    println!("{cur}");
    cur.clone() + 1
};

// we can assign `state` to `next` since `next` is not referencing `.read()`.
*state.write() = next;
````

or, simply by calling `drop()` on the guard

````rust
let cur1 = state.read();
let cur2 = *cur1 + 1;
drop(cur1); // dropping early asserts we can `.write()` the signal safely
*state.write() = cur2 + 1;
````

In very advanced use cases, you can make a copy of the signal or use the `read_unchecked` method to relax the borrowing rules:

````rust
match result.read_unchecked().as_ref() {
    Ok(resp) => rsx! { "success! {resp}" }
    Err(err) => rsx! { "err: {err:?}" },
}
````

 > 
 > Rust 2021 had issues with `.read()` in match statements, whereas Rust 2024 fixes this issue, meaning you no longer need to use `read_unchecked`

While this might seem scary or error prone, you will *very rarely* run into these issues when building apps. The `.read()` and `.write()` guards respect Rust's ownership rules within a given scope and concurrent scopes are protected by the [Clippy `await_holding_refcell_ref` lint](https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_refcell_ref).

## Signals implement `Copy`

If you've used Rust to build other projects - like a webserver or a command line tool - you might have encountered situations with closures, threads, and async tasks that required an `Arc` or `Rc` to satisfy the borrow checker.

![Concurrent Access](/assets/07/concurrent-arc.png)

If our data is used across several parallel threads, or even just held in a callback, we might need to wrap it in an `Arc` or `Rc` smart pointer and `.clone()` it. This can lead to cumbersome code where we constantly call `.clone()` to share data into callbacks and async tasks.

````rust
let state = Arc::new(123);

// thread 1
std::thread::spawn({
    let state = state.clone();
    move |_| println!("{state:?}"),
})

// thread 2
std::thread::spawn({
    let state = state.clone();
    move |_| println!("{state:?}"),
})
````

Unfortunately, UI code constantly encounters this problem - **this is why Rust does not have a great reputation for building GUI apps**!

To solve this, we built the [generational-box crate](https://crates.io/crates/generational-box) that provides a `GenerationalBox` type that implements [Rust's `Copy` trait](https://doc.rust-lang.org/std/marker/trait.Copy.html). The `Copy` trait is very important: Rust automatically copies `Copy` types (when needed) on boundaries of scopes.

````rust
let state = GenerationalBox::new(123);

// the `move` keyword automatically copies the GenerationalBox!
std::thread::spawn(move |_| println!("{state:?}"));

// we can easily share across threads with no `.clone()` noise
std::thread::spawn(move |_| println!("{state:?}"));
````

Instead of copying the underlying value, the `GenerationalBox` simply copies a *handle* to the value. This handle is essentially a runtime-verified smart pointer. Accessing the contents of a signal is not as efficient as reading a pointer directly - there is an extra pointer indirection and lock - but we expect most code to not be bottlenecked by reading the contents of a `GenerationalBox`.

Dioxus Signals are built directly on top of `GenerationalBox`. They share the same `Copy` semantics and ergonomics, but with the same tradeoffs.

## Signals are Disposed

Signals implementing `Copy` is a huge win for ergonomics. However, there is a tradeoff. The `GenerationalBox` type does not have automatic [RAII](https://doc.rust-lang.org/rust-by-example/scope/raii.html) support. This means when a `GenerationalBox` is dropped, its resources are **not immediately cleaned up**. It can be tricky to correctly use `GenerationalBox` directly. Dioxus manages the *resource* lifecycle by cleaning up resources using the *component* lifecycle.

The Signal type is built on `GenerationalBox`. Whenever you call `use_signal`, we automatically:

* Call `Signal::new()`
* Register `signal.dispose()` on the component's `on_drop`

Whenever a component is unmounted, its hooks are dropped. When you create Signals in a component, each Signal is registered with a Signal "owner" on that component. When the component is unmounted, the owner drops, and in its `Drop` implementation, it calls `.dispose()` on all Signals that were created in its scope.

Effectively, we connected the `.dispose()` method of the Signals to the unmount of the component.

Because the Signal is disposed when the component unmounts, reading it after will cause a runtime panic. This very rarely happens in practice, but *is* possible if you "save" the signal in a component higher up the tree. Doing so would violate the one-way-data flow pillar of reactivity, but is technically possible.

![Concurrent Access](/assets/07/use-after-free.png)

Reading a Signal after it's been disposed is similar to the "use-after-free" bug with pointers, but reading a Signal *is not* undefined behavior. In debug mode, the Signal will be hoisted to its reader and you'll receive a warning in the logs that a Signal is being read after it's been disposed.

A similar issue can arise when you call `Signal::new()` directly. Dioxus creates an implicit Signal owner that is owned by the current component. The contents of this Signal will only be dropped when the current component is unmounted. Calling `Signal::new()` can lead to unbounded memory usage until the component is dropped. It's rare to do this in normal application code but can crop up in library development.

````rust
let mut users = use_signal(|| vec![]);

rsx! {
    button {
        // the underlying strings won't be dropped until the component is unmounted, or you call `.dispose()` manually
        onclick: move |_| {
            users.write().push(Signal::new("bob".to_string()));
        },
        "Add a new user"
    }
}
````

When mapping Signals or creating them on-the-fly, it's best to prefer the built-in methods and reactive collections.

## Effects, Memos, and More

Signals are just one piece of the Dioxus reactivity system. Hooks like `use_effect` and `use_memo` are able to isolate their reactive scopes to just callbacks and futures. This means `.read()` and `.write()` in these scopes won't queue re-render side-effects in their containing component.

We cover these hooks in more depth in a [later chapter](./effects.md).
# Handling User Input

It's time to make our app interactive! In Dioxus, user input is handled by attaching event listeners to elements. When an event listener is triggered, Dioxus runs the provided closure. In the closure, you can write to signals, log messages, make network requests, or take any action that makes the UI feel *alive*.

````rust
fn app() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        h1 { "High-Five counter: {count}" }
        button { onclick: move |_| count += 1, "Up high!" }
        button { onclick: move |_| count -= 1, "Down low!" }
    }
}
````

````inject-dioxus
DemoFrame {
    readme::App {}
}
````

## Event Handlers

Event handlers are callbacks used to respond to user actions. Event handlers can capture dozens of different interactions: button clicks, page scrolls, mouse movements, text input, and more.

Adding an event handler to an element is similar to adding an attribute with the `key: value` syntax. The handler name usually starts with `on` - and accepts a closure as the value. For example, to handle clicks on a button, we can add an `onclick` handler:

````rs@event_click.rs
rsx! {
    button { width: "100%", height: "100%",
        // This event handler will be called when the button is clicked
        onclick: move |event| log!("Clicked! Event: {event:#?}"),
        "click me!"
    }
}
````

````inject-dioxus
DemoFrame {
    event_click::AppDemo {}
}
````

There are many different event handlers available:

* **Mouse Events**: `onclick`, `onmouseover`, `onmousedown`, `onmousemove`, etc.
* **Keyboard Events**: `onkeydown`, `onkeyup`, `onkeypress`
* **Form Events**: `onsubmit`, `oninput`, `onchange`, etc.
* **Focus Events**: `onfocus`, `onblur`
* **Drag-and-Drop Events**: `ondrag`, `ondrop`, `ondragover`, etc.
* **UI Events**: `onscroll`, `onload`, `onscroll`, `onresize`

The full list of event listeners is available in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Events).

## The Event Object

Event handlers receive an [`Event`](https://docs.rs/dioxus-core/latest/dioxus_core/struct.Event.html) object containing information about the event. Different types of events contain different types of data. For example, mouse-related events contain [`MouseData`](https://docs.rs/dioxus/latest/dioxus/events/struct.MouseData.html), which provides details like the mouse position and which mouse buttons were pressed.

The event object is the first argument in the event handler callback:

````rust
rsx! {
    button {
        onclick: move |event| {   // <-- our `Event` object
            //
        }
    }
}
````

In the example above, this event data was logged to the terminal:

````
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
Clicked! Event: UiEvent { bubble_state: Cell { value: true }, data: MouseData { coordinates: Coordinates { screen: (242.0, 256.0), client: (26.0, 17.0), element: (16.0, 7.0), page: (26.0, 17.0) }, modifiers: (empty), held_buttons: EnumSet(), trigger_button: Some(Primary) } }
````

 > 
 > To learn what the different event types for HTML provide, read the [events module docs](https://docs.rs/dioxus-html/latest/dioxus_html/events/index.html).

## Handling Common Events

The most common action you'll take in an event handler is modifying the application's state. This might involve updating a filter, toggling a switch, or presenting feedback to text input.

For components like toggles, we might use a boolean signal and a checkbox:

````rust
let mut upload_enabled = use_signal(|| true);
rsx! {
    input {
        type: "checkbox",

        // set the upload_enabled signal
        oninput: move |evt| upload_enabled.set(evt.checked()),
    }
}
````

For components like filters, we might use the HTML `select` element:

````rust
let mut option = use_signal(|| None);
rsx! {
    select {
        // set the signal to the select's `value`
        oninput: move |evt| option.set(Some(evt.value())),

        option { label: "Sedan", value: "sedan" }
        option { label: "Suv", value: "suv" }
        option { label: "Truck", value: "truck" }
    }
}
````

For text, we might use the `input` element:

````rust
let mut first_name = use_signal(|| "".to_string());
rsx! {
    input {
        type: "text",
        placeholder: "First Name…",

        // Update the first_name signal on text input
        oninput: move |e| first_name.set(e.value()),
    }
}
````

For forms, we might use a HashMap to hold the key-value pairs:

````rust
let mut values = use_signal(HashMap::new);

rsx! {
    form {
        onsubmit: move |evt| {
            // Prevent the default form submission navigation
            evt.prevent_default();
            values.set(evt.values());
        },

        label { for: "username", "Username" }
        input { type: "text", name: "username" }
    }
}
````

Dioxus bridges the Rust-JavaScript boundary by adding ergonomic accessor methods on the `Event` object to make reading values from the DOM easier. These include:

* A `.value()` method for input events to read the input contents
* A `.values()` method for form events to read all the form values
* A `.checked()` method on checkbox input events to read the `.checked` state
* A `.files()` event to read any uploaded files
* A `.key()` event to convert keydown events into a Rust `Key` enum
* and many more methods!

 > 
 > We provide a large number of examples in the [Dioxus GitHub repository](https://github.com/DioxusLabs/dioxus/tree/main/examples). Be sure to also read the docs on [handling events in HTML](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Events).

## Controlled vs Uncontrolled Inputs

Dioxus provides two ways of handling the state of input elements:

* **Uncontrolled mode**: the default where the input element handles its own state
* **Controlled mode**: an alternative mode where you control the input element's state manually

Controlled mode is useful if you plan to transform or programmatically modify the user's input.

### Uncontrolled Inputs

*Uncontrolled mode* is the default mode for input elements. In this mode, the input element itself manages its own state like the input value, cursor position, and focusing. We simply attach an event listener to the input and react to changes in the value:

````rs@input_uncontrolled.rs
pub fn App() -> Element {
    rsx! {
        form { onsubmit: move |event| { tracing::info!("Submitted! {event:?}") },
            input { name: "name" }
            input { name: "age" }
            input { name: "date" }
            input { r#type: "submit" }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    input_uncontrolled::App {}
}
````

````
Submitted! UiEvent { data: FormData { value: "", values: {"age": "very old", "date": "1966", "name": "Fred"} } }
````

In this mode, we have no control over the actual value of the input. The user may enter any value and our code updates state in response.

### Controlled Inputs

*Controlled mode* as an alternative mode for input elements where you directly control the state of the input. If the user types invalid text in the input, you can reject it or overwrite it.

To put an input element in controlled mode, we drive its `value` attribute directly:

````rs@input_controlled.rs
pub fn App() -> Element {
    let mut name = use_signal(|| "bob".to_string());

    rsx! {
        input {
            // we tell the component what to render
            value: "{name().to_ascii_uppercase()}",
            // and what to do when the value changes
            oninput: move |event| name.set(event.value())
        }
    }
}
````

````inject-dioxus
DemoFrame {
    input_controlled::App {}
}
````

Controlled inputs enable more control over the input element behavior. You can:

* Transform the input as it's modified (e.g. to make sure it is upper case)
* Validate the input, rejecting invalid inputs
* Programmatically change the value (e.g. a "randomize" button that fills the input with nonsense)

## Event Propagation

When the user interacts with our app, their interactions might trigger multiple event listeners at once. In the simplest case, a `div` may contain a `button` - both with their own `onclick` listeners:

![Multiple Listeners](/assets/07/multiple-listeners.png)

In what order will the listeners fire? Event handling comes in two phases:

* **Event Capturing**: Listeners are triggered as the event "descends" to the target.
* **Event Bubbling**: Listeners are triggered as the event "bubbles" to the root.

By default, Dioxus only captures the "bubbling" phase of the event, so the inner `button` will receive the `onclick` event before the `div`.

![Bubbling Diagram](/assets/07/event-capturing.png)

As the event bubbles to the root element (in this case, the document root), you have an opportunity to prevent any further listeners from being triggered. To stop the event from propagating upwards, you can call the `stop_propagation()` method on the event:

````rs@event_nested.rs
rsx! {
    div { onclick: move |_event| {},
        "outer"
        button {
            onclick: move |event| {
                event.stop_propagation();
            },
            "inner"
        }
    }
}
````

This ensures *only* the inner `button` will run its `onclick` handler - the `div` handler will not be triggered. This behavior can be useful when building advanced UI like drag-and-drop interactions and custom menus.

 > 
 > For more information about event propagation see [the MDN docs on event bubbling](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling)

## Prevent Default

Some events have a default behavior. For keyboard events, this might be entering the typed character. For mouse events, this might be selecting some text. For forms, this might be submitting the form and navigating the page.

You can call the `prevent_default()` method on the event to stop this default behavior.

````rs@event_prevent_default.rs
rsx! {
    a {
        href: "https://example.com",
        onclick: |evt| {
            evt.prevent_default();
            log!("link clicked")
        },
        "example.com"
    }
}
````

````inject-dioxus
DemoFrame {
    event_prevent_default::AppDemo {}
}
````

Event handlers will still be called, but the "default" behavior of the interaction will be cancelled. The `prevent_default()` method is frequently used in interactions like:

* Capturing file drops
* Preventing form navigations
* Overriding the `a` link element behavior
* Disallowing certain text input
* Enabling drag-and-drop behavior for arbitrary elements

 > 
 > For more information about default behaviors, see the [MDN docs on preventDefault()](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)

## Downcasting to Native Events

In some cases, the Dioxus `Event` type does not bridge enough of the Event's data. In these cases, we can directly access the platform-specific event type. Dioxus does not do this automatically since not all platforms share a consistent event interface with some platforms providing richer detail than others.

To downcast the event, we can use `event.downcast::<T>()` where `T` is the type we are trying to downcast to. You'll mostly use this extension when building web applications to downcast into the underlying `web_sys` event:

````rust
rsx! {
    button {
        onclick: move |evt| {
            let web_evt = evt.downcast::<web_sys::Event>().unwrap();
            let target = web_evt.target().unwrap();
            log!("target: {:?}", target);
        },
        "Click me!"
    }
}
````

## Asynchronous Handlers

Event Handlers can either be synchronous or asynchronous. Dioxus automatically calls `spawn()` on the Futures produced by asynchronous event handlers:

````rust
rsx! {
    button {
        onclick: move |evt| async move {
            let res = reqwest::get("https://dog.ceo/api/breeds/image/random/")
                .await
                .unwrap()
                .json::<DogApi>()
                .await;
            log!("res: {:?}", res);
        },
        "Fetch a dog!"
    }
}
````

Dioxus won't cancel previous Tasks spawned by the onclick handler, so multiple rapid button clicks will start multiple concurrent fetches. Be careful to not mutate state in asynchronous handlers without synchronization first.

## Handling files

You can insert a file picker by using an input element of type `file`. This element supports the `multiple` attribute, to let you pick more files at the same time. You can select a folder by adding the `directory` attribute: Dioxus will map this attribute to browser specific attributes, because there is no standardized way to allow a directory to be selected.

Extracting the selected files is a bit different from what you may typically use in Javascript.

The `FormData` event contains a `files` field with data about the uploaded files. This field contains a `FileEngine` struct which lets you fetch the filenames selected by the user. This example saves the filenames of the selected files to a `Vec`:

````rs@input_fileengine.rs
pub fn App() -> Element {
    let mut filenames: Signal<Vec<String>> = use_signal(Vec::new);
    rsx! {
        input {
            // tell the input to pick a file
            type: "file",
            // list the accepted extensions
            accept: ".txt,.rs",
            // pick multiple files
            multiple: true,
            onchange: move |evt| {
                for file in evt.files() {
                    filenames.write().push(file.name());
                }
            }
        }
    }
}
````

If you're planning to read the file content, you need to do it asynchronously, to keep the rest of the UI interactive. This example event handler loads the content of the selected files in an async closure:

````rs@input_fileengine_async.rs
onchange: move |evt| {
    async move {
        for file in evt.files() {
            if let Ok(file) = file.read_string().await {
                files_uploaded.write().push(file);
            }
        }
    }
}
````

Lastly, this example shows you how to select a folder, by setting the `directory` attribute to `true`.

````rs@input_fileengine_folder.rs
input {
    type: "file",
    // Select a folder by setting the directory attribute
    directory: true,
    onchange: move |evt| {
        for file in evt.files() {
            println!("{}", file.name());
        }
    }
}
````

## Handler Props

Sometimes, you might want to make a component that accepts an event handler. A simple example would be a `FancyButton` component, which accepts an `onclick` handler with the `EventHandler` type:

````rs@event_handler_prop.rs
#[derive(PartialEq, Clone, Props)]
pub struct FancyButtonProps {
    onclick: EventHandler<MouseEvent>,
}

pub fn FancyButton(props: FancyButtonProps) -> Element {
    rsx! {
        button {
            class: "fancy-button",
            onclick: move |evt| props.onclick.call(evt),
            "Click me!"
        }
    }
}
````

To actually call the event handler, you call it with the `.call()` method:

````rs@event_handler_prop.rs
onclick: move |evt| props.onclick.call(evt),
````

 > 
 > Note: just like any other attribute, you can name the handlers anything you want! Any closure you pass in will automatically be turned into an `EventHandler`.

## Custom Data

Event Handlers are generic over the closure's first argument, so you can pass in any data, e.g:

````rs@event_handler_prop.rs
struct ComplexData(i32);

#[derive(PartialEq, Clone, Props)]
pub struct CustomFancyButtonProps {
    onclick: EventHandler<ComplexData>,
}

pub fn CustomFancyButton(props: CustomFancyButtonProps) -> Element {
    rsx! {
        button {
            class: "fancy-button",
            onclick: move |_| props.onclick.call(ComplexData(0)),
            "click me pls."
        }
    }
}
````

The `EventHandler<T>` type is a subset of the base `Callback<Args, Ret>` type that allows you to return a value from the closure.

## Returning a Value From an Event Handler

If you want to accept a closure that returns a value, you can use the `Callback` type. The callback type accepts two generic arguments, `I`, the input type, and `O`, the output type. Just like `EventHandler`, `Callback` is automatically converted in props and can be easily copied anywhere in your component:

````rs@event_handler_prop.rs
#[derive(PartialEq, Clone, Props)]
pub struct CounterProps {
    modify: Callback<u32, u32>,
}

pub fn Counter(props: CounterProps) -> Element {
    let mut count = use_signal(|| 1);

    rsx! {
        button {
            onclick: move |_| count.set(props.modify.call(count())),
            "double"
        }
        div { "count: {count}" }
    }
}
````

## Callbacks Carry the Runtime

Many Dioxus runtime functions are "free functions" - you can freely call them without needing an explicit handle to the Dioxus runtime. This works by implicitly setting a thread-local called "current runtime", roughly equivalent to this pseudocode:

````rust
thread_local! {
    static CURRENT_RUNTIME: Cell<Option<Runtime>> = Cell::new(None);
}

fn render_users_component(app: &Application) {
    CURRENT_RUNTIME.set(app.runtime());
    app.run_component();
    CURRENT_RUNTIME.set(None);
}
````

Whenever *your* code runs from within Dioxus, the runtime will always be set. However, plain closures do not automatically set the current runtime. Trying to call closures outside the app that reference state from within the app might cause a panic.

Fortunately, the `EventHandler` and `Callback` types carry a handle to the Dioxus runtime, ensuring runtime methods succeed. When the callback is called, the closure sets the `CURRENT_RUNTIME` variable. This means you can pass the `EventHandler` and `Callback` types to APIs like file-system watchers and system IO where the Dioxus runtime is not usually active.
# Async and Futures

Not all actions complete immediately. Some actions, like a network request, require waiting for system input/output (IO). While waiting for network response, we want to provide status updates, add a loading spinner, and most importantly: avoid blocking the UI thread. Code that blocks the UI thread will prevent further user input, making the UI feel janky and unintuitive.

Rust provides a built-in way of handling asynchronous work with its built-in async/await system. Dioxus provides a first-class integration with Rust's async/await system.

## Future: Rust's Async Primitive

The `Future` trait is the core of async Rust. A future represents a value that may not yet be ready. In other languages, this is sometimes called a *Promise* or *Task*. You can read more about Futures in the [Rust book](https://doc.rust-lang.org/book/ch17-00-async-await.html).

We won't cover all the details of futures here, but there are a few important things to know before using them in Dioxus:

* **Futures are lazy**: They do not do anything until you `await` them or `spawn` them.
* **Futures are concurrent but not always parallel**: In Dioxus, all futures run on the main thread.
* **Futures pause at await points**: You should not hold any locks across those await points.
* **Futures can be cancelled before they complete**: Your futures need to be "cancel safe."

Futures should be able to handle stopping at any time without panicking or leaving the application in an inconsistent state. They should also be careful not to run blocking operations that lock the main thread.

The lifecycle of a future follows a consistent structure:

* A callback calls an `async fn` or an async closure
* The async function returns a Future
* A `dioxus::spawn()` call submits the future to the Dioxus runtime, returning a `Task`
* The Future is polled in the background until it returns a `Ready` value
* If the Future is cancelled, Rust calls its `Drop` implementation

![Future Diagram](/assets/07/future-diagram.png)

## Lazy futures

Unlike JavaScript's Promises, Rust futures are *lazy*. This means that they do not start executing until you call `.await` or start them in the background with `spawn`.

This Future will never log "Ran" because it is never awaited:

````rs@async_crash_course.rs
let future = async {
    println!("Ran");
};
````

To run this Future, you can either await it in another Future or spawn it:

````rs@async_crash_course.rs
let future = async {
    println!("Ran");
};
let other_future = async {
    future.await;
    println!("Ran Other");
};
spawn(other_future);
````

You can stop polling a Future any time or customize how a Future is polled using the [futures](https://crates.io/crates/futures) crate.

## Running Futures with `spawn`

The Dioxus [`spawn`](https://docs.rs/dioxus/0.7/dioxus/prelude/fn.spawn.html) function starts running a Future in the background and returns a `Task` that you can use to control the Future. It is the basis of all other async hooks in dioxus. You can use spawn to execute one-off tasks in event handlers, hooks or other Futures:

````rs@asynchronous.rs
let mut response = use_signal(|| "Click to start a request".to_string());

rsx! {
    button {
        onclick: move |_| {
            response.set("...".into());
            // Spawn will start a task running in the background
            spawn(async move {
                let resp = reqwest::Client::new()
                    .get("https://dioxuslabs.com")
                    .send()
                    .await;

                if resp.is_ok() {
                    response.set("dioxuslabs.com responded!".into());
                } else  {
                    response.set("failed to fetch response!".into());
                }
            });
        },
        "{response}"
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::SpawnButton {}
}
````

Since spawning in event handlers is very common, Dioxus provides a more concise syntax. If you return a Future from an event handler, Dioxus will automatically `spawn` it:

````rs@asynchronous.rs
let mut response = use_signal(|| "Click to start a request".to_string());

rsx! {
    button {
        // Async closures passed to event handlers are automatically spawned
        onclick: move |_| async move {
            response.set("...".into());
            let resp = reqwest::Client::new()
                .get("https://dioxuslabs.com")
                .send()
                .await;

            if resp.is_ok() {
                response.set("dioxuslabs.com responded!".into());
            } else  {
                response.set("failed to fetch response!".into());
            }
        },
        "{response}"
    }
}
````

## Running Futures with `use_action`

You'll frequently want to spawn an action in response to some user input and store the result. For rapid user input, you'll also want to cancel previous actions to prevent race conditions. Dioxus provides a built-in hook that simplifies this pattern with a function called `use_action`.

The `use_action` hook combines signals and tasks into a single unified interface. Simply call `use_action` with a callback that returns a `Result<T>`:

````rust
// Whenever this action is called, it will re-run the future and return the result.
let mut breed = use_action(move |breed| async move {
    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    struct DogApi {
        message: String,
    }

    reqwest::get(format!("https://dog.ceo/api/breed/{breed}/images/random"))
        .await
        .unwrap()
        .json::<DogApi>()
        .await
});
````

You can call the action with `.call()`:

````rust
rsx! {
    button {
        onclick: move |_| {
            breed.call(cur_breed.clone());
        },
        "{cur_breed}"
    }
}
````

And then, elsewhere in your component, you can read the result with `.value()`:

````rust
match breed.value() {
    Some(Ok(res)) => rsx! {
        img { src: "{res.read().message}" }
    },
    Some(Err(_e)) => rsx! {
        div { "Failed to fetch a dog, please try again." }
    },
    None => rsx! {
        div { "Click the button to fetch a dog!" }
    },
}
````

If an action is pending, calling `.call()` will cancel the current action's `Task`, replacing it with the new task.

## Automatic Cancellation

The Future you pass to the `spawn` will automatically be cancelled when the component is unmounted. If you need to keep the Future running until it is finished, you can use [`spawn_forever`](https://docs.rs/dioxus/0.7/dioxus/prelude/fn.spawn_forever.html) instead:

````rs@asynchronous.rs
// Spawn will start a task running in the background which will not be
// cancelled when the component is unmounted
dioxus::dioxus_core::spawn_forever(async move {
   let resp = reqwest::Client::new()
       .get("https://dioxuslabs.com")
       .send()
       .await;

   if resp.is_ok() {
       response.set("dioxuslabs.com responded!".into());
   } else  {
       response.set("failed to fetch response!".into());
   }
});
````

## Manual Cancellation

If you want to cancel your future manually, you can call the `cancel` method on the `Task` returned by `spawn` or `spawn_forever`. This will stop the future from running and drop it.

````rs@asynchronous.rs
let mut response = use_signal(|| "Click to start a request".to_string());
let mut task = use_signal(|| None);

rsx! {
    button {
        onclick: move |_| {
            response.set("...".into());
            // Spawn will start a task running in the background
            let new_task = spawn(async move {
                let resp = reqwest::Client::new()
                    .get("https://httpbin.org/delay/1")
                    .send()
                    .await;

                if resp.is_ok() {
                    response.set("httpbin.org responded!".into());
                } else  {
                    response.set("failed to fetch response!".into());
                }
            });
            task.set(Some(new_task));
        },
        "{response}"
    }
    button {
        onclick: move |_| {
            // If the task is running, cancel it
            if let Some(t) = task.take() {
                t.cancel();
                response.set("Request cancelled".into());
            } else {
                response.set("No request to cancel".into());
            }
        },
        "Cancel Request"
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::CancelButton {}
}
````

## Cancel Safety

Async tasks can be cancelled at any time. The futures you spawn in dioxus may be canceled:

1. When the component they were spawned in is unmounted.
1. When the task is cancelled manually using the `cancel` method on the `Task` returned by `spawn` or `spawn_forever`.
1. When a resource restarts

This means that your futures need to be cancel safe. A cancel-safe future is one that can be stopped at any await point without causing issues. For example, if you are using a global state, you need to ensure that the state is restored when the future is dropped:

````rs@asynchronous.rs
static RESOURCES_RUNNING: GlobalSignal<HashSet<String>> = Signal::global(|| HashSet::new());
let mut breed = use_signal(|| "hound".to_string());
let dogs = use_resource(move || async move {
    // Modify some global state
    RESOURCES_RUNNING.write().insert(breed());

    // Wait for a future to finish. The resource may cancel
    // without warning if breed is changed while the future is running. If
    // it does, then the breed pushed to RESOURCES_RUNNING will never be popped
    let response = reqwest::Client::new()
        .get(format!("https://dog.ceo/api/breed/{breed}/images"))
        .send()
        .await?
        .json::<BreedResponse>()
        .await;

    // Restore some global state
    RESOURCES_RUNNING.write().remove(&breed());

    response
});
````

````inject-dioxus
DemoFrame {
    asynchronous::NotCancelSafe {}
}
````

You can mitigate issues with cancellation by cleaning up resources manually. For example, by making sure global state is restored when the future is dropped:

````rs@asynchronous.rs
static RESOURCES_RUNNING: GlobalSignal<HashSet<String>> = Signal::global(|| HashSet::new());
let mut breed = use_signal(|| "hound".to_string());
let dogs = use_resource(move || async move {
    // Modify some global state
    RESOURCES_RUNNING.write().insert(breed());

    // Automatically restore the global state when the future is dropped, even if
    // isn't finished
    struct DropGuard(String);
    impl Drop for DropGuard {
        fn drop(&mut self) {
            RESOURCES_RUNNING.write().remove(&self.0);
        }
    }
    let _guard = DropGuard(breed());

    // Wait for a future to finish. The resource may cancel
    // without warning if breed is changed while the future is running. If
    // it does, then it will be dropped and the breed will be popped
    reqwest::Client::new()
        .get(format!("https://dog.ceo/api/breed/{breed}/images"))
        .send()
        .await?
        .json::<BreedResponse>()
        .await
});
````

````inject-dioxus
DemoFrame {
    asynchronous::CancelSafe {}
}
````

Async methods will often mention if they are cancel safe in their documentation. Generally, most futures you'll encounter when building Dioxus apps *are* cancel safe.

## Concurrency vs Parallelism

Concurrency and parallelism are often confused, but the difference has important implications for how you write your applications. Multiple concurrent tasks may be in progress at the same time, but they don't necessarily run at the same time. In Rust, futures are concurrent. They can yield control to other tasks at await points, allowing other tasks to run while they wait for a value to become ready.

![concurrent](/assets/07/async_concurrent.png)

In contrast, multiple parallel tasks can run at exactly the same time on different threads. In Rust, you can spawn parallel tasks using the `std::thread` module or libraries like `rayon`.

![parallel](/assets/07/async_parallel.png)

Rust has multiple different async runtimes like `tokio` or `wasm-bindgen-futures`. Dioxus provides its own async runtime built on top of a platform specific runtime for each renderer. On desktop and mobile, we use Tokio to progress futures.

The Dioxus runtime is single threaded which means futures can use `!Send` types, but they need to be careful to never block the thread.

````rs@async_crash_course.rs
spawn(async {
    // This will block the main thread and make the UI unresponsive.
    // Do not do this!
    solve_for_the_answer_to_life_and_everything();
    println!("Ran");
});
````

If you have an expensive task you need to run, you should spawn it on a separate thread using [`std::thread::spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html) on desktop/mobile or use a [web worker](https://docs.rs/gloo-worker/latest/gloo_worker/) on the web. This will allow the main thread to continue running and keep the UI responsive.

````rs@async_crash_course.rs
std::thread::spawn(|| {
    // This will run on a separate thread and not block the main thread.
    solve_for_the_answer_to_life_and_everything();
    println!("Ran");
});
````

## Handling locks

Futures will pause execution at `.await` points, allowing other tasks to run until the future is ready to continue. You should never hold `read`/`write` locks across `.await` points because another async task could try to use the value while the future is paused and the lock is still open. Instead, you need to ensure that locks are only held for the duration of the critical section and released before awaiting.

![async locks](/assets/07/async_lock_await.png)

## Long-lived Futures

In some apps, you might want to include long-lived tasks that exist for the lifetime of the app. This might be a background sync engine or a thread listening to some system IO. For these use cases, we provide the `spawn_forever` function. This works exactly the same as `spawn`, but instead of spawning the future under the *current* component, the future is attached to the *root* component. Because the root component is never unmounted, the task continues until the app is closed.

````rust
use_hook(|| spawn_forever(async move {
    println!("Starting a background task!");
}));
````

This function does have its drawbacks and is meant for advanced use cases. If any resources like a Signal are used in this future, they must *also* be valid for the lifetime of the app. Using Signals after they have been dropped will lead to a panic and crash your app!
# Data Fetching

One of the most common asynchronous operations in applications is making network requests. This guide will cover how to fetch data in Dioxus, how to avoid waterfalls, and using libraries to manage caching and invalidating requests.

The hooks and techniques we cover here are built on top of the Future and Signal primitives.

## Library Dependencies

While Dioxus does not provide a built-in HTTP client, you can use the popular [reqwest](https://docs.rs/reqwest/latest/reqwest/) library to make asynchronous network requests. We will be using the reqwest library throughout the examples in this page. Before we start, make sure to add the `reqwest` and `serde` libraries to your `Cargo.toml`:

````sh
cargo add reqwest --features json
cargo add serde --features derive
````

Your Cargo.toml should have the reqwest and serde libraries:

````toml
[dependencies]
# ... dioxus and other dependencies
reqwest = { version = "*", features = ["json"] }
serde = { version = "1", features = ["derive"] }
````

We are planning on eventually integrating a library like [dioxus-query](https://crates.io/crates/dioxus-query) directly into Dioxus for better integration with the app router.

## Requests from Event Handlers

The simplest way to request data is simply by attaching an async closure to an EventHandler.

````rust
#[derive(serde::Deserialize)]
struct DogApi {
    message: String,
}

let mut img_src = use_signal(|| "image.png".to_string());

let fetch_new = move |_| async move {
    let response = reqwest::get("https://dog.ceo/api/breeds/image/random")
        .await
        .unwrap()
        .json::<DogApi>()
        .await
        .unwrap();

    img_src.set(response.message);
};

rsx! {
    img { src: img_src }
    button { onclick: fetch_new, "Fetch a new dog!" }
}
````

Whenever the user clicks the button, the `fetch_new` closure is fired, a new Future is spawned, and the network request is made. When the response is complete, we set `img_src` to the return value.

Unfortunately, data fetching is not always quite this simple. If the user rapidly presses the fetch button, multiple requests will be made simultaneously, and the image source will overwritten multiple times. To mitigate this, we can add a "loading" Signal to prevent multiple requests:

````rust
let mut img_src = use_signal(|| "image.png".to_string());
let mut loading = use_signal(|| false);

let fetch_new = move |_| async move {
    if loading() {
        return;
    }

    loading.set(true);
    let response = reqwest::get("https://dog.ceo/api/breeds/image/random")
        .await
        .unwrap()
        .json::<DogApi>()
        .await
        .unwrap();

    img_src.set(response.message);
    loading.set(false);
};

// ...
````

Manually handling edge cases of data loading can be tedious, so we've built a more general solution for futures with `use_resource`.

## Asynchronous State with `use_resource`

The [`use_resource`](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_resource.html) hook can be used to *derive* asynchronous state. This function accepts an async closure that returns a Future. As the future is polled, `use_resource` tracks `.read()` calls of any contained Signals. If another action calls `.write()` on the tracked signals, the `use_resource` immediately restarts.

````rs@asynchronous.rs
let mut breed = use_signal(|| "hound".to_string());
let dogs = use_resource(move || async move {
    reqwest::Client::new()
        // Since breed is read inside the async closure, the resource will subscribe to the signal
        // and rerun when the breed is written to
        .get(format!("https://dog.ceo/api/breed/{breed}/images"))
        .send()
        .await?
        .json::<BreedResponse>()
        .await
});

rsx! {
    input {
        value: "{breed}",
        // When the input is changed and the breed is set, the resource will rerun
        oninput: move |evt| breed.set(evt.value()),
    }

    div {
        display: "flex",
        flex_direction: "row",
        // You can read resource just like a signal. If the resource is still
        // running, it will return None
        if let Some(response) = &*dogs.read() {
            match response {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        } else {
            "Loading..."
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::UseResource {}
}
````

The `use_resource` hook might look similar to the `use_memo` hook. Unlike `use_memo`, the resource's output is not memoized with `PartialEq`. That means any components/reactive hooks that read the output will rerun if the future reruns even if the value it returns is the same:

````rs@asynchronous.rs
let mut number = use_signal(|| 0);

// Resources rerun any time their dependencies change. They will
// rerun any reactive scopes that read the resource when they finish
// even if the value hasn't changed
let halved_resource = use_resource(move || async move { number() / 2 });

log!("Component reran");

rsx! {
    button {
        onclick: move |_| number += 1,
        "Increment"
    }
    p {
        if let Some(halved) = halved_resource() {
            "Halved: {halved}"
        } else {
            "Loading..."
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::UseResourceDemo {}
}
````

 > 
 > Note: The future you pass to `use_resource` must be cancel safe. Cancel safe futures are futures that can be stopped at any await point without causing causing issues. For example, this task is not cancel safe:
 > 
 > ````rs@asynchronous.rs
 > static RESOURCES_RUNNING: GlobalSignal<HashSet<String>> = Signal::global(|| HashSet::new());
 > let mut breed = use_signal(|| "hound".to_string());
 > let dogs = use_resource(move || async move {
 >     // Modify some global state
 >     RESOURCES_RUNNING.write().insert(breed());
 > 
 >     // Wait for a future to finish. The resource may cancel
 >     // without warning if breed is changed while the future is running. If
 >     // it does, then the breed pushed to RESOURCES_RUNNING will never be popped
 >     let response = reqwest::Client::new()
 >         .get(format!("https://dog.ceo/api/breed/{breed}/images"))
 >         .send()
 >         .await?
 >         .json::<BreedResponse>()
 >         .await;
 > 
 >     // Restore some global state
 >     RESOURCES_RUNNING.write().remove(&breed());
 > 
 >     response
 > });
 > ````
 > 
 > ````inject-dioxus
 > DemoFrame {
 >     asynchronous::NotCancelSafe {}
 > }
 > ````
 > 
 > It can be fixed by making sure the global state is restored when the future is dropped:
 > 
 > ````rs@asynchronous.rs
 > static RESOURCES_RUNNING: GlobalSignal<HashSet<String>> = Signal::global(|| HashSet::new());
 > let mut breed = use_signal(|| "hound".to_string());
 > let dogs = use_resource(move || async move {
 >     // Modify some global state
 >     RESOURCES_RUNNING.write().insert(breed());
 > 
 >     // Automatically restore the global state when the future is dropped, even if
 >     // isn't finished
 >     struct DropGuard(String);
 >     impl Drop for DropGuard {
 >         fn drop(&mut self) {
 >             RESOURCES_RUNNING.write().remove(&self.0);
 >         }
 >     }
 >     let _guard = DropGuard(breed());
 > 
 >     // Wait for a future to finish. The resource may cancel
 >     // without warning if breed is changed while the future is running. If
 >     // it does, then it will be dropped and the breed will be popped
 >     reqwest::Client::new()
 >         .get(format!("https://dog.ceo/api/breed/{breed}/images"))
 >         .send()
 >         .await?
 >         .json::<BreedResponse>()
 >         .await
 > });
 > ````
 > 
 > ````inject-dioxus
 > DemoFrame {
 >     asynchronous::CancelSafe {}
 > }
 > ````
 > 
 > Async methods will often mention if they are cancel safe in their documentation.

## Asynchronous State with `use_loader`

The `use_resource` hook is great for loading arbitrary values. However, working with resources that return results can be a little cumbersome. In some cases, the `use_loader` hook is a better choice.

The `use_loader` hook is designed to work with reactive futures that return `Result<T, E>`. Instead of returning a `Resouce<T>`, like `use_resource`, the `use_loader` hook *actually* returns a `Result<Loader<T>, Loading>`. The `Loading` return type tightly integrates with Error Boundaries and Suspense - both of which are very useful in server-side-rendering (SSR).

Because `use_loader` returns a Result, you can use the `?` syntax to early return if the resource is pending or errored:

````rust
// Fetch the list of breeds from the Dog API, using the `?` syntax to suspend or throw errors
let breed_list = use_loader(move || async move {
    reqwest::get("https://dog.ceo/api/breeds/list/all")
        .await?
        .json::<ListBreeds>()
        .await
})?;
````

Generally, we recommend using `use_resource` when doing client-side fetching and `use_loader` when doing hybrid client/server fetching.

## Avoiding Waterfalls

One common issue when fetching data is the "waterfall" effect, where requests run sequentially. This can lead to slow loading times and a poor user experience. To avoid waterfalls, you can hoist your data loading logic to a higher level in your component tree and avoid returning early before unrelated requests.

Lets look at at an app that causes a waterfall effect:

````rs@data_fetching.rs
fn fetch_dog_image(
    breed: impl Display,
) -> impl Future<Output = dioxus::Result<String, CapturedError>> {
    async move {
        let response = reqwest::get(format!("https://dog.ceo/api/breed/{breed}/images/random"))
            .await?
            .json::<DogApi>()
            .await?;
        Ok(response.message)
    }
}

#[component]
fn DogView() -> Element {
    let poodle_img = use_resource(|| fetch_dog_image("poodle"));

    let poodle_img = match poodle_img() {
        Some(Ok(src)) => src,
        _ => {
            return rsx! {
                p { "Loading or error..." }
            };
        }
    };

    let golden_retriever_img = use_resource(|| fetch_dog_image("golden retriever"));

    let golden_retriever_img = match golden_retriever_img() {
        Some(Ok(src)) => src,
        _ => {
            return rsx! {
                p { "Loading or error..." }
            };
        }
    };

    let pug_img = use_resource(|| fetch_dog_image("pug"));

    let pug_img = match pug_img() {
        Some(Ok(src)) => src,
        _ => {
            return rsx! {
                p { "Loading or error..." }
            };
        }
    };

    rsx! {
        div {
            h1 { "Dog Images" }
            img { src: "{poodle_img}" }
            img { src: "{golden_retriever_img}" }
            img { src: "{pug_img}" }
        }
    }
}
````

In this example, we return early from the component when any of the requests are still loading. The request for the golden retriever and pug images will not start until the poodle image is loaded, causing a waterfall effect.

![waterfall effect](/assets/07/waterfall_effect.png)

We can avoid this issue by moving all of the early returns after the data fetching for all three images has started. This way, all requests will start at the same time which means they can execute in parallel:

````rs@data_fetching.rs
let poodle_img = use_resource(|| fetch_dog_image("poodle"));
let golden_retriever_img = use_resource(|| fetch_dog_image("golden retriever"));
let pug_img = use_resource(|| fetch_dog_image("pug"));

let poodle_img = match poodle_img() {
    Some(Ok(src)) => src,
    _ => {
        return rsx! {
            p { "Loading or error..." }
        };
    }
};
let golden_retriever_img = match golden_retriever_img() {
    Some(Ok(src)) => src,
    _ => {
        return rsx! {
            p { "Loading or error..." }
        };
    }
};
let pug_img = match pug_img() {
    Some(Ok(src)) => src,
    _ => {
        return rsx! {
            p { "Loading or error..." }
        };
    }
};

rsx! {
    div {
        h1 { "Dog Images" }
        img { src: "{poodle_img}" }
        img { src: "{golden_retriever_img}" }
        img { src: "{pug_img}" }
    }
}
````

![no waterfall effect](/assets/07/no_waterfall_effect.png)

## Organizing Data Fetching

While it might be tempting to place `use_resource` calls *everywhere* in your app, we strongly recommend limiting yourself to just a few sources of data fetching. It is generally easier to reason about centralized loading states rather than many fragmented sources.

As we add more sources of data fetching, we also add a larger combination of loading states. If possible, it's better to load a users's "name" and "id" in *one* request, rather than two.

## Libraries for Data Fetching

`use_resource` is a great way to fetch data in dioxus, but it can be cumbersome to manage complex data fetching scenarios. Libraries like [Dioxus query](https://docs.rs/dioxus-query/latest/dioxus_query/) provide more advanced features for data fetching, such as caching, invalidation, and polling. We won't cover the api of these libraries in detail here, but you can check out the [dioxus awesome](https://dioxuslabs.com/awesome/) list for more libraries that can help you with data fetching.
# Effects and Memos

Signals provide a foundation for mutable state in Dioxus apps. Calls to `.read()` subscribe reactive scopes and calls to `.write()` queue side-effects.

However, sometimes we want to run *our own* side-effects when a Signal's value changes. Other times, we want to isolate reactive scopes such that changes to a signal do not automatically queue a component to be re-rendered. In these cases, we reach for Memos with `use_memo` and Effects with `use_effect`.

## Multiple Reactive Scopes

To understand Effects and Memos, we need to first understand that a single Signal (or other reactive value) can be read in multiple reactive scopes simultaneously. For instance, a signal may be shared among several components via props. Each component that calls `.read()` on the signal value is automatically subscribed to any changes of the signal's value. When the signal value changes, it runs the re-render side-effect.

Effects and Memos allow us to observe changes in reactive values without re-rendering components. We can isolate smaller units of reactivity with memos and then queue our own side-effects with effects.

![Multiple Readers](/assets/07/multiple-scopes.png)

Memos implement the `Readable` trait (but not the Writable trait!) and thus implement the same ergonomic extensions as signals. Both Memos and Effects are `Copy` and have the same lifecycle and Drop semantics as signals.

## Derived State with Memo

`use_memo` is a reactive primitive that lets you derive state from any tracked value. It takes a closure that computes the new state and returns a tracked value that contains the current state of the memo. When a dependency of the memo changes, the memo will rerun, and a new value will be calculated.

The value returned from the closure will only cause the memo's value to update - and thus any side-effects - when they are not equal, determined by the `PartialEq` between the old and new value.

````rs@reactivity.rs
fn Memo() -> Element {
    let mut count = use_signal(|| 0);

    // use_memo creates a tracked value that is derived from count
    // Since we read count inside the closure, it becomes a dependency of the memo
    // Whenever count changes, the memo will rerun
    let half_count = use_memo(move || count() / 2);

    use_effect(move || {
        // half_count is itself a tracked value
        // When we read half_count, it becomes a dependency of the effect
        // and the effect will rerun when half_count changes
        log!("{half_count}");
    });

    rsx! {
        button { onclick: move |_| count += 1, "Increment" }

        div { "Count is {count}" }
        div { "Half count is {half_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::MemoDemo {}
}
````

Memos can be useful to perform expensive computations outside the component's reactive scope, preventing re-renders when the inputs change. In this example, by performing our computation *inside* the memo, we prevent the component from re-rendering when either `loading` or `loading_text` changes. Instead, the component will only re-render when the computed memo value changes.

````rust
let mut loading = use_signal(|| false);
let mut loading_text = use_signal(|| "loading".to_string());

let subheading = use_memo(move || {
    if loading() && loading_text() == "loading" {
        return "The state is loading";
    }

    "The state is not loading"
});

rsx! {
    h1 { "{subheading}" }
}
````

## Derived Elements

The `use_memo` hook is particularly powerful. In addition to primitive values, it can even memoize `Element` objects! We can break up large components into a series of smaller memos for a performance boost.

In practice, you won't need to frequently use Element memoization, but it can be useful. Most commonly, we can transform the result of some expensive computation directly into an Element without needing to store the intermediate value:

````rust
let mut loading_text = use_signal(|| "loading".to_string());

let loading_ui = use_memo(move || {
    let num_chars = loading_text.read().chars().count();
    rsx! { "there are {num_chars} characters!" }
});

rsx! {
    h1 { "Demo" }
    {loading_ui}
}
````

Astute readers will recognize that memoized UI and components are essentially the same concept - components are simply functions of memoized state that return an Element.

## Running Side-Effects

By default, whenever a Tracked value changes, any reactive scopes observing the value with `.read()` will run side-effects. The classic example is a component: when a signal value changes, the component queues a side-effect that re-renders the component.

![Component renders are effects](/assets/07/component-effect.png)

We can attach our own side-effects to Signals and Memos using the `use_effect` hook. It creates a closure that is run any time a tracked value that is run inside the closure changes.

Any value you read inside the closure will become a dependency of the effect. If the value changes, the effect will rerun.

````rs@reactivity.rs
fn Effect() -> Element {
    // use_signal creates a tracked value called count
    let mut count = use_signal(|| 0);

    use_effect(move || {
        // When we read count, it becomes a dependency of the effect
        let current_count = count();
        // Whenever count changes, the effect will rerun
        log!("{current_count}");
    });

    rsx! {
        button { onclick: move |_| count += 1, "Increment" }

        div { "Count is {count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::EffectDemo {}
}
````

## Prefer Actions over Side-Effects

You might be wondering: "why should I ever run side-effects?" And, indeed, they should not be a frequently used tool in your toolbox. Side-effects can be difficult to reason about and are frequently misused when an action should be preferred.

The classic example of a side-effect is to synchronize UI state with some external state. For example, we might have a `Title {}` component that sets the window's title whenever the title changes:

````rust
fn Title() -> Element {
    let mut text = use_signal(|| "");

    // attach an effect to modify the document title whenever title changes
    use_effect(move || {
        window().document().set_title(text());
    });

    rsx! {
        input {
            oninput: move |e| text.set(e.value()),
            placeholder: "Set the document title"
        }
    }
}
````

This is a valid use case for side-effects. Dioxus guarantees side-effects will be run *after* the UI has been painted to the screen. If we instead set the document title from the oninput handler, another change in state during the same step might cause the `Title {}` component to be unmounted. In this case, the document title will have been set even though the `Title {}` component is no longer present.

However, some actions should *not* be effects. Effects are widely over-used in React and the source of many state headaches. If you can be reasonably sure that the `Title {}` component won't be unmounted, then it is better to set the document title directly in the handler:

````rust
fn Title() -> Element {
    rsx! {
        input {
            oninput: move |e| {
                window().document().set_title(e.value())
            },
            placeholder: "Set the document title"
        }
    }
}
````

## Opting Out of Subscriptions

In some situations, you may need to read a reactive value without subscribing to it. You can use the `peek` method to get a reference to the inner value without registering the value as a dependency of the current reactive context:

````rs@reactivity.rs
fn Peek() -> Element {
    let mut count = use_signal(|| 0);

    // The toggle signal is a tracked value
    let mut toggle = use_signal(|| false);

    use_effect(move || {
        // When we read count, it becomes a dependency of the effect
        let current_count = count();
        log!("current_count is {current_count}");

        if current_count % 4 == 0 {
            // We peek at the value of toggle instead of reading it,
            // so it does not become a dependency
            let current_toggle = *toggle.peek();
            // We didn't subscribe to toggle, so this will not cause
            // the effect to rerun forever
            toggle.set(!current_toggle);
            log!("flipped toggle to {toggle}");
        }
    });

    rsx! {
        button { onclick: move |_| count += 1, "Change Signal" }

        div { "Count is {count}" }
        div { "Toggle is {toggle}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::PeekDemo {}
}
````

## Working with Untracked State

Most of the state in your app will be tracked values. All built in hooks return tracked values, and we encourage custom hooks to do the same. However, there are times when you need to work with untracked state. For example, you may receive a raw untracked value in props. When you read an untracked value inside a reactive context, it will not subscribe to the value:

````rs@reactivity.rs
fn Component() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        button { onclick: move |_| count += 1, "Change Signal" }

        Count { count: count() }
    }
}

// The count reruns the component when it changes, but it is not a tracked value
#[component]
fn Count(count: i32) -> Element {
    // When you read count inside the memo, it does not subscribe to the count signal
    // because the value is not reactive
    let double_count = use_memo(move || count * 2);

    rsx! {
        div { "Double count: {double_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::NonReactiveDemo {}
}
````

You can start tracking raw state with the `use_reactive` hook. This hook takes a tuple of dependencies and returns a reactive closure. When the closure is called in a reactive context, it will track subscribe to the dependencies and rerun the closure when the dependencies change.

````rs@reactivity.rs
#[component]
fn Count(count: i32) -> Element {
    // You can manually track a non-reactive value with the use_reactive hook
    let double_count = use_memo(
        // Use reactive takes a tuple of dependencies and returns a reactive closure
        use_reactive!(|(count,)| count * 2),
    );

    rsx! {
        div { "Double count: {double_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::UseReactiveDemo {}
}
````

## Making Props Reactive

To avoid losing reactivity with props, we recommend you wrap any props you want to track in a `ReadSignal`. Dioxus will automatically convert `T` into `ReadSignal<T>` when you pass props to the component. This will ensure your props are tracked and rerun any state you derive in the component:

````rs@reactivity.rs
// You can track props by wrapping the type in a ReadOnlySignal
// Dioxus will automatically convert T into ReadOnlySignal<T> when you pass
// props to the component
#[component]
fn Count(count: ReadOnlySignal<i32>) -> Element {
    // Then when you read count inside the memo, it subscribes to the count signal
    let double_count = use_memo(move || count() * 2);

    rsx! {
        div { "Double count: {double_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    reactivity::MakingPropsReactiveDemo {}
}
````
# Hoisting State

You now have enough Dioxus knowledge to build large and complex apps! As your apps scale in size, you might want to refactor large components into a collection of smaller components. Alternatively, you might add a new component that needs to access state from a sibling component.

In these cases, we need to "lift" up shared state to the nearest common ancestor. This technique of lifting common state up the tree is called *hoisting*.

![Hoisting State](/assets/07/hoisting-state.png)

## Hoisting Signals

The most common items to hoist are signals and local state. As your apps grow in size, we split larger components into smaller components. However, your smaller child components still need to access the same state. In these cases, we pass state down the tree.

We might start with a larger component that combines multiple sources of state - in this case, a user's name, email, and some validation in a Memo:

````rust
#[component]
fn EmailAndName() -> Element {
    let mut name = use_signal(|| "name".to_string());
    let mut email = use_signal(|| "email".to_string());
    let is_valid = use_memo(move || validate_name_and_email(name, email))
    rsx! {
        if !is_valid() { "Invalid name or email" }
        input { oninput: move |e| name.set(e.value()) }
        input { oninput: move |e| email.set(e.value()) }
    }
}
````

We might want to split out the validation UI into its own component. In this case, we can move the `Validator` markup into its own child component:

````rust
#[component]
fn EmailAndName() -> Element {
    let mut name = use_signal(|| "name".to_string());
    let mut email = use_signal(|| "email".to_string());
    rsx! {
        Validator { name, email }
        input { oninput: move |e| name.set(e.value()) }
        input { oninput: move |e| email.set(e.value()) }
    }
}

#[component]
fn Validator(name: Signal<String>, email: Signal<String>) -> Element {
    let is_valid = use_memo(move || validate_name_and_email(name, email));

    rsx! {
        if !is_valid() { "Invalid name or email" }
    }
}
````

As our app continues to grow in complexity, we might want to use the `is_valid` memo in other components. For example, we might want to style the input box differently if the input is invalid. In this case, need to *hoist* the `is_valid` memo out of the `Validator` component back into the `EmailAndName` component:

````rust
#[component]
fn EmailAndName() -> Element {
    let mut name = use_signal(|| "name".to_string());
    let mut email = use_signal(|| "email".to_string());
    let is_valid = use_memo(move || validate_name_and_email(name, email));

    rsx! {
        Validator { is_valid }
        div { class: if !is_valid() { "border-red" },
            input { oninput: move |e| name.set(e.value()) }
            input { oninput: move |e| email.set(e.value()) }
        }
    }
}

#[component]
fn Validator(is_valid: Memo<bool>) -> Element {
    rsx! {
        if !is_valid() { "Invalid name or email" }
    }
}
````

Now, our Validator component only depends on the memo of `name` and `email`, and not their contents. Notice how we started by splitting our UI *first* and *then* state. It's generally better to centralize our state primitives and pass down derived values where possible.

## Decaying Readable Types to ReadSignal

If you look closely at the `Validator` component, you might notice it currently takes a `Memo` type for an argument. Of course, that's the type `use_memo` returns! However, requiring the `Memo` type limits how we can use this component. Practically speaking, we don't *need* a Memo. Our `Validator` just wants a `bool`. And indeed, we can simply accept a bool:

````rust
#[component]
fn Validator(is_valid: bool) -> Element {
    rsx! {
        if !is_valid { "Invalid name or email" }
    }
}
````

Unfortunately, Rust primitives are *not* reactive types. When you read or write to a primitive - or any other types that aren't reactive - reactive contexts can't subscribe to their changes. Only reactive types like Signal, Memo, Resource, and ReadSignal will participate in the Dioxus reactivity system.

For example, an effect that logs whenever the validation state changes *won't fire* with the plain `is_valid` boolean as an argument.

````rust
// ❌ is_valid is untracked, and our effect won't work properly
#[component]
fn Validator(is_valid: bool) -> Element {
    use_effect(move || log!("validity change: {is_valid}"));
    rsx! {
        if !is_valid { "Invalid name or email" }
    }
}
````

How should you define your component's props such that it accepts *any* reactive value?

To solve this, Dioxus implements `Into<ReadSignal>` for all Readable reactive types. If a type allows you to `.read()` it, it will also automatically convert to a read-only handle of the inner value.

To fix our `Validator` component, we simply wrap `is_valid` in a `ReadSignal`:

````rust
// ✅ is_valid is reactive!
#[component]
fn Validator(is_valid: ReadSignal<bool>) -> Element {
    use_effect(move || log!("validity change: {is_valid}"));
    rsx! {
        if !is_valid { "Invalid name or email" }
    }
}
````

Now, parent components that use this child component can use any Readable reactive primitive as the value, allowing our original example to work properly.

````rust
// ✅ is_valid can be passed from a memo or a signal
#[component]
fn EmailAndName() -> Element {
    let mut name = use_signal(|| "name".to_string());
    let mut email = use_signal(|| "email".to_string());
    let is_valid = use_memo(move || validate_name_and_email(name, email));

    rsx! {
        Validator { is_valid }
        div { class: if !is_valid() { "border-red" },
            input { oninput: move |e| name.set(e.value()) }
            input { oninput: move |e| email.set(e.value()) }
        }
    }
}
````

We call this process of converting a read-write type into a read-only type "decaying". The read-only handle is arguably less useful than a full read-write handle, but has wider compatibility and is easier to reason about.

## Automatic Conversion to ReadSignal

For our `Validator` component above, we showed how any Readable reactive type like `Signal` and `Memo` automatically "decay" into `ReadSignal`. However, what if we wanted to pass just a plain boolean value?

````rust
#[component]
fn EmailAndName() -> Element {
    rsx! {
        Validator { is_valid: true }
    }
}
````

Again, `ReadSignal` saves the day! When using components, any untracked values passed as properties automatically implement `Into<ReadSignal>`. This is extremely powerful. We can upgrade plain primitive values into reactive values without boilerplate.

````rust
// ✅ this component accepts memos, signals, and even primitive values!
#[component]
fn Validator(is_valid: ReadSignal<bool>) -> Element {
    rsx! {
        if !is_valid { "Invalid name or email" }
    }
}
````

This super-power comes in most useful when doing computations in expressions at the callsite. For example, we might choose not to memoize the validator logic, and instead simply run it inline:

````rust
#[component]
fn EmailAndName() -> Element {
    let mut name = use_signal(|| "name".to_string());
    let mut email = use_signal(|| "email".to_string());

    rsx! {
        Validator { is_valid: validate_name_and_email(name, email) }
        input { oninput: move |e| name.set(e.value()) }
        input { oninput: move |e| email.set(e.value()) }
    }
}
````

As a general rule, it's best to wrap every readable component property in a `ReadSignal`. This ensures every prop is automatically reactive and is maximally compatible with the rest of the Dioxus ecosystem.

## Hoisting Callbacks

In Dioxus, the `Signal` object is both a reader *and* a writer. We designed signals to be ergonomic and conceptually straightforward: to read the value, you use `.read()`, and to write the value, you use `.write()`. This makes the basic `Signal` type extremely powerful.

If you're not careful with hoisting state, you might eventually try to build a component that takes a mutable signal as an argument:

````rust
// ❌ Mutable props are bad!
#[component]
fn Incrementer(mut sig: Signal<i32>) -> Element {
    rsx! {
        button {
            onclick: move |_| sig += 1,
            "Increment"
        }
    }
}
````

While this may compile (with warnings!), we actively discourage the usage of mutable data in component props since it breaks the foundation of one-way data-flow.

Instead, Dioxus gives you the ability to use callbacks instead, allowing the *caller* to handle updates to state, not the *callee*. Instead of mutating the count in the `Incrementer` component, you should expose an `onclick` callback and let the parent component handle updating state.

````rust
// ✅ Use callbacks instead!
#[component]
fn Parent() -> Element {
    let mut count = use_signal(|| 0);
    rsx! {
        Incrementer {
            onclick: move |_| count += 1,
        }
    }
}

#[component]
fn Incrementer(onclick: EventHandler<MouseEvent>) -> Element {
    rsx! {
        button {
            onclick: move |e| onclick.call(e),
            "Increment!"
        }
    }
}
````

To make hoisting callbacks even more ergonomic, Dioxus allows shorthand property declaration of element attributes and event listeners:

````rust
#[component]
fn Incrementer(onclick: EventHandler<MouseEvent>) -> Element {
    rsx! {
        button { onclick, "Increment!" }
    }
}
````

In the case where your hoisted callback needs to return a value, you can use the `Callback` type directly which accepts both arguments and return value as generics:

````rust
#[component]
fn CallbackChild(onclick: Callback<MouseEvent, String>) -> Element {
    let mut current = use_signal(|| "".to_string());
    rsx! {
        // onclick.call() accepts a MouseEvent and returns a String
        button {
            onclick: move |e| current.set(onclick.call(e)),
            "Set Value"
        }
    }
}
````

By hoisting mutation as callbacks, our child components are naturally more modular and simple to reason about.
# Global Context

By now, you have the requisite knowledge to build large Dioxus apps! When your component tree grows to several layers deep, passing state through component props can be become tedious and repetitive.

````rust
fn app() -> Element {
    let name = use_signal(|| "bob".to_string());
    rsx! { Container { name } }
}

#[name]
fn Container(name: Signal<String>) -> Element {
    rsx! { Content { name } }
}

#[name]
fn Content(name: Signal<String>) -> Element {
    rsx! { Title { name } }
}

#[name]
fn Title(name: Signal<String>) -> Element {
    rsx! { h1 { "{name}" } }
}
````

Passing state through several layers of component properties is called "prop drilling." Wouldn't it be great if we could pass the `name` signal from the app root *directly* to the Title component?

This is where *global context* becomes useful. Components can insert values into the global context, allowing and any child components to "reach up" and read those values.

![Context Tree](/assets/07/context-tree.png)

Note that context is only available by "reaching up" the tree. Recall a fundamental pillar of reactivity: data flows down. In the one-way data-flow model, child components can freely read the state of their parent components. You can think of context as an invisible extra argument passed through the properties of each component from the root to every child.

````rust
fn Child(context: Context, ..props) -> Element { /* */ }
````

Context is roughly defined as a recursive definition of itself:

````rust
struct Context {
    contexts: Vec<Rc<dyn Any>>
    parent: Option<Context>,
}
````

When we "reach up" through the tree, we first walk the current component's context list, and then check each parent recursively until the target context is found.

## Providing and Consuming Context

Before we can start reaching up the component tree, we first need to *provide* context to child components. Dioxus exposes the `provide_context` and `use_context_provider` functions. You typically place your state initializer in the `use_context_provider` hook like so:

````rust
fn app() -> Element {
    // use_context_provider takes an initializer closure
    use_context_provider(|| "Hello world!".to_string());

    rsx! { Child {} }
}
````

Now, to read the context, we pair the provider with a consumer. To do so, we call `use_context` and set the return type to be the same type as the context we provided. In the example above, we provided a `String` type object; therefore, we consume it with the `String` generic:

````rust
fn Child() -> Element {
    let title = use_context::<String>();
    rsx! { "{title}" }
}
````

The `::<String>` syntax declares the return type of this use of `use_context`. In Dioxus, context objects are indexed by their [TypeId](https://doc.rust-lang.org/std/any/struct.TypeId.html). A type's TypeId is a  compile-time hash that uniquely identifies every Rust type. No two types will share the same TypeId unless the refer to the same underlying type declaration - ie, [type aliases](https://doc.rust-lang.org/reference/items/type-aliases.html) will share the same TypeId.

When providing context objects, we should wrap the data we want to store in a custom type or [new type](https://doc.rust-lang.org/rust-by-example/generics/new_types.html). This ensures that we can store multiple `String` objects in the context tree and retrieve them by their wrapper type.

Declaring a new type requires a new struct declaration:

````rust
#[derive(Clone)]
struct Title(String);

#[derive(Clone)]
struct Subtitle(String);
````

Then, we can provide the context using our wrapper types:

````rust
use_context_provider(|| Title("Hello world!".to_string()));
use_context_provider(|| Subtitle("Hello world!".to_string()));
````

To consume the context, we pass in the appropriate struct type:

````rust
let title = use_context::<Title>();
let title = use_context::<Subtitle>();
````

In practice, you don't need to wrap *every* field of your state in a newtype, usually just one struct to encapsulate a set of data is enough.

````rust
#[derive(Clone)]
struct HeaderContext {
    title: String,
    subtitle: String
}
````

## Context Provider Components

Sometimes you don't want context to apply to *every* component in your tree - just a subset is fine. If you want to provide state to a scoped portion of the elements in your `rsx!` macro, you can create a new component that provides context to its children called a **Context Provider**.

For example, we may write a `ThemeProvider` component that wraps its children and provides context:

````rust
#[component]
fn ThemeProvider(children: Element, color: ThemeColor) -> Element {
    use_context_provider(|| ThemeState::new(color));
    children
}
````

Then, we can use the context provider in our RSX multiple times, but with different parameters:

````rust
fn app() -> Element {
    rsx! {
        ThemeProvider {
            color: ThemeColor::Red,
            h1 { "Red theme!" }
        }
        ThemeProvider {
            color: ThemeColor::Blue,
            h1 { "Blue theme!" }
        }
    }
}
````

## Dynamically Providing and Consuming Context

Dioxus provides several different functions to provide and consume context. You do not necessarily need to use the `use_context` and `use_context_provider` hooks. Instead, you can dynamically provide and consume context *at runtime* with `provide_context` and `consume_context`.

Being able to dynamically consume context is powerful. We can directly access context in event handlers and async tasks without an additional hook.

````rust
fn ToggleTheme() -> Element {
    // no hooks required!
    rsx! {
        button {
            onclick: move |_| consume_context::<ThemeProvider>().set_theme(ThemeColor::Red),
            "Make Red"
        }
        button {
            onclick: move |_| consume_context::<ThemeProvider>().set_theme(ThemeColor::Blue),
            "Make Blue"
        }
    }
}
````

Because the Dioxus runtime always sets the theme context when running handlers and polling futures, this even works in async tasks:

````rust
rsx! {
    button {
        onclick: move |_| async move {
            let color = fetch_random_color().await;
            consume_context::<ThemeProvider>().set_theme(color);
        },
        "Make Random Color"
    }
}
````

Note that we can also dynamically provide context too, though this is less useful. Whenever we dynamically provide context, the current component's context entry is replaced (if it existed).

````rust
use_context_provider(|| ThemeProvider::new());
rsx! {
    button {
        onclick: move |_| dioxus::core::provide_context(ThemeProvider::reset()),
        "Reset Theme Provider"
    }
}
````

Replacing context is *not* a reactive operation which inherently limits its usefulness.

## Providing Signals

So far, we've only demonstrated how to provide simple values like Strings. As mentioned above, dynamically replacing context is not a reactive operation, so we shouldn't use it to update state in our application.

To make our context fully reactive, we should provide signals. Typically, you'll bundle a collection of signals together into a larger state object:

````rust
#[derive(Clone, Copy)]
struct HeaderContext {
    title: Signal<String>,
    subtitle: Signal<String>
}
````

Notice how our `HeaderContext` derives both `Clone` and `Copy`. For context to be shared throughout the component tree, each context entry must implement `Clone`. Dioxus signals are extremely ergonomic because the implement `Copy` too, which makes them easier to work with in async contexts. Similarly, our custom context structs can also implement `Copy` and gain the same ergonomic benefits.

To construct our HeaderContext, we use one of two approaches. The first is to build a Provider component:

````rust
#[component]
fn HeaderProvider(children: Element) -> Element {
    // create signals with `use_signal`
    let title = use_signal(|| "Title".to_string());
    let subtitle = use_signal(|| "Subtitle".to_string());

    // And then use them to build the HeaderContext directly
    use_context_provider(|| HeaderContext { title, subtitle });

    children
}
````

The second approach is to use `Signal::new()` directly, either in a `HeaderContext::new()` method or a `use_header_provider` function. The advantage here is that users can provide `HeaderContext` without needing to wrap their RSX elements.

````rust
fn app() -> Element {
    use_context_provider(|| HeaderContext::new());

    // ...
}

impl HeaderContext {
    fn new() -> HeaderContext {
        HeaderContext {
            title: Signal::new("Title")
            subtitle: Signal::new("Subtitle")
        }
    }
}
````

Using `new` methods is idiomatic Rust and lets us customize the initial parameters used to build the context.

When we bundle signals in a struct, we can make working with state a bit easier by adding accessor and mutation methods.

````rust
impl HeaderContext {
    pub fn reset(&mut self) {
        self.title.set("".to_string());
        self.subtitle.set("".to_string());
    }

    pub async fn fetch(&mut self) {
        let data = api::fetch_header_info().await;
        self.title.set(data.title);
        self.subtitle.set(data.subtitle);
    }

    pub fn uppercase_title(&self) -> String {
        self.title.cloned().to_ascii_uppercase()
    }
}
````

Now, when we want to interact with the header context, we use its methods:

````rust
let mut header = use_context::<HeaderContext>();

rsx! {
    h1 { "{header.uppercase_title()}" }
    button { onclick: move |_| header.reset(), "Reset" }
    button { onclick: move |_| header.fetch(), "Fetch New" }
}
````

With context and signals, you should have all the tools required to architect large reactive Dioxus apps. These simple primitives compose into a complete first-party state solution. You can say goodbye to libraries like [Redux](https://redux.js.org) and [Mobx](https://mobx.js.org/README.html)!

## Global Signals

We're not done with global state *just* yet! Dioxus provides an enhancement to the "signals in context" pattern with **global signals**. Global signals are signals available to *every* component in your application. Global signals are automatically mounted to the root component of your app.

Because the `GlobalSignalProvider` is automatically mounted to your app, you don't need to call `use_context_provider`. To create a new global signal, you use the `Signal::global` initializer in a `static`.

````rs@guide_state.rs
static SONG: GlobalSignal<String> = Signal::global(|| "Drift Away".to_string());
````

And then read and write to it from anywhere:

````rs@guide_state.rs
#[component]
fn Player() -> Element {
    rsx! {
        h3 { "Now playing {SONG}" }
        button {
            onclick: move |_| *SONG.write() = "Vienna".to_string(),
            "Shuffle"
        }
    }
}
````

GlobalSignals are only global to one app - not the entire program. This means that in "multitenant" environments like server-side-rendering and multi-window desktop, every app gets its own *independent* global signal value.

````rust
// every separate instance of the app receive its own "COUNT" GlobalSignal
static COUNT: GlobalSignal<i32> = Signal::global(|| 0);

fn app() -> Element {
    rsx! {
        div { "{COUNT}" }
        button { onclick: move |_| *COUNT.write() += 1 }
    }
}
````

While it may seem like `COUNT` is synchronized across *every* running app, it actually is just local to one app at a time. Global signals are roughly implemented as a HashMap of global signal key to value where the key is a unique compile-time identifier per instance.

In addition to global signals, you can also have global memos with GlobalMemo. These are similar to regular memos, allowing you to incrementally compute new values as the inner reactive values are updated.

````rust
static COUNT: GlobalSignal<i32> = Signal::global(|| 0);
static DOUBLE_COUNT: GlobalMemo<i32> = Memo::global(|| COUNT.cloned() * 2);

fn app() -> Element {
    rsx! {
        div { "count: {COUNT}" }
        div { "double: {DOUBLE_COUNT}" }
        button { onclick: move |_| *COUNT.write() += 1 }
    }
}
````

Note that the types for GlobalSignal and GlobalMemo are actually `Global<Signal<T>>` and `Global<Memo<T>>` - if you implemented the required traits, you can make any custom reactive type globally available!
# Reactive Stores and Collections

The `Signal` object is great for making your application state reactive. So far, we've demonstrated how signals can make any type reactive simply by wrapping its initializer in a `use_signal` hook:

````rust
let mut count: Signal<i32> = use_signal(|| 0);
````

Whenever we call `.read()` or `.write()` on the signal, we can easily access and modify the underlying value and queue components to be re-rendered.

As your data structures evolve, you might run into new challenges. Some questions you might ask:

* "How do I add reactivity to types I don't own?"
* "What exactly re-renders when I modify just *one* entry in a collection?"
* "What if I can't wrap every value in my app in a signal?"

As our apps become more interesting, we're more likely to pull in third-party libraries and organize our state into collections like HashMaps, BTrees, and Vectors. In these cases, we need to interact with data structures *we don't own.*

To make working with structs and collections easier, Dioxus provides the **Store**.

## Reactive Stores

In Dioxus, reactive stores are types that isolate reactivity to just a path in a data structure. Stores allow us to "zoom in" on a smaller portion of our data, ignoring all other reads and writes.

The simplest stores are structs that derive a `Store` trait:

````rust
#[derive(Store)]
struct HeaderState {
    title: String,
    subtitle: String
}
````

To use stores as state, we use the `use_store` hook:

````rust
let header = use_store(|| HeaderState {
    title: "Hello, ".to_string(),
    subtitle: "world!".to_string(),
});
````

The `Store` drive macro generates additional methods on `Store<HeaderState>` that allow us to "zoom in" to fields of the struct. We access the fields by calling the field name like a method:

````rust
fn app() -> Element {
    let header = use_store(|| HeaderState {
        title: "Hello, ".to_string(),
        subtitle: "world!".to_string(),
    });

    // we can "zoom in" with the generated `.title()` method.
    let title = header.title();

    rsx! { "{title}" }
}
````

The `.title()` method returns an object called a "lens". Lenses are not unique to Dioxus -  they are common throughout functional programming and web development.

### The `Store<Value, Lens>` type

When we use the `.title()` method, we're creating a new `Store` object, but with an additional generic parameter that specifies how the lens "zooms in" on our state. Lenses are zero-cost, meaning that the cost of using the `.title()` method is the same as indexing the struct directly with `.title`. One side-effect is that the generic type can't be explicitly "named" or specified:

````rust
// the second generic is the unique type of the lens
let title: Store<HeaderState, _> = header.title();
````

Notice how the default `Store` we get from `use_store` has an elided default generic argument:

````rust
let title: Store<HeaderState> = use_store(|| HeaderState::new());
````

Because the lens is "unnamable", we need to accept the lens as a generic in any functions that work with stores. If we only need to read the store, we can require the lens implements the `Readable` trait. If we need to write to the store, we can require the lens implements the `Writable` trait.

````rust
// This function works with any lens that can read the header state like ReadStore<HeaderState> or Store<HeaderState, _>
fn get_title(state: Store<HeaderState, impl Readable<Target = HeaderState>>) -> String {
    state.title().cloned()
}

// This function works with any lens that can write to the header state like Store<HeaderState> or Store<HeaderState, _>
fn clear_title(state: Store<HeaderState, impl Writable<Target = HeaderState>>) {
    state.title().take();
}
````

On the component boundary, Stores are automatically boxed and converted to `ReadSignal` or `ReadStore` as needed so you don't need to worry about the lens type:

````rust
fn app() -> Element {
    let header = use_store(|| HeaderState {
        title: "Hello, ".to_string(),
        subtitle: "world!".to_string(),
    });

    rsx! {
        // the lens returned by `.title()` decays into a `ReadSignal` automatically!
        Title { title: header.title() }
        // the lens returned by `.subtitle()` decays into a `ReadStore` automatically!
        Subtitle { subtitle: header.subtitle() }
    }
}

#[component]
fn Title(title: ReadSignal<String>) -> Element {
    // ..
}

#[component]
fn Subtitle(subtitle: ReadStore<String>) -> Element {
    // ..
}
````

### Stores are Readable and Writable

The `Store` type implements the same `Readable` and `Writable` traits that signals implement, allowing us to use stores and lenses just like signals:

````rust
// we can use `.read()`
let title = header.title().read();

// we can use `.write()`
*header.title().write() = "goodbye".to_string();

// we can use `.set()`
header.title().set("goodbye!".to_string());
````

Stores and lenses also implement the same `Readable` and `Writable` extension traits, allowing us to work with them like regular Rust values:

````rust
fn app() -> Element {
    let mut header = use_store(|| HeaderState {
        title: "Hello, ".to_string(),
        subtitle: "world!".to_string(),
    });

    rsx! {
        // Stores implement display
        h3 { "{header.title()}" }

        // They are `Copy`, making them easy to share between scopes
        button { onclick: move |_| header.title().write().clear() }
    }
}
````

### Nested Stores

Stores can also be nested, allowing lenses to "see through" multiple levels of datastructures:

````rust
#[derive(Store)]
struct HeaderState {
    title: String,
    subtitle: String,
    other: OtherHeaderState,
}

#[derive(Store)]
struct OtherHeaderState {
    title2: String,
    subtitle2: String,
}

// now we can "zoom in" to nested fields:
let title2 = header.other().title2();
````

The ability for a store to "zoom in" through nested datastructures is dependent on whether or not types also implement `Store`. If, for example, or nested structs *didn't* implement the `Store` trait, then we can't lens them:

````rust
#[derive(Store)]
struct HeaderState {
    title: String,
    subtitle: String,
    other: OtherHeaderState,
}

struct OtherHeaderState {
    title2: String,
    subtitle2: String,
}

// ❌ we *can't* lens the OtherHeaderState
let title2 = header.other().title2();
````

It's important to know that stores can't lens through types that don't implement `Store`. When working with 3rd-party APIs and datastructures, foreign structs typically don't implement the `Store` trait, meaning we can't make them entirely reactive.

### Result, Option, and enumerated Lenses

Some fields of our store may be an enumerated value, like a [Result](https://doc.rust-lang.org/std/result/) or an [Option](https://doc.rust-lang.org/std/option/). Stores provide a few helpful extension methods that make working with the enum easier and make the enum itself reactive.

We can update our header example to include both `Result` and `Option` types:

````rust
#[derive(Store)]
struct HeaderState {
    title: Result<String, String>,
    subtitle: Option<String>,
}
````

Just like regular `Result` and `Option`, store lenses also implement `.unwrap()` (and a number of utility methods).

````rust
let title = header.title().unwrap();
let subtitle = header.subtitle().unwrap();
````

To properly gain access to the underyling `Option<String>` we can use one of two approaches:

* The `.transpose()` method which converts `Store<Option<String>>` to `Option<Store<String>>`
* Using `.read().as_ref()`

The `.transpose()` approach is useful since we keep the lens, allowing us to "zoom in" to nested structs and collections.

````rust
let len = match header.subtitle().transpose() {
    Some(subtitle) => subtitle.read().len(),
    None => 0,
};
````

Alternatively, we can use `.as_ref()` the lens to gain access to the underlying value, but we lose the ability to reactively "zoom in" further:

````rust
let len = match header.subtitle().as_ref() {
    Some(subtitle) => subtitle.chars().count(),
    None => 0,
};
````

You can usually choose either approach - just know that using `.as_ref()` calls `.read()` internally, and the "reactivity zoom" might not be perfectly precise.

## Reactive Collections

You might be wondering: "what's the best way to handle HashMaps and Vectors in signals?" So far, we've only showcased simple state in signals, like strings and integers. Just like strings and integers, you can place collections directly into signals:

````rust
type UserId = i32;
struct UserData {
    name: String,
    email: String,
}

let mut users = use_signal(|| HashMap::<UserId, UserData>::new());

rsx! {
    ul {
        for (id, data) in users.read().iter() {
            li { key: "{id}", "{data.name}" }
        }
    }
}
````

For small apps, this is usually fine. However, we might eventually want to move the `li {}` element into its own component. Unfortunately, we'll immediately run into lifetime issues with the `GenerationalRef` guard returned by `.iter()`:

````rust
// ❌ This won't compile!
fn app() -> Element {
    let mut users = use_signal(|| HashMap::<UserId, UserData>::new());

    rsx! {
        // the lifetime here is is not `'static` won't pass to the ListItem component
        for (id, user) in users.read().iter() {
            ListItem { key: "{id}", user }
        }
    }
}

// `UserData` cannot be borrowed here
#[component]
fn ListItem(user: ReadSignal<UserData>) -> Element {
    rsx! {
        li { "{user.read().name}" }
    }
}
````

In these scenarios, we have a few options:

* Deeply clone the `UserData` object, detaching its lifetime from the `for` loop
* Clone individual fields of the `UserData` object
* Use Stores and pass a Lens

The first two options require us to perform potentially expensive clones when rendering our component. Instead, we can use stores and lenses to find a zero-cost solution, simply by converting our `use_signal` to a `use_store` call:

````rust
fn app() -> Element {
    // switch to using `use_store`
    let mut users = use_store(|| HashMap::<UserId, UserData>::new());

    rsx! {
        for (id, user) in users.iter() {
            ListItem { key: "{id}", user }
        }
    }
}

// And now we can accept a `ReadSignal<UserData>` as a prop
#[component]
fn ListItem(user: ReadSignal<UserData>) -> Element {
    rsx! {
        li { "{user.read().name}" }
    }
}
````

The `Store<HashMap<K, V>>` type is a special type that implements reactivity on a per-entry basis. When we insert or remove values from the `users` store, only *one* re-render is queued. If we edit an individual entry in the HashMap, only a single `ListItem` will re-render.

Alternatively, we could derive `Store` on our `UserData` type, and accept `ReadStore<UserData>` allowing us to further lens into specific fields of our UserData entry:

````rust
#[derive(Store)]
struct UserData {
    name: String,
    email: String,
}

fn app() -> Element {
    let users = use_store(|| HashMap::<UserId, UserData>::new());

    rsx! {
        for (id, user) in users.iter() {
            ListItem { key: "{id}", user }
        }
    }
}

#[component]
fn ListItem(user: ReadStore<UserData>) -> Element {
    rsx! {
        li { "{user.name()}" }
    }
}
````

## Extending Stores with Methods

You can extend your store types with methods with the `#[store]` attribute macro. Methods inside the macro are converted into an extension trait that is automatically implemented for `Store<T, Lens>`. The macro will automatically add bounds to the `Lens` generic based on the self parameter of the method. If the method takes `&self`, the `Lens` will be bound by `Readable`. If the method takes `&mut self`, the `Lens` will be bound by `Writable`.

````rust
type MappedUserDataStore<Lens> = Store<String, MappedMutSignal<String, Lens, fn(&UserData) -> &String, fn(&mut UserData) -> &mut String>>;

#[store]
impl<Lens> Store<UserData, Lens> {
    // This will automatically require `Readable` on the lens since it takes `&self`
    fn user_email(&self) -> String {
        self.email().cloned()
    }

    // This will automatically require `Writable` on the lens since it takes `&mut self`
    fn clear_name(&mut self) {
        self.name().take();
    }

    // This method does not require any bounds on the lens since it takes `self`
    fn into_parts(self) -> (MappedUserDataStore<Lens>, MappedUserDataStore<Lens>) where Self: Copy {
        (self.email(), self.name())
    }
}
````

## Making the Most of Stores

Hopefully, the examples here highlight when stores might be useful in your applications. It might be tempting to use stores *everywhere*, but in many cases, signals and structs are good enough. Most apps won't run into performance issues where precise control over the reactivity of struct fields makes a huge difference.

Stores are most useful when interfacing with foreign data types and optimizing huge collections - not something you need to do every day!
# Error handling

A major selling point of using Rust for web development its renowned reliability. A common sentiment by developers deploying Rust services:

 > 
 > "We deployed our Rust service and then forgot about it because it just kept running without any issues"

Rust provides developers powerful tools to track where errors occur and easy ways to handle them. Similarly, in Dioxus, we provide additional tools like early returns, a special RenderError type, and ErrorBoundaries to help you handle errors in a declarative way.

## Returning Errors from Components

Recall that Dioxus components are functions that take props and return an `Element`. Astute observers might recognize that the `Element` type is actually a type alias for `Result<VNode, RenderError>`!

The `RenderError` type can be created from an error type that implements `Error`. You can use `?` to bubble up any errors you encounter while rendering to the nearest error boundary:

````rs@error_handling.rs
#[component]
fn ThrowsError() -> Element {
    // You can return any type that implements `Error`
    let number: i32 = use_hook(|| "1.234").parse()?;

    todo!()
}
````

The [`RenderError`](https://docs.rs/anyhow/latest/anyhow/) is special error type that is an enum of either `Error(CapturedError)` or `Suspended(SuspendedFuture)`. A `RenderError` automatically implements `From<CapturedError>` which implements `From<anyhow::Error>`.

````rust
/// An error that can occur while rendering a component
#[derive(Debug, Clone, PartialEq)]
pub enum RenderError {
    /// The render function returned early due to an error.
    ///
    /// We captured the error, wrapped it in an Arc, and stored it here. You can no longer modify the error,
    /// but you can cheaply pass it around.
    Error(CapturedError),

    /// The component was suspended
    Suspended(SuspendedFuture),
}
````

Because `RenderError` can be automatically coerced from an `anyhow::Error`, we can use anyhow's `Context` trait to bubble up any error while rendering:

````rust
fn Counter() -> Element {
    let count = "123".parse::<i32>().context("Could not parse input")?;

    // ...
}
````

## CapturedError, RenderError, and anyhow::Error

Through the entire stack, Dioxus has many different error types. The large quantity can lead to some confusion.

### anyhow::Error

Unlike many other libraries, Dioxus uses the `anyhow::Error` as its core error type. In many APIs that take user code - like callbacks, actions, and loaders - you can cleanly use anyhow's Error type:

````rust
let mut breed = use_action(move |breed| async move {
    let res = reqwest::get(format!("https://dog.ceo/api/breed/{breed}/images/random"))
        .await
        .context("Failed to fetch")?
        .json::<DogApi>()
        .await
        .context("Failed to deserialize")?;

    anyhow::Ok(res)
});
````

Many APIs also either take or return an anyhow error. You can use `anyhow::Result` as the result type for a server function:

````rust
#[get("/dogs")]
async fn get_dogs() -> anyhow::Result<i32> {
    Ok(123)
}
````

The anyhow crate provides an ergonomic, dynamic error type that can ingest any errors that implement the `std::Error` trait. We chose to use anyhow's error type since it cleanly integrates with the broader Rust ecosystem. GUI apps can encounter many different types of errors along the way, and only a few are worth handling completely with a dedicated variant.

If you need to downcast the anyhow error to a specific error type, you can use `.downcast_ref::<T>()`. Other utilities like `.context()`, `anyhow!()`, and `bail!()` work seamlessly with the rest of Dioxus

### Captured Error

A `CapturedError` is a transparent wrapper type around anyhow's Error that makes it implement the `Clone` trait. The implementation is quite simple:

````rust
#[derive(Debug, Clone)]
pub struct CapturedError(pub Arc<anyhow::Error>);
````

The `CapturedError` type is useful when you need to call `.clone()` on the error, as is required by `use_resource`. The hook `use_resource` requires that the output by `Clone` - but the default `anyhow::Error` type is *not*.

In cases where you need a concrete error type, like in loaders and actions, consider using `dioxus::Ok()` which will return a `Result<T, CapturedError>`:

````rust
let value = use_resource(|| async move {
    let res = fetch("/dogs")?;
    dioxus::Ok(res)
});
````

## Capturing errors with ErrorBoundaries

In JavaScript, you might have used `try` and `catch` to throw and catch errors in your code:

````js
try {
    // Some code that might throw an error
    let result = riskyOperation();
    console.log(result);
} catch (error) {
    // Handle the error
    console.error("Something went wrong:", error.message);
}
````

In Dioxus, you can take a similar try/catch approach within the component tree with error boundaries. Error boundaries let you catch and handle errors produced while rendering our app.

[Error Boundaries](/assets/07/error-boundaries.png)

When you return an error from a component, it gets thrown to the nearest error boundary. That error boundary can then handle the error and render a fallback UI with the handle_error closure:

````rs@error_handling.rs
#[component]
fn Parent() -> Element {
    rsx! {
        ErrorBoundary {
            // The error boundary accepts a closure that will be rendered when an error is thrown in any
            // of the children
            handle_error: |_| {
                rsx! { "Oops, we encountered an error. Please report this to the developer of this application" }
            },
            ThrowsError {}
        }
    }
}
````

## Throwing Errors from Event Handlers

In addition to components, you can throw errors from event handlers. If you throw an error from an event handler, it will bubble up to the nearest error boundary just like a component:

````rs@error_handling.rs
#[component]
fn ThrowsError() -> Element {
    rsx! {
        button {
            onclick: move |_| {
                // Event handlers can return errors just like components
                let number: i32 = "1...234".parse()?;

                tracing::info!("Parsed number: {number}");

                Ok(())
            },
            "Throw error"
        }
    }
}
````

This is useful when handling async work or work that fails frequently.

## Adding context to errors

You can add additional context to your errors with anyhow's [`Context`](https://docs.rs/anyhow/latest/anyhow/trait.Context.html) trait. Calling `context` on a `Result` will add the context to the error variant of the `Result`:

````rs@error_handling.rs
#[component]
fn ThrowsError() -> Element {
    // You can call the context method on results to add more information to the error
    let number: i32 = use_hook(|| "1.234")
        .parse()
        .context("Failed to parse name")?;

    todo!()
}
````

If you need to show some specific UI for the error, we recommend wrapping the error in a custom type and then downcasting when it's caught.

## Downcasting Specific Errors

When handling errors in Error Boundaries, you can match on specific types of errors, optionally choosing to capture the error and prevent it from bubbling.

By default, errors are caught by the nearest Error Boundary. In some scenarios, we might not want to catch a specific type of error, like a NetworkError.

In our handler code, we can use with `.error()` to get the current error and then re-throw it if necessary:

````rust
rsx! {
    ErrorBoundary {
        handle_error: |error: ErrorContext| {
            // Network errors need to be handled by a different error boundary!
            if let Some(err) = error.error() {
                return Err(e.into())
            }

            // Otherwise, handle this error here
            rsx! {
                div { "Oops, we encountered an error" }
            }
        },
        // ...
    }
}
````

## Local Error Handling

If you need more fine-grained control over error states, you can store errors in reactive hooks and use them just like any other value. For example, if you need to show a phone number validation error, you can store the error in a memo and show it below the input field if it is invalid:

````rs@error_handling.rs
#[component]
pub fn PhoneNumberValidation() -> Element {
    let mut phone_number = use_signal(|| String::new());
    let parsed_phone_number = use_memo(move || phone_number().parse::<PhoneNumber>());

    rsx! {
        input {
            class: "border border-gray-300 rounded-md p-2 mb-4",
            placeholder: "Phone number",
            value: "{phone_number}",
            oninput: move |e| {
                phone_number.set(e.value());
            },
        }

        match parsed_phone_number() {
            Ok(phone_number) => rsx! {
                div {
                    "Parsed phone number: {phone_number}"
                }
            },
            Err(error) => rsx! {
                div {
                    "Phone number is invalid: {error}"
                }
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    error_handling::PhoneNumberValidation {}
}
````
# Suspense

[Resources](../basics/resources.md) let you load data asynchronously in Dioxus, but it can be cumbersome to handle the loading state of each resource individually. Dioxus provides a `SuspenseBoundary` component to group multiple asynchronous tasks and show a loading view while any of them are suspended.

You can create a `SuspenseBoundary` with a loading closure and children. Then you can call `.suspend()?` on any resource inside the children to pause rendering of that component until the future is finished. The suspense boundary will show the loading view while any of its children are suspended. Once that suspense is resolved, it will show the children again.

We can use a suspense boundary to show a grid of different breeds of dogs without handling each loading state individually:

````rs@asynchronous.rs
fn DogGrid() -> Element {
    rsx! {
        SuspenseBoundary {
            // When any child components (like BreedGallery) are suspended, this closure will
            // be called and the loading view will be rendered instead of the children
            fallback: |_| rsx! {
                div {
                    width: "100%",
                    height: "100%",
                    display: "flex",
                    align_items: "center",
                    justify_content: "center",
                    "Loading..."
                }
            },
            div {
                display: "flex",
                flex_direction: "column",
                BreedGallery {
                    breed: "hound"
                }
                BreedGallery {
                    breed: "poodle"
                }
                BreedGallery {
                    breed: "beagle"
                }
            }
        }
    }
}

#[component]
fn BreedGallery(breed: ReadSignal<String>) -> Element {
    let response = use_resource(move || async move {
        // Artificially slow down the request to make the loading indicator easier to seer
        gloo_timers::future::TimeoutFuture::new(1000).await;
        reqwest::Client::new()
            .get(format!("https://dog.ceo/api/breed/{breed}/images"))
            .send()
            .await?
            .json::<BreedResponse>()
            .await
    })
    // Calling .suspend()? will suspend the component and return early while the future is running
    .suspend()?;

    // Then you can just handle the happy path with the resolved future
    rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            match &*response.read() {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::DogGridView {}
}
````

## Customizing the loading view from children

If you need to change the loading view while a specific task is loading, you can provide a different loading view with the `with_loading_placeholder` method. The loading placeholder you return from the method will be passed to the suspense boundary and may choose to render it instead of the default loading view:

````rs@asynchronous.rs
fn DogGrid() -> Element {
    rsx! {
        SuspenseBoundary {
            // The fallback closure accepts a SuspenseContext which contains
            // information about the suspended component
            fallback: |suspense_context: SuspenseContext| {
                rsx! {
                    div {
                        width: "100%",
                        height: "100%",
                        display: "flex",
                        align_items: "center",
                        justify_content: "center",
                        "Loading..."
                    }
                }
            },
            div {
                display: "flex",
                flex_direction: "column",
                BreedGallery {
                    breed: "hound"
                }
                BreedGallery {
                    breed: "poodle"
                }
                BreedGallery {
                    breed: "beagle"
                }
            }
        }
    }
}

#[component]
fn BreedGallery(breed: ReadSignal<String>) -> Element {
    let response = use_resource(move || async move {
        gloo_timers::future::TimeoutFuture::new(breed().len() as u32 * 100).await;
        reqwest::Client::new()
            .get(format!("https://dog.ceo/api/breed/{breed}/images"))
            .send()
            .await?
            .json::<BreedResponse>()
            .await
    })
    .suspend()?;

    // Then you can just handle the happy path with the resolved future
    rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            match &*response.read() {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::DogGridViewWithLoadingPlaceholder {}
}
````

## Suspense with Fullstack

Dioxus fullstack will wait for suspended futures during server-side rendering. This means your async data loading starts sooner and search engines can see the resolved version of your page. However, using suspense in fullstack does require some changes for hydration compatibility.

To use suspense in your fullstack application, you need to switch every suspended resource to the `use_server_future` hook. `use_server_future` handles serializing the result of the future on the server and deserializing that result on the client. It will also suspend automatically, so you don't need to call `.suspend()` on the resource.

````rs@asynchronous.rs
#[component]
fn BreedGallery(breed: ReadOnlySignal<String>) -> Element {
    // use_server_future is very similar to use_resource, but the value returned from the future
    // must implement Serialize and Deserialize and it is automatically suspended
    let response = use_server_future(move || async move {
        // The future will run on the server during SSR and then get sent to the client
        reqwest::Client::new()
            .get(format!("https://dog.ceo/api/breed/{breed}/images"))
            .send()
            .await
            // reqwest::Result does not implement Serialize, so we need to map it to a string which
            // can be serialized
            .map_err(|err| err.to_string())?
            .json::<BreedResponse>()
            .await
            .map_err(|err| err.to_string())
        // use_server_future calls `suspend` internally, so you don't need to call it manually, but you
        // do need to bubble up the suspense variant with `?`
    })?;

    // If the future was still pending, it would have returned suspended with the `?` above
    // we can unwrap the None case here to get the inner result
    let response_read = response.read();
    let response = response_read.as_ref().unwrap();

    // Then you can just handle the happy path with the resolved future
    rsx! {
        div {
            display: "flex",
            flex_direction: "row",
            match response {
                Ok(urls) => rsx! {
                    for image in urls.iter().take(3) {
                        img {
                            src: "{image}",
                            width: "100px",
                            height: "100px",
                        }
                    }
                },
                Err(err) => rsx! { "Failed to fetch response: {err}" },
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    asynchronous::DogGridFullstack {}
}
````

Unlike `use_resource`, `use_server_future` is only reactive in the closure, not the future itself. If you need to subscribe to another reactive value, you need to read it in the closure before passing it to the future:

````rs@asynchronous.rs
let id = use_signal(|| 0);
// ❌ The future inside of use_server_future is not reactive
use_server_future(move || {
    async move {
        // But the future is not reactive which means that the future will not subscribe to any reads here
        println!("{id}");
    }
});
// ✅ The closure that creates the future for use_server_future is reactive
use_server_future(move || {
    // The closure itself is reactive which means the future will subscribe to any signals you read here
    let cloned_id = id();
    async move {
        // But the future is not reactive which means that the future will not subscribe to any reads here
        println!("{cloned_id}");
    }
});
````

### Streaming Suspense

The default behavior for server side rendering is to wait for all suspended futures then send the fully resolved page. If you [enable](https://docs.rs/dioxus/0.7/dioxus/prelude/struct.ServeConfigBuilder.html#method.enable_out_of_order_streaming) out of order streaming, dioxus will send the finished HTML chunks to the client one at a time as they are resolved. This lets you show the loading views in your suspense boundaries while you are still waiting for other futures to resolve on the server:

````rs@asynchronous.rs
fn main() {
    dioxus::LaunchBuilder::new()
        .with_context(server_only! {
            // Enable out of order streaming during SSR
            dioxus::server::ServeConfig::builder().enable_out_of_order_streaming()
        })
        .launch(DogGrid);
}
````

![Out of order streaming](/assets/06_docs/streaming_dogs.mp4)

For more information on streaming, see the [streaming documentation](../../essentials/fullstack/streaming.md).
# Dioxus Fullstack

Almost all apps need a remote server to store and update user data. Dioxus provides a number of fullstack utilities for building your app's server alongisde the client. With Dioxus Fullstack, you can build *both* your app's frontend and backend entirely in Rust!

Dioxus Fullstack deeply integrates with the popular [Axum](https://docs.rs/axum/latest/axum/) framework, making it easy to quickly add complex fullstack functionality to your app, including:

* **Server-Side-Rendering**: Render HTML on the server and hydrate it on the client
* **Server Functions**: Type-safe Axum HTTP endpoints directly callable from the client
* **Hot-Reload**: Rapid Rust hot-reload during development powered by [subsecond](https://crates.io/crates/subsecond)
* **Typed Routing**: Easily extract queries and paths from the URL
* **Multi-part Forms**: Capture multipart form data from the client into typed Rust structs
* **Binary Streams**: Easily add file upload/download backend capability
* **SSE and WebSockets**: Complex, stateful datatypes for server communication
* **Asset Management**: Automatically optimizes assets for deployment to CDNs
* **WASM Support**: Deploy to WASM-based providers like Cloudflare Workers
* **Bundle Splitting**: Split apart large WASM blobs on a per-route basis
* **Static Site Generation**: Generate HTML markup perfect for blogs and static sites

Currently, Dioxus Fullstack does not provide built-in utilities for things like Databases, Caches, Sessions, and Mailers. Our current focus is to finish polishing the fullstack integration before branching out into a more "complete" fullstack solution. You'll need to pull in 3rd-party crates like `Sqlx` and `tower-sessions` to use such features. To help, we provide a [few examples in the Dioxus GitHub repo](https://github.com/DioxusLabs/dioxus/tree/main/examples/07-fullstack) to get started.

## Hot-Reload

With Dioxus, our goal is to maximize your developer productivity. Dioxus Fullstack ships with full Rust hot-reload support built-in thanks to our hot-patch engine [subsecond](https://crates.io/crates/subsecond). Subsecond uses advanced assembly and linker techniques to allow modifying Rust functions at runtime. You can add new endpoints, pages, and logic to your app without manually rebuilding.

![Dual Serve Hot-Reload](/assets/07/dual-serve-hotreload.mp4)

Subsecond currently has a few limitations. For the best experience, we recommend only modifying code in the "tip" of your app. Note that code that runs only once will not be hot-reloadable and will require a restart of the app.

## Server functions

Dioxus Fullstack provides an easy way to communicate with the server from any client. Server functions let you define a function that always runs on the server. When you call that function from the client, Dioxus will automatically serialize the arguments, send them to the server, run the function on the server, serialize the return value, and send it back to the client.

````rust
// The body of the function will always run on the server so we can do server-side operations like database queries
#[get("/api/dog/{breed}")]
async fn fetch_dog(breed: String) -> Result<String> {
    DB.execute("SELECT url FROM dogs WHERE id = ?1", &breed)
}
````

We can use the results of server functions during server-side-rendering along with hydration:

````rust
let url = use_server_future(|| fetch_dog("poodle".to_string()));

rsx! {
    img { src: "{url}", alt: "A cute dog" }
}
````

Server functions are described in more detail in the [server functions guide](./server_functions.md). In addition to this guide, you can find more examples of fullstack apps in the [examples directory](https://github.com/DioxusLabs/dioxus/tree/main/examples).

## Websockets and Streams

Dioxus Fullstack comes with full support for Axum, and with it, special client handlers for things like WebSockets and HTTP Streams. We provide a number of utilities like `use_websocket` to reactively manage these resources on the client.

![Fullstack websockets](/assets/07/fullstack-websockets.avif)

Our `Streaming<T>` wrapper allows you to easily send arbitrary bytes, text, JSON, and chunked file contents to and from the server. Easily roll your own hybrid client-server types by implementing `IntoRequest` and `FromResponse`!

## Server Side Rendering

Dioxus Fullstack allows you to render your app on the server, speeding up load times for your users and improving your site's discoverability for search engines like Google. Server-side-rendering (SSR) allows you to render

## Bundle Splitting and Lazy Loading

## Assets

Because Dioxus Fullstack integrates with our build tool DX, your fullstack apps come pre-optimized for deploying onto infrastructure like content-distribution-networks (CDNs). CDNs reduce your bandwidth usage and speed up your app's time-to-first byte for maximum performance. Assets bundled with DX are hashed, letting the server infinitely cache their contents.
# Project Setup

Fullstack Dioxus apps are structured a bit differently than client-only apps. This distinction has implications on how we organize our apps, requiring more care when adding dependencies and including code.

In this chapter, we'll explore how to use feature flags and cargo targets to structure our apps for fullstack development.

 > 
 > Dioxus provides a number of templates with `dx new` to automatically bootstrap new fullstack projects.
 > 
 > If you want to get started quickly, we suggest using one of the built-in templates and then heading on to next chapter.

## The Server/Client split

A "fullstack" application is actually composed of two distinct apps:

* The client application that runs the web, desktop, or mobile application
* The server application that renders the initial HTML and runs server functions

Because our client app and server app target different platforms, we need to include different code and different dependencies. You can conceptualize the "server" as just another platform for your app, just like you might target both iOS and Android. The server will have different dependencies than the client app, and thus you need to properly configure your app's `Cargo.toml` and build flags.

## How DX builds your app

Our build tool, DX, is capable of building both the client and server of your app simultaneously. If the `--hotpatch` flag is enabled, DX will also automatically hot-reload both the client and server code in tandem.

When developing your app, you'll generally use `dx serve`. This command accepts the usual arguments you might pass to `cargo run`:

````sh
# We can customize the build's features, profile, or release mode
dx serve --features "spicy" --release

# We can specify examples, packages, and binaries
dx serve --example dogs
````

Under the hood, DX automatically detects if the target app has a server variant by checking its `Cargo.toml` for a Cargo feature called "server". In this Cargo feature, you would enable the `server` feature on Dioxus:

````toml
[features]
server = ["dioxus/server"]
````

DX will also look for specific client features (`"web"` / `"desktop"` / `"mobile"`) and enable the relevant feature depending on the target platform. DX uses the concept of "platform" to distinguish types of builds from one another.

To set a build's platform, you can use `--platform web/desktop/ios/android` or the shorthands like `--web`, `--desktop`, `--ios`, etc. When you specify a platform, DX also enables a corresponding feature in your Cargo.toml:

````toml
# enabled with `--web`
web = ["dioxus/web"]

# enabled with `--desktop`
desktop = ["dioxus/desktop"]

# enabled with `--mobile`
mobile = ["dioxus/mobile"]
````

Running the command might look like:

````sh
# sets target=wasm32-unknown-unknown, features="web", profile="wasm-dev"
dx serve --web

# sets target=host, features="desktop", profile="desktop-dev"
dx serve --desktop

# sets target=aarch64-apple-ios-sim, features="mobile", profile="ios-dev"
dx serve --ios
````

If your `dioxus` dependency enables the `fullstack` feature, DX recgonizes this app is a fullstack app and then creates two builds, each with a separate platform:

````toml
[dependencies]
dioxus = { version = "0.7", features = ["fullstack"] }

[features]
web = ["dioxus/web"]
server = ["dioxus/server"]
````

Internally, DX splits your input command into two separate `cargo build` commands, each with a different platform.

![Server Client Split](/assets/06_docs/server_split.png)

Feature flags like these for the client and server are automatically generated by the CLI when you run `dx new` with fullstack enabled. If you are creating a project from scratch, you will need to add the feature flags manually.

 > 
 > If you are not familiar with features in rust, you can read more about feature flags in the [cargo reference](https://doc.rust-lang.org/cargo/reference/features.html).

## Customizing the Builds

A fullstack app is comprised of two separate binaries, so DX provides a way to customize each. Usually, the default `dx serve` command is sufficient, but for complex app setups that need per-target customization, you can use the `@client` and `@server` modifiers to pass target-specific cargo args to each:

````sh
dx serve \
  @client --ios --features "optimizations" \
  @server --bin server
````

This syntax makes it possible to have two separate entrypoints for our app. This can be extremely useful if you have an existing backend and would like to launch that alongside your Dioxus frontend.

By default, DX isolates your server and client builds by levaraging Cargo Profiles. Cargo profiles let us specify certain build modifiers like opt-level, debug symbols, LTO, and other optimizations.

DX will use these profiles

* `web-dev` / `web-release`: targetting the web with `--web`
* `server-dev` / `server-release`: targetting the server (implicitly, or with `--server`)
* `desktop-dev` / `desktop-release`: targetting iOS apps with `--ios`
* `ios-dev` / `ios-release`: targetting iOS apps with `--ios`
* `android-dev` / `android-release`: targetting iOS apps with `--ios`

These profiles correspond 1:1 with the "platforms" DX supports. Note that a `platform` is just a way of DX to isolate two builds from each other. You can completely customize the build, including:

* `--renderer`: swap between the various 1st-party renderers (ie `--renderer native`)
* `--bundle`: the bundle format of the build (`.app`, `.apk`, `.ipa`, etc.)
* all cargo options (`--features`, `--target`, `--profile`, `--bin`, etc.)

## Adding Server Only Dependencies

Many dependencies like [`tokio`](https://docs.rs/tokio/latest/tokio/index.html) cannot be compiled to WebAssembly, and thus should only be built for the server. If these dependencies are enabled when building a WASM bundle, you will receive cryptic compilation errors. As such, we need to take care not to accidentally add server-only dependencies to our client app.

For example, if we want to interact with the filesystem in a server function, we might want to add `tokio`. The `tokio` crate provides utilities for working with async IO with abstractions like [`tokio::fs::File`](https://docs.rs/tokio/latest/tokio/fs/struct.File.html). Unfortunately, if try to add `tokio` with its `full` feature set, we will receive a compilation error:

````toml
[dependencies]
# ...
# ❌ If tokio is added as a required dependency, it will be included in both the server
# and the web bundle. The web bundle will fail to build because tokio is not
# compatible with wasm
tokio = { version = "1", features = ["full"] }
````

If we try to compile with tokio as a required dependency, we will get a compilation error like this:

````sh
error[E0432]: unresolved import `crate::sys::IoSourceState`
  --> /Users/user/.cargo/registry/src/index.crates.io-6f17d22bba15001f/mio-1.0.2/src   |source.rs:14:5
14 | use crate::sys::IoSourceState;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ no `IoSourceState` in `sys`
...
````

Since we added `tokio` as a dependency for all three binaries, cargo tries to compile it for each target. This fails because `tokio` is not compatible with the `wasm32-unknown-unknown` target.

To fix the issue, we can **make the dependency optional and only enable it in the server feature**:

````toml
[dependencies]
# ...
# ✅ Since the tokio dependency is optional, it is not included in the web and desktop
# bundles.
tokio = { version = "1", features = ["full"], optional = true }

[features]
# ...
# ✅ Since the tokio dependency is enabled in the server feature, it is included in
# the server binary.
server = ["dioxus/server", "dep:tokio"]
````

Now when we build with `dx serve`, the project compiles successfully!

## Adding Client Only Dependencies

Many dependencies like [`wasm-bindgen`](https://docs.rs/wasm-bindgen/latest/wasm_bindgen/index.html) and [`web-sys`](https://docs.rs/web-sys/latest/web_sys/index.html) are only compatible with the client. Unlike server-only dependencies, these dependencies can compile on native targets, but they will panic when used outside of the browser.

You can reduce build times for your server and native binaries by including web dependencies only in the browser client binary.

Instead of adding web only dependencies to every binary in your project like this:

````toml
[dependencies]
# ...
# ❌ If web-sys is added as a required dependency, it will be included in the server,
# native, and the web bundle which makes build times longer.
web-sys = { version = "0.3.60", features = ["console"] }
````

You can make the dependency optional and only enable it in the `web` feature in your `Cargo.toml`:

````toml
[dependencies]
# ...
# ✅ Since the web-sys dependency is optional, it is not included in the server and
# native bundles.
web-sys = { version = "0.3.60", features = ["console"], optional = true }

[features]
# ...
# ✅ Since the web-sys dependency is enabled in the web feature, it is included in
# the web bundle.
web = ["dioxus/web", "dep:web-sys"]
````

## Managing Binary Specific Imports

Once you have set up binary specific dependencies, you need to adjust any of your imports to only import the dependencies when building for the binary that includes those dependencies.

For example, if `tokio` is only enabled in the server feature, you will need to import it like this:

````rs@server_tokio_import.rs
// Since the tokio dependency is only enabled in the server feature,
// we need to only import it when the server feature is enabled.
#[cfg(feature = "server")]
use {tokio::fs::File, tokio::io::AsyncReadExt};
````

You also need to only compile any usage of the dependency when the feature is enabled:

````rs@server_tokio_import.rs
// Since the tokio dependency is only enabled in the server feature,
// we need to only compile any usage of the dependency when the server feature is enabled.
#[cfg(feature = "server")]
async fn read_file() -> Result<String, std::io::Error> {
    let mut file = File::open("path/to/file").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}

// The bodies of server functions automatically only compile when the server feature is enabled.
#[server]
async fn get_file_contents() -> Result<String> {
    let mut file = File::open("path/to/file").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}
````

It may be more convenient to group server or client specific code into a module that is only compiled when the feature is enabled:

````rs@server_tokio_import.rs
// Instead of configuring each item that is only used in the server, you can group
// them into a module that is only compiled when the server feature is enabled.
#[cfg(feature = "server")]
mod tokio_utilities {
    use std::path::PathBuf;
    use tokio::fs::File;
    use tokio::io::AsyncReadExt;

    pub async fn read_file(path: PathBuf) -> Result<String, std::io::Error> {
        let mut file = File::open(path).await?;
        let mut contents = String::new();
        file.read_to_string(&mut contents).await?;
        Ok(contents)
    }
}

// Then you can define your server functions using shared utilities you defined for
// server only code.
#[server]
async fn get_file_contents() -> Result<String> {
    let file = tokio_utilities::read_file(PathBuf::from("path/to/file")).await?;
    Ok(file)
}

#[server]
async fn get_other_file_contents() -> Result<String> {
    let file = tokio_utilities::read_file(PathBuf::from("path/to/other/file")).await?;
    Ok(file)
}
````

 > 
 > The [rust reference](https://doc.rust-lang.org/reference/conditional-compilation.html) has more information about conditional compilation in rust.

## Separate Frontend and Backend Crates

If you so choose, you can split your frontend and backend into separate crates. This can be useful for larger projects where you have separate complex entrypoints for web, desktop, and mobile.

Workspace setups bring extra complexity, but they can make it much easier to share data types and functions across several different projects. For instance, you might have a single API crate used by several different apps.

In these cases, we might organize our workspace like so:

````
├── Cargo.toml
└── packages/
    ├── cat-app/
    │     ...
    ├── dog-app/
    │     ...
    └── pet-api/
          ...
````

If you're using Dioxus Fullstack, you can import your `pet-api`'s server functions to call from your UI. In the client app, you can then import the `pet-api` crate:

````toml
[dependencies]
pet-api = { workspace = true }
````

To launch the server, you can choose one of two options:

1. Start the pet-api server from the client project
1. Launch the pet-api crate's main binary

If your server is simple enough, then option 1 can be a decent option since it automatically integrates with `dx serve`.

However, if you choose to have a dedicated server binary, then you'll need to use the `@client` and `@server` modifiers to use a diffeent binary:

````sh
dx serve @client --bin dog-app @serer --bin pet-api
````

The built-in "Workspace" Dioxus Template can serve as a good starting point for workspace setups.
# Server Side Rendering

Dioxus Fullstack supports a powerful feature called "server side rendering" (SSR). SSR enables your apps to load data on the server *before* sending HTML to the client.

Server-side-rendering improve's your site's page load times and makes it easier for web crawlers like Google to index. Sites that are easier to index rank higher in web searches, improving your conversion rate and ultimately, your bottom line.

## SSR vs CSR

You might be intimated by the various terms, tradeoffs, and details. Don't worry - these additional concepts are simply optimizations to make your site perform better in various ways. You can still build a beautiful, useful, accessible site without enhancements like server-side-rendering.

The terms SSR and CSR refer to two different approaches to rendering pages:

* **CSR**: *Client-side-rendering*, data is loaded by a "skeleton" page with `fetch()`
* **SSR**: *Server-side-rendering*, data is loaded on the server and serialized into HTML

SSR gives us the ability to send a more "complete" HTML document to the user when the visit the site, making the site immediately usable and improving its ranking in search results.

### CSR: The "App" Architecture

The architecture of web applications have shifted substantially over the years. Client-side-rendering is a somewhat "modern" architecture where the server responds to user requests with a "skeleton" HTML.

The skeleton HTML might be barebones - something like:

````html

<html>
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
        <script src="/index.js"> </script>
    </head>
    <body>
        <div id="main"></div>
    </body>
</html>
````

Note how there's no content *in the HTML document* when it loads. Once this barebones page is loaded by the browser, the `index.js` script executes, calling your app's `main` function. Data fetching is usually done as an *effect* after the initial `main` executes.

When using the CSR approach, there are *many* HTTP requests required to load the page:

* The initial GET to `index.html`
* The GET to `index.js`
* Multiple `GET` calls to backend endpoints to load data

Also note the numerous phases where the app *appears* to be in a loading state:

* The initial HTML is blank
* Once `main` executes, the page is blank, waiting for data to load
* Cascading fetches cause child components to be blank in a "waterfall"

This architecture is called client-side-rendering because the **client** is responsible for rendering the HTML on the page. This approach is well suited for interactive apps with little static content, like document editors, search tools, or anything that is well suited as an "app". This architecture is the primary architecture for desktop and mobile apps.

![CSR Diagram](/assets/07/csr-diagram.avif)

### SSR: The "Site" Architecture

In contrast to CSR, server-side-rendering is widely used for the classic "site" type application. Websites like e-commerce, portfolios, blogs, news, and other content-heavy applications prefer to render the initial HTML **on the server**.

Once the initial HTML reaches the client, extra supporting JavaScript (or WebAssembly) is executed, transforming the static page into an interactive one.

The HTML that reaches the client is usually "complete" with content:

````html
<html>
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
        <title> Our Site | Page XYZ </title>
        <meta name="description" content="Our really cool site - Page XYZ" />
        <link href="/main.css" />
        <link href="/page-xyz.css" />
        <script src="/index.js"/>
    </head>
    <body>
        <div id="main">
            <h1> This is a really cool site </h1>
            <h3> You are on page XYZ </h3>
            <p> Enjoy the content! </p>
        </div>
    </body>
</html>
````

Look closely to compare the two HTML bodies. The SSR HTML is full of content - the "main" div has headers and paragraphs, and the "head" of the app has page-specific attributes like its title, meta tags, and page-specific styling.

When using the SSR approach, there are *few* HTTP requests required to load the page:

* Initial GET to load `index.html`
* Follow-up GET requests to load assets

Also note the page only seems to be loading *once*:

* The user is waiting for the `index.html` to download.

Because the initial `GET` requests returns a complete picture of the site, crawlers like Google can easily read your site's contents, improving your ranking in search results.

![SSR Diagram](/assets/07/ssr-diagram.avif)

### Mixing CSR and SSR

Fortunately, these two architectures can be used *together* in a hybrid approach. This comes in two flavors:

* Default to SSR, add reactivity with "islands"
* Default to CSR, caching *some* data from the server

Dioxus employs the second approach. As a framework, we are focused on enabling great "app-like" experiences. Rust excels when building complex logic that is typically found in interaction-heavy applications.

There are *many* frameworks in the first category - projects like Ruby on Rails, NextJS, and Elixir Phoenix all serve primarily server-rendered content quite well. Dioxus easily handles SSR, but provides many tools and utilities that focus on client interaction.

## Do You Need SSR?

SSR is ideal for sites and pages that need to rank well in web searches like e-commerce stores, blogs, news, and other static content. In some instances, if your site is *entirely* static, you can even use static-site-generation to pre-render every page and deploy directly to a CDN.

However, adding SSR to your site is not always necessary, nor does it need to be enabled for every page. Dioxus SSR is *progressive*, meaning that by default, pages are rendered on the client, and you can *opt-in* to rendering components on the server. Any data not cached by the server will become a client-side fetch when the page finally loads.

## Hydration

In dioxus fullstack, the server renders the initial HTML for improved loading times. This initial version of the page is what most web crawlers and search engines see.

After the initial HTML is rendered, the client makes the page interactive through a process called **hydration**. Usually, hydration is purely an enhancement. You generally shouldn't need to think about hydration, but there are a few things you need to keep in mind to avoid [hydration errors](#hydration-errors).

To better understand hydration, let's walk through a simple example:

````rs@hydration.rs
fn Weather() -> Element {
    let mut weather = use_server_future(fetch_weather)?;

    rsx! {
        div {
            "{weather:?}"
        }
        button {
            onclick: move |_| weather.restart(),
            "Refetch"
        }
    }
}
````

## Rendering the initial HTML

When the server receives a request to render the `Weather` component, it renders the page to HTML and serializes some additional data the client needs to hydrate the page. It will follow these steps to render our component:

1. Run the component
1. Wait until all server futures are resolved
1. Serialize any non-deterministic data (like the `weather` future) for the client
1. Render the HTML

[![](https://mermaid.ink/img/pako:eNpdkDFTwzAMhf-KT3M70HbKwELhGMqSdAIziFhNfI2lnGzDQa__HZfk4Iq1-D1_ejr5BK04ggoOg3y0PWoy-61lE_Nbpzj2Jt68WGhI30lN4x2ZmtiReu4svBZwPs4rtckLm13958ZVaa4zmzsJozBxumqK6ynb4-C_yMxTHnLKSvGa3FyCfiabx_3Tbn4sxsTElVkub0vgLNeT3FieChYQSAN6V1Y9XSALqadAFqpydahHC5bPhcOcpPnkFqqkmRagkrseqgMOsag8Oky09Vh-J_y6I_KzSPhH3TufRGfz_A3Ce3PT?type=png)](https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNpdkDFTwzAMhf-KT3M70HbKwELhGMqSdAIziFhNfI2lnGzDQa__HZfk4Iq1-D1_ejr5BK04ggoOg3y0PWoy-61lE_Nbpzj2Jt68WGhI30lN4x2ZmtiReu4svBZwPs4rtckLm13958ZVaa4zmzsJozBxumqK6ynb4-C_yMxTHnLKSvGa3FyCfiabx_3Tbn4sxsTElVkub0vgLNeT3FieChYQSAN6V1Y9XSALqadAFqpydahHC5bPhcOcpPnkFqqkmRagkrseqgMOsag8Oky09Vh-J_y6I_KzSPhH3TufRGfz_A3Ce3PT)

Once the server finishes rendering, it will send this structure to the client as HTML:

[![](https://mermaid.ink/img/pako:eNqFUcFKAzEQ_ZUwh57agy22sAUFqaCgF1sQNCLTZLYbupss2VmLlv67s92luoo4uSRv3nvzhuzBBEuQQJqHnckwslottFdVvd5ELDNVjZ81LCk6zN0HWbVARg0vQpGyLpJhF7xaXbVIU_5MJCmxyV53hJxR7ATkbc96Irxb71i81c3q_u4_3ybKIOe5dW-DDc9P9GPzXJr7bl5yeeg3p51yXTOLa_Amd2b722QmvAdKI1XZH5mb3R57W7VVjb_dJ1_KY241Gl1IQjWQJB02bbGZ9u2BIRQUC3RWPmPfkDTIkII0JHK1GLcatD8ID2sOy3dvIOFY0xBiqDcZJCnmlbzq0iLTwqEELk5oif4phOIH69o6DrEDD5_uGqQ1?type=png)](https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNqFUcFKAzEQ_ZUwh57agy22sAUFqaCgF1sQNCLTZLYbupss2VmLlv67s92luoo4uSRv3nvzhuzBBEuQQJqHnckwslottFdVvd5ELDNVjZ81LCk6zN0HWbVARg0vQpGyLpJhF7xaXbVIU_5MJCmxyV53hJxR7ATkbc96Irxb71i81c3q_u4_3ybKIOe5dW-DDc9P9GPzXJr7bl5yeeg3p51yXTOLa_Amd2b722QmvAdKI1XZH5mb3R57W7VVjb_dJ1_KY241Gl1IQjWQJB02bbGZ9u2BIRQUC3RWPmPfkDTIkII0JHK1GLcatD8ID2sOy3dvIOFY0xBiqDcZJCnmlbzq0iLTwqEELk5oif4phOIH69o6DrEDD5_uGqQ1)

## Hydrating on the client

When the client receives the initial HTML, it hydrates the HTML by rerunning each component. As each component re-reruns, Dioxus loads cached data from the server, properly linking the HTML to each interactive DOM node.

Rerunning each component lets the client re-construct some non-serializable state like event handlers and kick off any client side logic like `use_effect` and `use_future`.

Hydration follows these steps:

1. Deserialize any data from the server (like the `weather` future)
1. Run the component with the deserialized data.
1. Hydrate the HTML sent from the server, adding event listeners and running effects.

[![](https://mermaid.ink/img/pako:eNpdkLFuAjEMhl_F8gxDgemGLlyrDnThmNp0SC-Gi7g4JydpRRHvXsOdkFpnif__s534jG10hBXu-_jddlYy7GrDkMrnQezQQXp4N7juPXGGxjuCl5MT63Nkgx8Kajgv1GYfGTbbUblGWmphTYnE297_EDQkXyTwXHIRSvfqG7tQdlsY1jEMkXXWX3ul9m1u1vm7183kErsRSkuYzx-1zZQuxnRleDw4w0ASrHf60_MVMpg7CmSw0quzcjRo-KKcLTk2J26xylJohhLLocNqb_ukWRmcvqH2VpcT7upg-S3G8I96crolmcTLL4RBdIg?type=png)](https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNpdkLFuAjEMhl_F8gxDgemGLlyrDnThmNp0SC-Gi7g4JydpRRHvXsOdkFpnif__s534jG10hBXu-_jddlYy7GrDkMrnQezQQXp4N7juPXGGxjuCl5MT63Nkgx8Kajgv1GYfGTbbUblGWmphTYnE297_EDQkXyTwXHIRSvfqG7tQdlsY1jEMkXXWX3ul9m1u1vm7183kErsRSkuYzx-1zZQuxnRleDw4w0ASrHf60_MVMpg7CmSw0quzcjRo-KKcLTk2J26xylJohhLLocNqb_ukWRmcvqH2VpcT7upg-S3G8I96crolmcTLL4RBdIg)

## Hydration Errors

For hydration to work, **the component must render exactly the same thing on the client and the server**. If it doesn't, you might see an error like this:

````
Uncaught TypeError: Cannot set properties of undefined (setting 'textContent')
at RawInterpreter.run (yourwasm-hash.js:1:12246)
````

Or this:

````
Error deserializing data:
Semantic(None, "invalid type: floating point `1.2`, expected integer")
This type was serialized on the server at src/main.rs:11:5 with the type name f64. The client failed to deserialize the type i32 at /path/to/server_future.rs
````

### Non-deterministic Eata

Much of the logic in your components is "deterministic" - meaning that given the same inputs to a component, the component will render the same output. It's very important that the inputs to your component remain stable across the client and the server.

Some inputs are "non-deterministic". For example, an app like Instagram has a "feed" of content. Calling `GET /api/feed` might not return the same result every time. This type of data must be serialized *into the HTML* and then *deserialized on the client* to ensure the exact same data is used during hydration.

### Non-deterministic Data with Server Cached

You must put any non-deterministic data in `use_server_future`, `use_server_cached` or `use_effect` to avoid hydration errors. For example, if you need to render a random number on your page, you can use `use_server_cached` to cache the random number on the server and then use it on the client:

````rs@hydration.rs
// ❌ The random number will be different on the client and the server
let random: u8 = use_hook(|| rand::random());
// ✅ The same random number will be serialized on the server and deserialized on the client
let random: u8 = use_server_cached(|| rand::random());
````

### Async Loading with Server Futures

If you need render some data from a server future, you need to use `use_server_future` to serialize the data instead of waiting for the (non-deterministic) amount of time `use_resource(...).suspend()?` takes:

````rs@hydration.rs
// ❌ The server function result may be finished on the server, but pending on the client
let random: u8 = use_resource(|| random_server_function()).suspend()?().unwrap_or_default();
// ✅ Once the server function is resolved on the server, it will be sent to the client
let random: u8 = use_server_future(|| random_server_function())?()
    .unwrap()
    .unwrap_or_default();
````

### Async Loading with `use_loader`

New in Dioxus 0.7 is the `use_loader` hook - a hook dedicated for isomorphic data loading that excels in both CSR and SSR architectures.

The `use_loader` hook is very similiar to `use_server_future`, but with a slightly different API. Unlike `use_server_future`, the `use_loader` hook will not re-suspend the page when the underyling future re-runs. Also, unlike `use_server_future`, the `use_loader` hook will re-throw any loading errors to the nearest suspense boundary:

````rust
fn app() -> Element {
    // Fetch the list of breeds from the Dog API, using the `?` syntax to suspend or throw errors
    let breed_list = use_loader(move || async move {
        reqwest::get("https://dog.ceo/api/breeds/list/all")
            .await?
            .json::<ListBreeds>()
            .await
    })?;

    rsx! {
        for cur_breed in breed_list.read().message.keys().take(20).cloned() {
            button {
                onclick: move |_| {
                    breed.call(cur_breed.clone());
                },
                "{cur_breed}"
            }
        }
    }
}
````

The `use_loader` hook takes a callback that returns a `Result<T, E>`. If that future returns a result, the error is automatically thrown. The `use_loader` hook excels when building sites that are both highly interactive and require SSR capabilities.

### Client Only Data with Effects

If you need to grab some data that is only available on the client, make sure you get it inside of a `use_effect` hook which runs after the component has been hydrated:

````rs@hydration.rs
// ❌ Using a different value client side before hydration will cause hydration issues
// because the server rendered the html with another value
let mut storage = use_signal(|| {
    #[cfg(feature = "server")]
    return None;
    let window = web_sys::window().unwrap();
    let local_storage = window.local_storage().unwrap().unwrap();
    local_storage.set_item("count", "1").unwrap();
    local_storage.get_item("count").unwrap()
});

// ✅ Changing the value inside of an effect is fine because effects run after hydration
let mut storage = use_signal(|| None);
use_effect(move || {
    let window = web_sys::window().unwrap();
    let local_storage = window.local_storage().unwrap().unwrap();
    local_storage.set_item("count", "1").unwrap();
    storage.set(local_storage.get_item("count").unwrap());
});
````

### Avoid Side Effects in Server Cached Hooks

The dioxus fullstack specific hooks `use_server_cached` and `use_server_future` don't run the same on the server and the client. The server will always run the closure, but the client may not run the closure if the server serialized the result. Because of this, the code you run inside these hooks **cannot have side effects**. If it does, the side effects will not be serialized and it can cause a hydration mismatch error:

````rs@hydration.rs
// ❌ The state of the signal cannot be serialized on the server
let mut storage = use_signal(|| None);
use_server_future(move || async move {
    storage.set(Some(server_future().await));
})?;

// ✅ The value returned from use_server_future will be serialized on the server and hydrated on the client
let storage = use_server_future(|| async move { server_future().await })?;
````
# Server Functions

Dioxus Fullstack provides an ergonomic solution for quickly building your backend API and calling those endpoints on the client called *Server Functions*. Server Functions are regular Rust functions that define an Axum-compatible endpoint:

````rust
#[get("/api/hello-world")]
async fn hello_world() -> Result<String> {
	Ok("Hello world!".to_string())
}
````

Server functions automatically generate an HTTP endpoint for your app. After launching your app, you can `curl` your endpoint directly:

````sh
# returns "Hello world!"
curl http://127.0.0.1:8080/api/hello-world
````

Server functions can be called directly from the client as a function:

````rust
let onclick = move |_| async move {
	let msg = hello_world().await;
	// ...
}
````

Server functions can take all sorts of modifiers like server-only extractors and custom axum payloads, making them even more powerful than a plain axum handler:

````rust
#[get("/api/users/{user_id}", db: SqlDb)]
async fn get_user(user_id: Uuid) -> Result<UserData> {
    db.get(user_id)
}
````

Ultimately, a server function is just an axum endpoint - you can cleanly use the entirety of the Axum ecosystem with server functions!

## Anatomy of a Server Function

A server function is an HTTP endpoint in the form of a Rust fuction. We can transform a regular function into a server function by annotating it with one of a few procedural macros:

* Explicitly using the `#[get]`, `#[post]`, `#[put]`, `#[delete]`, `#[patch]` macros
* Anonymously with the `#[server]` macro

To make a server function, simply add one of `#[get]`, `#[post]`, etc on top of your function. This function has a few restrictions - it must:

* Be an async function
* Return a `Result<T, E>`
* Take arguments that are either `Serialize + Deserialize` *or* `IntoRequest + FromRequest`
* Return a type that is either `Serialize + Deserialize` *or* `IntoResponse + FromResponse`

Dioxus uses some specialization "magic" to enable flexible input and output types, so the errors for types not satisfying these bounds might be rather unwieldly.

In essence, the non-URL inputs must either be a set of items that are obviously serializable (think strings, numbers, custom types):

````rust
// The function inputs create a single serializable object that looks like:
//
// ```
// #[derive(Serialize, Deserialize)]
// struct Body {
//     a: String,
//     b: i32,
//     c: serde_json::Value,
// }
// ```
#[get("/api/json-body")]
async fn json_body(a: String, b: i32, c: serde_json::Value) -> Result<()> {
	Ok(())
}
````

*or*, the inputs would be a single object that implements Axum's `FromRequest` trait and Dioxus' `IntoRequest` trait. Dioxus Fullstack provides a number of built-in types that implement these types and can be used across the client and the server:

````rust
// The `FileStream` type lets us stream file uploads from the client to the server
#[get("/api/upload")]
async fn upload(file: FileStream) -> Result<()> {
	// ....
}
````

Similarly, the output type can be either a serializable object (strings, numbers, custom strutures)

````rust
// Our custom payload implements `Serialize + Deserialize`
#[derive(Serialize, Deserialize)]
struct Payload {
	a: i32,
	b: String
}

#[get("/api/json-out")]
async fn json_body() -> Result<Payload> {
	Ok(Payload {
		a: 123,
		b: "hello".to_string(),
	})
}
````

*or* an object that implements Axum's `IntoResponse` trait and Dioxus' `FromResponse` trait. Many built-in types implement these traits and can be returned to the client:

````rust
#[get("/api/stream")]
async fn stream() -> Result<Streaming<String>> {
	// ...
}
````

If you want to use a 3rd-party Axum response type but it doesn't implement `FromResponse`, then you need to call `.into_response()` and return an `axum::response::Response` type instead:

````rust
#[get("/api/video", range: RangeHeader)]
async fn video_endpoint() -> Result<axum::response::Response> {
	let chunk = get_chunk_from_range(range);
	Ok(chunk.into_response())
}
````

### Path and Query Extractors

We can combine custom payload bodies with query and path extractors, enabling us to build APIs that are suitable both for our Rust frontend and any other HTTP client. This can be particularly useful if your API is consumed both by your own app and external customers.

To add query and path extractors, we can use the Axum route syntax in the macro. The macro will parse the route and generate the associated axum extractors for you:

````rust
#[get("/api/products/{product}?color&quantity")]
async fn get_product_data(product: String, color: String, quantity: Option<i32>) -> Result<Vec<Product>> {
	// ...
}
````

Under the hood, we generate `axum::extract::Query<T>` and `axum::extract::Path<T>` objects, so you can use any valid types, like `Option<T>`. When extracting from the URL, values are URL-encoded and URL-decoded. Note that not all structures can be cleanly URL-encoded, so we recommend sticking with simple data types where possible.

We can combine path and query extractors with the body extractor. This is especially useful when sending additional data alongside custom payloads.

````rust
// we can pass along additional data to objects like streams!
#[post("/api/photos/upload?name&rating")]
async fn upload_photo(name: String, rating: i32, image: FileStream) -> Result<i32> {
	// ...
}
````

### Custom Inputs

We mentioned earlier that the non-query arguments of a server function must be one of two types:

* A group of serializable types (strings, ints, custom serializable structs)
* A single type that implements `FromRequest` and `IntoRequest`

The second type - `FromRequest + IntoRequest` - is extremely powerful. This lets us create new bodies that abstract over the client request with Rust methods, making things like the built-in `WebsocketOptions` and `Websocket` types possible.

````rust
#[get("/api/ws")]
async fn get_updates(options: WebsocketOptions) -> Result<Websocket> {
	Ok(options.on_upgrade(|mut socket| {
		// ...
	}))
}
````

The `WebsocketOptions` type implements the two key Rust traits mentioned above: `FromRequest` and `IntoRequest`.

The first trait, [`FromRequest`](https://docs.rs/axum/latest/axum/extract/trait.FromRequest.html), comes from Axum, the library that Dioxus fullstack is built on.

To implement the `FromRequest` trait, we need to define our new type and then implement the `from_request` method. If you aren't sure which `Rejection` type to use in the implementation, you can use the built-in `ServerFnError` type which integrates with the rest of Dioxus fullstack.

````rust
struct WebsocketOptions {}

impl<S: Send> FromRequest<S> for WebSocketOptions {
    type Rejection = axum::response::Response;

    fn from_request(
        request: Request,
        state: &S,
    ) -> impl Future<Output = Result<Self, Self::Rejection>> + Send {
		async move {
			// .. implementation for our type
		}
	}
}
````

Implementing `FromRequest` lets us use `WebsocketOptions` type as an Axum extractor. Now, we need to implement `IntoRequest` which lets create `WebsocketOptions` on the client before passing it off to the server.

The `IntoRequest` trait is generic over a hidden "state" type parameter. Generally, you'll implement the plain `IntoRequest` type, but for complex types like Websockets, we need a custom state object that the response (`Websocket`) will use to initialize with. In this case, we create a new state type called `UpgradingWebsocket` which will hold the state from the original request to properly upgrade the server's response into a `Websocket` handle.

````rust
struct UpgradingWebsocket {
	/// .. state for the connection
}

// IntoRequest is generic over `UpgradingWebsocket`
impl IntoRequest<UpgradingWebsocket> for WebSocketOptions {
    fn into_request(
        self,
        request: ClientRequest,
    ) -> impl Future<Output = std::result::Result<UpgradingWebsocket, RequestError>> + 'static {
		async move {
			let stream = send_request(request).await?;

			return Ok(UpgradingWebsocket {
				// ... pass along the stream
			})
		}
	}
}
````

For bodies that don't need custom state, you can just use the default `IntoRequest` type which is generic over the Dioxus Fullstack `ClientResponse` type

````rust
// the default state is `ClientResponse`:
pub trait IntoRequest<R = ClientResponse>: Sized {
    fn into_request(
        self,
        req: ClientRequest,
    ) -> impl Future<Output = Result<R, RequestError>> + 'static;
}
````

Now, when the client makes a request to our endpoint, the `WebsocketOptions` struct can be used to store state for the connection:

````rust
// We can now use `WebsocketOptions` as a custom body:
#[get("/api/ws/")]
async fn get_updates(options: WebsocketOptions) -> Result<()> {
	// ...
}

// Calling the endpoint is still quite simple:
_ = get_updates(WebsocketOptions::new()).await?;
````

### Custom Outputs

The `IntoRequest` and `FromRequest` traits allow us to send arbitrary data types to the Server, but sometimes we need to return arbitrary data types to the Client. In our example above, this would be the `Websocket` return type:

````rust
#[get("/api/ws")]
async fn get_updates(options: WebsocketOptions) -> Result<Websocket> {
	Ok(options.on_upgrade(|mut socket| {
		// ...
	}))
}
````

As mentioned above, the return type of a server function must be one of two types:

* An obviously serializable object (string, int, custom struct)
* A type that implements `IntoResponse` and `FromResponse`

The [`IntoResponse`](https://docs.rs/axum/latest/axum/response/trait.IntoResponse.html) trait comes from Axum and is quite simple to implement. To implement the `IntoResponse` type, we just need to implement the `into_response` method for our custom type. The return type here is an Axum `Response` which is very simple to construct:

````rust
impl IntoResponse for Websocket {
	fn into_response(self) -> Response {
        Response::builder()
			.status(200)
			.header(/* */)
			.body(/* */)
			.unwrap()
	}
}
````

The Response here is directly passed along to the client. Dioxus Fullstack might attach some additional headers to the response, but the response body will remain untouched as its returned through the Axum router.

Now, to use our `Websocket` type on the client, we need to implement `FromResponse`. The `FromResponse` trait is an analog to the `IntoResponse` trait, with a similar definition:

````rust
pub trait FromResponse<R = ClientResponse>: Sized {
    fn from_response(res: R) -> impl Future<Output = Result<Self, ServerFnError>>;
}
````

Just like `IntoRequest`, the `FromResponse` trait is generic over a default state parameter (usually `ClientResponse`). For our `Websocket` type, we need to match the same state parameter as our `WebsocketOptions` type. Usually, we *aren't* generic over the state paramter since the `ClientResponse` type is quite useful on its own, but for `Websocket`, we want to make sure the input request has the required state at compile time.

To implement `FromResponse`, we need to create a new instance of our type from the stored state:

````rust
impl FromResponse<UpgradingWebsocket> for Websocket {
    fn from_response(res: UpgradingWebsocket) -> impl Future<Output = Result<Self, ServerFnError>> {
		async move {
			// ...
		}
	}
}
````

Note that the error type here is `ServerFnError`. This type ensures that the client code can properly downcast any errors that occur while making the request into a standard error type. The `ServerFnError` type includes a number of useful error variants, allowing us to express all sorts of failure modes, some with a standardized HTTP status code and details.

### Server Extractors

As you build increasingly complex backends, you might need more control over extracting data from the request. This could be handling things like auth tokens, cookies, range headers, or any number of tasks related to the request and its headers. Sometimes, these values cannot be sent directly from the client.

In the case of authentication, we might want to extract a stateful extension from the request or reader a specific header like the auth-bearer. In many cases, the client does not explicitly pass these types to the server as they are either extracted using server-only state or implicitly attached like cookies.

To extract arbitrary data from the request, we can "hoist" the function arguments into the macro. The types here must implement Axum's `FromRequestParts` trait - or `FromRequest` if there's no client-only body.

````rust
// Our `auth` argument is a function argument hoisted to the argument list in the proc macro
#[post("/api/user/login", auth: auth::Session)]
pub async fn login() -> Result<()> {
    auth.login_user(2);
    Ok(())
}
````

Because the types here must implement `FromRequestParts`, we can use a wide variety of built-in extractors. For example, we can extract the entire `HeaderMap` object from the request:

````rust
#[get("/api/headers", headers: dioxus::fullstack::HeaderMap)]
async fn get_headers() -> Result<String> {
    Ok(format!("{:#?}", headers))
}
````

We can stack as many of these extractors as we'd like:

````rust
#[post("/api/user/login", header: TypedHeader<Cookie>, auth: Session)]
pub async fn login() -> Result<()> {
    // ...
}
````

Server-only extractors make it easy to migrate existing axum handlers to Server Functions without too many code modifications.

## Handling Errors

### Acceptable Error Types

By default, Dioxus exports a custom `Result<T>` type in the prelude. Whenever you call `use dioxus::prelude::*`, you import this `Result<T>` type into the module's scope. This `Result<T>` type is actually a re-export of anyhow's `Result<T>` type.

Anyhow's Result type is a widely used "dynamic" error type used in Rust applications. It is extremely flexible, allowing you to use Rust's powerful question-mark (`?`) syntax with any error type that implements `std::Error`.

This means that the above examples are equivalent to using the anyhow error type directly:

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<(), anyhow::Error> {
    // ...
}
````

Unfortunately, when errors are created on the server, Dioxus Fullstack cannot preserve the error's type on the client. Therefore, all errors from endpoints that use the plain `Result<T>` will always downcast to the Dioxus Fullstack `ServerFnError` type:

````rust
// Make the request, assuming it always fails, unwrapping the error
let res = login().await.unwrap_err();

// We can only downcast this error to `ServerFnError`
let error = res.downcast_ref::<ServerFnError>().unwrap();
````

If you want more detail about the error type, you can use the `ServerFnError` type directly, or use `ServerFnResult`:

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<(), ServerFnError> {
    // ...
}
````

The `ServerFnError` type is a special error type that integrates cleanly with the rest of Dioxus. Its many variants represent various failure points of handling a given request. Its two most imporant variants are `ServerError` and `RequestError`.

````rust
pub enum ServerFnError {
    /// Occurs when there is an error while actually running the function on the server.
    #[error("error running server function: {message} (details: {details:#?})")]
    ServerError {
        /// A human-readable message describing the error.
        message: String,

        /// HTTP status code associated with the error.
        code: u16,

		/// Serialized custom error type
        details: Option<serde_json::Value>,
    },

    /// Occurs on the client if there is a network error while trying to run function on server.
    #[error("error reaching server to call server function: {0} ")]
    Request(RequestError),

	// ...
}
````

If an endpoint returns a `ServerFnError`, you can match the result on the client, providing more useful feedback to the user in the event of a failure:

````rust
match login().await {
	Err(ServerFnError::ServerError { code, .. }) => {
		if code == 404 {
			// .. handle not found
		}

		if code == 401 {
			// .. handle unauthorized
		}
	}
	_ => { /* */ }
}
````

Endpoints can accept a wide variety of error types, including:

* `anyhow::Error`: a simple, flexible error type to build quickly
* `ServerFnError`: a structured error for granularly handling types of errors
* `StatusCode`: a simple wrapper around the HTTP status code
* `HttpError`: the error type returned from the `OrHttpError` type
* Custom Errors: user-defined errors (see below)

### Custom Errors

In addition to `anyhow::Error`, `ServerFnError`, and `HttpError`, Server Functions can return custom, user-defined errors. These errors must implement `Serialize`, `Deserialize`, and an additional trait called `AsStatusCode`. `AsStatusCode` requires the error implement `From<ServerFnError>` and a method to get the actual status code from the error itself.

You can easily create new error types using the `thiserror` crate's `Error` macro. The `#[from]` attribute makes it possible to easily convert `ServerFnError` into the custom error type.

````rust
#[derive(thiserror::Error, Debug, Serialize, Deserialize)]
enum MyCustomError {
    #[error("bad request")]
    BadRequest { custom_name: String },

    #[error("not found")]
    NotFound,

    #[error("internal server error: {0}")]
    ServerFnError(#[from] ServerFnError),
}
````

We must then implement `AsStatusCode` so Dioxus Fullstack knows which status code to return to the client in the event of an error.

````rust
impl AsStatusCode for MyCustomError {
    fn as_status_code(&self) -> StatusCode {
        match self {
            MyCustomError::BadRequest { .. } => StatusCode::BAD_REQUEST,
            MyCustomError::NotFound => StatusCode::NOT_FOUND,
            MyCustomError::ServerFnError(e) => e.as_status_code(),
        }
    }
}
````

### Ergonomic Error Handling

Dioxus Fullstack provides a utility trait called `OrHttpError` to convert common failure cases into proper HTTP status codes and error messages. This trait makes it simpler to follow proper web semantics (like 404 for not-found, 401 for not-authorized, etc) while keeping inline with ergonomic Rust error handling.

You can use `OrHttpError` methods on any `Result<T>`, `Option<T>`, or `bool`, to return an `Err(HttpError)`.

For example, we might write an `authorize` method that throws an error if authorization fails. We can use the method `or_unauthorized()?` to convert the error into an appropriate status code.

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<(), ServerFnError> {
	authenticate_user()
		.or_unauthorized("You must be logged in to view this resource")?;
	// ..
}
````

To prevent polluting the global scope, only a few utility methods are available by default. You can use the `or_http_error` to return any status code:

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<(), ServerFnError> {
	authenticate_user()
		.or_http_error(StatusCode::UNAUTHORIZED, "Log in first!")?;
	// ..
}
````

Note that even when we use `anyhow::Error`, Dioxus will automatically extract the appropriate status code from the error:

````rust
// our `Result<T>` contains an `HttpError` object
#[post("/api/user/login")]
pub async fn login() -> Result<()> {
	authenticate_user()
		.or_http_error(StatusCode::UNAUTHORIZED, "Log in first!")?;
	// ..
}
````

This is true for `HttpError`, `StatusCode`, and `ServerFnError`, all of which are downcasted from the anyhow Error type.

## Customizing Headers

### Customizing Response Headers

todo ...

### Customizing Request Headers

todo ...

## Registering Server Functions

Dioxus Fullstack automatically registers all server functions for you automatically. This means you can quickly build your backend without needing to explicitly wire up endpoints to a central router.

By default, this is done when you call `dioxus::launch`. If you wish to customize the underyling Axum router, you can instead use `dioxus::serve` which lets you manually construct the router.

For simplicity, you can use the `dioxus::server::router` function to create the very same Axum router that `dioxus::launch` initializes:

````rust
fn main() {
	#[cfg(feature = "server")]
	dioxus::serve(|| async move {
		// We create a new axum router with server functions and SSR automatically wired up
		let mut router = dioxus::server::router(app);

		// We can customize the router however we want with layers and nested routers, etc
		// ...

		// And then return the router
		Ok(router)
	});

	#[cfg(not(feature = "server"))]
	dioxus::launch(app);
}
````

Note how we use Rust's built-in `#[cfg]` macro to conditionally launch the app based on the `server` feature. When `server` feature is enabled, we enable `dioxus::serve`, and when it is disabled, we enable `dioxus::launch`.

Within the `dioxus::serve` closure, we can run setup for our app and customize the axum router. For example, we could add new axum routes to the router:

````rust
#[cfg(feature = "server")]
dioxus::serve(|| async move {
	use dioxus::server::axum::routing::{get, post};

	Ok(dioxus::server::router(app)
		.route("/submit", post(|| async { "Form submitted!" }))
		.route("/about", get(|| async { "About us" }))
		.route("/contact", get(|| async { "Contact us" })))
});
````

The `dioxus::server::router` function creates a new axum router that sets up a few imporant pieces:

* Static Assets: automatically serve the `public` directory, index.html and assets
* SSR: automatically run the app, render it to HTML, and serialize data for hydration
* Server Functions: automatically initialize the API endpoints

Dioxus uses extension methods on the Axum router (given by `DioxusRouterExt`):

````rust
axum::Router::new()
	.register_server_functions()
	.serve_static_assets()
	.fallback(
		get(render_handler).with_state(RenderHandleState::new(cfg, app)),
	)
````

The `.register_server_functions()` method iterates through all global server functions and then registers them on the given router. You can manually iterate through the list of global server functions and register single endpoints, or create new routers with a subset of routes with `ServerFunction::collect()`:

````rust
// We can iterate through all server functions:
for func in ServerFunction::collect() {
	// Read their data
	tracing::info!(
		"Registering server function: {} {}",
		func.method(),
		func.path()
	);

	// And add them to our router
	router = func.register_server_fn_on_router(router);
}
````
# Headers and Status

One core aspect of server functions and server-side-rendering is customizing responses to user requests.

This could be for many different reasons:

* Return structured status codes (200, 404, 500, etc)
* Add cookies to the response for authentication
* Set custom headers of the response (Content-Type, Caching, Range, etc)

With server functions, this might be

## Response Headers with `SetHeader`

todo... waiting for changes in dioxus itself...

`SetHeader<T>` can set a specific header
`Redirect` can set the redirect header

## Setting Client-Side Headers

todo... waiting for changes in dioxus itself...

Currently not possible, sadly.

## Setting Server Headers

todo... waiting for changes in dioxus itself...

`FullstackContext::response_headers`
# Fullstack Error Handling

Errors are unfortunately inevitable in software development. Even in Rust, apps might not behave as expected and user requests might be malformed.

In these cases, you might want to show an error page to the user while also returning an appropriate status code.

## Creating an Error

Recall in the [Server Functions](./server_functions.md) chapter, that all server functions must return a `Result<T>`:

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<()> {
    // ...
}
````

Because server functions are called from the client, they need some way of expressiong *both* a request failure and a server failure. If the user is offline, we want to reliably return an offline error and status in the UI.

Also recall that server functions can return several different error types:

* `ServerFnError`: A broad error type encompasing request failures and server failures
* `anyhow::Error`: A general-purpose error type that downcasts its inner value
* `CapturedError`: A cheaply-clonable `anyhow::Error` wrapper
* `StatusCode`: A specific HTTP status code
* `HttpError`: A specific HTTP status code and a message
* Custom Errors: User errors that implement `Serialize + Deserialize + AsStatusCode`

Dioxus will attempt to downcast server function errors and captured errors into status codes such that the returned page receives an appropriate HTTP status.

If an error does not downcast to a known status-code-like error type, then the request will default to a `500 INTERNAL SERVER ERROR`.

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<()> {
    // This will return a 500 status code
    return Err(anyhow::anyhow!("Bad request!").into());

    // ...
}
````

The `OrHttpError` error type makes emitting status codes quite simple with its extension methods on `Result<T>`, `Option<T>`, and `bool`.

````rust
#[post("/api/user/login")]
pub async fn login() -> Result<()> {
	authenticate_user()
        // this method comes from `OrHttpError`
		.or_unauthorized("You must be logged in to view this resource")?;
	// ..
}
````

## Error Status Codes Bubble

In the event of an error, Dioxus extracts the status code for the response by downcasting errors that bubble to root component.

For example, this example app does not provide a root error boundary, and thus all errors will bubble up to the root:

````rust
fn app() -> Element {
    let post_data = use_loader(move || get_post())?;

    rsx! {
        p { "{post_data}" }
    }
}

// This endpoint always throws an error
#[get("/api/post/")]
async fn get_post() -> Result<String, HttpError> {
    HttpError::not_found("Post not found")
}
````

If you `curl` the app, you'll notice that it returns a `404` status code.

If we want to catch the error and provide a nice fallback UI, we can use an `ErrorBoundary`. Note that when we catch the error, we must

````rust
fn app() -> Element {
    rsx! {
        ErrorBoundary {
            handle_error: move |err| {
                // To ensure the HTTP status is still set properly, we need to call `commit_error_status`
                let http_error = FullstackContext::commit_error_status(err.error().unwrap());

                // and then we can render some pretty fallback UI
                rsx! { "An error occured! {http_error:?}" }
            },
            Post {}
        }
    }
}

fn Post() -> Element {
    let post_data = use_loader(move || get_post())?;
    rsx! { p { "{post_data" } }
}
````

The `commit_error_status` function on `FullstackContext` extracts the HTTP status from a `CapturedError` and then modifies the outgoing response accordingly.

## Error Layout with Router

If you're using the Dioxus Router for your app's routing, then it might not be immediately clear how to integrate custom error pages into your app.

In these cases, we'd take a similar approach with an `ErrorBoundary`. We could either wrap our `Router {}` component in an error boundary, or add a layout to our app that renders the fallback UI.

````rust
// A router definition with `ErrorLayout` layout
#[derive(Routable, PartialEq, Clone, Debug)]
enum Route {
    #[layout(ErrorLayout)]
    #[route("/")]
    Home,

    #[route("/blog/:id")]
    Blog { id: u32 },
}

// And then our Outlet is wrapped in a fallback UI
#[component]
fn ErrorLayout() -> Element {
    rsx! {
        ErrorBoundary {
            handle_error: move |err: ErrorContext| {
                let http_error = FullstackContext::commit_error_status(err.error().unwrap());
                match http_error.status {
                    StatusCode::NOT_FOUND => rsx! { div { "404 - Page not found" } },
                    _ => rsx! { div { "An unknown error occurred" } },
                }
            },
            Outlet::<Route> {}
        }
    }
}
````

Using layouts for error pages is extremely powerful. You can isolate fallback UI to specific parts of the page while also properly setting the returned status code.

For example, the GitHub UI retains most of its UI while isolate the 404 message to just the source code viewer:

![Github Fallback UI](/assets/07/github-fallbackui.avif)

It's a better user experience to render a web page that is visually consistent while also still delivering the appropriate status code.
# Axum Router

Dioxus fullstack is built on the popular backend crate Axum. The default `dioxus::launch` function will initialize a default Axum server for your fullstack project. If you need more control, you can easily customize the router with `dioxus::serve`.

The `dioxus::serve` function is the primary entrypoint for Dioxus apps that run on the server, as is standard in fullstack applications. For fullstack apps, you'll typically use both `dioxus::launch` and `dioxus::serve`, enabling each entrypoint based on the `"server"` feature.

````rust
fn main() {
    // Run `serve()` on the server only
    #[cfg(feature = "server")]
    dioxus::serve(|| async move {
        // Create a new router for our app using the `router` function
        let mut router = dioxus::server::router(app);

        // .. customize the router, adding layers and new routes

        // And then return the router
        Ok(router)
    });

    // When not on the server, just run `launch()` like normal
    #[cfg(not(feature = "server"))]
    dioxus::launch(app);
}
````

The `dioxus::server::router` function creates a new axum router that sets up a few imporant pieces:

* Static Assets: automatically serve the `public` directory, index.html and assets
* SSR: automatically run the app, render it to HTML, and serialize data for hydration
* Server Functions: automatically initialize the API endpoints

Dioxus uses extension methods on the Axum router (given by `DioxusRouterExt`) that is equivalent to enabling each of these items manually:

````rust
axum::Router::new()
	.register_server_functions()
	.serve_static_assets()
	.fallback(
		get(render_handler).with_state(RenderHandleState::new(cfg, app)),
	)
````

## Adding New Routes

One common use-case of a custom axum router is to add new routes to the router that are *not* defined with server functions. We might want to include special endpoints that respond dynamically or that return non-HTML data types.

This example adds three new routes to our app:

````rust
dioxus::serve(|| async move {
    use dioxus::server::axum::routing::{get, post};

    let router = dioxus::server::router(app)
        .route("/submit", post(|| async { "Form submitted!" }))
        .route("/about", get(|| async { "About us" }))
        .route("/contact", get(|| async { "Contact us" }));

    Ok(router)
});
````

Note that the server-side-rendering handler is registered as a *fallback* handler. Any routes we manually register will take priority over the Dioxus app. Since these handlers are axum handlers, they can take the typical modifiers, like `.with_state()`, `.layer()`, etc.

````rust
let router = dioxus::server::router(app)
    .route(
        "/submit",
        post(
            |state: State<FormSubmitter>, ping: Extension<Broadcast>, cookie: TypedHeader<Cookie>| async {
                // ... endpoint logic
            },
        ),
    )
    .with_state(FormSubmitter::new())
    .layer(Extension(Broadcast::new()));
````

## Adding `Layers`

Axum allows you to to attach middleware to many parts of your router:

* To entire routers with [Router::layer](https://docs.rs/axum/latest/axum/struct.Router.html#method.layer) and [Router::route_layer](https://docs.rs/axum/latest/axum/struct.Router.html#method.route_layer).
* To method routers with [MethodRouter::layer](https://docs.rs/axum/latest/axum/routing/method_routing/struct.MethodRouter.html#method.layer) and [MethodRouter::route_layer](https://docs.rs/axum/latest/axum/routing/method_routing/struct.MethodRouter.html#method.route_layer).
* To individual handlers with [Handler::layer](https://docs.rs/axum/latest/axum/handler/trait.Handler.html#method.layer).

## Adding State with Extensions

As you build out your app, you might want to expose state to your endpoints and to your requests. Axum provides two ways of adding state to endpoints: `Extension` and `State<T>`. Extensions enable you to attach extra data to requests as they are handled by your router.

You can use extensions *either* as a form of global state *or* as a way of attaching state to requests. To share a given piece of data with all endpoints, you can attach the extension as a layer to the router in `dioxus::serve`:

````rust
dioxus::serve(|| async move {
    use dioxus::server::axum::Extension;
    use tokio::sync::broadcast;

    let router = dioxus::server::router(app)
        .layer(Extension(broadcast::channel::<String>(16).0));

    Ok(router)
});
````

Now, in our handlers, we can extract the extension from the request:

````rust
#[post("/api/broadcast", ext: Extension<broadcast::Sender<String>>;)]
async fn broadcast_message() -> Result<()> {
    ext.send("New broadcast message".to_string())?;
    Ok(())
}
````

If we want to attach state to a single request - as in the case with a session middleware - we can attach a new middleware to the router that dynamically inserts a new extension into the request.

````rust
use axum::{extract::Request, middleware::Next, middleware};

let router = dioxus::server::router(app)
    .layer(middleware::from_fn(|req: Request, next: Next| async move {
        // Attach some extra state to the request
        req.extensions_mut().insert(Session::new());

        // And then return the response with `next.run()
        Ok::<_, Infallible>(next.run(req).await)
    }))
````

## Adding State with `State<T>`

As you migrate an existing Axum backend to Dioxus Fullstack, you might eventually need to use Axum's `State<T>` type parameter. In Axum, the `State<T>` type provides state to your axum endpoints using compile-time guarantees.

... todo - currently no migration pattern here

## Using `Lazy<T>` as Global State

As a simpler alternative to axyn extensions and `State<T>`, you can also use the built-in `Lazy<T>` type to access server resources without needing to set up a dedicated `dioxus::serve` entrypoint. The `Lazy<T>` type is very similar to the standard library's `LazyLock<T>` type, making it possible to initialize asynchronous data like database connections.

Simply create a new `Lazy<T>` instance as a `static` variable:

````rust
static DATABASE: Lazy<sqlx::SqlitePool> = Lazy::new(|| async move {
    dioxus::Ok(
        SqlitePoolOptions::new()
            .max_connections(5)
            .connect_with("sqlite::memory:".parse().unwrap())
            .await?,
    )
});
````

When you access the `DATABASE` object in your code, Dioxus will ensure it's properly initialized, blocking the current thread until the initializer finishes. This lets you use asynchronous resources *synchronously* which makes them extremely ergonomic.

````rust
/// When using the `Lazy<T>` type, it implements `Deref<Target = T>`, so you can use it like a normal reference.
#[get("/api/users")]
async fn get_users() -> Result<Vec<String>> {
    let users = DATABASE
        .fetch_all(sqlx::query("SELECT name FROM users"))
        .await?
        .iter()
        .map(|row| row.get::<String, _>("name"))
        .collect::<Vec<_>>();

    Ok(users)
}
````

Typically, Rust discourages the use of global variables for managing state, but for apps like web-servers, it's generally okay to have a single shared object for the entire app.

Note that you can also use the built-in standard `LazyLock` type for simple synchronous data:

````rust
static MESSAGES: LazyLock<Mutex<Vec<String>>> = LazyLock::new(|| Mutex::new(Vec::new()));

#[post("/api/messages")]
async fn add_message() -> Result<()> {
    MESSAGES.lock().await.push("New message".to_string());
    Ok(())
}
````

## Nesting Routers

todo....
# Middleware

Middleware allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.

Dioxus Fullstack provides two main ways of adding middleware to your app:

* Imperatively using Axum's APIs on your Router in `dioxus::serve`
* Declaratively by annotating individual endpoints with the `#[middleware]` attribute

## What is Middleware?

In web applications, middleware are functions that are called before and after the request is handled by your endpoint logic.

The underyling web framework that Dioxus Fullstack is built on - Axum - does not define its own bespoke middleware system. Instead, it leans on the broader ecosystem, integrating with the more fundamental [`tower`](https://github.com/tower-rs/tower) and [`hyper`](https://github.com/hyperium/hyper) crates.

Axum *does* provide a simple way of writing middleware with `middleware::from_fn`:

````rust
axum::middleware::from_fn(
    |request: Request, next: Next| async move {
        // Read and write the contents of the incoming request
        println!("Headers: {:?}", request.headers());

        // And then run the request, modifying and returning the response
        next.run(request).await
    },
)
````

Middleware give you both *read* and *write* access to both the *request* and the *response* of the handler. This is extremely powerful!

You can implements a wide range of functionality with middleware:

* Logging and telemetry
* Rate limiting
* Validation
* Compression
* CORS, CSRF
* Authentication and Authorization
* Caching

The broader Rust ecosystem has many different 3rd party crates for middleware.

The two main crates to look for middleware are:

* [Tower](https://docs.rs/tower/latest/tower/): The underyling library for networking
* [Tower-HTTP](https://github.com/tower-rs/tower-http): A dedicated HTTP-specific middleware library

## Middleware on the Router

Because Dioxus is built on Axum, you can use many Axum APIs directly. Dioxus Fullstack does not provide any bespoke wrappers around Axum middleware - you can simply attach them to your router in `dioxus::serve`:

````rust
dioxus::serve(|| async move {
    use axum::{extract::Request, middleware::Next};
    use dioxus::server::axum;

    Ok(dioxus::server::router(app)
        // we can apply a layer to the entire router using axum's `.layer` method
        .layer(axum::middleware::from_fn(
            |request: Request, next: Next| async move {
                // Read the incoming request
                println!("Request: {} {}", request.method(), request.uri().path());

                // Run the handler, returning the response
                let res = next.run(request).await;

                // Read/write the response
                println!("Response: {}", res.status());

                res
            },
        )))
});
````

The Tower-HTTP crate provides a number of useful middleware layers to add to your app. The `ServiceBuilder` object can be used to efficiently assemble a `Service` which handles a wide range of middleware actions:

````rust
// Use tower's `ServiceBuilder` API to build a stack of tower middleware
// wrapping our request handler.
let middleware = ServiceBuilder::new()
    // Mark the `Authorization` request header as sensitive so it doesn't show in logs
    .layer(SetSensitiveRequestHeadersLayer::new(once(AUTHORIZATION)))
    // High level logging of requests and responses
    .layer(TraceLayer::new_for_http())
    // Share an `Arc<State>` with all requests
    .layer(AddExtensionLayer::new(Arc::new(state)))
    // Compress responses
    .layer(CompressionLayer::new())
    // Propagate `X-Request-Id`s from requests to responses
    .layer(PropagateHeaderLayer::new(HeaderName::from_static("x-request-id")))
    // If the response has a known size set the `Content-Length` header
    .layer(SetResponseHeaderLayer::overriding(CONTENT_TYPE, content_length_from_response))
    // Authorize requests using a token
    .layer(ValidateRequestHeaderLayer::bearer("passwordlol"))
    // Accept only application/json, application/* and */* in a request's ACCEPT header
    .layer(ValidateRequestHeaderLayer::accept("application/json"))
    // Wrap a `Service` in our middleware stack
    .service_fn(handler);
````

You can then attach this service as a layer to your router:

````rust
dioxus::serve(|| async move {
    use axum::{extract::Request, middleware::Next};
    use dioxus::server::axum;

    // Assemble a middleware object from the ServiceBuilder
    let middleware = ServiceBuilder::new()
        .layer(/* */)
        .layer(/* */)
        .layer(/* */);

    Ok(dioxus::server::router(app).layer(middleware))
});
````

Axum recommend initializing multiple middleware on a `ServiceBuilder` object for maximum performance, but you can also attach layers directly onto the router:

````rust
dioxus::serve(|| async move {
    use axum::{extract::Request, middleware::Next};
    use dioxus::server::axum;

    Ok(
        dioxus::server::router(app)
            .layer(/* */)
            .layer(/* */)
            .layer(/* */)
    )
});
````

## Middleware on individual Routes

If you need to apply middleware to just a handful of specific routes, you can use the `#[middleware]` attribute. Unlike router-level middleware, route-level middleware will only be applied to a specific endpoint. Alternatively, you could register routes one-by-one on the axum router with dedicated calls `.layer()`.

For example, we might want to add a "timeout" middleware to a specific server function. This middleware will stop running the server function if it reaches a certain timeout:

````rs@server_function_middleware.rs
#[cfg(feature = "server")]
use {std::time::Duration, tower_http::timeout::TimeoutLayer};

// Add a timeout middleware to the server function that will return an error if the function takes longer than 1 second to execute
#[post("/api/timeout")]
#[middleware(TimeoutLayer::new(Duration::from_secs(1)))]
pub async fn timeout() -> Result<(), ServerFnError> {
    tokio::time::sleep(Duration::from_secs(2)).await;
    Ok(())
}
````

Under the hood, Dioxus Fullstack creates a `MethodRouter` object and then attaches these layers with calls to `.layer()` automatically.

## Caching and Middleware

In the chapter on server-side-rendering, we discussed at length about how Dioxus Fullstack is architected around client-side-rendering, with SSR being an additional enhancement. One enhancement is the ability to add a `Cache-Control` header to HTML responses, letting our CDN and Reverse Proxy decrease the load on our server. When the `Cache-Control` header is present, the proxy is able to cache responses.

 > 
 > It's very important to note that middleware can "bust" the cache - even accidentally!

If you're using middleware for session management or authentication, it can be easy to accidentally cache pages that shouldn't be cached. For example, a news site might want to cache its homepage:

````rust
dioxus::server::router(app)
    .layer(axum::middleware::from_fn(
        |request: Request, next: Next| async move {
            // If the route is `/home`, cache the page
            let is_home = request.uri() == "/home";

            let res = next.run(request).await;

            if is_home {
                res.headers_mut().insert("Cache-Control", "max-age=10800")
            }

            res
        }
    ))
````

Eventually, we might add a feature that lets users customize their homepage. We might add a session layer to our router:

````rust
dioxus::server::router(app)
    .layer(session_layer) // a new session layer
    .layer(caching_layer)
````

If we're not careful, we might accidentally cache a *logged-in user's* homepage! Caching is typically based on the request's URL, but middleware also operate on headers. If we show dynamic content based on headers (like auth or sessions), we need to take care to only cache certain respones.

Many reverse proxies have the ability to configure caching based on request headers. We suggest diving into our deploy platform's reverse proxy setup, or implementing a smarter caching middleware yourself.
# Websockets

Dioxus Fullstack provides built-in types for creating and managing websockets that work alongside server functions. Dioxus websockets are built on top of the underyling Axum websocket API, but with a few improvements tailored for building fullstack apps:

* Hybrid shared server/client types
* Reactive wrapper for use in UI code
* Typed inputs, outputs, and customizable encoding

Websockets are an extremely powerful communication protocol that allows bidirectional message passing to and from the server. Websockets are more efficient than HTTP requests for large amounts of messages, provide better real-time support, and allow for *ordered* data transmission.

Note that websockets are *stateful*, meaning that a websocket connection ties a client and server together for a given session. If you plan to use websockets in a "serverless" environment with time limits of request handling, then you need some way to "store" the websocket session across multiple requests.

## Websocket and WebsocketOptions

To create a new server function that returns a websocket, simply use `WebsocketOptions` as your body type and `Websocket` as your response type.

````rust
#[get("/api/uppercase_ws")]
async fn uppercase_ws(options: WebSocketOptions) -> Result<Websocket> {
    Ok(options.on_upgrade(move |mut socket| async move {
        // send back a greeting message
        _ = socket
            .send("Hello!".to_string())
            .await;

        // Loop and echo back uppercase messages
        while let Ok(msg) = socket.recv().await {
            _ = socket.send(msg.to_ascii_uppercase()).await;
        }
    }))
}
````

The `Websocket` type is generic over three parameters - the input type, output type, and encoding:

````rust
pub struct Websocket<In = String, Out = String, E = JsonEncoding> {
    // ...
}
````

The input and output types are the types used when you call `.send()` and `.recv()` on the `socket` object provided after `on_upgrade`. By strongly typing the websocket, we guarantee that your client and server always use the right message format across the client and server.

The `on_upgrade` method is a wrapper over the underlying Axum `on_upgrade` API that returns an axum response, indicating to the client that the websocket upgrade process is succesful. If the client agrees, then the server will run the `on_upgrade` callback, spawning the future. Note that this future is spawned on a tokio [LocalSet](https://docs.rs/tokio/latest/tokio/task/struct.LocalSet.html). This means the future does not need to be `Send`.

We can use our own message types for the input and output messages. Calls to `.send()` and `.recv()` will attempt to deserialize messages into the right type, returning an error if the deserialization fails.

````rust
// Events flowing *from* the client to the server
#[derive(Serialize, Deserialize, Debug)]
enum ClientEvent {
    TextInput(String),
}

// Events flowing *to* the client from the server
#[derive(Serialize, Deserialize, Debug)]
enum ServerEvent {
    Uppercase(String),
}

#[get("/api/uppercase_ws")]
async fn uppercase_ws(options: WebSocketOptions) -> Result<Websocket<ClientEvent, ServerEvent>> {
    // ...
}
````

We can also customize the encoding of the websocket with the third generic on `Websocket`. By default, messages are encoded using JSON with `JsonEncoding`, but you can opt for an alternative format like the binary Cbor format with `CborEncoding`:

````rust
#[get("/api/uppercase_ws")]
async fn uppercase_ws(options: WebSocketOptions) -> Result<Websocket<ClientEvent, ServerEvent, CborEncoding>> {
    // ...
}
````

Generally, if you're working with Rust-only clients, then Cbor or MsgPack are better options, but 3rd-party clients might be better suited with the standard JSON encoding.

If you need to send extra details to the server before establishing the websocket connection, you can use path and query parameters as well as header extraction like usual.

````rust
#[get("/api/uppercase_ws?name&age")]
async fn uppercase_ws(
    name: String,
    age: i32,
    options: WebSocketOptions,
) -> Result<Websocket<ClientEvent, ServerEvent, CborEncoding>> {
    // ...
}
````

## Connecting to a Websocket

On the client, to connect to a websocket, we'll simply call the server function and await the result. You might do this inside a `use_future` hook to connect to the websocket endpoint when the component is mounted:

````rust
// Calling `.recv()` automatically waits for the connection to be established and deserializes
// messages as they arrive.
use_future(move || async move {
    // Connect to the websocket
    let socket = uppercase_ws(WebSocketOptions::new()).await;

    // Wait for the next message with `.recv()`
    while let Ok(msg) = socket.recv().await {
        messages.push(msg);
    }
});
````

The `Websocket` object has a number of utility methods you can use to assess the state of the connection, send messages, and receive messages. We expose a number of lower-level APIs like `send_raw` that let you send raw websocket frames in case the typed API is too strict.

## The use_websocket hook

You might notice in the `use_future` example above, the websocket is only accessible to its containining scope. In a practical app, you'll want to send messages into the websocket and react to any changes in connection status.

The `use_websocket` hook wraps the `websocket` object with signal-based reactivity. We can use `.status()` to read the websocket connection state, and `.send()` to send messages to the server.

To connect to the websocket, we might use `use_websocket`:

````rust
// The `use_websocket` wraps the `WebSocket` connection and provides a reactive handle to easily
// send and receive messages and track the connection state.
//
// We can customize the websocket connection with the `WebSocketOptions` struct, allowing us to
// set things like custom headers, protocols, reconnection strategies, etc.
let mut socket = use_websocket(|| uppercase_ws("John Doe".into(), 30, WebSocketOptions::new()));
````

To listen for messages, we can use `.recv()` in a future:

````rust
// Calling `.recv()` automatically waits for the connection to be established and deserializes
// messages as they arrive.
use_future(move || async move {
    while let Ok(msg) = socket.recv().await {
        messages.push(msg);
    }
});
````

And then to send messages, we can use `.send()` on the handle:

````rust
rsx! {
    input {
        placeholder: "Type a message",
        oninput: move |e| async move {
            _ = socket.send(ClientEvent::TextInput(e.value())).await;
        },
    }
}
````

If the connection fails, you can restart it by manually calling `.set()` on the handle with a new websocket object.
# Streams and SSE

Dioxus Fullstack provides an easy way to send and receive streaming data from a server. This can be useful to
implement functionality like streaming LLM responses, file downloads, and server-sent-events (SSE).

Unlike websockets which allow two-way communication, streams are unidirectional. In browsers, it's usually impossible to have a streaming input *and* a streaming output, so you should stick to using streams for things like text/byte responses or file sending.

## Streaming Text

Dioxus Fullstack provides the `TextStream` type to easily send chunks of text between the client and the server. We can use this type as the input or output of a server function:

````rust
// The output is a `TextStream`
#[get("/api/test_stream?start")]
async fn text_stream(start: Option<i32>) -> Result<TextStream> {
    let mut count = start.unwrap_or(0);

    // We can create a new text stream with `spawn`
    Ok(TextStream::spawn(move |tx| async move {

        // Send a message with `unbounded_send`
        while tx.unbounded_send(format!("Hello, world! {}", count)).is_ok() {
            count += 1;

            // and then wait a bit
            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        }
    }))
}
````

You can create a new stream with `TextStream::spawn` which gives you an `UnboundedSender` object, or from `TextStream::new()` which takes an existing type that implements the `Stream` trait

````rust
// the `rx` here implements `Stream` which can be used in `new()`
let (tx, rx) = futures::channel::mpsc::unbounded();

tokio::spawn(async move {
    let mut count = start.unwrap_or(0);
    loop {
        let message = format!("Hello, world! {}", count);
        if tx.unbounded_send(message).is_err() {
            break;
        }

        count += 1;
        tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
    }
});

Ok(Streaming::new(rx))
````

## Streaming Bytes

The `TextStream` type is a superset of the `ByteStream` type. To send raw bytes between the client and the server, simply use `ByteStream` in the same way as `TextStream`, but with the `Bytes` type as input:

````rust
#[post("/api/upload_as_bytestream")]
async fn upload_as_bytestream(mut stream: ByteStream) -> Result<()> {
    while let Some(chunk) = stream.next().await {
        // ... handle chunk
    }

    Ok(())
}
````

Note that in this example, we are *consuming* the byte stream using `.next()`. Streams in Dioxus implement the standard [`Stream`](https://docs.rs/futures/latest/futures/prelude/trait.Stream.html) trait, which has a number of [useful extensions](https://docs.rs/futures/latest/futures/stream/trait.StreamExt.html).

## The Generic `Streaming<T, E>` type

Both the `TextStream` and `ByteStream` types are implemented as specific variations of the generic `Streaming<T, E>` type. Under the hood, both stream types are simply streams of `Vec<u8>`. The `ByteStream` type wraps the incoming bytes in the `Bytes` type while `TextStream` ensures they're valid utf-8 text.

You can use any encoding provided it imlpements the `Encoding` trait.

````rust
pub trait Encoding {
    fn content_type() -> &'static str;
    fn stream_content_type() -> &'static str;
    fn to_bytes(data: impl Serialize) -> Option<Bytes>;
    fn from_bytes<O: DeserializeOwned>(bytes: Bytes) -> Option<O>;
}
````

Dioxus provides a number of built-in encodings:

* JsonEncoding: String-encoded JSON text
* CborEncoding: Binary-encoded data in the [CBOR](https://cbor.io) format
* PostcardEncoding: A binary encoding built on [Postcard](https://docs.rs/postcard/latest/postcard/) meant for use in no_std apps
* MsgPackEncoding: A compact binary encoding in a ["JSON but small" format](https://msgpack.org/index.html)

As each element in the stream arrives, it will be appropriately chunked and then deserialized using the encoding's `from_bytes` and `to_bytes` implementations.

This means we can stream arbitrary data - even custom structures!

````rust
#[derive(Serialize, Deserialize, Debug)]
struct Dog {
    name: String,
    age: u8,
}

/// A custom `Streaming<T, E>` endpoint that streams JSON-encoded `Dog` structs to the client.
///
/// Dioxus provides the `JsonEncoding` type which can be used to encode and decode JSON data.
#[get("/api/json_stream")]
async fn json_stream() -> Result<Streaming<Dog, JsonEncoding>> {
    Ok(Streaming::spawn(|tx| async move {
        for count in 0..10 {
            let dog = Dog {
                name: format!("Dog {}", count),
                age: (count % 10) as u8,
            };

            if tx.unbounded_send(dog).is_err() {
                break;
            }

            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        }
    }))
}
````

## File Streams

The final stream type, `FileStream`, is a special stream type *not* built on `Streaming<T, E>`. File streams use platform-native optimizations to efficiently stream files without buffering the entire file into memory.

We can create the `FileStream` object in a variety of ways. For example, we can use `from_path` to efficiently stream arbitrary files from the server's file system:

````rust
/// This endpoint uses `file!()` to return the current file's `PathBuf`
#[get("/api/download_as_filestream")]
async fn download_as_filestream() -> Result<FileStream> {
    Ok(FileStream::from_path(file!()).await?)
}
````

The `FileStream` type can be created from the `FileData` type from dioxus-html. This makes it easy to add streaming file uploads to your app from the HTML `<input />` and `<form />` elements:

````rust
// Our client component calls the endpoint with `file.into()`
fn app() -> Element {
    rsx! {
        h3 { "Upload as FileUpload" }
        div {
            ondragover: move |evt| evt.prevent_default(),
            ondrop: move |evt| async move {
                evt.prevent_default();
                for file in files {
                    _ = upload_file_as_filestream(file.into()).await;
                }
            },
            "Drop files here"
        }
    }
}

// Our server endpoint accepts `FileStream`
#[post("/api/upload_as_file_stream")]
async fn upload_file_as_filestream(mut upload: FileStream) -> Result<()> {
    // ...
}
````

The `FileStream` type also sets extra headers like `Content-Dispostion` and `X-Content-Size` which give the server endpoint more information to efficiently handle the upload.
# Forms and Multipart

Dioxus natively supports HTML Forms and Multipart uploads.

* HTML forms are collections of input elements represented as a list of key-value pairs
* Multipart requests are requests that contain multiple bodies

Many forms you'll build will be rather simple. Uploading them will only require a single request body. In some cases, as with file-uploads, you'll need a multi-part form data.

## Forms

Dioxus Fullstack supports form uploads through Axum's typed `Form<T>` type. Simply wrap a struct that implements `Serialize + Deserialize` and pass it as an argument to a server function:

````rust
// Our form payload
#[derive(Deserialize, Serialize)]
pub struct LoginForm {
    username: String,
    password: String,
}

// Our form endpoint
#[post("/api/login")]
async fn login(form: Form<LoginForm>) -> Result<()> {
    // Verify the username and password.
    // In a real application, you'd check these against a database.
    if form.0.username == "admin" && form.0.password == "password" {
        // ..
    }
}
````

The values from the form can be created manually by constructing the form body, or automatically by calling `.parsed_values()` on the `FormEvent` type created by `onsubmit`.

````rust
rsx! {
    form {
        onsubmit: move |evt: FormEvent| async move {
            // Prevent the browser from navigating away.
            evt.prevent_default();

            // Extract the form values into our `LoginForm` struct. The `.parsed_values` method
            // is provided by Dioxus and works with any form element that has `name` attributes.
            let values: LoginForm = evt.parsed_values().unwrap();

            // Call the login endpoint
            login(Form(values)).await;
        },
        input { r#type: "text", id: "username", name: "username" }
        label { "Username" }
        input { r#type: "password", id: "password", name: "password" }
        label { "Password" }
        button { "Login" }
    }
}
````

Form elements must have a "name" attribute which will be used during the deserialization process to identify form fields.

Note that `GET` requests will encode the form values in the request URL. This might not work for complex data structures, so it's best practice to use `POST` endpoints for handling form data.

## Multipart

With some forms, you'll need to handle multiple request bodies in a single request. For example, if your form has file inputs, the browser will automatically create a multi-part request with the form values in one body and then file uploads in another.

Dioxus provides the `MultipartFormData` type which will automatically convert `FormEvent` objects into proper multi-part requests.

On the client, youd'd convert the `FormEvent` with `.into()`:

````
rsx! {
    form {
        display: "flex",
        flex_direction: "column",
        gap: "8px",
        onsubmit: move |evt| async move {
            evt.prevent_default();

            upload(evt.into()).await;
        },
        label { r#for: "headshot", "Photos" }
        input { r#type: "file", name: "headshot", multiple: true, accept: ".png,.jpg,.jpeg" }
        label { r#for: "resume", "Resume" }
        input { r#type: "file", name: "resume", multiple: false, accept: ".pdf" }
        label { r#for: "name", "Name" }
        input { r#type: "text", name: "name", placeholder: "Name" }
        label { r#for: "age", "Age" }
        input { r#type: "number", name: "age", placeholder: "Age" }
        input { r#type: "submit", name: "submit", value: "Submit your resume" }
    }
}
````

On the server, youd'd use an endpoint that takes `MultipartFormData` and then iterate through the fields using `next_field()`:

````rust
#[post("/api/upload-multipart")]
async fn upload(mut form: MultipartFormData) -> Result<()> {
    while let Ok(Some(field)) = form.next_field().await {
        let name = field.name().unwrap_or("<none>").to_string();
        let file_name = field.file_name().unwrap_or("<none>").to_string();
        let content_type = field.content_type().unwrap_or("<none>").to_string();
        let bytes = field.bytes().await;

        // ...
    }

    Ok(())
}
````

Currently Dioxus does not support typed `MultipartFormData` objects, but it *is* something we'd like to add in the future.
# Authentication

Most production-ready apps have some sort of authentication and authorization to restrict data and resources from being publicly accessible to all users.

Dioxus does *not* provide a built-in way of managing authentication. However, since auth is such a critical component of building fullstack apps, this chapter will help guide you through the process of implementing it for your app.

 > 
 > In the future, we'd like to integrate sessions and auth directly into Dioxus fullstack, but for now, you'll need to rely on 3rd-party libraries.

## What is Authentication?

Authentication is the process of verifying a user's identity, usually through the use of cookies or access tokens.

Your app should not blindly accept actions from untrusted users, so it's important to verify that a user who claims to be "Bob" *actually is* "Bob".

## What is Authorization?

Authorization is the *next step* after authentication. Once a user's identity is verified, you must then verify that they can actually take a given action.

You don't want one user to change another user's login credentials, so any action related to user data must be *authorized* first.

## Auth is Built on Sessions

Fundamentally, auth works by associating a users *connection* with some *session* in a database. As a user traverses our page and makes actions, we need some way of identifying their session on the server.

Usually, this is done via a middleware that automatically registers every connection with a row in your database. If the user is *unauthenticated*, you can either store their session as an anonymous user, or a ignore it competely.

A session is usually inserted with an axum-level middleware:

````rust
dioxus::server::router(app)
    .layer(axum::middleware::from_fn(
        |request: Request, next: Next| async move {
            // Get the auth token and then insert the session into the request's extensions
            //
            // We need to look up the auth token in our database to retrieve the session
            if let Some(token) = request.headers().get("Authorization") {
                if let Some(session) = DATABASE.get_session(token) {
                    request.extensions_mut().insert(session);
                }
            }

            // And then run the request
            next.run(request).await
        },
    ))
````

## Libraries for Authentication

You can implement session lookup and session creation system manually, or use a 3rd-party library like [`axum_session_auth`](https://crates.io/crates/axum_session_auth) to handle most of the complexity for you.

Generally, you'll add a 3rd-party library as a `.layer()` on your router, and it will add the `Session` extension to your requests automatically:

````rust
dioxus::serve(|| async move {
    // Create an axum router that dioxus will attach the app to
    Ok(dioxus::server::router(app)
        // Add the `AuthLayer`
        .layer(
            AuthLayer::new(Some(db.clone()))
                .with_config(AuthConfig::<i64>::default().with_anonymous_user_id(Some(1))),
        )
        // And add the `SessionLayer`
        .layer(SessionLayer::new(
            SessionStore::<SessionSqlitePool>::new(
                Some(db.into()),
                SessionConfig::default().with_table_name("test_table"),
            )
            .await?,
        )))
})
````

The `axum_session_auth` crate integrates with `Sqlx` to automatically manage sessions using a row in your database.

## Auth as an Extractor

You can use extractors to integrate auth with your Fullstack application.

You can create a custom extractor to extract the auth session from the request. From that auth session, you can check if the user has the required privileges before returning the private data.

Because the sessions are inserted into every request, you can extract them with server-only extractors:

````rust
/// We use the `auth::Session` extractor to get access to the current user session.
/// This lets us modify the user session, log in/out, and access the current user.
#[post("/api/user/login", auth: auth::Session)]
pub async fn login() -> Result<()> {
    auth.login_user(2);
    Ok(())
}

/// Just like `login`, but this time we log out the user.
#[post("/api/user/logout", auth: auth::Session)]
pub async fn logout() -> Result<()> {
    auth.logout_user();
    Ok(())
}
````

A [full auth example](https://github.com/DioxusLabs/dioxus/blob/7102bc3b6a0ddea3a9e71423fc6d667df8d956f3/examples/07-fullstack/auth/src/main.rs) with the complete implementation is available in the fullstack examples.

## Auth as a 3rd-party service

Implementing auth can be somewhat tedious, so there are a number of 3rd party services that simplify the implementation for you. With these services, the session and auth data tends to not live in *your database*, but rather theirs.

We don't recommend any particular 3rd party service. However, there are some solutions like Supabase and Firebase where sessions are managed in your database, but with prebuilt infrastructure for you to integrate with.
# Native Clients

So far, we've focused on using fullstack alongside a web application. However, not all apps you'll build with Dioxus will be loaded in a web browser. Dioxus supports mobile apps and desktop apps as well.

On these platforms, fullstack works a bit differently. You can still use server functions, but things like server-side-rendering no-longer apply.

## Developing a Native Fullstack App

Developing a native fullstack app works just the same as developing a fullstack web app. Make sure your `Cargo.toml` has the appropriate features:

````toml
[dependencies]
dioxus = { verison = "0.7", features = ["fullstack"] }

[features]
server = ["dioxus/server"]
desktop = ["dioxus/desktop"]
````

And then, to serve the app, use `dx serve --<platform>`:

````sh
dx serve --desktop
````

## Server Functions for Native App

When you build a native app that relies on server functions, you can freely call any server function just as you would with a web app.

This simple hello world app works the same on web, desktop, and mobile:

````rust
use dioxus::prelude::*;

fn main() {
    dioxus::launch(|| {
        let mut message = use_action(get_message);

        rsx! {
            h1 { "Server says: "}
            pre { "{message:?}"}
            button { onclick: move |_| message.call("world".into(), 30), "Click me!" }
        }
    });
}

#[get("/api/{name}/?age")]
async fn get_message(name: String, age: i32) -> Result<String> {
    Ok(format!("Hello {}, you are {} years old!", name, age))
}
````

Your native code can still make requests to your backend. However, when if you deployed your app to production, you might notice that the native app *does not know where to make requests*.

In the web, requests are always made to the current host origin. For example, requests to this endpoint are made to `/api/dogs`:

````rust
#[get("/api/dogs")]
async fn get_message() -> Result<()> {
    // ..
}
````

Desktop and mobiles are not served from a specific URL, and thus do not know which host to make a request to.

To set a specific server URL, you must call `set_server_url` before making any requests:

````rust
fn main() {
    #[cfg(not(feature = "server"))]
    dioxus::fullstack::set_server_url("https://hot-dog.fly.dev");

    dioxus::launch(app);
}
````

This ensures that requests are always properly joined with the correct host.

## Disabled Fullstack Features

When using fullstack with native apps, a number of features and optimizations are disabled. Native apps are usually meant to be used offline, so their rendering needs to happen entirely on the client. Architecturally, native apps are similar to single-page-applications (SPA) where the bundle loads and *then* HTTP requests are made to load content.

As such, a number of functions are disabled:

* There is no hydration context, and thus no hydration data to hydrate the page
* The app is never rendered on the server, skipping `[cfg(feature = "server")]` code
* There is no `FullstackContext` when rendering components
* HTML Streaming and SSG have no effect

Functionally, this won't change how you build your apps, but you should be aware that some code might never be executed.

## Prefer Known Endpoints

Dioxus supports two ways of annotating server functions:

* Explicitly with `#[get]`, `#[post]`, `#[delete]`, etc.
* Anonymously with `#[server]`

When you use the `#[server]` macro, the endpoint path is free to change as you update the endpoint's signature and body. If you re-redeploy your backend, URLs that worked previously are not guaranteed to exist in the future.

````rust
// ❌ this endpoint generates `/api/do_it12nldkj2378jnakls`
#[server]
async fn do_it() -> Result<()> {
    //
}
````

Because the endpoint receives a hash, its name is unique and might change as you update its code.

When using server functions with native clients, we strongly recommend using the `#[get]` / `#[post]` annotations since they guarantee a stable endpoint.

````rust
// ✅ This endpoint is stable
#[post("/api/do_it")]
async fn do_it() -> Result<()> {
    //
}
````

## Versioning

Because native clients are distributed as downloadable software, they might not always up to date as the latest version of your code. This can be particularly challenging when you want to update the signature of an endpoint.

````rust
// version 1
#[post("/api/do_it")]
async fn do_it() -> Result<()> { /* */ }

// version 2
// ❌ we are breaking old clients!
#[post("/api/do_it")]
async fn do_it(name: String) -> Result<()>  { /* */ }
````

We hope this problem is obvious to you - if you re-redploy your backend with breaking changes, previous clients will break!

To upgrade APIs, we recommend one of two options:

* Use `Option<T>` to add new fields
* Use `/api/v1`, `/api/v2/` versioning

For most API upgrades, you can simply add new fields by making new values optional with `Option<T>`:

````rust
// version 2
// ✅ Option<String> means `name` is not required
#[post("/api/do_it")]
async fn do_it(name: Option<String>) -> Result<()>  { /* */ }
````

For API changes that require much larger changes, we recommend using a versioning scheme to create different versions of the API accessible by the client:

````rust
// This is at /api/v1/
#[post("/api/v1/do_it")]
async fn do_it() -> Result<()> { /* */ }

// This is at api/v2
#[post("/api/v2/do_it")]
async fn do_it(name: String) -> Result<()> { /* */ }
````

Creating different API versions is common practice and helps prevent breaking old clients as you update your app.

## Deploying

You can deploy native fullstack apps just the same as you would deploy a regular web app. Server apps always generate a `server` binary and a `/public/` folder. Native apps will generate an app bundle (`.app`, `.ipa`, `.apk`, etc).

You can distribute the native app via an app store or by making the file downloadable to your users.

To distribute the server, simply upload it to a hosting provider of your choice. As long as you set the `server_url` in the native app, you should be able to access your backend from the native client.
# Streaming

For some sites, it is extremely important to optimize "time-to-first-byte". Users want to see results as soon as possible, even if not *all* results are ready immediately.

Dioxus supports this usecase with a technology called *"HTML Streaming"*. HTML streaming allows you to quickly send an initial skeleton of the page to the user and then fill in various components as their data loads.

## What is Streaming?

The default rendering mode in dioxus fullstack waits for all [suspense boundaries](../advanced/suspense.md#suspense-with-fullstack) to resolve before sending the entire page as HTML to the client. If you have a page with multiple chunks of async data, the server will wait for all of them to complete before rendering the page.

When streaming is enabled, the server can send chunks of HTML to the client as soon as each suspense boundary resolves. You can start interacting with a page as soon as the first part of the HTML is sent, instead of waiting for the entire page to be ready. This can lead to a much faster initial load time.

Bellow is the same [hackernews example](https://github.com/DioxusLabs/dioxus/tree/main/examples/01-app-demos/hackernews) rendered with and without streaming enabled. While both pages take the same amount of time to load all the data, the page with streaming enabled on the left shows you the data as soon as it becomes available.

````inject-dioxus
DemoFrame {
    overflow: "hidden",
    FakePage {
        div {
            display: "flex",
            flex_direction: "row",
            justify_content: "space-around",
            align_items: "center",
            height: "100%",
            width: "100%",
            img {
                max_height: "100%",
                max_width: "50%",
                aria_label: "Hackernews with streaming enabled",
                src: asset!("/assets/static/streaming-enabled-hackernews"),
            }
            img {
                max_height: "100%",
                max_width: "50%",
                aria_label: "Hackernews with streaming disabled",
                src: asset!("/assets/static/streaming-disabled-hackernews"),
            }
        }
    }
}
````

## SEO and No JS

When streaming is enabled, all of the contents of the page are still rendered into the html document, so search engines can still crawl and index the full content of the page. However, the content will not be visible to users unless they have JavaScript enabled. If you want to support users without JavaScript, you will need to disable streaming and use the default rendering mode.

## Do You Need Streaming?

HTML streaming is best suited for apps like e-commerce sites where much of the data is quick to render (the product image, description, etc) but some data takes much longer to resolve. In these cases, you don't want to make the user wait too long for the page to load, so you send down what you have as soon as possible.

Streaming adds some slight overhead and complexity to your app, so it's disabled by default.

## Enabling Streaming

You can enable streaming in the ServeConfig builder with the `enable_out_of_order_streaming` method. If you are launching your application through the `dioxus::LaunchBuilder`, you can use the `with_cfg` method to pass in a configuration that enables streaming:

````rs@streaming.rs
pub fn main() {
    dioxus::LaunchBuilder::new()
        .with_cfg(server_only! {
            dioxus::server::ServeConfig::builder().enable_out_of_order_streaming()
        })
        .launch(app);
}
````

or if you are using a custom axum server, you can pass the config into `serve_dioxus_application` directly:

````rs@streaming.rs
#[cfg(feature = "server")]
#[tokio::main]
async fn main() {
    let addr = dioxus::cli_config::fullstack_address_or_localhost();
    let router = axum::Router::new()
        // Server side render the application, serve static assets, and register server functions
        .serve_dioxus_application(
            dioxus::server::ServeConfig::builder().enable_out_of_order_streaming(),
            app,
        )
        .into_make_service();
    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, router).await.unwrap();
}
````

## Head elements with streaming

Head elements can only be rendered in the initial HTML chunk that contains the `<head>` tag. You should include all of your `document::Link`, `document::Meta`, and `document::Title` elements in the first part of your page if possible. If you have any head elements that are not included in the first chunk, they will be rendered by the client after hydration instead, which will not be visible to any search engines or users without JavaScript enabled.

The initial chunk of HTML is send after [commit_initial_chunk](https://docs.rs/dioxus-fullstack/0.7.0-alpha.1/dioxus_fullstack/prelude/fn.commit_initial_chunk.html) is called for the first time. If you are using the router, this will happen automatically when all suspense boundaries above the router are resolved. If you are not using the router, you can call `commit_initial_chunk` manually after all of your blocking head elements have been rendered.

````rs@streaming.rs
/// An enum of all of the possible routes in the app.
#[derive(Routable, Clone)]
enum Route {
    // The home page is at the / route
    #[route("/")]
    Home,
}

fn Home() -> Element {
    let title = use_server_future(get_title)?;
    let description = use_server_future(get_description)?;

    rsx! {
        // This will be rendered on the server because it is inside the same (root)
        // suspense boundary as the `Router` component.
        document::Title { {title} }
        SuspenseBoundary {
            fallback: |_| {
                rsx! { "Loading..." }
            },
            AsyncHead {}
        }
    }
}

fn AsyncHead() -> Element {
    let description = use_server_future(get_description)?;
    // The resource should always be resolved at this point because the `?` above bubbles
    // up the async case if it is pending
    let current_description = description.read_unchecked();
    let current_description = current_description.as_ref().unwrap();

    rsx! {
        // This will be rendered on the client because it is in a
        // suspense boundary below the `Router` component.
        document::Meta { name: "description", content: "{current_description}" }
    }
}
````

## Response Headers with Streaming

When rendering an app with streaming enabled, Dioxus will wait for the app to commit its initial skeleton before sending a response to the user's request. This is done with the `commit_initial_chunk()` method.

Once the initial chunk is committed, you can no longer change the headers of the response nor change the HTTP status.

For example, you might have a server function that throws a 404 status code:

````rust
#[get("/api/post/{id}")]
async fn get_post(id: u32) -> Result<String, HttpError> {
    match id {
        1 => Ok("first post".to_string()),
        _ => HttpError::not_found("Post not found")?,
    }
}
````

With streaming disabled, if this status code is bubbled to the root component as an error, the user will get a `404 NOT FOUND` status in the response.

````rust
#[component]
fn Post(id: ReadSignal<u32>) -> Element {
    // If `get_post` returns a 404, then the user will also get a 404
    let post_data = use_loader(move || get_post(id()))?;

    rsx! {
        h1 { "Post {id}" }
        p { "{post_data}" }
    }
}
````

However, when streaming is *enabled*, the status code from this server function will only be propagated to the user *before* the call to `commit_initial_chunk()`.

Normally, you won't call `commit_initial_chunk()` yourself since the `Router` component calls it for you once the root suspense boundary is resolved.

This means that, when suspense is enabled, server functions won't set the HTTP status code if they are called from within a dedicated suspense boundary:

````rust
fn Home() -> Element {
    rsx! {
        SuspenseBoundary {
            fallback: |_| rsx! { "loading..." },

            // Errors here won't propagate to the response headers
            Post { id: 123 }
        }
    }
}
````
# Static Site Generation

Static site generation (SSG) lets you pre-generate all static pages of your application at build time. Once you have the static HTML pages, you can deploy them to any static hosting provider like GitHub Pages.

SSG is extremely powerful since it lets you cache the rendering of your pages before deploying to production. This cuts down on bandwidth costs, lets you cache content on a CDN, and allows for deploying *without* a server. Many deploy providers let you deploy SSG sites for free!

## How Dioxus SSG works

Dioxus SSG works by running your app locally, querying the app for a sitemap, and then indexing your site using `curl` requests manually. If your site is configured to use SSG, then it will cache HTML for each page on the filesystem.

This approach to SSG is quite different than a traditional static-site-generator like Hugo, Jekyll, or Zola. Dioxus SSG is designed to let you write your entire site in Rust, load data however you want, and then deploy a hybrid SSG app that loads SPA content.

## You might not need SSG

Even if your app has a significant amount of static content, you might not actually need SSG. You should use SSG in a few cases:

* You have *lots* of static content that benefits from pre-rendering before deploy
* You don't need a backend for your site

Sites like docs and portfolios benefit from SSG while apps like photo editors will not. In many cases, you can simply set `Cache-Control` headers while rendering pages and let your CDN or reverse-proxy handle caching for you!

## Setting up the ServeConfig

SSG builds on top of the incremental rendering feature of Dioxus fullstack. We need to set up the `ServeConfig` to enable incremental rendering. The incremental config needs to render to the `public` directory where Dioxus places all other public files like the wasm binary and static assets. The `public` directory in the web folder will always be placed alongside the server binary.

````rs@static_site_generation.rs
fn main() {
    dioxus::LaunchBuilder::new()
        // Set the server config only if we are building the server target
        .with_cfg(server_only! {
            ServeConfig::builder()
                // Enable incremental rendering
                .incremental(
                    dioxus::server::IncrementalRendererConfig::new()
                        // Store static files in the public directory where other static assets like wasm are stored
                        .static_dir(
                            std::env::current_exe()
                                .unwrap()
                                .parent()
                                .unwrap()
                                .join("public")
                        )
                        // Don't clear the public folder on every build. The public folder has other files including the wasm
                        // binary and static assets required for the app to run
                        .clear_cache(false)
                )
                .enable_out_of_order_streaming()
        })
        .launch(app);
}
````

## Configuring static routes

Once you have incremental rendering enabled, you need to tell the CLI about the static routes in your app. The CLI looks for a server function at the endpoint `"static_routes"` that returns a list of all static urls. It will call this server function at build time and pre-render all of the routes in the list.

````rs@static_site_generation.rs
#[derive(Routable, Clone, PartialEq)]
pub enum Route {
    // Any routes with no dynamic segments in your router will be included in the static routes list
    #[route("/")]
    Index {},

    #[route("/other")]
    Other {},
}

// The server function at the endpoint "static_routes" will be called by the CLI to generate the list of static
// routes. You must explicitly set the endpoint to `"static_routes"` in the server function attribute instead of
// the default randomly generated endpoint.
#[server(endpoint = "static_routes", output = server_fn::codec::Json)]
async fn static_routes() -> Result<Vec<String>, ServerFnError> {
    // The `Routable` trait has a `static_routes` method that returns all static routes in the enum
    Ok(Route::static_routes()
        .iter()
        .map(ToString::to_string)
        .collect())
}
````

## Publishing static sites

Finally, you can bundle your site with `dx bundle --web --ssg`. Once the CLI finishes bundling, you should see a `public` folder in the dx folder of your project:

![Dioxus SSG](/assets/06_docs/ssg_folder.png)

The folder contains all of the static assets that you need to serve your site. You can copy the public folder into any static hosting provider like GitHub Pages.
# Introduction

As your app grows, it can be helpful to organize your app into multiple pages or views you can switch between. In web application, each view has an associated url that can be saved and shared. The Dioxus router helps you manage the URL state of your application. It provides a type safe interface that checks all routes at compile time to prevent runtime errors.

## Installing the router

To get started, you can add the `router` feature to your `dioxus` dependency in your `Cargo.toml`:

````toml
[dependencies]
dioxus = { version = "0.7", features = ["router"] }
````

## Creating a Routable enum

The core of the router is your `Routable` enum. You will use this enum throughout your application to navigate to different pages. Each variant of the enum is a single view page in your app handles:

1. Parsing your route from a URL
1. Displaying your route as a URL
1. Rendering your route as a component

To create a `Routable` enum, you will need to derive the `Routable` with a `#[route(..)]` attribute on each variant which describes the format of the route. You must have a component in scope that matches the name of each variant to render the route:

````rs@router_introduction.rs
use dioxus::prelude::*;

#[derive(Clone, Debug, PartialEq, Routable)]
enum Route {
    #[route("/")]
    Home,

    #[route("/about")]
    About,

    #[route("/user/:id")]
    User { id: u32 },
}

#[component]
fn Home() -> Element {
    rsx! { "Welcome to the home page!" }
}

#[component]
fn About() -> Element {
    rsx! { "This is the about page." }
}

#[component]
fn User(id: u32) -> Element {
    rsx! { "User page for user with id: {id}" }
}
````

## Rendering the router

Now that you have defined your routes, you can use the `Router` component to render them. The `Router` component takes your `Routable` enum as a generic argument to define handle parsing, and rendering routes.

````rs@router_introduction.rs
fn main() {
    dioxus::launch(|| rsx! { Router::<Route> {} });
}
````

## Linking to your first route

To navigate between routes, you can use the `Link` component provided by the router. The `Link` component takes a `to` prop which can be either a unchecked string route or a variant of your `Routable` enum:

````rust@router_introduction.rs
// ...

#[component]
fn Home() -> Element {
    rsx! {
        div {
            "Welcome to the home page!"
            Link { to: Route::About, "Go to About Page" }
        }
    }
}
````
# Defining Routes

When creating a `Routable` enum, we can define routes for our application using the `route("path")` attribute.

## Route Segments

Each route is made up of segments. Most segments are separated by `/` characters in the path.

There are five fundamental types of segments:

1. [Static segments](#static-segments) are fixed strings that must be present in the path.
1. [Dynamic segments](#dynamic-segments) are types that can be parsed from a segment.
1. [Catch-all segments](#catch-all-segments) are types that can be parsed from multiple segments.
1. [Query segments](#query-segments) are types that can be parsed from the query string.
1. [Hash fragments](#hash-segments) are types that can be parsed from the hash fragment.

Routes are matched:

* First, from most specific to least specific (Static then Dynamic then Catch All) (Query and hash are always matched)
* Then, if multiple routes match the same path, the order in which they are defined in the enum is followed.

## Static segments

Fixed routes match a specific path. For example, the route `#[route("/about")]` will match the path `/about`.

````rs@static_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // Routes always start with a slash
    #[route("/")]
    Home {},
    // You can have multiple segments in a route
    #[route("/hello/world")]
    HelloWorld {},
}

#[component]
fn Home() -> Element {
    todo!()
}

#[component]
fn HelloWorld() -> Element {
    todo!()
}
````

## Dynamic Segments

Dynamic segments are in the form of `:name` where `name` is
the name of the field in the route variant. If the segment is parsed
successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromStr`.

````rs@dynamic_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with : are dynamic segments
    #[route("/post/:name")]
    BlogPost {
        // You must include dynamic segments in child variants
        name: String,
    },

    #[route("/document/:id")]
    Document {
        // You can use any type that implements FromStr
        // If the segment can't be parsed, the route will not match
        id: usize,
    },
}

// Components must contain the same dynamic segments as their corresponding variant
#[component]
fn BlogPost(name: String) -> Element {
    todo!()
}

#[component]
fn Document(id: usize) -> Element {
    todo!()
}
````

## Catch All Segments

Catch All segments are in the form of `:..name` where `name` is the name of the field in the route variant. If the segments are parsed successfully then the route matches, otherwise the matching continues.

The segment can be of any type that implements `FromSegments`. (`Vec<String>` implements this by default)

Catch All segments must be the *last route segment* in the path (query segments are not counted) and cannot be included in nests.

````rs@catch_all_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with :.. are catch all segments
    #[route("/blog/:..segments")]
    BlogPost {
        // You must include catch all segment in child variants
        segments: Vec<String>,
    },
}

// Components must contain the same catch all segments as their corresponding variant
#[component]
fn BlogPost(segments: Vec<String>) -> Element {
    todo!()
}
````

## Query Segments

Query segments are in the form of `?:name&:othername` where `name` and `othername` are the names of fields in the route variant.

Unlike [Dynamic Segments](#dynamic-segments) and [Catch All Segments](#catch-all-segments), parsing a Query segment must not fail.

The segment can be of any type that implements `FromQueryArgument`.

Query segments must be the *after all route segments* and cannot be included in nests.

````rs@query_segments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with ?: are query segments
    #[route("/blog?:name&:surname")]
    BlogPost {
        // You must include query segments in child variants
        name: String,
        surname: String,
    },
}

#[component]
fn BlogPost(name: String, surname: String) -> Element {
    rsx! {
        div { "This is your blogpost with a query segment:" }
        div { "Name: {name}" }
        div { "Surname: {surname}" }
    }
}
````

## Hash Segments

Hash segments are in the form of `#:field` where `field` is a field in the route variant.

Just like [Query Segments](#query-segments), parsing a Hash segment must not fail.

The segment can be of any type that implements `FromHashFragment`.

Hash fragments must be the *after all route segments and any query segments* and cannot be included in nests.

````rs@hash_fragments.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    // segments that start with #: are hash segments
    #[route("/blog#:name")]
    BlogPost {
        // You must include hash segments in child variants
        name: String,
    },
}

#[component]
fn BlogPost(name: String) -> Element {
    rsx! {
        div { "This is your blogpost with a query segment:" }
        div { "Name: {name}" }
    }
}
````

## Nested Routes

When developing bigger applications we often want to nest routes within each
other. As an example, we might want to organize a settings menu using this
pattern:

````plain
└ Settings
  ├ General Settings (displayed when opening the settings)
  ├ Change Password
  └ Privacy Settings
````

We might want to map this structure to these paths and components:

````plain
/settings		  -> Settings { GeneralSettings }
/settings/password -> Settings { PWSettings }
/settings/privacy  -> Settings { PrivacySettings }
````

Nested routes allow us to do this without repeating /settings in every route.

### Nesting

To nest routes, we use the `#[nest("path")]` and `#[end_nest]` attributes.

The path in nest must not:

1. Contain a [Catch All Segment](routes.md#catch-all-segments)
1. Contain a [Query Segment](routes.md#query-segments)

If you define a dynamic segment in a nest, it will be available to all child routes and layouts.

To finish a nest, we use the `#[end_nest]` attribute or the end of the enum.

````rs@nest.rs
#[derive(Routable, Clone)]
// Skipping formatting allows you to indent nests
#[rustfmt::skip]
enum Route {
    // Start the /blog nest
    #[nest("/blog")]
        // You can nest as many times as you want
        #[nest("/:id")]
            #[route("/post")]
            PostId {
                // You must include parent dynamic segments in child variants
                id: usize,
            },
        // End nests manually with #[end_nest]
        #[end_nest]
        #[route("/:id")]
        // The absolute route of BlogPost is /blog/:name
        BlogPost {
            id: usize,
        },
    // Or nests are ended automatically at the end of the enum
}

#[component]
fn BlogPost(id: usize) -> Element {
    todo!()
}

#[component]
fn PostId(id: usize) -> Element {
    todo!()
}
````
# Links & Navigation

When we split our app into pages, we need to provide our users with a way to
navigate between them. On regular web pages, we'd use an anchor element for that,
like this:

````html
<a href="/other">Link to an other page</a>
````

However, we cannot do that when using the router for three reasons:

1. Anchor tags make the browser load a new page from the server. This takes a
   lot of time, and it is much faster to let the router handle the navigation
   client-side.
1. Navigation using anchor tags only works when the app is running inside a
   browser. This means we cannot use them inside apps using Dioxus Desktop.
1. Anchor tags cannot check if the target page exists. This means we cannot
   prevent accidentally linking to non-existent pages.

To solve these problems, the router provides us with a [`Link`] component we can
use like this:

````rs@links.rs
#[component]
fn NavBar() -> Element {
    rsx! {
        nav {
            Link { to: Route::Home {}, "Home" }
        }
        Outlet::<Route> {}
    }
}
````

The `target` in the example above is similar to the `href` of a regular anchor
element. However, it tells the router more about what kind of navigation it
should perform. It accepts something that can be converted into a
[`NavigationTarget`]:

* The example uses a Internal route. This is the most common type of navigation.
  It tells the router to navigate to a page within our app by passing a variant of a \[`Routable`\] enum. This type of navigation can never fail if the link component is used inside a router component.
* \[`External`\] allows us to navigate to URLs outside of our app. This is useful
  for links to external websites. NavigationTarget::External accepts an URL to navigate to. This type of navigation can fail if the URL is invalid.

 > 
 > The [`Link`] accepts several props that modify its behavior. See the API docs
 > for more details.

# Programmatic Navigation

Sometimes we want our application to navigate to another page without having the
user click on a link. This is called programmatic navigation.

## Using a Navigator

We can get a navigator with the [`navigator`] function which returns a [`Navigator`].

We can use the [`Navigator`] to trigger four different kinds of navigation:

* `push` will navigate to the target. It works like a regular anchor tag.
* `replace` works like `push`, except that it replaces the current history entry
  instead of adding a new one. This means the prior page cannot be restored with the browser's back button.
* `Go back` works like the browser's back button.
* `Go forward` works like the browser's forward button.

````rs@navigator.rs
#[component]
fn Home() -> Element {
    let nav = navigator();

    // push
    nav.push(Route::PageNotFound { route: vec![] });

    // replace
    nav.replace(Route::Home {});

    // go back
    nav.go_back();

    // go forward
    nav.go_forward();

    rsx! { h1 { "Welcome to the Dioxus Blog!" } }
}
````

You might have noticed that, like [`Link`], the [`Navigator`]s `push` and
`replace` functions take a [`NavigationTarget`]. This means we can use either
`Internal`, or `External` targets.

## External Navigation Targets

Unlike a [`Link`], the [`Navigator`] cannot rely on the browser (or webview) to
handle navigation to external targets via a generated anchor element.

This means, that under certain conditions, navigation to external targets can
fail.

# History Providers

\[`HistoryProvider`\]s are used by the router to keep track of the navigation history
and update any external state (e.g. the browser's URL).

The router provides two \[`HistoryProvider`\]s, but you can also create your own.
The two default implementations are:

* The \[`MemoryHistory`\] is a custom implementation that works in memory.
* The \[`LiveviewHistory`\] is a custom implementation that works with the liveview renderer.
* The \[`WebHistory`\] integrates with the browser's URL.

By default, the router uses the \[`MemoryHistory`\]. It might be changed to use
\[`WebHistory`\] when the `web` feature is active, but that is not guaranteed.

You can override the default history:

````rs@history_provider.rs
#[component]
fn App() -> Element {
    rsx! {
        Router::<Route> { config: || RouterConfig::default() }
    }
}
````

# Routing Update Callback

In some cases, we might want to run custom code when the current route changes. For this reason, the [`RouterConfig`] exposes an `on_update` field.

## How does the callback behave?

The `on_update` is called whenever the current routing information changes. It is called after the router updated its internal state, but before dependent components and hooks are updated.

If the callback returns a [`NavigationTarget`], the router will replace the current location with the specified target. It will not call the `on_update` again.

If at any point the router encounters a navigation failure, it will go to the appropriate state without calling the `on_update`. It doesn't matter if the invalid target initiated the navigation, was found as a redirect target, or was returned by the `on_update` itself.

## Code Example

````rs@routing_update.rs
#[derive(Routable, Clone, PartialEq)]
enum Route {
    #[route("/")]
    Index {},
    #[route("/home")]
    Home {},
}

#[component]
fn Home() -> Element {
    rsx! {
        p { "Home" }
    }
}

#[component]
fn Index() -> Element {
    rsx! {
        p { "Index" }
    }
}

fn app() -> Element {
    rsx! {
        Router::<Route> {
            config: || {
                RouterConfig::default()
                    .on_update(|state| {
                        (state.current() == Route::Index {})
                            .then_some(NavigationTarget::Internal(Route::Home {}))
                    })
            },
        }
    }
}
````

# History Buttons

Some platforms, like web browsers, provide users with an easy way to navigate
through an app's history. They have UI elements or integrate with the OS.

However, native platforms usually don't provide such amenities, which means that
apps wanting users to have access to them, need to implement them. For this
reason, the router comes with two components, which emulate a browser's back and
forward buttons:

* [`GoBackButton`]
* [`GoForwardButton`]

````rs@history_buttons.rs
fn HistoryNavigation() -> Element {
    rsx! {
        GoBackButton { "Back to the Past" }
        GoForwardButton { "Back to the Future" }
    }
}
````

As you might know, browsers usually disable the back and forward buttons if
there is no history to navigate to. The router's history buttons try to do that
too, but depending on the \[history provider\] that might not be possible.

Importantly, neither `WebHistory` supports that feature.
This is due to limitations of the browser History API.

However, in both cases, the router will just ignore button presses, if there is
no history to navigate to.

Also, when using `WebHistory`, the history buttons might
navigate a user to a history entry outside your app.
# Layouts

Layouts allow you to wrap all child routes in a component. This can be useful when creating something like a header that will be used in many different routes.

[`Outlet`] tells the router where to render content in layouts. In the following example,
the Index will be rendered within the [`Outlet`].

Here is a more complete example of a layout wrapping the body of a page.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/")]
        Index {},
}

#[component]
fn Wrapper() -> Element {
    rsx! {
        header { "header" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index() -> Element {
    rsx! { h1 { "Index" } }
}
````

The example above will output the following HTML (line breaks added for
readability):

````html
<header>header</header>
<h1>Index</h1>
<footer>footer</footer>
````

## Layouts with dynamic segments

You can combine layouts with nested routes to create dynamic layouts with content that changes based on the current route.

Just like routes, layouts components must accept a prop for each dynamic segment in the route. For example, if you have a route with a dynamic segment like `/:name`, your layout component must accept a `name` prop:

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[nest("/:name")]
        #[layout(Wrapper)]
            #[route("/")]
            Index {
                name: String,
            },
}

#[component]
fn Wrapper(name: String) -> Element {
    rsx! {
        header { "Welcome {name}!" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index(name: String) -> Element {
    rsx! { h1 { "This is a homepage for {name}" } }
}
````

Or to get the full route, you can use the `use_route` hook.

````rs@outlet.rs
#[derive(Routable, Clone)]
#[rustfmt::skip]
enum Route {
    #[layout(Wrapper)]
        #[route("/:name")]
        Index {
            name: String,
        },
}

#[component]
fn Wrapper() -> Element {
    let full_route = use_route::<Route>();
    rsx! {
        header { "Welcome to {full_route}!" }
        // The index route will be rendered here
        Outlet::<Route> {}
        footer { "footer" }
    }
}

#[component]
fn Index(name: String) -> Element {
    rsx! { h1 { "This is a homepage for {name}" } }
}
````
# Advanced Topics

This section covers a variety of advanced topics you may find useful as your dioxus app grows. It covers topic from organizing your app with custom hooks to breaking out of dioxus with effects.

## Table of Contents

* [Custom hooks](./custom_hooks.md) In addition to the built-in hooks, Dioxus lets you create your own custom hooks to encapsulate logic you can use throughout your components.
* [Component Lifecycle](./lifecycle.md) Every component in dioxus follows the same, mount, diff and drop lifecycle. This section covers how to hook into that lifecycle.
* [Suspense](./suspense.md) Suspense lets wait for async data and provides a way to show a unified loading view for a group of components.
* [Breaking Out](./breaking_out.md) Sometimes the apis provided by dioxus aren't enough. This section covers how to break out of dioxus and use your own apis to manipulate the DOM or call JS functions.
# Custom Hooks

Hooks are a great way to encapsulate business logic. If none of the existing hooks work for your problem, you can write your own.

When writing your hook, you can make a function that starts with `use_` and takes any arguments you need. You can then use the `use_hook` method to create a hook that will be called the first time the component is rendered.

## Composing Hooks

To avoid repetition, you can encapsulate business logic based on existing hooks to create a new hook.

For example, if many components need to access an `AppSettings` struct, you can create a "shortcut" hook:

````rs@hooks_composed.rs
fn use_settings() -> Signal<AppSettings> {
    consume_context()
}
````

Or if you want to wrap a hook that persists reloads with the storage API, you can build on top of the use_signal hook to work with mutable state:

````rs@hooks_composed.rs
use gloo_storage::{LocalStorage, Storage};
use serde::{de::DeserializeOwned, Serialize};

/// A persistent storage hook that can be used to store data across application reloads.
#[allow(clippy::needless_return)]
pub fn use_persistent<T: Serialize + DeserializeOwned + Default + 'static>(
    // A unique key for the storage entry
    key: impl ToString,
    // A function that returns the initial value if the storage entry is empty
    init: impl FnOnce() -> T,
) -> UsePersistent<T> {
    // Use the use_signal hook to create a mutable state for the storage entry
    let state = use_signal(move || {
        // This closure will run when the hook is created
        let key = key.to_string();
        let value = LocalStorage::get(key.as_str()).ok().unwrap_or_else(init);
        StorageEntry { key, value }
    });

    // Wrap the state in a new struct with a custom API
    UsePersistent { inner: state }
}

struct StorageEntry<T> {
    key: String,
    value: T,
}

/// Storage that persists across application reloads
pub struct UsePersistent<T: 'static> {
    inner: Signal<StorageEntry<T>>,
}

impl<T> Clone for UsePersistent<T> {
    fn clone(&self) -> Self {
        *self
    }
}

impl<T> Copy for UsePersistent<T> {}

impl<T: Serialize + DeserializeOwned + Clone + 'static> UsePersistent<T> {
    /// Returns a reference to the value
    pub fn get(&self) -> T {
        self.inner.read().value.clone()
    }

    /// Sets the value
    pub fn set(&mut self, value: T) {
        let mut inner = self.inner.write();
        // Write the new value to local storage
        LocalStorage::set(inner.key.as_str(), &value);
        inner.value = value;
    }
}
````

## Custom Hook Logic

You can use [`use_hook`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_hook.html) to build your own hooks. In fact, this is what all the standard hooks are built on!

`use_hook` accepts a single closure for initializing the hook. It will be only run the first time the component is rendered. The return value of that closure will be used as the value of the hook – Dioxus will take it, and store it for as long as the component is alive. On every render (not just the first one!), you will get a reference to this value.

 > 
 > Note: You can use the `use_on_destroy` hook to clean up any resources the hook uses when the component is destroyed.

Inside the initialization closure, you will typically make calls to other dioxus runtime methods. For example:

* The `use_signal` hook tracks state in the hook value, and uses [`ReactiveContext`](https://docs.rs/dioxus/latest/dioxus/prelude/struct.ReactiveContext.html) to make Dioxus re-render any component that has observed it whenever the signal's value changes.

Here is a simplified implementation of the `use_signal` hook:

````rs@hooks_custom_logic.rs
use std::cell::RefCell;
use std::collections::HashSet;
use std::rc::Rc;
use std::sync::{Arc, Mutex};

struct Signal<T> {
    value: Rc<RefCell<T>>,
    subscribers: Arc<Mutex<HashSet<ReactiveContext>>>,
}

impl<T> Clone for Signal<T> {
    fn clone(&self) -> Self {
        Self {
            value: self.value.clone(),
            subscribers: self.subscribers.clone(),
        }
    }
}

fn my_use_signal<T: 'static>(init: impl FnOnce() -> T) -> Signal<T> {
    use_hook(|| {
        // A set of subscribers to notify about changes to this signals value
        let subscribers = Default::default();
        // Create the initial state
        let value = Rc::new(RefCell::new(init()));

        Signal { value, subscribers }
    })
}

impl<T: Clone> Signal<T> {
    fn get(&self) -> T {
        // Subscribe the context observing the signal (if any) to updates of its value.
        if let Some(reactive_context) = ReactiveContext::current() {
            reactive_context.subscribe(self.subscribers.clone());
        }

        self.value.borrow().clone()
    }

    fn set(&self, value: T) {
        // Update the state
        *self.value.borrow_mut() = value;
        // Trigger a re-render of the components that observed the signal's previous value
        let mut subscribers = std::mem::take(&mut *self.subscribers.lock().unwrap());
        subscribers.retain(|reactive_context| reactive_context.mark_dirty());
        // Extend the subscribers list instead of overwriting it in case a subscriber is added while reactive contexts are marked dirty
        self.subscribers.lock().unwrap().extend(subscribers);
    }
}
````

* The `use_context` hook calls [`consume_context`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.consume_context.html) (which would be expensive to call on every render) to get some context from the component

Here is an implementation of the `use_context` and `use_context_provider` hooks:

````rs@hooks_custom_logic.rs
pub fn use_context<T: 'static + Clone>() -> T {
    use_hook(|| consume_context())
}

pub fn use_context_provider<T: 'static + Clone>(f: impl FnOnce() -> T) -> T {
    use_hook(|| {
        let val = f();
        // Provide the context state to the component
        provide_context(val.clone());
        val
    })
}

````

## Building Reactive Hooks

The `use_hook` primitive only provides a way to *store* a value. It does not directly integrate with the Dioxus runtime to allow *modifying* state or queueing effects.

To queue a component to re-render, you can use the `dioxus::core::needs_update` primitive. This sends a message to the internal Dioxus scheduler to queue the current component to be re-rendered.

````rust
log!("Re-rendering!");

rsx! {
    // Clicking this button will force a re-render
    button {
        onclick: move |_| dioxus::core::needs_update(),
        "Queue for re-rendering"
    }
}
````

We can combine `needs_update`, `use_hook`, and [interior mutability](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html) to build hooks that work with the Dioxus reactivity system.

````rust
// We declare a new "ReactiveString" type that calls `needs_update` when modified
#[derive(Default)]
struct ReactiveString { inner: Rc<RefCell<String>> }
impl ReactiveString {
    fn get(&self) -> String {
        self.inner.borrow().to_string()
    }
    fn set(&mut self, new: String) {
        *self.inner.write() = new;
        dioxus::core::needs_update();
    }
}

// We store the ReactiveString in a hook
fn use_reactive_string(init: impl FnOnce() -> String) -> ReactiveString {
    let inner = use_hook(|| Rc::new(RefCell::new(init())));
    ReactiveString { inner }
}

// And then when can use it in our component
let mut name = use_reactive_string(|| "Jane".to_string());

rsx! {
    // Clicking the button will cause `needs_update` to be queue a re-render
    button {
        onclick: move |_| name.set("Bob".to_string()),
        "Name: {name.get()}"
    }
}
````

In practice, you should never need to build state management primitives yourself. We provide these examples to help you understand how they work.
# Component Lifecycle

## Initializing State with `use_hook`

`use_hook` lets you create new state for your component. The closure you pass to `use_hook` will be called once the first time the component is rendered. Every time the component is re-rendered, the value that was created the first run will be re-used.

````rs@component_lifecycle.rs
fn UseHook() -> Element {
    // The closure that is passed to use_hook will be called once the first time the component is rendered
    let random_number = use_hook(|| {
        let new_random_number = random_number();

        log!("{new_random_number}");

        new_random_number
    });

    rsx! {
        div { "Random {random_number}" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::UseHookDemo {}
}
````

## Rerendering

You can use tracked values to re-render your component whenever a value changes.

````rs@component_lifecycle.rs
fn Rerenders() -> Element {
    let mut count = use_signal(|| 0);

    log!("Rerendering parent component with {}", *count.peek());

    rsx! {
        button { onclick: move |_| count += 1, "Increment" }
        // Since we read count here, the component will rerender when count changes
        Count { current_count: count() }
    }
}

// If the count prop changes, the component will rerender
#[component]
fn Count(current_count: i32) -> Element {
    log!("Rerendering child component with {current_count}");

    rsx! {
        div { "The count is {current_count}" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::RerenderDemo {}
}
````

### ⚠️ Don't mutate state in the body of a component

You should avoid changing state in the body of a component. If you read and write to state in the body of a component, you can cause an infinite loop as the component tries to rerender because of the change which triggers another state change.

````rs@component_lifecycle.rs
fn Bad() -> Element {
    let mut count = use_signal(|| 0);

    // ❌ Don't mutate state in the body of the component.
    // It can easily cause an infinite loop!
    count += 1;

    rsx! { "{count}" }
}
````

Instead, derive state with `use_memo`, `use_resource`, or mutate state in a effect.

## Using Effects

You can use effects to run code whenever a component is rendered.

````rs@component_lifecycle.rs
fn Effect() -> Element {
    // Effects run after the component is rendered
    // You can use them to read or modify the rendered component
    use_effect(|| {
        log!("Effect ran");
        document::eval(&format!(
            "document.getElementById('effect-output').innerText = 'Effect ran'"
        ));
    });

    rsx! {
        div { id: "effect-output", "This will be changed by the effect" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::EffectDemo {}
}
````

## Cleaning Up Components with Drop

Before a component is dropped, it will drop all of its hooks. You can use this drop behavior to clean up any resources that your component is using. If you just need the drop effect, you can use the [`use_drop`](https://docs.rs/dioxus/latest/dioxus/prelude/fn.use_drop.html) hook.

````rs@component_lifecycle.rs
fn TogglesChild() -> Element {
    let mut show = use_signal(|| true);

    rsx! {
        button { onclick: move |_| show.toggle(), "Toggle" }
        if show() {
            Child {}
        }
    }
}

fn Child() -> Element {
    // You can use the use_drop hook to clean up any resources
    dioxus::core::use_drop(|| {
        log!("Child dropped");
    });

    rsx! {
        div { "Child" }
    }
}
````

````inject-dioxus
DemoFrame {
    component_lifecycle::DropDemo {}
}
````
# Breaking Out of Dioxus

Dioxus makes it easy to build reactive user interfaces. However, there are some cases where you may need to break out of the reactive paradigm to interact with the DOM directly.

## Interacting with JavaScript with `eval` and `web-sys`

Dioxus exposes a limited number of [web apis](https://developer.mozilla.org/en-US/docs/Web/API) with a nicer interface. If you need access to more APIs, you can use the `eval` function to run JavaScript in the browser.

For example, you can use the eval function to read the domain of the current page:

````rs@breaking_out.rs
pub fn Eval() -> Element {
    let mut domain = use_signal(String::new);
    rsx! {
        button {
            // When you click the button, some javascript will run in the browser
            // to read the domain and set the signal
            onclick: move |_| async move {
                domain.set(document::eval("return document.domain").await.unwrap().to_string());
            },
            "Read Domain"
        }
        "Current domain: {domain}"
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::Eval {}
}
````

If you are only targeting web, you can also use the [`web-sys`](https://crates.io/crates/web-sys) crate for typed access to the web APIs. Here is what reading the domain looks like with web-sys:

````rs@breaking_out.rs
use ::web_sys::window;
use wasm_bindgen::JsCast;
pub fn WebSys() -> Element {
    let mut domain = use_signal(String::new);
    rsx! {
        button {
            // When you click the button, we use web-sys to read the domain and a signal
            onclick: move |_| {
                domain
                    .set(
                        window()
                            .unwrap()
                            .document()
                            .unwrap()
                            .dyn_into::<::web_sys::HtmlDocument>()
                            .unwrap()
                            .domain(),
                    );
            },
            "Read Domain"
        }
        "Current domain: {domain}"
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::WebSys {}
}
````

## Synchronizing DOM updates with `use_effect`

If you do need to interact with the DOM directly, you should do so in a `use_effect` hook. This hook will run after the component is rendered and all of the Dioxus UI has been rendered. You can read or modify the DOM in this hook.

For example, you can use the `use_effect` hook to write to a canvas element after it is created:

````rs@breaking_out.rs
pub fn Canvas() -> Element {
    let mut count = use_signal(|| 0);

    use_effect(move || {
        // Effects are reactive like memos, and resources. If you read a value inside the effect, the effect will rerun when that value changes
        let count = count.read();

        // You can use the count value to update the DOM manually
        document::eval(&format!(
            r#"var c = document.getElementById("dioxus-canvas");
var ctx = c.getContext("2d");
ctx.clearRect(0, 0, c.width, c.height);
ctx.font = "30px Arial";
ctx.fillText("{count}", 10, 50);"#
        ));
    });

    rsx! {
        button {
            // When you click the button, count will be incremented and the effect will rerun
            onclick: move |_| count += 1,
            "Increment"
        }
        canvas { id: "dioxus-canvas" }
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::Canvas {}
}
````

## Getting access to elements with `onmounted`

If you need a handle to an element that is rendered by dioxus, you can use the `onmounted` event. This event will fire after the element is first mounted to the DOM. It returns a live reference to the element with some methods to interact with it.

You can use the onmounted event to do things like focus or scroll to an element after it is rendered:

````rs@breaking_out.rs
pub fn OnMounted() -> Element {
    let mut input_element = use_signal(|| None);

    rsx! {
        div { height: "100px",
            button {
                class: "focus:outline-2 focus:outline-blue-600 focus:outline-dashed",
                // The onmounted event will run the first time the button element is mounted
                onmounted: move |element| input_element.set(Some(element.data())),
                "First button"
            }

            button {
                // When you click the button, if the button element has been mounted, we focus to that element
                onclick: move |_| async move {
                    if let Some(header) = input_element() {
                        let _ = header.set_focus(true).await;
                    }
                },
                "Focus first button"
            }
        }
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::OnMounted {}
}
````

## Down casting web sys events

Dioxus provides platform agnostic wrappers over each event type. These wrappers are often nicer to interact with than the raw event types, but they can be more limited. If you are targeting web, you can downcast the event with the `as_web_event` method to get the underlying web-sys event:

````rs@breaking_out.rs
pub fn Downcast() -> Element {
    let mut event_text = use_signal(|| 0);

    rsx! {
        div {
            onmousemove: move |event| {
                #[cfg(feature = "web")]
                {
                    use dioxus::web::WebEventExt;
                    event_text.set(event.as_web_event().movement_x());
                }
            },
            "movement_x was {event_text}"
        }
    }
}
````

````inject-dioxus
DemoFrame {
    breaking_out::Downcast {}
}
````
